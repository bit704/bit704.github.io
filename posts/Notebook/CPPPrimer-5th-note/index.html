

<!DOCTYPE html>
<html lang="zh-CN-spec" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-10-17-logo.png">
  <link rel="icon" href="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-10-17-logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="bit704">
  <meta name="keywords" content="blog">
  
    <meta name="description" content="Stanley B. Lippman，Josée Lajoie，Barbara E. Moo 著">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++ Primer》第五版笔记">
<meta property="og:url" content="https://reddish.fun/posts/Notebook/CPPPrimer-5th-note/index.html">
<meta property="og:site_name" content="Homeworld">
<meta property="og:description" content="Stanley B. Lippman，Josée Lajoie，Barbara E. Moo 著">
<meta property="og:locale">
<meta property="article:published_time" content="2023-01-07T15:59:15.058Z">
<meta property="article:modified_time" content="2024-01-06T13:12:20.847Z">
<meta property="article:author" content="bit704">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>《C++ Primer》第五版笔记 - Homeworld</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"reddish.fun","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 65vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>逝者如斯夫！不舍昼夜。</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>联系我</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-link-fill"></i>
                <span>更多</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/links/">
                    
                    <span>外部链接</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://reddish.fun/posts/Article/additional/">
                    
                    <span>一些说明</span>
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-11-15-spaceplane.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="《C++ Primer》第五版笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-07 23:59" pubdate>
          2023年1月7日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          63k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">《C++ Primer》第五版笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>Stanley B. Lippman，Josée Lajoie，Barbara E. Moo 著</p>
<span id="more"></span>
<p>王刚，杨巨峰 译</p>
<figure>
<img
src="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-C%2B%2BPrimer_s.jpg" srcset="/img/loading.gif" lazyload
alt="封面" />
<figcaption aria-hidden="true">封面</figcaption>
</figure>
<p class="note note-primary">
摘录整理。
</p>
<h2 id="推荐序1">推荐序1</h2>
<p>第5版之于2011版标准，如同第3版之于1998版标准，必将成为经典的学习读本。</p>
<p>第5版则更加像一本学习教程，由浅入深，并结合大量代码实例来讲述C++语法和标准库。</p>
<p>学习语言的一个境界是把自己想象成编译器。</p>
<p>本书的另一个特色是将C++的语法和标准库融为一体来介绍。C++标准库本身就是C++语法的最佳样例，其中包含不少C++高级特性的指导性用法。在我的程序设计经历中，<strong>有些C++语言特性（比如虚拟继承），我只在标准库中看到过实用做法</strong>。</p>
<p>在实践中，不必全面地使用C++语言的各种特性，而应根据工程项目的实际情况，适当取舍（譬如动态类型信息、虚拟继承、异常等特性的使用很值得商榷）。通常只鼓励使用C++语言的一个子集就够了，<strong>一个值得学习和参考的例子是Google发布的Google
C++ Style Guide</strong>。</p>
<h2 id="推荐序2">推荐序2</h2>
<p>编译器实现的速度也令人惊喜。短短两年时间，从开源的GCC、LLVM到专有的Visual
C++和Intel
C++，对于新标准的追踪之快，覆盖之全，与当年C++98标准颁布之后迟迟不能落地的窘境相比，可谓对比强烈。</p>
<p>一种优秀的编程语言，一定要对于计算这件事情实现一个完整和自洽的抽象。</p>
<p>而C语言之所以四十年长盛不衰，根本在于它对于现代计算机提供了一个<strong>底层的高级抽象</strong>：凡是比它低的抽象都过于简陋，凡是比它高的抽象都可以用C语言构造出来。</p>
<p>每当你需要走下去直接与硬件对话时，C++成为C之外唯一有效率的选择。</p>
<p>C++同时支持4种不同的编程风格：<strong>C风格、基于对象、面向对象和泛型</strong>。事实上，把微软的COM也算进来的话，还可以加上一种“基于组件”的风格。</p>
<p>每一个具体的技术领域，只需要读四五本书就够了。以前的C++是个例外，因为语言设计有缺陷，所以要读很多书才知道如何绕过缺陷。现在的C++11完全可以了，大家读四五本书就可以达到合格的水平，这恰恰是语言进步的体现。</p>
<p>本书是这四五本中的一本，而且是“教程+参考书”，扛梁之作，初学者的不二法门。另一本是《C++标准程序库》，对于C++熟手来说更为快捷。Scott
Meyers的Effective
C++永远是学习C++者必读的，只不过这本书的第4版不知道什么时候出来。Anthony
Williams的C++ Concurrency in
Action是学习用标准C++开发并发程序的最佳选择。国内的作品，我则高度推荐陈硕的《Linux多线程服务端编程》。这本书的名字赶跑了不少潜在的读者，所以我要特别说明一下。这本书是C++开发的高水平作品，与其说是教你怎么用C++写服务端开发，不如说是教你如何以服务端开发为例子提升C++开发水平。前面几本书都是谈标准C++自己的事情，碰到像iostream这样失败的标准组件也不得不硬着头皮介绍。而这本书是接地气的实践结晶，告诉你面对具体问题时应怎样权衡，C++里什么好用，什么不好用，为什么，等等。</p>
<h2 id="前言">前言</h2>
<p>2011年，C++标准委员会发布了ISO
C++标准的一个重要修订版。此修订版是C++进化过程中的最新一步，延续了前几个版本对编程效率的强调。新标准的主要目标是：</p>
<ul>
<li>使语言更为统一，更易于教学。</li>
<li>使标准库更简单、安全、使用更高效。</li>
<li>使编写高效率的抽象和库变得更简单。</li>
</ul>
<p>现代C++语言可以看作是<strong>三部分</strong>组成的：</p>
<ul>
<li>低级语言，大部分继承自C语言。</li>
<li>现代高级语言特性，允许我们定义自己的类型以及组织大规模程序和系统。</li>
<li>标准库，它利用高级特性来提供有用的数据结构和算法。</li>
</ul>
<p><a
target="_blank" rel="noopener" href="http://www.informit.com/title/0321714113">扩展示例的源码</a>，在书本下方的download选项卡里下载。</p>
<h2 id="第1章-开始">第1章 开始</h2>
<h3 id="编写一个简单的c程序">1.1 编写一个简单的C++程序</h3>
<p>一个<strong>函数的定义</strong>包含四部分：返回类型（return
type）、函数名（function name）、一个括号包围的形参列表（parameter
list，允许为空）以及函数体（function body）。</p>
<p>在大多数系统中，main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。</p>
<p><strong>命令行运行编译器</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ CC prog1.cc<br></code></pre></td></tr></table></figure>
<p>CC是编译器程序的名字，$是系统提示符。编译器生成一个可执行文件。Windows系统会将这个可执行文件命名为prog1.exe。UNIX系统中的编译器通常将可执行文件命名为a.out。在Windows下执行可以忽略其扩展名.exe，在一些系统中需要用<span
class="math inline">\(./\)</span>显式指出其位于当前目录。</p>
<p>访问main的返回值的方法依赖于系统。在UNIX和Windows系统中，执行完一个程序后，都可以通过echo命令获得其返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在UNIX系统中，通过如下命令获得状态：</span><br>$ <span class="hljs-built_in">echo</span> $?<br><span class="hljs-comment"># 在Windows系统中查看状态可键入：</span><br>$ <span class="hljs-built_in">echo</span> %ERRORLEVEL%<br></code></pre></td></tr></table></figure>
<p>默认情况下，运行GNU编译器的命令是g++：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ g++ -o prog1 prog1.cc<br></code></pre></td></tr></table></figure>
<p>-o
prog1是编译器参数，指定了可执行文件的文件名。在不同的操作系统中，此命令生成一个名为prog1或prog1.exe的可执行文件。在UNIX系统中，可执行文件没有后缀；在Windows系统中，后缀为.exe。如果省略了-o
prog1参数，在UNIX系统中编译器会生成一个名为a.out的可执行文件，在Windows系统中则会生成一个名为a.exe的可执行文件。</p>
<p>根据使用的GNU编译器的版本，你可能需要指定-std=c++0x参数来打开对C++11的支持。</p>
<h3 id="初识输入输出">1.2 初识输入输出</h3>
<p>cin、cout、cerr、clog</p>
<p>写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 等价</span><br>std::cout &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; std::flush;<br>std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; std::<span class="hljs-built_in">fflush</span>(stdout);<br></code></pre></td></tr></table></figure>
<h3 id="注释简介">1.3 注释简介</h3>
<p>C++中有两种注释：单行注释和界定符对注释。</p>
<ul>
<li>单行注释以双斜线（//）开始，以换行符结束。当前行双斜线右侧的所有内容都会被编译器忽略，这种注释可以包含任何文本，包括额外的双斜线。</li>
<li>另一种注释使用继承自C语言的两个界定符（/＊和＊/）。这种注释以/＊开始，以＊/结束，可以包含除＊/外的任意内容，包括换行符。编译器将落在/＊和＊/之间的所有内容都当作注释。</li>
</ul>
<p>注释风格：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This file contains code from &quot;C++ Primer, Fifth Edition&quot;, by Stanley B.</span><br><span class="hljs-comment"> * Lippman, Josee Lajoie, and Barbara E. Moo, and is covered under the</span><br><span class="hljs-comment"> * copyright and warranty notices given in that book:</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * &quot;Copyright (c) 2013 by Objectwrite, Inc., Josee Lajoie, and Barbara E. Moo.&quot;</span><br><span class="hljs-comment">*/</span> <br></code></pre></td></tr></table></figure>
<p>注释界定符不能嵌套！单行注释会忽略一切。</p>
<h3 id="控制流">1.4 控制流</h3>
<p>while、for、if</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 遇到文件结束符结束。在Windows系统中，输入文件结束符的方法是敲Ctrl+Z（按住Ctrl键的同时按Z键），然后按Enter或Return键。在UNIX系统中，包括Mac OS X系统中，文件结束符输入是用Ctrl+D。</span><br><span class="hljs-keyword">while</span> (std::cin &gt;&gt; value) <br>    ...<br></code></pre></td></tr></table></figure>
<h3 id="类简介">1.5 类简介</h3>
<p>成员函数是定义为类的一部分的函数，有时也被称为方法（method）。</p>
<h3 id="书店程序">1.6 书店程序</h3>
<p>无。</p>
<h1 id="第ⅰ部分-c基础">第Ⅰ部分 C++基础</h1>
<h2 id="第2章-变量和基本类型">第2章 变量和基本类型</h2>
<h3 id="基本内置类型">2.1 基本内置类型</h3>
<p>C++定义了一套包括<strong>算术类型</strong>（arithmetic
type）和<strong>空类型</strong>（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。</p>
<p>大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。在C++语言中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。</p>
<p>如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为<strong>带符号数会自动地转换成无符号数</strong>。</p>
<p><img
src="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-28-literal.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="变量">2.2 变量</h3>
<p>在C++语言中，<strong>初始化</strong>是一个异常复杂的问题，我们也将反复讨论这个问题。很多程序员对于用等号=来初始化变量的方式倍感困惑，这种方式容易让人认为初始化是赋值的一种。事实上在C++语言中，初始化和赋值是两个完全不同的操作。然而在很多编程语言中二者的区别几乎可以忽略不计，即使在C++语言中有时这种区别也无关紧要，所以人们特别容易把二者混为一谈。</p>
<p><strong>初始化不是赋值</strong>，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 4种初始化方式</span><br><span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> a&#123;pi&#125;, b = &#123;pi&#125;; <span class="hljs-comment">// 会因为存在信息丢失的危险导致报错</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(pi)</span>, d </span>= pi;  <span class="hljs-comment">// 不报错，正常执行</span><br></code></pre></td></tr></table></figure>
<p>使用{}初始化被称为<strong>列表初始化</strong>（list
initialization）。在 C++11
中，初始化列表的适用性被大大增加了。它可以用于任何类型对象的初始化。</p>
<p>定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的（参见2.1.2节，第33页），如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持<strong>分离式编译</strong>（separate
compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<p>为了支持分离式编译，C++语言将声明和定义区分开来。<strong>声明</strong>（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<strong>定义</strong>（definition）负责创建与名字关联的实体。变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;  <span class="hljs-comment">// 声明i而非定义i</span><br><span class="hljs-type">int</span> j;  <span class="hljs-comment">// 声明并定义j</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 定义</span><br></code></pre></td></tr></table></figure>
<p>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p>
<p>变量能且只能被定义一次，但是可以被多次声明。</p>
<p>如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
<p>C++是一种<strong>静态类型</strong>（statically
typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type
checking）。</p>
<p><strong>作用域</strong>（scope）是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p>
<p>因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。</p>
<h3 id="复合类型">2.3 复合类型</h3>
<p>复合类型（compound
type）是指基于其他类型定义的类型。C++语言有几种复合类型，本章将介绍其中的两种：<strong>引用和指针</strong>。</p>
<p><strong>引用</strong></p>
<p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。因为引用本身不是一个对象，所以不能定义引用的引用。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。</p>
<p>除了2.4.1节（第55页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象<strong>严格匹配</strong>。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p>
<blockquote>
<p>第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。这是因为编译器创建了一个<strong>临时变量</strong>作为绑定的中间值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = i; <span class="hljs-comment">// 正确</span><br><span class="hljs-comment">// 相当于 const int temp = i; cosnt int &amp;r1 = temp; 因此i和r1的类型可以不一致</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span> &amp;r4 = r1 * <span class="hljs-number">2</span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>
<p>第二种例外情况是，我们可以将基类的指针或引用绑定到派生类对象上。</p>
</blockquote>
<p><strong>指针</strong></p>
<p>其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p>
<p>除了2.4.2节（第56页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所有指针的类型都要和它所指向的对象<strong>严格匹配</strong>。</p>
<blockquote>
<p>第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> *cptr = &amp;pi;<br></code></pre></td></tr></table></figure>
<p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。<strong>所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</strong></p>
<p>第二种例外情况是，我们可以将基类的指针或引用绑定到派生类对象上。</p>
</blockquote>
<p><strong>空指针</strong></p>
<p>得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。过去的程序还会用到一个名为NULL的预处理变量（preprocessor
variable）来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。</p>
<p><strong>预处理变量</strong>不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须在前面加上std::。</p>
<p>以void＊的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象，关于这点将在19.1.1节（第726页）有更详细的介绍，4.11.3节（第144页）将讲述获取void＊指针所存地址的方法。</p>
<blockquote>
<p>当我们把指针存放在void＊中，并且使用static_cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，因此我们必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。</span><br><span class="hljs-comment">// 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> *p;<br><span class="hljs-type">int</span> *&amp;r = p; <span class="hljs-comment">// r是一个对指针p的引用</span><br>r = &amp;i; <span class="hljs-comment">// 令p指向i</span><br>*r = <span class="hljs-number">0</span>; <span class="hljs-comment">// 将i改为0</span><br></code></pre></td></tr></table></figure>
<h3 id="const限定符">2.4 const限定符</h3>
<p>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</p>
<p>默认状态下，const对象仅在文件内有效。</p>
<p>如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>
<p><strong>const的引用</strong></p>
<p>可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为<strong>对常量的引用</strong>（reference
to
const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</p>
<p>对const的引用可能引用一个并非const的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;r1 = i; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = i;<br>r1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 正确，r2代表的值也已为0</span><br>r2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>（自己补充的例子）</p>
<p>由于前面2.3中提到的引用绑定的例外情况，对常量的引用会存在以下情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = i;<br>i = <span class="hljs-number">0</span>;<br>cout &lt;&lt; r1 &lt;&lt; endl;<br><span class="hljs-comment">// 42</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = j;<br>j = <span class="hljs-number">0</span>;<br>cout &lt;&lt; r2 &lt;&lt; endl;<br><span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>指针和const</strong></p>
<p>用名词<strong>顶层const</strong>（top-level
const）表示指针本身是个常量，而用名词<strong>底层const</strong>（low-level
const）表示指针所指的对象是一个常量。</p>
<p><strong>更一般的</strong>，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p1 = &amp;i;  <span class="hljs-comment">// 顶层const,p1不能改变</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">42</span>; <span class="hljs-comment">// 顶层const,ci不能改变</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;ci; <span class="hljs-comment">// 底层const,p2可以改变</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = p2; <span class="hljs-comment">// 右边是顶层const,左边是底层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r = ci;  <span class="hljs-comment">// 用于声明引用的const都是底层const</span><br><span class="hljs-comment">// 当执行对象的拷贝操作时,顶层const不受什么影响</span><br>i = ci;  <span class="hljs-comment">// 正确</span><br>p2 = p3; <span class="hljs-comment">// 正确</span><br><span class="hljs-comment">// 拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行</span><br><span class="hljs-type">int</span> *p = p3;  <span class="hljs-comment">// 错误，p3包含底层const，p没有</span><br>p2 = p3; <span class="hljs-comment">// 正确，p2、p3都是底层const</span><br>p2 = &amp;i;  <span class="hljs-comment">// 正确，int * 可以转化为 const int *</span><br><span class="hljs-type">int</span> &amp;r = ci;  <span class="hljs-comment">// 普通的int&amp;不能绑定到int常量上</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = i; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure>
<p><strong>constexpr和常量表达式</strong></p>
<p>常量表达式（const
expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> m = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 是</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 是</span><br><span class="hljs-type">int</span> s = <span class="hljs-number">24</span>; <span class="hljs-comment">// 不是</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> p = <span class="hljs-built_in">cal_p</span>(); <span class="hljs-comment">// 不是</span><br></code></pre></td></tr></table></figure>
<p>在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿。</p>
<p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。</p>
<p>常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“<strong>字面值类型</strong>”（literal
type）。其他一些字面值类型将在7.5.6节（第267页）和19.3节（第736页）介绍。</p>
<blockquote>
<p>除了算术类型、引用和指针外，某些类也是字面值类型。和其他类不同，字面值类型的类可能含有constexpr函数成员。这样的成员必须符合constexpr函数的所有要求，它们是隐式const的（参见7.1.2节，第231页）。</p>
<p>枚举属于字面值常量类型（参见7.5.6节，第267页）。</p>
</blockquote>
<p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p>
<p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。</p>
<p>（constexpr只能写在指针左边。）</p>
<h3 id="处理类型">2.5 处理类型</h3>
<p>有两种方法可用于定义类型别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 传统的方法是使用关键字typedef</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> wages;  <span class="hljs-comment">// wages是double的同义词</span><br><span class="hljs-keyword">typedef</span> wages base, *p; <span class="hljs-comment">// base是double的同义词，p是double*的同义词</span><br><span class="hljs-comment">// 别名声明（alias declaration）</span><br><span class="hljs-keyword">using</span> SI = Sales_item;<br></code></pre></td></tr></table></figure>
<p>不能用简单的代换来理解别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *pstring;<br><span class="hljs-type">const</span> pstring cstr = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 指向char的常量指针</span><br><span class="hljs-comment">// 不应该理解为const char *cstr  = 0;</span><br><span class="hljs-comment">// 声明语句中用到pstring时，其基本数据类型是指针。可是用char＊重写了声明语句后，数据类型就变成了char，＊成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。</span><br><span class="hljs-type">const</span> pstring *ps; <span class="hljs-comment">// 该指针的对象是指向char的常量指针</span><br></code></pre></td></tr></table></figure>
<p><strong>auto</strong></p>
<p>编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p>
<p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的<strong>初始基本数据类型</strong>都必须一样<strong>（符号&amp;和＊只从属于某个声明符，而非基本数据类型的一部分）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i; <span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>对引用对象，编译器以它引用的类型作为auto的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, &amp;r = i;<br><span class="hljs-keyword">auto</span> a = r; <span class="hljs-comment">// a是整数</span><br></code></pre></td></tr></table></figure></li>
<li><p><strong>auto一般会忽略掉顶层const，同时底层const则会保留下来。</strong>如果希望推断出的auto类型是一个顶层const，需要明确指出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i, &amp;cr = ci;<br><span class="hljs-keyword">auto</span> b = ci; <span class="hljs-comment">// b是整数（顶层const，忽略）</span><br><span class="hljs-keyword">auto</span> c = cr; <span class="hljs-comment">// c是整数</span><br><span class="hljs-keyword">auto</span> d = &amp;i; <span class="hljs-comment">// d是整数指针</span><br><span class="hljs-keyword">auto</span> e = &amp;ci; <span class="hljs-comment">// e是指向整数常量的指针（对常量对象取地址是底层const）</span><br><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> f = ci; <span class="hljs-comment">// f是const int</span><br><br><span class="hljs-comment">// 设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留。</span><br><span class="hljs-keyword">auto</span> &amp;g = ci; <span class="hljs-comment">// g是整数常量引用</span><br><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>; <span class="hljs-comment">// 错误，不能为非常量引用绑定字面值</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span>; <span class="hljs-comment">// 正确</span><br><br><span class="hljs-comment">// 续初始基本数据类型一致原则</span><br><span class="hljs-keyword">auto</span> k = ci, &amp;l = i; <span class="hljs-comment">//k是整数,l是整型引用</span><br><span class="hljs-keyword">auto</span> &amp;m = ci, *p = &amp;ci; <span class="hljs-comment">//m是整型常量引用,p是指向整型常量的指针</span><br><span class="hljs-keyword">auto</span> &amp;n = i, *p2 = &amp;ci; <span class="hljs-comment">//错误，不一致</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>decltype</strong></p>
<p>希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。</p>
<p>decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<br><span class="hljs-keyword">decltype</span>(r+<span class="hljs-number">0</span>) b;  <span class="hljs-comment">// 正确，b是一个未初始化的int。decltype(r)是引用，decltype(r+0)不是。</span><br><span class="hljs-keyword">decltype</span>(*p) c;  <span class="hljs-comment">// 错误，c是int&amp;,必须初始化。如果表达式的内容是解引用操作，则decltype将得到引用类型。</span><br><br><span class="hljs-keyword">decltype</span>((i)) d; <span class="hljs-comment">// 错误，d是int&amp;,必须初始化。decltype((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</span><br><span class="hljs-keyword">decltype</span>(i) e;  <span class="hljs-comment">// 正确，e是一个未初始化的int。</span><br></code></pre></td></tr></table></figure>
<h3 id="自定义数据结构">2.6 自定义数据结构</h3>
<p>C++11新标准规定，可以为数据成员提供一个<strong>类内初始值</strong>（in-class
initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。</p>
<p>头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。</p>
<p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>
<p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>（preprocessor），它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。</p>
<ul>
<li>#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。</li>
<li>头文件保护符（header
guard），头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。</li>
</ul>
<p>头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。</p>
<h2 id="第3章-字符串向量和数组">第3章 字符串、向量和数组</h2>
<h3 id="命名空间的using声明">3.1 命名空间的using声明</h3>
<p><strong>位于头文件的代码一般来说不应该使用using声明。</strong>这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。</p>
<h3 id="标准库类型string">3.2 标准库类型string</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化</span><br>string s1; <span class="hljs-comment">// 默认初始化，空串</span><br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>; <span class="hljs-comment">// 直接初始化，s2是s1的副本</span><br>string s2 = s1; <span class="hljs-comment">// 拷贝初始化，s2是s1的副本</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>; <span class="hljs-comment">// 直接初始化，s3是字面值&quot;value&quot;的副本，除了字面值最后那个空字符外</span><br><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;c&#x27;</span>)</span></span>; <span class="hljs-comment">// 直接初始化，s4是cccc</span><br><span class="hljs-comment">//操作</span><br>os&lt;&lt;s; <br>is&gt;&gt;s;<br><span class="hljs-built_in">getline</span>(is,s);<br>s.<span class="hljs-built_in">empty</span>();<br>s.<span class="hljs-built_in">size</span>();<br>s[n];<br>s1+s1;<br>s1=s2;<br>s1==s2;<br>s1!=s2;<br>&lt;,&lt;=,&gt;,&gt;= <span class="hljs-comment">//字典序比较，大小写敏感</span><br></code></pre></td></tr></table></figure>
<p>在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。</p>
<p>getline从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。</p>
<p><strong>string::size_type</strong>类型</p>
<p>string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。无符号整型数，勿要与带符号数混用，例如比大小。</p>
<p>因为某些历史原因，也为了与C兼容，所以<strong>C++语言中的字符串字面值并不是标准库类型string的对象</strong>。切记，字符串字面值与string是不同的类型。当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。</p>
<p>一般来说，<strong>C++程序应该使用名为cname的头文件而不使用name.h的形式</strong>，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。</p>
<h3 id="标准库类型vector">3.3 标准库类型vector</h3>
<p>因为vector“容纳着”其他对象，所以它也常被称作容器（container）。</p>
<p>vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector&lt;int&gt;。</p>
<p>早期版本的C++标准中如果vector的元素还是vector（或者其他模板类型），则其定义的形式与现在的C++11新标准略有不同。过去，必须在外层vector对象的右尖括号和其元素类型之间添加一个空格，如应该写成vector&lt;vector&lt;int&gt;
&gt;而非vector&lt;vector&lt;int&gt;&gt;。</p>
<p>C++语言提供了几种不同的初始化方式，在大多数情况下这些初始化方式可以相互等价地使用，<strong>三个例外</strong>：</p>
<ol type="1">
<li>使用拷贝初始化时（即使用=时），只能提供一个初始值；</li>
<li>如果提供的是一个<strong>类内初始值</strong>，则只能使用拷贝初始化或使用花括号的形式初始化；</li>
<li>如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 10个0</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v2&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">// 10</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 10个1</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v4&#123;<span class="hljs-number">10</span>,<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 10，1</span><br><span class="hljs-comment">// 只有在无法执行列表初始化时才会考虑其他初始化方式。</span><br>vector&lt;string&gt; v5&#123;<span class="hljs-string">&quot;hi&quot;</span>&#125;; <span class="hljs-comment">// &quot;hi&quot;</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v6</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>)</span></span>; <span class="hljs-comment">// 错误</span><br>vector&lt;string&gt; v7&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//  10个&quot;&quot;</span><br>vector&lt;string&gt; v8&#123;<span class="hljs-number">10</span>,<span class="hljs-string">&quot;hi&quot;</span>&#125;; <span class="hljs-comment">// 10个&quot;hi&quot;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;::size_type <span class="hljs-comment">// 正确</span><br>vector::size_type <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>
<h3 id="迭代器介绍">3.4 迭代器介绍</h3>
<p>原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！=而非&lt;进行判断有点儿奇怪。C++程序员习惯性地使用!=，是因为因为这种编程风格在标准库提供的所有容器上都有效。所有标准库容器的迭代器都定义了==和!=，但是它们中的大多数都没有定义&lt;运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; cv;<br><span class="hljs-keyword">auto</span> it1 = v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// vector&lt;int&gt;::iterator</span><br><span class="hljs-keyword">auto</span> it2 = cv.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// vector&lt;int&gt;::const_iterator</span><br><span class="hljs-keyword">auto</span> it3 = v.<span class="hljs-built_in">cbegin</span>(); <span class="hljs-comment">// vector&lt;int&gt;::const_iterator</span><br></code></pre></td></tr></table></figure>
<p>箭头运算符 -&gt; 把解引用和成员访问两个操作结合在一起：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 等价</span><br>it-&gt;mem;<br>(*it).mem;<br></code></pre></td></tr></table></figure>
<p>谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</p>
<p>迭代器相减得到类型名为<strong>difference_type</strong>的带符号整型数。</p>
<h3 id="数组">3.5 数组</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</span><br><span class="hljs-type">int</span> *ptr[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 含有10个整型指针的数组</span><br><span class="hljs-type">int</span> &amp;refs[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 错误，不存在引用的数组</span><br><span class="hljs-built_in">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-comment">// Parray指向一个含有10个整数的数组</span><br><span class="hljs-built_in">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr; <span class="hljs-comment">// arrRef引用一个含有10个整数的数组</span><br><span class="hljs-type">int</span> *(&amp;array)[<span class="hljs-number">10</span>] = ptrs; <span class="hljs-comment">// array是数组的引用，该数组含有10个指针</span><br></code></pre></td></tr></table></figure>
<p>在使用数组下标的时候，通常将其定义为<strong>size_t</strong>类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。两个指针相减的结果的类型是一种名为<strong>ptrdiff_t</strong>的标准库类型，带符号类型。</p>
<p>使用数组的时候编译器一般会把它转换成指针。在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">// ia2是一个整型指针，指向ia首元素</span><br><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// ia3是一个含有10个整数的数组</span><br>ia3 = p; <span class="hljs-comment">// 错误，不能用整型指针给数组赋值</span><br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia); <span class="hljs-comment">// 指向ia首元素的指针</span><br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia); <span class="hljs-comment">// 指向arr尾元素下一位置的指针</span><br><span class="hljs-comment">// 这两个函数定义在iterator头文件中。</span><br></code></pre></td></tr></table></figure>
<p>内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。</p>
<p><strong>C风格字符串</strong></p>
<p>字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的C风格字符串（C-style
character
string）。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束（null
terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（'\0'）。一般利用指针来操作这些字符串。</p>
<p>尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用。</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = s.<span class="hljs-built_in">c_str</span>();<br><span class="hljs-comment">// 如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</span><br><br><span class="hljs-comment">// 使用数组初始化vector对象</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(begin(int_arr),end(int_arr))</span></span>;<br></code></pre></td></tr></table></figure>
<h3 id="多维数组">3.6 多维数组</h3>
<p>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用range for遍历二维数组，需要将外层循环的控制变量声明成引用类型，避免数组被自动转成指针</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> rowCnt = <span class="hljs-number">3</span>, colCnt = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> ia[rowCnt][colCnt];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;row : ia)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> col : row)<br>        cout &lt;&lt; col &lt;&lt; endl;<br><br><span class="hljs-comment">// 使用别名的两种方式</span><br><span class="hljs-keyword">using</span> int_array = <span class="hljs-type">int</span>[<span class="hljs-number">4</span>]; <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> int_array[<span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">for</span> (int_array *p = ia; p != ia + <span class="hljs-number">3</span>; ++p)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> *q = *p; q != *p + <span class="hljs-number">4</span>; ++q)<br>        cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="第4章-表达式">第4章 表达式</h2>
<h3 id="基础">4.1 基础</h3>
<p>作用于一个运算对象的运算符是一元运算符，如取地址符(&amp;)和解引用符(*)；作用于两个运算对象的运算符是二元运算符，如相等运算符(==)和乘法运算符(*)。除此之外，还有一个作用于三个运算对象的三元运算符(?:)。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p>
<p>使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。</p>
<p>C++的表达式要不然是<strong>右值</strong>（rvalue，读作“are-value”），要不然就是<strong>左值</strong>（lvalue，读作“ell-value”）。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</p>
<p>假定p的类型是int*，因为解引用运算符生成左值，所以decltype(*p)的结果是int&amp;。另一方面，因为取地址运算符生成右值，所以decltype(&amp;p)的结果是int**，也就是说，结果是一个指向整型指针的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// &lt;&lt;运算符没有明确规定何时以及如何对运算对象求值，因此下面的输出表达式是未定义的</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; endl; <span class="hljs-comment">//未定义</span><br></code></pre></td></tr></table></figure>
<p>有4种运算符明确规定了运算对象的求值顺序。<code>?: &amp;&amp; || ,</code>
。</p>
<h3 id="算术运算符">4.2 算术运算符</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bool值不应参与运算</span><br><span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>;<br><span class="hljs-type">bool</span> b2 = -b; <span class="hljs-comment">//b2是true</span><br></code></pre></td></tr></table></figure>
<p>C++11新标准则规定商一律向0取整（即直接切除小数部分）。</p>
<p>除了-m导致溢出的特殊情况，其他时候 (-m)/n 和 m/(-n) 都等于
-(m/n)，m%(-n) 等于 m%n，(-m)%n 等于 -(m%n)。</p>
<h3 id="逻辑和关系运算符">4.3 逻辑和关系运算符</h3>
<p>逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为<strong>短路求值</strong>（short-circuit
evaluation）。</p>
<h3 id="赋值运算符">4.4 赋值运算符</h3>
<p>无。</p>
<h3 id="递增和递减运算符">4.5 递增和递减运算符</h3>
<p><strong>除非必须，否则不用递增递减运算符的后置版本。</strong></p>
<p>前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。</p>
<p><strong>简洁可以成为一种美德</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; *iter++ &lt;&lt; endl;<br><span class="hljs-comment">// 等价于</span><br>cout &lt;&lt; *iter &lt;&lt; endl;<br>++iter;<br></code></pre></td></tr></table></figure>
<h3 id="成员访问运算符">4.6 成员访问运算符</h3>
<p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/z1481281370/cpplearn/1616089">1.5.2
值的类别</a></p>
<p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。</p>
<h3 id="条件运算符">4.7 条件运算符</h3>
<p><code>?:</code>具有右结合性。</p>
<h3 id="位运算符">4.8 位运算符</h3>
<p>无。</p>
<h3 id="sizeof运算符">4.9 sizeof运算符</h3>
<p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。</p>
<p>sizeof运算符满足<strong>右结合律</strong>，其所得的值是一个size_t类型的常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//等价</span><br><span class="hljs-keyword">sizeof</span> *p;<br><span class="hljs-built_in">sizeof</span>(*p);<br></code></pre></td></tr></table></figure>
<p>sizeof运算符无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。</p>
<p>sizeof运算符的结果部分地依赖于其作用的类型：</p>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。</li>
<li>对指针执行sizeof运算得到指针本身所占空间的大小。</li>
<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>
</ul>
<h3 id="逗号运算符">4.10 逗号运算符</h3>
<p>逗号运算符（comma
operator）含有两个运算对象，按照从左向右的顺序依次求值。</p>
<h3 id="类型转换">4.11 类型转换</h3>
<p>编译器会自动<strong>隐式转换</strong>：</p>
<ul>
<li>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。</li>
<li>在条件中，非布尔值转换成布尔类型。</li>
<li>初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</li>
<li>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。</li>
<li>如第6章将要介绍的，函数调用时也会发生类型转换。</li>
</ul>
<p><strong>算术转换</strong></p>
<p>如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型<strong>不小于</strong>带符号类型，那么带符号的运算对象转换成无符号的。例如，假设两个类型分别是unsigned
int和int，则int类型的运算对象转换成unsigned int类型。</p>
<p>如果两个运算对象的类型分别是long和unsigned
int，并且int和long的大小相同，则long类型的运算对象转换成unsigned
int类型；如果long类型占用的空间比int更多，则unsigned
int类型的运算对象转换成long类型。</p>
<p>其它<strong>隐式转换</strong>：</p>
<ul>
<li><p>数组转换成指针</p></li>
<li><p>指针的转换</p>
<p>常量整数值0或者字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void
*；指向任意对象的指针能转换成const void *。</p></li>
<li><p>转换成布尔类型</p></li>
<li><p>转换成常量</p>
<p>允许将指向非常量类型的指针/引用转换成指向相应的常量类型的。</p></li>
<li><p>类类型定义的转换</p>
<p>例如需要标准库string类型的地方使用C风格字符串</p></li>
</ul>
<p><strong>显式转换</strong></p>
<p><strong>static_cast</strong>可以执行编译器无法自动执行的类型转换。任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> slope = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(j) / i;<br><br><span class="hljs-type">void</span> *p = &amp;d;<br><span class="hljs-type">double</span> *dp = <span class="hljs-built_in">static_const</span>&lt;<span class="hljs-type">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure>
<p><strong>const_cast</strong>是唯一能改变表达式的常量属性的显示转换（仅限底层const），不能用来改变表达式的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *pc;<br><span class="hljs-type">char</span> *p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(pc); <span class="hljs-comment">//正确，但通过p写值是未定义的行为</span><br><span class="hljs-comment">// const_cast绝对不是为了改变const变量的值而设计的！在函数参数的传递上const_cast的作用才显现出来。</span><br></code></pre></td></tr></table></figure>
<p><strong>reinterpret_cast</strong>非常危险，本质上依赖于机器。要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *ip;<br><span class="hljs-comment">// 由于显式地声称这种转换合法，所以编译器不会发出任何警告或错误信息。接下来再使用pc时就会认定它的值是char＊类型，编译器没法知道它实际存放的是指向int的指针。</span><br><span class="hljs-type">char</span> *pc = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(ip);<br></code></pre></td></tr></table></figure>
<p><strong>dynamic_cast</strong></p>
<p>19.2节详细介绍。</p>
<h3 id="运算符优先级表">4.12 运算符优先级表</h3>
<p><a
target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C%E5%92%8CC%2B%2B%E9%81%8B%E7%AE%97%E5%AD%90">C和C++运算符
- 维基百科，自由的百科全书</a></p>
<p>不同地方分级略有差异。</p>
<p>对于含有超过一个运算符的表达式，要想理解其含义关键要理解<strong>优先级、结合律和求值顺序</strong>。</p>
<h2 id="第5章-语句">第5章 语句</h2>
<h3 id="简单语句">5.1 简单语句</h3>
<p>空块的作用等价于空语句。</p>
<h3 id="语句作用域">5.2 语句作用域</h3>
<p>定义在控制结构当中的变量只在相应语句的内部可见。</p>
<h3 id="条件语句">5.3 条件语句</h3>
<p>如果要在switch结构中case标签内定义变量，最好用花括号限制在语句块内。</p>
<p>书中给的例子比较简略，详细的讨论可以参考：<a
target="_blank" rel="noopener" href="https://blog.csdn.net/LvzJason/article/details/123445116">【C++】switch
case内部的变量定义问题</a>。变量定义在编译阶段就会执行，变量初始化是运行阶段的事。</p>
<h3 id="迭代语句">5.4 迭代语句</h3>
<p>无。</p>
<h3 id="跳转语句">5.5 跳转语句</h3>
<p>无。</p>
<h3 id="try语句块和异常处理">5.6 try语句块和异常处理</h3>
<p>异常处理包括：·</p>
<ul>
<li>throw表达式（throw
expression），异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发（raise）了异常。</li>
<li>try语句块（try
block），异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句（catch
clause）结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码（exception
handler）。</li>
<li>一套异常类（exception
class），用于在throw表达式和相关的catch子句之间传递异常的具体信息。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-keyword">using</span> std::runtime_error;<br><span class="hljs-comment">// 片段</span><br><span class="hljs-keyword">while</span> (cin &gt;&gt; item1 &gt;&gt; item2) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// execute code that will add the two Sales_items</span><br>        <span class="hljs-comment">// if the addition fails, the code throws a runtime_error exception</span><br>        <span class="hljs-comment">// first check that the data are for the same item </span><br>        <span class="hljs-keyword">if</span> (item1.<span class="hljs-built_in">isbn</span>() != item2.<span class="hljs-built_in">isbn</span>())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Data must refer to same ISBN&quot;</span>);<br><br>        <span class="hljs-comment">// if we&#x27;re still here, the ISBNs are the same</span><br>        cout &lt;&lt; item1 + item2 &lt;&lt; endl;<br>    &#125; <span class="hljs-built_in">catch</span> (runtime_error err) &#123;<br>        <span class="hljs-comment">// remind the user that the ISBNs must match </span><br>        <span class="hljs-comment">// and prompt for another pair</span><br>        cout &lt;&lt; err.<span class="hljs-built_in">what</span>() <br>             &lt;&lt; <span class="hljs-string">&quot;\nTry Again?  Enter y or n&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-type">char</span> c;<br>        cin &gt;&gt; c;<br>        <span class="hljs-keyword">if</span> (!cin || c == <span class="hljs-string">&#x27;n&#x27;</span>)<br>            <span class="hljs-keyword">break</span>;      <span class="hljs-comment">// break out of the while loop</span><br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>异常中断了程序的正常流程。异常发生时，调用者请求的一部分计算可能已经完成了，另一部分则尚未完成。通常情况下，略过部分程序意味着某些对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正常释放，等等。那些在异常发生期间正确执行了“清理”工作的程序被称作异常安全（exception
safe）的代码。然而经验表明，<strong>编写异常安全的代码非常困难</strong>，这部分知识也（远远）超出了本书的范围。</p>
<p>C++标准库定义了一组类，用于报告标准库函数遇到的问题。它们分别定义在4个头文件中：</p>
<ul>
<li>exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。</li>
<li>stdexcept头文件定义了几种常用的异常类。</li>
<li>new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节（第407页）详细介绍。</li>
<li>type_info头文件定义了bad_cast异常类型，这种类型将在19.2节（第731页）详细介绍。</li>
</ul>
<p>异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const
char＊。该字符串的目的是提供关于异常的一些文本信息。</p>
<h2 id="第6章-函数">第6章 函数</h2>
<h3 id="函数基础">6.1 函数基础</h3>
<p>为了与C语言兼容，也可以使用关键字void表示函数没有形参。</p>
<p>我们把只存在于块执行期间的对象称为自动对象（automatic object）。</p>
<p><strong>局部静态对象</strong>（local static
object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p>
<p>函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。函数应该在头文件中声明而在源文件中定义。</p>
<p><strong>分离式编译</strong></p>
<p>如果我们修改了其中一个源文件，那么只需重新编译那个改动了的文件。大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（Windows）或.o（UNIX）的文件，后缀名的含义是该文件包含对象代码（object
code）。</p>
<h3 id="参数传递">6.2 参数传递</h3>
<p>和其他变量一样，形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。</p>
<p>熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。<strong>在C++语言中，建议使用引用类型的形参替代指针。</strong></p>
<p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。<strong>当函数无须修改引用形参的值时最好使用常量引用。</strong></p>
<p>我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 调用fcn函数时，既可以传入const int也可以传入int。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-comment">// 错误，重复定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 三个函数是等价的,每个函数的唯一形参都是const int＊类型的。当编译器处理对print函数的调用时，只检查传入的参数是否是const int＊类型。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><br><span class="hljs-comment">//形参也可以是数组的引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;arr)[<span class="hljs-number">10</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : arr)<br>        cout &lt;&lt; elem &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 由于数组的大小是构成数组类型的一部分，此时只能将print作用于大小为10的数组</span><br><br><span class="hljs-comment">// 传递多维数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> (*matrix)[<span class="hljs-number">10</span>], <span class="hljs-type">int</span> rowSize)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//形参argc表示数组中字符串的数量；形参argv是一个数组，它的元素是指向C风格字符串的指针。</span><br><span class="hljs-comment">//argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure>
<p><strong>可变形参</strong></p>
<p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：</p>
<ul>
<li><p>如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。</span><br> <span class="hljs-keyword">if</span> (expected != actual)<br>     <span class="hljs-built_in">error_msg</span>(&#123;<span class="hljs-string">&quot;functionX&quot;</span>, expected, actual&#125;);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">error_msg</span>(&#123;<span class="hljs-string">&quot;functionX&quot;</span>, <span class="hljs-string">&quot;okay&quot;</span>&#125;);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">(initializer_list&lt;string&gt; il)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> beg = il.<span class="hljs-built_in">begin</span>(); beg != il.<span class="hljs-built_in">end</span>(); ++beg)<br>        cout &lt;&lt; *beg &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，关于它的细节将在16.4节（第618页）介绍。</p></li>
</ul>
<p>还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与C函数交互的接口程序，是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。</p>
<h3 id="返回类型和return语句">6.3 返回类型和return语句</h3>
<p>不要返回局部对象的引用或指针。</p>
<p>调用一个返回引用的函数得到左值，其他返回类型得到右值。</p>
<p>允许main函数没有return语句直接结束。如果控制到达了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。</p>
<p><strong>返回数组指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方式一，使用别名</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> arrT[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">using</span> arrT = <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-function">arrT* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-comment">// 方式二</span><br><span class="hljs-built_in">int</span> (*<span class="hljs-built_in">func</span>(<span class="hljs-type">int</span> i))[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 方式三，尾置返回类型（trailing return type）</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> -&gt; <span class="hljs-title">int</span><span class="hljs-params">(*)</span>[10]</span>;<br><span class="hljs-comment">// 方式四，使用decltype</span><br><span class="hljs-comment">// decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个＊符号。</span><br><span class="hljs-type">int</span> odd[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> even[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-keyword">decltype</span>(odd) *<span class="hljs-built_in">arrPtr</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span>) ? &amp;odd : &amp;even;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="函数重载">6.4 函数重载</h3>
<p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。</p>
<p>main函数不能重载。</p>
<p><strong>底层const才可重载</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误重载</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> Phone)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone*)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone* <span class="hljs-type">const</span>)</span></span>;<br><span class="hljs-comment">// 正确重载</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account&amp;)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> Account&amp;)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account*)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> Account*)</span></span>;<br></code></pre></td></tr></table></figure>
<p>当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会<strong>优先</strong>选用非常量版本的函数。</p>
<p><strong>const_cast用于重载</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//也可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string的引用</span><br><span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-type">const</span> String &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt;= s2.<span class="hljs-built_in">size</span>() ? s1 : s2;<br>&#125;<br><span class="hljs-comment">//以下函数当它的实参不是常量时，得到的结果是一个普通的引用</span><br><span class="hljs-function">string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(string &amp;s1, string &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> &amp;r = <span class="hljs-built_in">shortString</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> string&amp;&gt;(s1),<br>                         <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> string&amp;&gt;(s2));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;string&amp;&gt;(r);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在C++语言中，名字查找发生在类型检查之前。</p>
<p>如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。<strong>在不同的作用域中无法重载函数名。</strong></p>
<h3 id="特殊用途语言特性">6.5 特殊用途语言特性</h3>
<p><strong>默认实参</strong></p>
<p>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p>
<p>在给定的作用域中一个形参只能被赋予<strong>一次</strong>默认实参。</p>
<p><strong>内联函数</strong></p>
<p>在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。内联函数可避免函数调用的开销。</p>
<p>将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。</p>
<p>内联说明只是向编译器发出的一个请求，<strong>编译器可以选择忽略这个请求</strong>。</p>
<p><strong>constexpr函数</strong></p>
<p>函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。</p>
<p>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名以及using声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> foo = <span class="hljs-built_in">new_sz</span>(); <span class="hljs-comment">// 正确</span><br><span class="hljs-comment">// 允许constexpr函数的返回值并非一个常量</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">size_t</span> cnt)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">new_sz</span>() * cnt; &#125;<br><span class="hljs-type">int</span> arr[<span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>)]; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> a2[<span class="hljs-built_in">scale</span>(i)]; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>
<p><strong>调试帮助</strong></p>
<p>定义在cassert头文件中的assert预处理宏由预处理器而非编译器管理。</p>
<p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。</p>
<p>编译器为每个函数都定义了_ _func_ _，它是const
char的一个静态数组，用于存放函数的名字。</p>
<h3 id="函数匹配">6.6 函数匹配</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误，二义性，无法匹配。只有一个就可以匹配。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>)</span></span>;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1.1</span>);<br><span class="hljs-comment">// 错误，二义性，无法匹配。只有一个就可以匹配。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-type">short</span>)</span></span>;<br><span class="hljs-built_in">ff</span>(<span class="hljs-number">3.14</span>);<br></code></pre></td></tr></table></figure>
<h3 id="函数指针">6.7 函数指针</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lengthCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;)</span></span>;<br><span class="hljs-comment">// 指针</span><br><span class="hljs-built_in">bool</span> (*pf)(<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;);<br>pf = lengthCompare;<br>pf = &amp;lengthCompare; <span class="hljs-comment">// 与上句等价，取地址符是可选的</span><br><span class="hljs-type">bool</span> b1 = <span class="hljs-built_in">pf</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;goodbye&quot;</span>);<br><span class="hljs-type">bool</span> b2 = (*pf)(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;goodbye&quot;</span>); <span class="hljs-comment">// 与上句等价，解引用符是可选的</span><br></code></pre></td></tr></table></figure>
<p>函数作为实参：此时它会自动转换成指针。</p>
<p>函数作为返回类型：<strong>必须显式地将返回类型指定为指针</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 别名</span><br><span class="hljs-comment">// 函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> Func2</span>;<br><span class="hljs-comment">// 指向函数的指针</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(*FuncP)</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> *Func2</span>;<br><span class="hljs-comment">// 函数类型</span><br><span class="hljs-keyword">using</span> F = <span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>);<br><span class="hljs-comment">// 指向函数的指针</span><br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>);<br><br><span class="hljs-function">PF <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-function">F <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 错误</span><br><span class="hljs-function">F *<span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 正确</span><br><br><span class="hljs-comment">// 直接声明f1</span><br><span class="hljs-built_in">int</span> (*<span class="hljs-built_in">f1</span>(<span class="hljs-type">int</span>))(<span class="hljs-type">int</span>*,<span class="hljs-type">int</span>);<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> -&gt; <span class="hljs-title">int</span> <span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>*,<span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure>
<p>形参（parameter）实参（argument）</p>
<h2 id="第7章-类">第7章 类</h2>
<h3 id="定义抽象数据类型">7.1 定义抽象数据类型</h3>
<p>成员函数通过一个名为<strong>this</strong>的额外的隐式参数来访问调用它的那个对象。</p>
<p>默认情况下，this的类型是指向类类型非常量版本的常量指针。成员函数的参数列表之后的const关键字表示this是一个指向常量的指针。常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p>
<p>一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。</p>
<p>​ 在参数列表后面写上<strong>=
default</strong>来要求编译器生成构造函数。=
default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。<strong>和其他函数一样，如果=
default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。</strong></p>
<p>构造函数初始值列表负责为新创建的对象的一个或几个数据成员赋初值。</p>
<h3 id="访问控制与封装">7.2 访问控制与封装</h3>
<p><strong>使用class和struct定义类唯一的区别就是默认的访问权限。</strong>如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。</p>
<p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的<strong>友元</strong>（friend）。</p>
<p><strong>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。</strong>如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。<strong>许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。</strong></p>
<h3 id="类的其他特性">7.3 类的其他特性</h3>
<p>定义在类内部的成员函数是自动inline的。</p>
<p>通过在变量的声明中加入<strong>mutable</strong>关键字声明为可变数据成员，即使是在一个const成员函数内也可修改。</p>
<p><strong>当我们提供一个类内初始值时，必须以符号=或者花括号表示。</strong></p>
<p>一个const成员函数如果以引用的形式返回<code>* this</code>，那么它的返回类型将是常量引用。这对链式调用函数不利（<code>temp.a().b()</code>形式），可以采用以下重载避免：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// display overloaded on whether the object is const or not</span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> </span>&#123; <span class="hljs-built_in">do_display</span>(os); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">const</span> Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">do_display</span>(os); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br><br><span class="hljs-comment">// function to do the work of displaying a Screen</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123;os &lt;&lt; contents;&#125;<br></code></pre></td></tr></table></figure>
<p>一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此<strong>类允许包含指向它自身类型的引用或指针</strong>。</p>
<p>类还可以把其他的类定义成<strong>友元</strong>，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。<strong>友元关系不存在传递性。</strong>要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。</p>
<h3 id="类的作用域">7.4 类的作用域</h3>
<p>一个类就是一个作用域。</p>
<p>编译器处理完类中的全部声明后才会处理成员函数的定义。</p>
<p>如果成员函数用到和类中成员变量相同的名字，可以用作用域运算符（::）或this指针显式访问类中成员变量。</p>
<h3 id="构造函数再探">7.5 构造函数再探</h3>
<p>使用使用<strong>构造函数初始值列表</strong>直接初始化，少了一步赋值操作效率更高；并且const成员变量或引用必须直接初始化。</p>
<p>构造函数初始值列表只说明用于初始化成员的值，而<strong>不限定初始化的具体执行顺序</strong>。</p>
<p>C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的<strong>委托构造函数</strong>（delegating
constructor）。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Sales_data <span class="hljs-title">obj</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 错误，声明了一个函数而非对象</span><br>Sales_data obj; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure>
<p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作<strong>转换构造函数</strong>（converting
constructor）。</p>
<p><strong>编译器只会自动地执行一步类型转换</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">item.<span class="hljs-built_in">combine</span>(<span class="hljs-string">&quot;9-999-99999-9&quot;</span>);<br><span class="hljs-comment">//错误，因为以上操作需要两步转换</span><br><span class="hljs-comment">//1.&quot;9-999-99999-9&quot;到string</span><br><span class="hljs-comment">//2.string到Sales_data对象</span><br></code></pre></td></tr></table></figure>
<p>可以将构造函数声明为<strong>explicit</strong>来阻止隐式转换。（1.只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复
2.explict声明的构造函数不能用于拷贝初始化）</p>
<blockquote>
<p>举例：</p>
<ul>
<li>接受一个单参数的const
char＊的string构造函数（参见3.2.1节，第76页）不是explicit的。</li>
<li>接受一个容量参数的vector构造函数（参见3.3.1节，第87页）是explicit的。</li>
</ul>
</blockquote>
<p><strong>聚合类</strong>（aggregate class）特点：</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值（参见2.6.1节，第64页）</li>
<li>没有基类，也没有virtual函数</li>
</ul>
<p><strong>字面值常量类</strong>是数据成员都是字面值类型的聚合类，或者满足以下特点：</p>
<ul>
<li>数据成员都是字面值类型</li>
<li>至少含有一个constexpr构造函数</li>
<li>如果一个数据成员含有类内初始值，内置类型成员的初始值必须是一条常量表达式；某种类类型的初始值必须使用成员自己的constexpr构造函数。</li>
<li>必须使用析构函数的默认定义，该成员负责销毁类的对象。</li>
</ul>
<blockquote>
<p>构造函数不能是const的（参见7.1.4节，第235页），但是字面值常量类的构造函数可以是constexpr（参见6.5.2节，第213页）函数。</p>
</blockquote>
<h3 id="类的静态成员">7.6 类的静态成员</h3>
<p>当在类的外部定义静态成员时，不能重复static关键字，<strong>该关键字只出现在类内部的声明语句</strong>。</p>
<p>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部<strong>定义</strong>一下该成员。（不然可能找不到定义）</p>
<p>非静态数据成员必须是完全类型，静态数据成员可以是<strong>不完全类型</strong>。</p>
<p>可以使用静态成员作为<strong>默认实参</strong>。</p>
<h1 id="第ⅱ部分-c标准库">第Ⅱ部分 C++标准库</h1>
<h2 id="第8章-io库">第8章 IO库</h2>
<h3 id="io类">8.1 IO类</h3>
<table>

<thead>
<tr class="header">
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>iostream</td>
<td>istream,wistream osteam,wostream iostream,wiostream</td>
</tr>
<tr class="even">
<td>fsteam</td>
<td>ifstream,wifstream ofstream,wofstream fstream,ofstream</td>
</tr>
<tr class="odd">
<td>sstream</td>
<td>isstringstream,wistringstream ostringstream,wostringstream
stringstream,wstringstream</td>
</tr>
</tbody>
</table>
<p>IO对象无拷贝或赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt;<span class="hljs-string">&quot;hi!&quot;</span>&lt;&lt;endl; <span class="hljs-comment">// 附加换行，刷新</span><br>cout&lt;&lt;<span class="hljs-string">&quot;hi!&quot;</span>&lt;&lt;flush; <span class="hljs-comment">// 刷新</span><br>cout&lt;&lt;<span class="hljs-string">&quot;hi!&quot;</span>&lt;&lt;ends; <span class="hljs-comment">// 附加空字符，刷新</span><br><span class="hljs-comment">// C++对ends的处理是在缓冲区附加’\0’然后刷新。windows和linux对’\0’的处理方式不同,在windows中会输出一个空格，而linux下则不会有输出。</span><br>cout&lt;&lt;unitbuf; <span class="hljs-comment">// 所有输出后立即刷新</span><br>cout&lt;&lt;nounitbuf; <span class="hljs-comment">// 回到正常缓冲方式</span><br></code></pre></td></tr></table></figure>
<p>如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。</p>
<p>标准库将cout和cin关联在一起，输入会导致输出缓冲区刷新。</p>
<p>使用<code>tie</code>成员函数，既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream。每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。</p>
<h3 id="文件输入输出">8.2 文件输入输出</h3>
<p>接受一个iostream类型引用（或指针）参数的函数，可以用一个对应的fstream（或sstream）类型来调用。</p>
<p><strong>文件模式</strong></p>
<ul>
<li>in 读</li>
<li>out 写</li>
<li>app 每次写前均定位到文件末尾</li>
<li>ate 打开文件后立即定位到文件末尾</li>
<li>trunc 截断文件</li>
<li>binary 以二进制方式进行IO</li>
</ul>
<p>open调用未显式指定输出模式，文件隐式地以out模式打开。out模式意味着同时使用trunc模式。</p>
<p>保留被ofstream打开的文件中已有数据的唯一方法是<strong>显式指定app或in模式</strong>。</p>
<h3 id="string流">8.3 string流</h3>
<p>无</p>
<h2 id="第9章-顺序容器">第9章 顺序容器</h2>
<h3 id="顺序容器概述">9.1 顺序容器概述</h3>
<table>

<thead>
<tr class="header">
<th>容器</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>vector</td>
<td>可变大小数组。支持快速随机访问。尾部之外的位置插入/删除很慢。</td>
</tr>
<tr class="even">
<td>deque</td>
<td>双端队列。支持快速随机访问。头尾位置插入/删除很快。</td>
</tr>
<tr class="odd">
<td>list</td>
<td>双向链表。只支持双向顺序访问。任何位置插入/删除很快。</td>
</tr>
<tr class="even">
<td>forward_list</td>
<td>单向链表。只支持单项顺序访问。任何位置插入/删除很快。</td>
</tr>
<tr class="odd">
<td>array</td>
<td>固定大小数组。支持快速随机访问。不能添加或删除元素。</td>
</tr>
<tr class="even">
<td>string</td>
<td>与vector类似，专用于保存字符。</td>
</tr>
</tbody>
</table>
<p>现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。</p>
<h3 id="容器库概览">9.2 容器库概览</h3>
<p>较旧的编译器可能需要在两个尖括号之间键入空格，例如，vector&lt;vector&lt;string&gt;
&gt;。</p>
<table>

<thead>
<tr class="header">
<th>通用容器操作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>类型别名</strong></td>
<td></td>
</tr>
<tr class="even">
<td>iterator</td>
<td>此容器类型的迭代器类型</td>
</tr>
<tr class="odd">
<td>const_iterator</td>
<td>const版本</td>
</tr>
<tr class="even">
<td>size_type</td>
<td>无符号整数类型，容器大小</td>
</tr>
<tr class="odd">
<td>difference_type</td>
<td>带符号整数类型，迭代器距离</td>
</tr>
<tr class="even">
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr class="odd">
<td>reference</td>
<td>元素的左值类型；等同于value_type&amp;</td>
</tr>
<tr class="even">
<td>const_reference</td>
<td>元素的const左值类型</td>
</tr>
<tr class="odd">
<td><strong>构造函数</strong></td>
<td></td>
</tr>
<tr class="even">
<td>C c;</td>
<td>默认构造函数（与内置数组一样，标准库array的大小也是类型的一部分）</td>
</tr>
<tr class="odd">
<td>C c1(c2);</td>
<td>构造c2的拷贝c1</td>
</tr>
<tr class="even">
<td>C c(b,e);</td>
<td>构造c，将迭代器b、e范围内的元素拷贝到c（array不支持）</td>
</tr>
<tr class="odd">
<td>C c{a,b,c...};</td>
<td>列表初始化c</td>
</tr>
<tr class="even">
<td><strong>赋值与swap</strong></td>
<td></td>
</tr>
<tr class="odd">
<td>c1=c2</td>
<td>将c1中元素替换为c2中元素</td>
</tr>
<tr class="even">
<td>c1={a,b,c...}</td>
<td>将c1中元素替换为列表中元素（array不支持）</td>
</tr>
<tr class="odd">
<td>a.swap(b)</td>
<td>交换</td>
</tr>
<tr class="even">
<td>swap(a,b)</td>
<td>交换</td>
</tr>
<tr class="odd">
<td><strong>大小</strong></td>
<td></td>
</tr>
<tr class="even">
<td>c.size()</td>
<td>c中元素数目（forward_list不支持）</td>
</tr>
<tr class="odd">
<td>c.max_size()</td>
<td>c可保存的最大元素数目</td>
</tr>
<tr class="even">
<td>c.empty()</td>
<td>是否为空</td>
</tr>
<tr class="odd">
<td><strong>添加/删除元素</strong></td>
<td>（array不支持）（不同容器中接口不同）</td>
</tr>
<tr class="even">
<td>c.insert(args)</td>
<td>将args中的元素拷贝进c</td>
</tr>
<tr class="odd">
<td>c.emplace(inits)</td>
<td>使用inits构造c中的一个元素</td>
</tr>
<tr class="even">
<td>c.erase(args)</td>
<td>删除args指定的元素</td>
</tr>
<tr class="odd">
<td>c.clear()</td>
<td>删除c中所有元素，返回void</td>
</tr>
<tr class="even">
<td><strong>关系运算符</strong></td>
<td></td>
</tr>
<tr class="odd">
<td>==, !=</td>
<td>所有容器都支持相等/不等运算符</td>
</tr>
<tr class="even">
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>关系运算符（无序关联容器不支持）</td>
</tr>
<tr class="odd">
<td><strong>获取迭代器</strong></td>
<td></td>
</tr>
<tr class="even">
<td>c.begin(), c.end()</td>
<td>返回指向c的首元素和尾元素之后位置的迭代器</td>
</tr>
<tr class="odd">
<td>c.cbegin(), c.end()</td>
<td>const版本</td>
</tr>
<tr class="even">
<td><strong>反向容器的额外成员</strong></td>
<td>（forward_list不支持）</td>
</tr>
<tr class="odd">
<td>reverse_iterator</td>
<td>逆序寻址</td>
</tr>
<tr class="even">
<td>const_reverse_iterator</td>
<td>const版本</td>
</tr>
<tr class="odd">
<td>c.rbegin(), c.rend()</td>
<td>返回指向c的尾元素和首元素之前位置的迭代器</td>
</tr>
<tr class="even">
<td>c.crbegin(), c.crend()</td>
<td>const版本</td>
</tr>
</tbody>
</table>
<p>虽然不能对内置数组类型进行拷贝或对象赋值操作，但array<strong>无此限制</strong>。</p>
<p>assign操作不适用于关联容器和array。</p>
<p><strong>赋值相关运算</strong>会导致指向左边容器内部的迭代器、引用和指针失效。</p>
<p><strong>swap操作</strong>不会导致容器内部的迭代器、引用和指针失效。array和string除外。</p>
<ul>
<li>对一个string调用swap会导致迭代器、引用和指针失效。</li>
<li>swap两个array会真正交换它们的元素。指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。</li>
</ul>
<h3 id="顺序容器操作">9.3 顺序容器操作</h3>
<table>

<thead>
<tr class="header">
<th>顺序容器添加元素操作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>c.push_back(t)</td>
<td>尾部创建</td>
</tr>
<tr class="even">
<td>c.emplace_back(args)</td>
<td></td>
</tr>
<tr class="odd">
<td>c.push_front()</td>
<td>头部创建</td>
</tr>
<tr class="even">
<td>c.emplace_front(args)</td>
<td></td>
</tr>
<tr class="odd">
<td>c.insert(p,t)</td>
<td>迭代器p指向的元素之前创建元素，<strong>返回指向新添加的元素的迭代器</strong></td>
</tr>
<tr class="even">
<td>c.emplace(p,args)</td>
<td></td>
</tr>
<tr class="odd">
<td>c.insert(p,n,t)</td>
<td>插入n个值为t的元素</td>
</tr>
<tr class="even">
<td>c.insert(p,b,e)</td>
<td>插入迭代器b、e范围内的元素</td>
</tr>
<tr class="odd">
<td>c.insert(p,il)</td>
<td>插入il（花括号包围的元素值列表）</td>
</tr>
</tbody>
</table>
<p>在新标准下，接受元素个数或范围的insert版本<strong>返回指向第一个新加入元素的迭代器</strong>。（在旧版本的标准库中，这些操作返回void。）如果范围为空，不插入任何元素，insert操作会将第一个参数返回。</p>
<p>emplace_front、emplace和emplace_back<strong>构造而不是拷贝元素</strong>。</p>
<p><strong>forward_list专有</strong>：</p>
<ul>
<li>insert_after</li>
<li>emplace_after</li>
<li>首前迭代器before_begin()、cbefore_begin()</li>
</ul>
<p>forward_list不支持push_back和emplace_back</p>
<p>vector、string不支持push_front和emplace_front</p>
<table>
<thead>
<tr class="header">
<th>顺序容器访问元素操作</th>
<th>（返回引用）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>c.back()</td>
<td>若c为空，函数行为未定义（forward_list不支持）</td>
</tr>
<tr class="even">
<td>c.front()</td>
<td>若c为空，函数行为未定义</td>
</tr>
<tr class="odd">
<td>c[n]</td>
<td>若n&gt;=c.size()，函数行为未定义</td>
</tr>
<tr class="even">
<td>c.at(n)</td>
<td>若下表越界，抛出out_of_range异常</td>
</tr>
</tbody>
</table>
<p>at和下标只适用于string、vector、deque、array。</p>
<table>

<thead>
<tr class="header">
<th>顺序容器删除元素操作</th>
<th>（一律不适用于array）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>c.pop_back()</td>
<td>若c为空，函数行为未定义（forward_list不支持）</td>
</tr>
<tr class="even">
<td>c.pop_front()</td>
<td>若c为空，函数行为未定义（vector、string不支持）</td>
</tr>
<tr class="odd">
<td>c.erase(p)</td>
<td>删除迭代器p所指向元素，<strong>返回指向被删元素之后元素的迭代器</strong></td>
</tr>
<tr class="even">
<td>c.erase(b,e)</td>
<td></td>
</tr>
<tr class="odd">
<td>c.clear()</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>forward_list专有</strong>：</p>
<ul>
<li>erase_after</li>
</ul>
<p><strong>操作容器后的迭代器、指针和引用失效问题</strong></p>
<p>添加元素后：</p>
<ul>
<li>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li>
<li>如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。</li>
</ul>
<p>删除元素后：</p>
<ul>
<li>对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。</li>
<li>对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。</li>
</ul>
<h3 id="vector对象是如何增长的">9.4 vector对象是如何增长的</h3>
<p>resize改变容器中元素的数目size，reserve改变容器的容量capacity（只增大）。</p>
<p>可以调用shrink_to_fit来要求deque、vector或string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，<strong>具体的实现可以选择忽略此请求</strong>。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。</p>
<p>只有在执行insert操作时size与capacity相等，或者调用resize或reserve时给定的大小超过当前capacity，vector才可能重新分配内存空间。会分配多少超过给定容量的额外空间，<strong>取决于具体实现</strong>。</p>
<h3 id="额外的string操作">9.5 额外的string操作</h3>
<p>如果string搜索函数搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义为一个const
string::size_type类型，并初始化为值<strong>-1</strong>。由于npos是一个unsigned类型，此初始值意味着npos等于任何string最大的可能大小。</p>
<h3 id="容器适配器">9.6 容器适配器</h3>
<p>一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。</p>
<p>3个顺序容器适配器：stack、queue、priority_queue。</p>
<p>默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</p>
<p>stack只要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器类型来构造stack。queue适配器要求back、push_back、front和push_front，因此它可以构造于list或deque之上，但不能基于vector构造。priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造于vector或deque之上，但不能基于list构造。</p>
<h2 id="第10章-泛型算法">第10章 泛型算法</h2>
<h3 id="概述">10.1 概述</h3>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。</p>
<h3 id="初识泛型算法">10.2 初识泛型算法</h3>
<p>无。</p>
<h3 id="定制操作">10.3 定制操作</h3>
<p><strong>谓词</strong>是一个可调用的表达式，其返回结果是一个能用作条件的值。</p>
<p>标准库算法所使用的谓词分为两类：一元谓词（unary
predicate，意味着它们只接受单一参数）和二元谓词（binary
predicate，意味着它们有两个参数）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();<br>&#125;<br><span class="hljs-comment">// 接受一个二元谓词</span><br><span class="hljs-comment">// 按长度由短至长排序words</span><br><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(),words.<span class="hljs-built_in">end</span>(),isShorter);<br><span class="hljs-comment">// 可以利用lambda表达式捕获局部变量为一元谓词提供更多参数</span><br><span class="hljs-comment">// 获取指向第一个满足a.size() &gt;= sz的迭代器</span><br><span class="hljs-keyword">auto</span> wc = <span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(),words.<span class="hljs-built_in">end</span>(),<br>                 [sz](<span class="hljs-type">const</span> string &amp;a)<br>                  &#123;<span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt;= sz;&#125;);<br></code></pre></td></tr></table></figure>
<p>stable_sort稳定排序算法维持相等元素的原有顺序。</p>
<p><strong>lambda表达式</strong></p>
<p>当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。</p>
<p>捕获列表只用于<strong>局部非static变量</strong>，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。</p>
<p>值捕获 / 引用捕获。</p>
<p>如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。</p>
<p>如果我们希望能改变一个被捕获的变量的值，就必须在参数列表尾加上关键字mutable。</p>
<blockquote>
<p>被捕获的变量成为了static成员。</p>
</blockquote>
<p><strong>bind函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;<br><span class="hljs-keyword">auto</span> wc = <span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>                 <span class="hljs-built_in">bind</span>(check_size, _1, sz));<br><span class="hljs-comment">// 如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库ref函数</span><br><span class="hljs-function">ostrean &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> string &amp;s, <span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; s &lt;&lt; c;<br>&#125;<br><span class="hljs-comment">// 错误</span><br>for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(print, os, _1, <span class="hljs-string">&#x27; &#x27;</span>));<br><span class="hljs-comment">// 正确</span><br>for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(print, <span class="hljs-built_in">ref</span>(os), _1, <span class="hljs-string">&#x27; &#x27;</span>));<br></code></pre></td></tr></table></figure>
<h3 id="再探迭代器">10.4 再探迭代器</h3>
<p><strong>插入迭代器</strong>（insert iterator）</p>
<p>这些迭代器被绑定到一个容器上，可用来向容器插入元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>list&lt;<span class="hljs-type">int</span>&gt; lst2, lst3;<br><span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">cbegin</span>(), lst.<span class="hljs-built_in">cend</span>(), <span class="hljs-built_in">front_insert</span>(lst2)); <span class="hljs-comment">// 倒序</span><br><span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">cbegin</span>(), lst.<span class="hljs-built_in">cend</span>(), <span class="hljs-built_in">inserter</span>(lst3, lst3,<span class="hljs-built_in">begin</span>())); <span class="hljs-comment">// 正序</span><br></code></pre></td></tr></table></figure>
<p><strong>流迭代器</strong>（stream iterator）</p>
<p>这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in_iter</span><span class="hljs-params">(cin)</span></span>; <br>istream_iteraror&lt;<span class="hljs-type">int</span>&gt; eof;<br><span class="hljs-keyword">while</span>(in_iter != eof)<br>    vec.<span class="hljs-built_in">push_back</span>(*in_iter++);<br><span class="hljs-comment">// 等价</span><br><span class="hljs-function">istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in_iter</span><span class="hljs-params">(cin)</span>, eof</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(in_iter, eof)</span></span>;<br><span class="hljs-comment">// 运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的程序没有任何影响。</span><br></code></pre></td></tr></table></figure>
<p><strong>反向迭代器</strong>（reverse iterator）</p>
<p>这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。</p>
<p><strong>移动迭代器</strong>（move iterator）</p>
<p>这些专用的迭代器不是拷贝其中的元素，而是移动它们。我们将在13.6.2节（第480页）介绍移动迭代器。</p>
<h3 id="泛型算法结构">10.5 泛型算法结构</h3>
<p>无。</p>
<h3 id="特定容器算法">10.6 特定容器算法</h3>
<p>容器forward_list和list对一些通用算法定义了自己特有的版本。与通用算法不同，这些链表特有版本会修改给定的链表。</p>
<h2 id="第11章-关联容器">第11章 关联容器</h2>
<table>
<thead>
<tr class="header">
<th>容器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>map</td>
<td>键值对</td>
</tr>
<tr class="even">
<td>set</td>
<td>键</td>
</tr>
<tr class="odd">
<td>multimap</td>
<td>可重复</td>
</tr>
<tr class="even">
<td>multiset</td>
<td>可重复</td>
</tr>
<tr class="odd">
<td>unordered_map</td>
<td>哈希函数组织</td>
</tr>
<tr class="even">
<td>unordered_set</td>
<td>哈希函数组织</td>
</tr>
<tr class="odd">
<td>unordered_multimap</td>
<td>可重复</td>
</tr>
<tr class="even">
<td>unordered_multiset</td>
<td>可重复</td>
</tr>
</tbody>
</table>
<h3 id="使用关联容器">11.1 使用关联容器</h3>
<p>无。</p>
<h3 id="关联容器概述">11.2 关联容器概述</h3>
<p>标准库类型pair定义在头文件utility中。</p>
<p>与其他标准库类型不同，pair的数据成员是public的，两个成员分别命名为first和second。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">pair&lt;string, string&gt; author&#123;<span class="hljs-string">&quot;James&quot;</span>, <span class="hljs-string">&quot;Joyce&quot;</span>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="关联容器操作">11.3 关联容器操作</h3>
<p><strong>关联容器额外的类型别名</strong></p>
<p>key_type 此容器类型的关键字类型</p>
<p>mapped_type 每个关键字关联的类型，仅限map</p>
<p>value_type 对于set，与key_type相同；对于map，为pair&lt;const
key_type， mapped_type&gt;</p>
<p>set的迭代器是const的。</p>
<p>对一个map使用下标操作，其行为与数组或vector上的下标操作很不相同：使用一个不在容器中的关键字作为下标，会<strong>添加</strong>一个具有此关键字的元素到map中。</p>
<p>因此，下标和at操作只适用于非const的map和unordered_map。</p>
<p>c.find(k)</p>
<p>c.count(k)</p>
<p>c.lower_bound(k)</p>
<p>c.upper_bound(k)</p>
<p>c.equal_range(k)</p>
<h3 id="无序容器">11.4 无序容器</h3>
<p>无序容器提供了一组管理桶的函数，可以用来性能调优。</p>
<p>自定义类型的无序容器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">hasher</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;sd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;string&gt;()(sd.<span class="hljs-built_in">isbn</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eqOp</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;lhs, <span class="hljs-type">const</span> Sales_data &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br><span class="hljs-keyword">using</span> SD_multiset = unordered_multiset&lt;Sales_data, <span class="hljs-keyword">decltype</span>(hasher)*, <span class="hljs-keyword">decltype</span>(eqOp)*&gt;;<br><span class="hljs-comment">// 参数是桶大小、哈希函数指针和相等性判断运算符指针</span><br><span class="hljs-function">SD_multiset <span class="hljs-title">bookstore</span><span class="hljs-params">(<span class="hljs-number">42</span>,hasder,eqOp)</span></span>;<br></code></pre></td></tr></table></figure>
<h2 id="第12章-动态内存">第12章 动态内存</h2>
<p><strong>静态内存</strong>用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。static对象在使用之前分配，在程序结束时销毁。</p>
<p><strong>栈内存</strong>用来保存定义在函数内的非static对象。栈对象仅在其定义的程序块运行时才存在</p>
<p>除了自动和static对象外，C++还支持动态分配对象，存储在<strong>堆内存</strong>中。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。</p>
<h3 id="动态内存与智能指针">12.1 动态内存与智能指针</h3>
<table>

<thead>
<tr class="header">
<th>shared_ptr和unique_ptr都支持</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>shared_ptr&lt;T&gt; sp</td>
<td>空智能指针</td>
</tr>
<tr class="even">
<td>unique_ptr&lt;T&gt; up</td>
<td></td>
</tr>
<tr class="odd">
<td>p</td>
<td>若p指向一个对象，返回true</td>
</tr>
<tr class="even">
<td>*p</td>
<td>解引用p，获得它指向的对象</td>
</tr>
<tr class="odd">
<td>p-&gt;mem</td>
<td>等价于(*p).mem</td>
</tr>
<tr class="even">
<td>p.get()</td>
<td>返回p中保存的指针。<strong>永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。</strong></td>
</tr>
<tr class="odd">
<td>swap(p,q) / p.swap(q)</td>
<td>交换</td>
</tr>
</tbody>
</table>
<table>

<thead>
<tr class="header">
<th>shared_ptr独有操作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>make_shared&lt;T&gt;(args)</td>
<td>初始化shared_ptr</td>
</tr>
<tr class="even">
<td>shared_ptr&lt;T&gt; p(q)</td>
<td></td>
</tr>
<tr class="odd">
<td>p = q</td>
<td></td>
</tr>
<tr class="even">
<td>p.unique()</td>
<td>p.use_count()为1则返回true</td>
</tr>
<tr class="odd">
<td>p.use_count()</td>
<td>返回与p共享对象的智能指针数量；可能很慢，用于调试</td>
</tr>
</tbody>
</table>
<p>到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候<strong>自动释放</strong>对象。</p>
<p>自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象<strong>拷贝、赋值和销毁</strong>操作的任何默认定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">string *ps1 = <span class="hljs-keyword">new</span> string; <span class="hljs-comment">// 默认初始化为空string</span><br>string *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(); <span class="hljs-comment">// 值初始化为空string</span><br><span class="hljs-type">int</span> *pi1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// 默认初始化，*pi1的值未定义</span><br><span class="hljs-type">int</span> *pi2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(); <span class="hljs-comment">// 值初始化为0，*pi2为0</span><br><br><span class="hljs-comment">// 用new分配const对象是合法的。</span><br><span class="hljs-type">const</span> string *pcs = <span class="hljs-keyword">new</span> <span class="hljs-type">const</span> string;<br></code></pre></td></tr></table></figure>
<p>动态内存的一个基本问题是<strong>可能有多个指针指向相同的内存</strong>。</p>
<p>可以通过<strong>定位new</strong>向new传递额外的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// 如果分配失败，new抛出std::bad_alloc。</span><br><span class="hljs-type">int</span> *p2 = <span class="hljs-built_in">new</span> (nothrow) <span class="hljs-type">int</span>; <span class="hljs-comment">// 传递给new一个由标准库定义的名为nothrow的对象。如果分配失败，new返回一个空指针。</span><br><span class="hljs-comment">// bad_alloc、nothrow都定义在头文件new中</span><br></code></pre></td></tr></table></figure>
<p>接受指针参数的智能指针构造函数是explicit的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用<strong>直接初始化</strong>形式来初始化一个智能指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误，拷贝初始化</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1024</span>);<br><span class="hljs-comment">// 正确，直接初始化</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">1024</span>))</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>智能指针陷阱</strong>：</p>
<ul>
<li>不使用相同的内置指针值初始化（或reset）多个智能指针。</li>
<li>不delete get（）返回的指针。·
不使用get（）初始化或reset另一个智能指针。</li>
<li>如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。</li>
</ul>
<table>

<thead>
<tr class="header">
<th>定义和改变shared_ptr的其它方法</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>shared_ptr&lt;T&gt; p(q)</td>
<td>p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型</td>
</tr>
<tr class="even">
<td>shared_ptr&lt;T&gt; p(u)</td>
<td>p从unique_ptr u那里接管对象所有权，将u置空</td>
</tr>
<tr class="odd">
<td>shared_ptr&lt;T&gt; p(q, d)</td>
<td>p接管内置指针q所指向对象的所有权。p将使用可调用对象d来代替delete。</td>
</tr>
<tr class="even">
<td>shared_ptr&lt;T&gt; p(p2, d)</td>
<td>p是shared_ptr p2的拷贝。p将使用可调用对象d来代替delete。</td>
</tr>
<tr class="odd">
<td>p.reset()</td>
<td>释放</td>
</tr>
<tr class="even">
<td>p.reset(q)</td>
<td></td>
</tr>
<tr class="odd">
<td>p.reset(q, d)</td>
<td></td>
</tr>
</tbody>
</table>
<table>

<thead>
<tr class="header">
<th>unique_ptr操作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>unique_ptr&lt;T&gt; u1</td>
<td></td>
</tr>
<tr class="even">
<td>unique_ptr&lt;T, D&gt; u2</td>
<td>u2会使用一个类型为D的可调用对象来释放它的指针</td>
</tr>
<tr class="odd">
<td>unique_ptr&lt;T, D&gt; u(d)</td>
<td></td>
</tr>
<tr class="even">
<td>u = nullptr</td>
<td></td>
</tr>
<tr class="odd">
<td>u.release()</td>
<td>释放，返回指针，置空</td>
</tr>
<tr class="even">
<td>u.reset()</td>
<td></td>
</tr>
<tr class="odd">
<td>u.reset(q)</td>
<td></td>
</tr>
<tr class="even">
<td>u.reset(nullptr)</td>
<td></td>
</tr>
</tbody>
</table>
<p>不能拷贝unique_ptr的规则有一个<strong>例外</strong>：我们可以拷贝或赋值一个将要被销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr。</p>
<p>unique_ptr管理删除器的方式与shared_ptr<strong>不同</strong>，其原因我们将在16.1.6节（第599页）中介绍。</p>
<table>

<thead>
<tr class="header">
<th>weak_ptr操作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>weak_ptr&lt;T&gt; w</td>
<td></td>
</tr>
<tr class="even">
<td>weak_ptr&lt;T&gt; w(sp)</td>
<td>与shared_ptr sp指向相同对象得weak_ptr</td>
</tr>
<tr class="odd">
<td>w = p</td>
<td>p可以是shared_ptr或weak_ptr</td>
</tr>
<tr class="even">
<td>w.reset()</td>
<td></td>
</tr>
<tr class="odd">
<td>w.use_count()</td>
<td>与w共享对象的shared_ptr的数量</td>
</tr>
<tr class="even">
<td>w.expired()</td>
<td>w.use_count()为0返回true</td>
</tr>
<tr class="odd">
<td>w.lock()</td>
<td>expired为true返回空shared_ptr，否则返回指向w的对象的shared_ptr</td>
</tr>
</tbody>
</table>
<h3 id="动态数组">12.2 动态数组</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方括号中的大小必须是整型，但不必是常量。</span><br><span class="hljs-type">int</span> *pia = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-built_in">get_size</span>()];<br><span class="hljs-comment">// 使用别名</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> arrT[<span class="hljs-number">42</span>];<br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> arrT;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">42</span>];<br></code></pre></td></tr></table></figure>
<p><strong>动态数组并不是数组类型</strong></p>
<p>由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end。这些函数使用数组维度（回忆一下，维度是数组类型的一部分）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围for语句来处理（所谓的）动态数组中的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// auto初始化</span><br><span class="hljs-keyword">auto</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">auto</span>(obj); <span class="hljs-comment">// p指向一个与obj类型相同的对象，该对象用obj进行初始化</span><br><span class="hljs-keyword">auto</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">auto</span>&#123;a,b,c&#125;; <span class="hljs-comment">// 错误，括号中只能有单个初始化器</span><br><br><span class="hljs-comment">// 不能用auto分配数组，只能</span><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]();<br></code></pre></td></tr></table></figure>
<p>用new分配一个大小为0的数组时，new返回一个<strong>合法</strong>的非空指针。</p>
<p>当我们释放一个指向数组的指针时，空方括号对是必需的：它指示编译器此指针指向一个对象数组的第一个元素。如果我们在delete一个指向数组的指针时忽略了方括号（或者在delete一个指向单一对象的指针时使用了方括号），其行为是<strong>未定义</strong>的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p;<br><span class="hljs-keyword">delete</span> [] pa;<br></code></pre></td></tr></table></figure>
<p>unique_ptr支持直接管理动态数组，shared_ptr不支持。</p>
<p>如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器；并且，为了访问数组中的元素，不能使用下标，必须用get获取一个内置指针，然后用它来访问数组元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-type">int</span> *p)&#123;<span class="hljs-keyword">delete</span> [] p;&#125;)</span></span>;<br>sp.<span class="hljs-built_in">reset</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)<br>    *(sp.<span class="hljs-built_in">get</span>() + i) = i;<br></code></pre></td></tr></table></figure>
<p>标准库allocator类定义在头文件memory中，它帮助我们<strong>将内存分配和对象构造分离开来</strong>。</p>
<table>

<thead>
<tr class="header">
<th>allocator</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>allocator&lt;T&gt; a</td>
<td></td>
</tr>
<tr class="even">
<td>a.allocate(n)</td>
<td></td>
</tr>
<tr class="odd">
<td>a.deallocate(p, n)</td>
<td>释放内存，n必须是p创建时所要求的大小。之前要destroy。</td>
</tr>
<tr class="even">
<td>a.construct(p, args)</td>
<td>args被传递给类型为T的构造函数。</td>
</tr>
<tr class="odd">
<td>a.destroy(p)</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = alloc.<span class="hljs-built_in">allocate</span>(vi.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);<br><span class="hljs-keyword">auto</span> q = <span class="hljs-built_in">uninitialized_copy</span>(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), p);<br><span class="hljs-built_in">uninitialized_fill_n</span>(q, vi.<span class="hljs-built_in">size</span>(), <span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure>
<h3 id="使用标准库文本查询程序">12.3 使用标准库：文本查询程序</h3>
<p>无。</p>
<h1 id="第ⅲ部分-类设计者的工具">第Ⅲ部分 类设计者的工具</h1>
<p><strong>直到学习完第13章，不要在类内的代码中分配动态内存。</strong></p>
<h2 id="第13章-拷贝控制">第13章 拷贝控制</h2>
<p>一个类通过定义五种特殊的成员函数来控制对象拷贝、移动、赋值和销毁时做什么，包括：</p>
<p>拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment
operator）、移动构造函数（move
constructor）、移动赋值运算符（move-assignment
operator）和析构函数（destructor）。</p>
<h3 id="拷贝赋值与销毁">13.1 拷贝、赋值与销毁</h3>
<p><strong>拷贝构造函数</strong></p>
<p>第一个参数是自身类类型的引用，且任何额外参数都有默认值。</p>
<p>拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生：</p>
<ul>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
<li>初始化标准库容器或是调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。</li>
</ul>
<p><strong>为什么拷贝构造函数自己的参数必须是引用类型？</strong></p>
<p>拷贝构造函数被用来初始化<strong>非引用类类型参数</strong>。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。</p>
<p>无论何时一个对象被销毁，就会自动调用其<strong>析构函数</strong>：</p>
<ul>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时，其成员被销毁。</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。</li>
<li>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁。</li>
</ul>
<p>定义为=default来<strong>显式地要求编译器生成合成的版本</strong>。</p>
<p>定义为=delete来<strong>显式删除</strong>。</p>
<p>与=default不同，=delete必须出现在函数第一次声明的时候。</p>
<p>对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象。</p>
<p>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p>
<h3 id="拷贝控制和资源管理">13.2 拷贝控制和资源管理</h3>
<p>可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</p>
<p>当你编写赋值运算符时，有两点需要记住：</p>
<ol type="1">
<li>如果将一个对象赋予它自身，赋值运算符必须能正确工作。</li>
<li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作。</li>
</ol>
<h3 id="交换操作">13.3 交换操作</h3>
<p>自定义swap友元函数效率更高。</p>
<p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为<strong>拷贝并交换</strong>（copy
and swap）的技术。在这个版本的赋值运算符中，参数并不是一个引用。</p>
<h3 id="拷贝控制示例">13.4 拷贝控制示例</h3>
<p>无。</p>
<h3 id="动态内存管理类">13.5 动态内存管理类</h3>
<p>无。</p>
<h3 id="对象移动">13.6 对象移动</h3>
<p>在旧C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。</p>
<p>标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p>
<p>通过&amp;&amp;而不是&amp;来获得<strong>右值引用</strong>（rvalue
reference）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;r = i;<br><span class="hljs-type">int</span> &amp;&amp;rr = i;  <span class="hljs-comment">// 错误，不能将右值引用绑定到左值</span><br><span class="hljs-type">int</span> &amp;r2 = i * <span class="hljs-number">42</span>; <span class="hljs-comment">// 错误，i * 42是一个右值 </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = i * <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;&amp;rr2 = i * <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure>
<p>变量表达式都是左值，我们<strong>不能将一个右值引用绑定到一个右值引用类型的变量上</strong>。</p>
<p>可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。</p>
<p>noexcept是我们承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表后指定noexcept。不抛出异常的移动构造函数和移动赋值运算符<strong>必须</strong>标记为noexcept。除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。</p>
<p>🔺只有当一个类没有定义任何自己版本的拷贝控制成员，<strong>且类的每个非static数据成员都可以移动时</strong>，编译器才会为它合成移动构造函数或移动赋值运算符。</p>
<p>如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。</p>
<p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。</p>
<p>🔺<strong>所有五个拷贝控制成员应该看作一个整体</strong>：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。</p>
<blockquote>
<p>网上有一种说法称其为三/五法则</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 添加的移动构造函数</span><br>    <span class="hljs-built_in">HasPtr</span>(HasPtr &amp;&amp;p) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">ps</span>(p.ps), <span class="hljs-built_in">i</span>(p.i) &#123;p.ps = <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-comment">// 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符</span><br>    HasPtr&amp; <span class="hljs-keyword">operator</span>=(HasPtr rhs) &#123;<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个<strong>移动迭代器</strong>。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。</p>
<p>由于一个移后源对象具有<strong>不确定</strong>的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。通过在类代码中小心地使用move，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。</p>
<p><strong>引用限定符</strong>(&amp;或&amp;&amp;)分别指出this可以指向一个左值或右值。对于&amp;限定的函数，我们只能将它用于左值；对于&amp;&amp;限定的函数，只能用于右值。类似<strong>const限定符</strong>，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。一个函数可以同时用const和引用限定。在此情况下，引用限定符必须跟随在const限定符之后。</p>
<blockquote>
<p>可以用&amp;修饰=运算符函数阻止向右值赋值。</p>
</blockquote>
<p><strong>可以综合引用限定符和const来区分一个成员函数的重载版本。</strong></p>
<p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</p>
<h2 id="第14章-重载运算与类型转换">第14章 重载运算与类型转换</h2>
<h3 id="基本概念">14.1 基本概念</h3>
<p>当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。</p>
<p>使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是，逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。除此之外，&amp;&amp;和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。</span><br>string u = <span class="hljs-string">&quot;hi&quot;</span> + s; <span class="hljs-comment">// 如果+是string的成员，则产生错误</span><br></code></pre></td></tr></table></figure>
<p>将运算符定义为成员函数还是普通的非成员函数？</p>
<ul>
<li>赋值（=）、下标（[ ]）、调用（（
））和成员访问箭头（-&gt;）运算符必须是成员。</li>
<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>
</ul>
<h3 id="输入和输出运算符">14.2 输入和输出运算符</h3>
<p>无。</p>
<h3 id="算术和关系运算符">14.3 算术和关系运算符</h3>
<p>通常情况下，我们把算术和关系运算符定义成<strong>非成员函数</strong>以允许对左侧或右侧的运算对象进行转换。</p>
<p>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。</p>
<h3 id="赋值运算符-1">14.4 赋值运算符</h3>
<p>在拷贝赋值和移动赋值运算符之外，标准库vector类还定义了第三种赋值运算符，该运算符接受花括号内的元素列表作为参数。</p>
<h3 id="下标运算符">14.5 下标运算符</h3>
<p>如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。</p>
<h3 id="递增和递减运算符-1">14.6 递增和递减运算符</h3>
<p>定义递增和递减运算符的类应该<strong>同时定义前置版本和后置版本</strong>。</p>
<p>为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用；后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。</p>
<p>后置版本接受一个额外的（不被使用）int类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 若显式调用</span><br>p.<span class="hljs-keyword">operator</span>++(<span class="hljs-number">0</span>); <span class="hljs-comment">// 调用后置版本</span><br>p.<span class="hljs-keyword">operator</span>++(); <span class="hljs-comment">// 调用前置版本</span><br></code></pre></td></tr></table></figure>
<h3 id="成员访问运算符-1">14.7 成员访问运算符</h3>
<p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</p>
<h3 id="函数调用运算符">14.8 函数调用运算符</h3>
<p>当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> wc = <span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(),words.<span class="hljs-built_in">end</span>(),<br>                 [sz](<span class="hljs-type">const</span> string &amp;a)<br>                  &#123; <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt;= sz;&#125;);<br><span class="hljs-comment">// 行为类似</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SizeComp</span> &#123;<br>    <span class="hljs-built_in">SizeComp</span>(<span class="hljs-type">size_t</span> n):<span class="hljs-built_in">sz</span>(n) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>() &gt;= sz; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">size_t</span> sz;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;string&gt;());<br></code></pre></td></tr></table></figure>
<p>比较两个无关指针将产生未定义的行为，但标准库规定其函数对象对于指针同样适用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string*&gt; nameTable;<br><span class="hljs-comment">// 错误</span><br><span class="hljs-built_in">sort</span>(nameTable,<span class="hljs-built_in">begin</span>(), nameTable.<span class="hljs-built_in">end</span>(),<br>    [](string *a, string *b)&#123;<span class="hljs-keyword">return</span> a &lt; b;&#125;);<br><span class="hljs-comment">// 正确</span><br><span class="hljs-built_in">sort</span>(nameTable.<span class="hljs-built_in">begin</span>(), nameTable.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">less</span>&lt;string*&gt;());<br></code></pre></td></tr></table></figure>
<p>可以使用function调用可调用对象（函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> i + j; &#125;<br><span class="hljs-keyword">auto</span> mod = [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> i % j; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">divide</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> denominator, <span class="hljs-type">int</span> divisor)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> denominator / divisor;<br>    &#125;<br>&#125;;<br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; f1 = add;<br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; f2 = divide;<br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; f2 = mod;<br></code></pre></td></tr></table></figure>
<p>不能（直接）将重载函数的名字存入function类型的对象中，需要通过函数指针消除二义性。</p>
<h3 id="重载类型转换与运算符">14.9 重载、类型转换与运算符</h3>
<p><strong>类型转换运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure>
<p>通常情况下，<strong>不要为类定义相同的类型转换</strong>，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。</p>
<h2 id="第15章-面向对象程序设计">第15章 面向对象程序设计</h2>
<p>面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。</p>
<h3 id="oop概述">15.1 OOP：概述</h3>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数</strong>（virtual
function）。任何构造函数之外的非静态函数都可以是虚函数。成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。</p>
<p>使用基类的引用（或指针）调用一个虚函数时将发生<strong>动态绑定</strong>。</p>
<h3 id="定义基类和派生类">15.2 定义基类和派生类</h3>
<p>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
<p>派生类必须通过使用<strong>类派生列表</strong>（class derivation
list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种<strong>访问说明符</strong>中的一个：public、protected或者private。</p>
<p>C++标准并没有明确规定派生类的对象在内存中如何分布。</p>
<p><strong>编译器会隐式地执行派生类到基类的转换。</strong>我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。</p>
<p>每个类负责定义各自的接口。派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
<p>如果基类定义了一个静态成员，则在整个继承体系中<strong>只存在该成员的唯一定义</strong>。</p>
<p>派生类的<strong>声明包含类名但是不包含它的派生列表</strong>。一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类、一个函数或一个变量等。派生列表以及与定义有关的其他细节必须与类的主体一起出现。</p>
<p>用作基类的类必须已经定义而非仅仅声明（隐含一个类不能派生它本身）。</p>
<p>类名后跟一个关键字final<strong>防止继承</strong>。</p>
<p>派生类向基类的<strong>自动</strong>类型转换<strong>只对指针或引用类型有效</strong>，在派生类类型和基类类型之间不存在这样的转换。和内置指针一样，智能指针类也支持派生类向基类的类型转换。基类向派生类不存在隐式类型转换。</p>
<h3 id="虚函数">15.3 虚函数</h3>
<p>当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做<strong>并非必须</strong>，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
<p>使用override关键字来说明派生类中的虚函数，使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误。</p>
<p>final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。</p>
<p>虚函数也可以拥有<strong>默认实参</strong>，如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。</p>
<p><strong>使用作用域运算符可以强迫其执行虚函数的某个特定版本。</strong></p>
<h3 id="抽象基类">15.4 抽象基类</h3>
<p>纯虚（pure
virtual）函数无须定义。在函数体的位置（即在声明语句的分号之前）书写=0。我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p>
<p>含有纯虚函数的类是<strong>抽象基类</strong>。不能创建抽象基类的对象。</p>
<h3 id="访问控制与继承">15.5 访问控制与继承</h3>
<p>protected关键字需要注意：派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。<strong>避免基类的protected保护被规避。</strong></p>
<p>某个类对其继承而来的成员的访问权限受到两个因素影响：</p>
<ol type="1">
<li>在基类中该成员的访问说明符</li>
<li>在派生类的派生列表中的访问说明符</li>
</ol>
<p><strong>派生访问说明符</strong>对于派生类的<strong>成员（及友元）</strong>能否访问其直接基类的成员没什么影响，目的是控制派生类<strong>用户（包括派生类的派生类在内）</strong>对于基类成员的访问权限。</p>
<p><strong>派生类向基类转换的可访问性</strong></p>
<p>假定D继承自B，D的XX能否使用派生类向基类的转换：</p>
<table>
<thead>
<tr class="header">
<th>继承方式</th>
<th>成员函数和友元</th>
<th>用户代码</th>
<th>派生类的成员和友元</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td>protected</td>
<td>✓</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr class="odd">
<td>private</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
</tr>
</tbody>
</table>
<p>友元关系不能传递和继承。</p>
<p>使用using声明语句可以改变可访问性（派生类只能为那些它可以访问的名字提供using声明）。</p>
<p>人们常常有一种错觉，认为在使用struct关键字和class关键字定义的类之间还有更深层次的差别。事实上，<strong>唯一的差别就是默认成员访问说明符及默认派生访问说明符</strong>；除此之外，再无其他不同之处。</p>
<h3 id="继承中的类作用域">15.6 继承中的类作用域</h3>
<p>派生类的作用域位于基类作用域<strong>之内</strong>。</p>
<p>即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员<strong>仍然是由静态类型决定</strong>。</p>
<p>派生类的成员将隐藏同名的基类成员（即使派生类成员和基类成员的形参列表不一致）。可以通过作用域运算符来使用一个被隐藏的基类成员。</p>
<p>如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。——解决方案：一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。</p>
<h3 id="构造函数与拷贝控制">15.7 构造函数与拷贝控制</h3>
<p>只要基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本。</p>
<p>如前所述（13.6），大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。</p>
<p>和构造函数及赋值运算符不同的是，析构函数<strong>只负责</strong>销毁派生类自己分配的资源。</p>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中<strong>显式</strong>使用基类的拷贝（或移动）构造函数。</p>
<p>和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。</p>
<h3 id="容器与继承">15.8 容器与继承</h3>
<p>无。</p>
<h3 id="文本查询程序再探">15.9 文本查询程序再探</h3>
<p>无。</p>
<h2 id="第16章-模板与泛型编程">第16章 模板与泛型编程</h2>
<h3 id="定义模板">16.1 定义模板</h3>
<p>模板定义以关键字template开始，后跟一个<strong>模板参数列表</strong>（template
parameter list），这是一个逗号分隔的一个或多个模板参数（template
parameter）的列表，用小于号（&lt;）和大于号（&gt;）包围起来。</p>
<p>编译器生成的版本通常被称为模板的实例（instantiation）。</p>
<p>在模板参数列表中，class和typename的含义相同，可以互换使用。</p>
<p>除了定义类型参数，还可以在模板中定义<strong>非类型参数</strong>（nontype
parameter）。当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是<strong>常量表达式</strong>，从而允许编译器在编译时实例化模板。绑定到指针或引用非类型参数的实参必须具有<strong>静态的生存期</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;usigned N, <span class="hljs-type">unsigned</span> M&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p1)[N], <span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p2)[M])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1,p2);<br>&#125;<br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;hi&quot;</span>,<span class="hljs-string">&quot;mom&quot;</span>);<br><span class="hljs-comment">// 编译器实例化</span><br><span class="hljs-comment">// int compare(const char (&amp;p1)[3], const char (&amp;p2)[4])</span><br></code></pre></td></tr></table></figure>
<p>inline或constexpr说明符放在模板参数列表之后，返回类型之前。</p>
<p>与非模板代码不同，模板的头文件通常<strong>既包括声明也包括定义</strong>。</p>
<p>模板的提供者保证：当使用模板时，所有不依赖于模板参数的名字都必须是可见的。当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须是可见的。</p>
<p>模板的用户保证：用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的。</p>
<p><strong>与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。</strong></p>
<p>与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。</p>
<p>默认情况下，对于一个实例化了的类模板，<strong>其成员只有在使用时才被实例化</strong>。这意味着相同的实例可能出现在多个对象文件中。可以通过<strong>显式实例化</strong>（explicit
instantiation）来避免这种开销。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实例化声明与定义</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blob</span>&lt;string&gt;;<br><span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;)</span></span>;<br><span class="hljs-comment">// 默认情况下，一个类模板的成员函数只有当程序用到它时才会进行实例化。但是一个类模板的实例化定义会实例化该模板的所有成员。</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 当我们使用一个类模板类型时必须提供模板实参。在类模板自己的作用域中，可以直接使用模板名而不提供实参。</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>&#123;<br>    BlobOtr ret = *<span class="hljs-keyword">this</span>;<br>    ++*<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在新标准中可以将模板类型参数声明为友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 无法用typedef给模板定义别名，using可以。</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> twin = pair&lt;T,T&gt;;<br>twin&lt;string&gt; authors;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 用作用域运算符（::）来访问static成员或类型成员。对于模板，如何区分？</span><br>T::size_type *p;<br><span class="hljs-comment">// 是在定义一个名为p的变量还是将一个名为size_type的static成员与名为p的变量相乘？</span><br><span class="hljs-comment">// 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须使用关键字typename显式告诉编译器该名字是一个类型。</span><br></code></pre></td></tr></table></figure>
<p>在新标准中，我们可以为函数和类模板提供<strong>默认实参</strong>。如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个<strong>空尖括号对</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> F = less&lt;T&gt;&gt;<br><span class="hljs-type">int</span> <span class="hljs-built_in">compare</span>(<span class="hljs-type">const</span> T &amp;v1, <span class="hljs-type">const</span> T &amp;v2, F f = <span class="hljs-built_in">F</span>())<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(v1, v2)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(v2, v1)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为<strong>成员模板</strong>（member
template）。成员模板不能是虚函数。</p>
<p>通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，shared_ptr使用户重载删除器更为方便。</p>
<h3 id="模板实参推断">16.2 模板实参推断</h3>
<p>将实参传递给带模板类型的函数形参时，<strong>能够自动应用的类型转换只有</strong>const转换及数组或函数到指针的转换(如果形参是一个引用，则数组不会转换为指针)。如果函数参数类型不是模板参数，则对实参进行正常的类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 指定显式模板实参(按由左至右的顺序)</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;</span><br><span class="hljs-function">T1 <span class="hljs-title">sum</span><span class="hljs-params">(T2, T3)</span></span>;<br><span class="hljs-type">int</span> i, <span class="hljs-type">long</span> lng;<br><span class="hljs-keyword">auto</span> val3 = <span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(i, lng); <span class="hljs-comment">//long long sum(int, long);</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 尾置返回类型</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> It&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fcn</span><span class="hljs-params">(It beg, It end)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(*beg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> *beg;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了获得元素类型，我们可以使用标准库的类型转换（type
transformation）模板。这些模板定义在头文件type_traits中。这个头文件中的类通常用于所谓的<strong>模板元程序设计</strong>，这一主题已超出本书的范围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> It&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fcn</span><span class="hljs-params">(It beg, It end)</span> -&gt; <span class="hljs-keyword">typename</span> remove_reference&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(*beg)</span>&gt;::type</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> *beg;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 可以用函数模板为一个函数指针赋值</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> T&amp;)</span></span>;<br><span class="hljs-built_in">int</span> (*pf1)(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;) = compare;<br></code></pre></td></tr></table></figure>
<p>正常绑定规则之外的两个例外规则：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">(T&amp;&amp;)</span></span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">f3</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 实参是一个int类型的右值，T是int</span><br><span class="hljs-built_in">f3</span>(i); <span class="hljs-comment">// 第一个例外：将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数（T&amp;&amp;）时，编译器推断模板类型参数为实参的左值引用类型。因此，当我们调用f3（i）时，编译器推断T的类型为int&amp;，而非int。</span><br><span class="hljs-comment">// (通常，我们不能（直接）定义一个引用的引用。但是，通过类型别名或通过模板类型参数间接定义是可以的。)</span><br><span class="hljs-comment">//第二个例外：X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;；类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</span><br><span class="hljs-comment">//因此，可以将任意类型的实参传递给T&amp;&amp;类型的函数参数。</span><br></code></pre></td></tr></table></figure>
<p>在实际中，右值引用通常用于两种情况：模板转发其实参或模板被重载。</p>
<p><strong>std::move</strong>的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果一个函数参数是<strong>指向模板类型</strong>参数的右值引用（如T&amp;&amp;），它对应的实参的const属性和左值/右值属性将得到保持。</p>
<p><strong>std::forward</strong>的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD <span class="hljs-keyword">constexpr</span> _Ty&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-comment">// forward an lvalue as either an lvalue or an rvalue</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD <span class="hljs-keyword">constexpr</span> _Ty&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-comment">// forward an rvalue as an rvalue</span><br>    <span class="hljs-built_in">static_assert</span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="hljs-string">&quot;bad forward call&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用<strong>std::forward</strong>实现翻转函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="重载与模板">16.3 重载与模板</h3>
<p>函数匹配规则:</p>
<ol type="1">
<li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</li>
<li>候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。</li>
<li>与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的（16.2.1）。</li>
<li>与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是，如果有多个函数提供同样好的匹配，则：
<ul>
<li>如果同样好的函数中只有一个是非模板函数，则选择此函数。</li>
<li>如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。</li>
<li>否则，此调用有歧义。</li>
</ul></li>
</ol>
<p>在定义任何函数之前，记得<strong>声明所有重载的函数版本</strong>。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</p>
<h3 id="可变参数模板">16.4 可变参数模板</h3>
<p>一个可变参数模板（variadic
template）就是一个接受可变数目参数的模板函数或模板类。</p>
<p>可变数目的参数被称为<strong>参数包</strong>（parameter
packet）。存在两种参数包：模板参数包（template parameter
packet），表示零个或多个模板参数；函数参数包（function parameter
packet），表示零个或多个函数参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp;... rest)</span></span>;<br><span class="hljs-comment">// Args是一个模板参数包；rest是一个函数参数包</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 用来终止递归调用</span><br><span class="hljs-comment">// 必须在可变参数版本之前声明</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> T &amp;t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; t;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp;... rest)</span> <span class="hljs-comment">// 扩展Args</span></span><br><span class="hljs-function"></span>&#123;<br>    os &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os,rest...); <span class="hljs-comment">// 扩展rest，递归</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>可变参数函数通常将它们的参数转发给其他函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// work的实参既扩展Args又扩展args</span><br>    <span class="hljs-built_in">work</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="模板特例化">16.5 模板特例化</h3>
<p>当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。重要的是要弄清：<strong>一个特例化版本本质上是一个实例，而非函数名的一个重载版本。</strong></p>
<p>为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中。因此，模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 比较任意两个类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> T&amp;)</span></span>;<br><span class="hljs-comment">// 处理字符串字面常量</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> N, <span class="hljs-type">size_t</span> M&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;)[N], <span class="hljs-type">const</span> (&amp;)[M])</span></span>;<br><span class="hljs-comment">// 无法将一个指针转换为一个数组的引用,因此需要下面的版本</span><br><span class="hljs-comment">// 处理字符数组的指针</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;p1, onst <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;p2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1, p2);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>与函数模板不同，<strong>类模板的特例化不必为所有模板参数提供实参</strong>。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化（partial
specialization）本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span> &#123;<br>    <span class="hljs-keyword">typedef</span> T type;<br>&#125;<br><span class="hljs-comment">// 部分特例化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;T&amp;&gt;<br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;T&amp;&amp;&gt;<br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;;<br></code></pre></td></tr></table></figure>
<p>可以只特例化特定成员函数而不是特例化整个模板。</p>
<h1 id="第ⅳ部分-高级主题">第Ⅳ部分 高级主题</h1>
<p>这些特性分为两类：一类对于求解大规模的问题很有用；另一类适用于特殊问题而非通用问题。</p>
<h2 id="第17章-标准库特殊设施">第17章 标准库特殊设施</h2>
<h3 id="tuple类型">17.1 tuple类型</h3>
<p>tuple类似pair，但可以有任意数量的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> item = <span class="hljs-built_in">make_tuple</span>(<span class="hljs-string">&quot;0-999-78345-X&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20.00</span>);<br><span class="hljs-keyword">auto</span> book = <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(item);<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(item)</span> trans</span>;<br><span class="hljs-type">size_t</span> sz = tuple_size&lt;trans&gt;::value;<br>tuple_element&lt;<span class="hljs-number">1</span>,trans&gt;::type cnt = <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(item)<br></code></pre></td></tr></table></figure>
<h3 id="bitset类型">17.2 bitset类型</h3>
<p>bitset类使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。</p>
<p>bitset可以用unsigned long
long、string、字符数组构造。字符数组如果不提供数组长度，必须是一个C风格字符串。</p>
<p><strong>string的下标编号习惯与bitset恰好相反</strong>：string中下标最大的字符（最右字符）用来初始化bitset中的低位（下标为0的二进制位）。</p>
<h3 id="正则表达式">17.3 正则表达式</h3>
<p>默认情况下，regex使用的正则表达式语言是ECMAScript。</p>
<p>regex_search和regex_match的参数：</p>
<p>(seq, m, r, mft) (seq, r, mft)</p>
<p>在字符序列seq中查找regex对象r中的正则表达式。</p>
<p>seq可以是一个string、表示范围的一对迭代器以及一个指向空字符结尾的字符数组的指针。</p>
<p>m是一个match对象，用来保持匹配结果的相关细节。</p>
<p>mft是一个可选的regex_constants::match_flag_type值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">pattern</span><span class="hljs-params">(<span class="hljs-string">&quot;[^c]ei&quot;</span>)</span></span>;<br>pattern = <span class="hljs-string">&quot;[[:alpha:]]*&quot;</span> + pattern + <span class="hljs-string">&quot;[[:alpha:]]&quot;</span>;<br><span class="hljs-function">regex <span class="hljs-title">r</span><span class="hljs-params">(pattern)</span></span>;<br>smatch results;<br>string test_str = <span class="hljs-string">&quot;receipt freind theif receive&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">regex_search</span>(test_str, results, r))<br>    cout &lt;&lt; results.<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (sregex_iterator <span class="hljs-built_in">it</span>(file.<span class="hljs-built_in">begin</span>(), file.<span class="hljs-built_in">end</span>(), r), end_it; it != end_it; ++it)<br>    cout &lt;&lt; it-&gt;<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>一个正则表达式的语法是否正确是在运行时解析的。</p>
<p>regex类保存类型char的正则表达式。wregex类保存类型wachar_t的正则表达式。</p>
<p>smatch表示string类型的输入序列；cmatch表示字符数组序列；wsmatch表示宽字符串（wstring）输入；而wcmatch表示宽字符数组。</p>
<p>正则表达式中的模式通常包含一个或多个子表达式（subexpression）。正则表达式语法通常用括号表示子表达式。第一个子匹配位置为0，表示整个模式对应的匹配，随后是每个子表达式对应的匹配。</p>
<h3 id="随机数">17.4 随机数</h3>
<p>随机数库的组成：</p>
<p>引擎 / 类型，生成随机unsigned整数序列</p>
<p>分布 / 类型，使用引擎返回服从特定概率分布的随机数</p>
<p>C++程序<strong>不应该使用库函数rand</strong>，而应使用default_random_engine类和恰当的分布类对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">default_random_engine e;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>	cout &lt;&lt; <span class="hljs-built_in">e</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-function">uniform_int_distribution&lt;<span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    cout &lt;&lt; <span class="hljs-built_in">u</span>(e) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure>
<p>一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。</p>
<h3 id="io库再探">17.5 IO库再探</h3>
<p>标准库定义了一组操纵符（manipulator）（参见1.2节，第6页）来修改流的格式状态。当操纵符改变流的格式状态时，通常改变后的状态<strong>对所有后续IO都生效</strong>。</p>
<p>标准库还提供了一组低层操作，支持<strong>未格式化IO</strong>（unformatted
IO）。这些操作允许我们将一个流当作一个无解释的字节序列来处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>(ch))<br>    cout.<span class="hljs-built_in">put</span>(ch)<br><span class="hljs-type">int</span> ch;<br><span class="hljs-keyword">while</span> ((ch = cin.<span class="hljs-built_in">get</span>()) != EOF)<br>    cout.<span class="hljs-built_in">put</span>(ch)<br></code></pre></td></tr></table></figure>
<p>⬜17.5.3 流随机访问</p>
<h2 id="第18章-用于大型程序的工具">第18章 用于大型程序的工具</h2>
<h3 id="异常处理">18.1 异常处理</h3>
<p>当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句。控制权从一处转移到另一处，这有两个重要的含义：</p>
<ol type="1">
<li>沿着调用链的函数可能会提早退出。</li>
<li>一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。</li>
</ol>
<p><strong>栈展开</strong>过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch子句为止；或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止。一个异常如果没有被捕获，则它将终止当前的程序。</p>
<p>出于栈展开可能使用析构函数的考虑，<strong>析构函数不应该抛出不能被它自身处理的异常</strong>。</p>
<p>当我们抛出一条表达式时，该表达式的<strong>静态编译时类型</strong>决定了异常对象的类型。</p>
<p>抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在。</p>
<p>像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p>
<p>通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。否则异常对象将被切掉一部分。</p>
<p>空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内（用于重新抛出）。如果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。（通常与catch(...)捕获所有异常一起使用）</p>
<p>要想处理构造函数初始值抛出的异常，我们必须将构造函数写成<strong>函数try语句块</strong>（也称为函数测试块，function
try block）的形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>Blob&lt;T&gt;::<span class="hljs-built_in">Blob</span>(std::initializer_list&lt;T&gt; il) <span class="hljs-keyword">try</span>:<br>	<span class="hljs-built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)) &#123;<br>        <br>    &#125; <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::bad_alloc &amp;e) &#123; <span class="hljs-built_in">handle_out_of_memory</span>(e); &#125;<br></code></pre></td></tr></table></figure>
<p>初始化构造函数的参数时发生的异常<strong>不属于</strong>函数try语句块，属于调用表达式的一部分。</p>
<p><strong>noexcept</strong></p>
<p>提供noexcept说明（noexcept
specification）指定某个函数不会抛出异常。</p>
<p>对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型之前。我们也可以在函数指针的声明和定义中指定noexcept。在typedef或类型别名中则不能出现noexcept。在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数的=0之前。</p>
<p>noexcept有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为noexcept异常说明的bool实参出现时，它是一个运算符。</p>
<p>函数指针及该指针所指的函数必须具有一致的异常说明。</p>
<figure>
<img
src="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-03-05-exception-class-hierarchy.jpg" srcset="/img/loading.gif" lazyload
alt="标准exception类层次" />
<figcaption aria-hidden="true">标准exception类层次</figcaption>
</figure>
<h3 id="命名空间">18.2 命名空间</h3>
<p>命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。</p>
<p>命名空间可以是<strong>不连续的</strong>。</p>
<p>在通常情况下，我们不把#include放在命名空间内部。如果我们这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。</p>
<p>全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在<strong>全局命名空间</strong>（global
namespace）中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。</p>
<p>C++11新标准引入了一种新的嵌套命名空间，称为<strong>内联命名空间</strong>（inline
namespace）（在关键字namespace前添加关键字inline）。和普通的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。</p>
<p><strong>未命名的命名空间</strong>（unnamed
namespace）是指关键字namespace后紧跟花括号括起来的一系列声明语句。它可以在某个给定的文件内不连续，但是不能跨越多个文件。</p>
<p>如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别。</p>
<p>在标准C++引入命名空间的概念之前，程序需要将名字声明成static的以使得其对于整个文件有效。<strong>在文件中进行静态声明的做法是从C语言继承而来的</strong>。在C语言中，声明为static的全局实体在其所在的文件外不可见。在文件中进行静态声明的做法已经被C++标准取消了，<strong>现在的做法是使用未命名的命名空间</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 别名</span><br><span class="hljs-keyword">namespace</span> Qlib = cplusplus_primer::QueryLib;<br>Qlib::Query q;<br></code></pre></td></tr></table></figure>
<p><strong>using声明</strong>（using
declaration）一次只引入命名空间的一个成员。有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止。</p>
<p>一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。在类的作用域中，这样的声明语句<strong>只能指向基类成员</strong>。</p>
<p><strong>using指示</strong>（using
directive）使得某个特定的命名空间中所有的名字都可见，一直到using指示所在的作用域结束都能使用。</p>
<p>using指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用域中。</p>
<p>🔺using指示具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> blip &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">16</span>, j = <span class="hljs-number">15</span>, k = <span class="hljs-number">23</span>;<br>&#125;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 正确，blip的j隐藏再命名空间中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">manip</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// using指示</span><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> blip;<br>    ++i; <span class="hljs-comment">// blip::j</span><br>    ++j; <span class="hljs-comment">// 二义性，全局的j还是blip::j?</span><br>    ++::j; <span class="hljs-comment">// 全局的j</span><br>    ++blip::j; <span class="hljs-comment">// blip::j</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">97</span>; <span class="hljs-comment">// 局部的k隐藏了blip::k</span><br>    ++k; <span class="hljs-comment">// 局部的k</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>虽然存在风险，using指示也并非一无是处，例如<strong>在命名空间本身的实现文件中就可以使用using指示</strong>。</p>
<p><strong>当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间。</strong>这一例外对于传递类的引用或指针的调用同样有效。</p>
<p>标准库move和forward函数极易冲突。</p>
<p>对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。</p>
<p>与using声明不同的是，对于using指示来说，引入一个与已有函数形参列表完全相同的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前作用域的版本即可。</p>
<h3 id="多重继承与虚继承">18.3 多重继承与虚继承</h3>
<p>在派生类的派生列表中可以包含多个基类，每个基类包含一个可选的访问说明符。</p>
<p>在多重继承关系中，派生类的对象包含有每个基类的子对象。</p>
<p>如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数<strong>定义它自己的版本</strong>。</p>
<p>编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意一种基类都<strong>一样好</strong>。</p>
<p>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。</p>
<p><strong>虚继承</strong>的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类（virtual
base
class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含<strong>唯一一个</strong>共享的虚基类子对象。</p>
<p>指定虚基类的方式是在派生列表中添加关键字virtual。虚派生只影响<strong>从指定了虚基类的派生类中进一步派生出的类</strong>，它不会影响派生类本身。</p>
<p><strong>虚基类成员的可见性</strong></p>
<p>假定类B定义了一个名为x的成员，D1和D2都是从B虚继承得到的，D继承了D1和D2，则在D的作用域中，x通过D的两个基类都是可见的。如果我们通过D的对象使用x，有三种可能性：</p>
<ol type="1">
<li><p>如果在D1和D2中都没有x的定义，则x将被解析为B的成员，此时不存在二义性，一个D的对象只含有x的一个实例。</p></li>
<li><p>如果x是B的成员，同时是D1和D2中某一个的成员，则同样没有二义性，派生类的x比共享虚基类B的x优先级更高。</p></li>
<li><p>如果在D1和D2中都有x的定义，则直接访问x将产生二义性问题。</p></li>
</ol>
<p>与非虚的多重继承体系一样，解决这种二义性问题最好的方法是在派生类中为成员自定义新的实例。</p>
<p>在虚继承中，<strong>虚基类是由最低层的派生类初始化的</strong>。</p>
<p>基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。</p>
<p>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则<strong>先构造虚基类</strong>，然后按照声明的顺序逐一构造其他非虚基类。</p>
<h2 id="第19章-特殊工具与技术">第19章 特殊工具与技术</h2>
<h3 id="控制内存分配">19.1 控制内存分配</h3>
<p>当使用一条<strong>new表达式</strong>时：</p>
<ol type="1">
<li>new表达式调用一个名为operator new（或者operator
new[]）的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。</li>
<li>编译器运行相应的构造函数以构造这些对象，并为其传入初始值。</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针。</li>
</ol>
<p>当使用一条<strong>delete表达式</strong>时：</p>
<ol type="1">
<li>对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数。</li>
<li>编译器调用名为operator delete（或者operator delete[
]）的标准库函数释放内存空间。</li>
</ol>
<p>应用程序可以在全局作用域中定义operator new函数和operator
delete函数，也可以将它们定义为成员函数。<strong>不能改变new运算符和delete运算符的基本含义。</strong></p>
<p>标准库定义了operator new函数和operator delete函数的8个重载版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 可能抛出bad_alloc异常 </span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>);<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-comment">// 承诺不会抛出bad_alloc异常，使用方法可见12.1.2，传入nothrow对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, <span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>, <span class="hljs-type">nothrow_t</span>&amp;) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, <span class="hljs-type">nothrow_t</span>&amp;) <span class="hljs-keyword">noexcept</span>;<br></code></pre></td></tr></table></figure>
<p>如果我们想要自定义operator
new函数，则可以为它提供额外的形参。此时，用到这些自定义函数的new表达式必须使用new的定位形式(🔺12.1.2
<strong>定位new</strong>)将实参传给新增的形参。</p>
<p>一般情况下可以自定义具有任何形参的operator
new，但以下形式只供标准库使用，<strong>不能被用户重新定义</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, <span class="hljs-type">void</span>*)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 编写operator new和operator delete的一种简单方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">void</span> *mem = <span class="hljs-built_in">malloc</span>(size))<br>        <span class="hljs-keyword">return</span> mem;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *mem)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-built_in">free</span>(mem); &#125;<br></code></pre></td></tr></table></figure>
<p>调用析构函数会销毁对象，但是不会释放内存。</p>
<h3 id="运行时类型识别">19.2 运行时类型识别</h3>
<p>运行时类型识别（run-time type
identification，<strong>RTTI</strong>）的功能由两个运算符实现：</p>
<ul>
<li>typeid运算符，用于返回表达式的类型。</li>
<li>dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。</li>
</ul>
<p>这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。</p>
<p>如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个bad_cast异常。</p>
<p>当typeid作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。</p>
<p>在某些情况下RTTI非常有用，比如当我们想为具有继承关系的类实现相等运算符时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>  <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Base&amp;, <span class="hljs-type">const</span> Base&amp;);<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">// Base的接口成员</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp;)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// Base的数据成员和其他用于实现的成员</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Derived的其它接口成员</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp;)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// Derived的数据成员和其他用于实现的成员</span><br>&#125;<br><br><span class="hljs-comment">// 类型一致才虚调用equal函数</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Base &amp;lhs, <span class="hljs-type">const</span> Base &amp;rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">typeid</span>(lhs) == <span class="hljs-built_in">typeid</span>(rhs) &amp;&amp; lhs.<span class="hljs-built_in">equal</span>(rhs);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Derived::equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Base &amp;lhs)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> Derived&amp;&gt;(rhs);<br>    <span class="hljs-comment">// 执行比较两个Derived对象的操作并返回结果</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Base::equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Base &amp;lhs)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 执行比较两个Base对象的操作并返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>type_info类的精确定义随着编译器的不同而略有差异。不过，C++标准规定type_info类必须定义在typeinfo头文件中，并且至少提供以下操作：</p>
<p>t1 == t2</p>
<p>t1 != t2</p>
<p>t.name() : 返回类型名（C风格字符串）</p>
<p>t1.before(t2) : 返回t1是否位于t2之前（bool）</p>
<h3 id="枚举类型">19.3 枚举类型</h3>
<p>枚举类型（enumeration）使我们可以将一组整型常量组织在一起。</p>
<p>C++包含两种枚举：限定作用域的和不限定作用域的。C++11新标准引入了<strong>限定作用域</strong>的枚举类型（scoped
enumeration）。</p>
<p>(在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的。在不限定作用域的枚举类型中，<strong>枚举成员的作用域与枚举类型本身的作用域相同</strong>。)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 限定作用域的枚举（或者等价地使用enum struct）</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">open_modes</span> &#123;input, output, append&#125;;<br><span class="hljs-comment">// 不限定作用域的枚举（或者等价地使用enum）</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">color</span> &#123;red,yellow,green&#125;;<br><span class="hljs-comment">// 如果enum是未命名的，则我们只能在定义该enum时定义它的对象。</span><br><span class="hljs-keyword">enum</span> &#123;floatPrec = <span class="hljs-number">6</span>, doublePrec = <span class="hljs-number">10</span>, double_doublePrec = <span class="hljs-number">10</span>&#125;;<br></code></pre></td></tr></table></figure>
<p>一个不限定作用域的枚举类型的对象或枚举成员<strong>才能</strong>自动地转换成整型（反过来不行）。</p>
<p>不限定作用域的enum未指定成员的默认大小，因此每个<strong>前向声明</strong>必须指定成员的大小。限定作用域的enum成员大小隐式地定义成int。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">intValues</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br></code></pre></td></tr></table></figure>
<h3 id="类成员指针">19.4 类成员指针</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 数据成员指针</span><br><span class="hljs-comment">// pdata可以指向一个常量（非常量）Screen对象的string成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::string Screen::*<span class="hljs-built_in">data</span>() &#123; <span class="hljs-keyword">return</span> &amp;Screen::contents; &#125;<br>&#125;<br><span class="hljs-type">const</span> string Screen::*pdata;<br>pdata = &amp;Screen::contents;<br>pdata = Screen::<span class="hljs-built_in">data</span>();<br><br>Screen myScreen, *pScreen = &amp;myScreen;<br><span class="hljs-keyword">auto</span> s = myScreen.*pdata;<br>s = pScreen-&gt;*pdata;<br><br><span class="hljs-comment">// 成员函数指针</span><br><span class="hljs-built_in">char</span> (Screen::*pmf)(Screen::pos, Screen::pos) <span class="hljs-type">const</span>;<br>pmf = &amp;Screen::get;<br>pmf = Screen::get; <span class="hljs-comment">// 和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则</span><br><span class="hljs-type">char</span> c1 = (pScreen-&gt;*pmf)();<br><br><span class="hljs-comment">// 与普通的函数指针不同，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符</span><br><span class="hljs-keyword">auto</span> fp = &amp;string::empty;<br><span class="hljs-built_in">find_if</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), fp); <span class="hljs-comment">// 错误,执行if (fp(*it))</span><br><br><span class="hljs-comment">// 1.使用function</span><br>function&lt;<span class="hljs-type">bool</span> (<span class="hljs-type">const</span> string&amp;)&gt; fcn = &amp;string::empty;<br><span class="hljs-built_in">find_if</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), fcn); <span class="hljs-comment">// 执行 if (((*it).*p)())</span><br><br><span class="hljs-comment">// 2.使用mem_fcn</span><br><span class="hljs-built_in">find_if</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fcn</span>(&amp;string&amp;&amp;empty));<br><br><span class="hljs-comment">// 3.使用bind</span><br><span class="hljs-built_in">find_if</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(&amp;string::empty, _1));<br></code></pre></td></tr></table></figure>
<h3 id="嵌套类">19.5 嵌套类</h3>
<p>一个类可以定义在另一个类的内部，前者称为嵌套类（nested
class）或嵌套类型（nested type）。</p>
<p>和成员函数一样，嵌套类必须声明在类的内部，但是可以定义在类的内部或者外部。</p>
<h3 id="union一种节省空间的类">19.6 union：一种节省空间的类</h3>
<p>当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。</p>
<p>union不能含有引用类型的成员。</p>
<p>union不能继承，不能含有虚函数。</p>
<p>默认情况下，union的成员都是公有的（与struct相同）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">Token</span> &#123;<br>    <span class="hljs-type">char</span> cval;<br>    <span class="hljs-type">int</span> ival;<br>    <span class="hljs-type">double</span> dval;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在<strong>匿名union</strong>的定义所在的作用域内该union的成员都是可以直接访问的。匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。</p>
<p>对于union来说，要想构造或销毁类类型的成员必须执行<strong>非常复杂</strong>的操作，因此我们通常把含有类类型成员的union内嵌在另一个类当中。（这个确实复杂）</p>
<h3 id="局部类">19.7 局部类</h3>
<p>类可以定义在某个函数的内部，我们称这样的类为局部类（local
class）。</p>
<p>局部类中不允许声明静态数据成员。</p>
<p>局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员。如果局部类定义在某个函数内部，则该函数的普通局部变量不能被该局部类使用。</p>
<p>定义成员时用到的名字可以出现在类的任意位置。如果某个名字不是局部类的成员，则继续在外层函数作用域中查找；如果还没有找到，则在外层函数所在的作用域中查找。</p>
<p>可以在局部类的内部再嵌套一个<strong>嵌套类</strong>。</p>
<h3 id="固有的不可移植的特性">19.8 固有的不可移植的特性</h3>
<p>为了支持低层编程，C++定义了一些固有的<strong>不可移植</strong>（nonportable）的特性。</p>
<blockquote>
<p>不可移植的特性是指因机器而异的特性，当我们将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。</p>
</blockquote>
<p><strong>位域</strong>（C++从C语言继承）</p>
<p>因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用<strong>无符号类型</strong>保存一个位域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Bit mode: <span class="hljs-number">2</span>; <span class="hljs-comment">// mode占2位二进制数</span><br></code></pre></td></tr></table></figure>
<p>取地址运算符（&amp;）不能作用于位域，因此任何指针都无法指向类的位域。</p>
<p><strong>volatile限定符</strong>（C++从C语言继承）</p>
<p>当对象的值可能在程序的控制或检测之外被改变时（例如一个由系统时钟定时更新的变量），应该将该对象声明为volatile。关键字volatile告诉编译器不应对这样的对象进行优化。</p>
<p>volatile限定符的用法和const<strong>很相似</strong>，但互相没什么影响，可以兼具。</p>
<p><strong>链接指示：extern "C"</strong>（C++新增）</p>
<p>C++使用链接指示（linkage directive）指出任意非C++函数所用的语言。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效。</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">void</span>(*)(<span class="hljs-type">int</span>))</span></span>;<br><span class="hljs-comment">// 因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给C++函数传入一个指向C函数的指针，则必须使用类型别名。</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> <span class="hljs-title">FC</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(FC *)</span></span>;<br><span class="hljs-comment">// 通过使用链接指示对函数进行定义，我们可以令一个C++函数在其他语言编写的程序中可用</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">double</span> dparm)</span> </span>&#123;<span class="hljs-comment">/*...*/</span>&#125;<br><span class="hljs-comment">// 有时需要在C和C++中编译同一个源文件，在编译C++程序的时候有条件地包含进来一些代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-comment">// 正在编译C++程序</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// C语言不支持函数重载</span><br><span class="hljs-comment">// C版本的calc函数可以在C或C++程序中调用，而使用了类类型形参的C++函数只能在C++程序中调用。</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> SmallInt <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">const</span> SmallInt&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> BigNum <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum&amp;)</span></span>;<br></code></pre></td></tr></table></figure>
<p>其中<strong>位域</strong>和<strong>volatile</strong>使得程序更容易访问硬件；<strong>链接指示</strong>使得程序更容易访问用其他语言编写的代码。</p>
<h1 id="练习选取">练习选取</h1>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Notebook/" class="category-chain-item">Notebook</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/CPP/">#CPP</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>《C++ Primer》第五版笔记</div>
      <div>https://reddish.fun/posts/Notebook/CPPPrimer-5th-note/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>bit704</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/Notebook/C-CPP-note/" title="C/C++学习笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C/C++学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/Article/difference-between-DX11-and-DX12/" title="DX11与DX12区别">
                        <span class="hidden-mobile">DX11与DX12区别</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br> 欢迎光临 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
