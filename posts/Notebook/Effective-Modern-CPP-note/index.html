

<!DOCTYPE html>
<html lang="zh-CN-spec" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-10-17-logo.png">
  <link rel="icon" href="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-10-17-logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="bit704">
  <meta name="keywords" content="blog">
  
    <meta name="description" content="42 Specific Ways to Improve Your Use of C++11 AND C++14">
<meta property="og:type" content="article">
<meta property="og:title" content="《Effective Modern C++》笔记">
<meta property="og:url" content="https://reddish.fun/posts/Notebook/Effective-Modern-CPP-note/index.html">
<meta property="og:site_name" content="Homeworld">
<meta property="og:description" content="42 Specific Ways to Improve Your Use of C++11 AND C++14">
<meta property="og:locale">
<meta property="article:published_time" content="2023-09-24T18:51:48.437Z">
<meta property="article:modified_time" content="2024-01-09T00:27:59.253Z">
<meta property="article:author" content="bit704">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>《Effective Modern C++》笔记 - Homeworld</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"reddish.fun","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 65vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>逝者如斯夫！不舍昼夜。</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>联系我</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-link-fill"></i>
                <span>更多</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/links/">
                    
                    <span>外部链接</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://reddish.fun/posts/Article/additional/">
                    
                    <span>一些说明</span>
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-11-15-spaceplane.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="《Effective Modern C++》笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-09-25 02:51" pubdate>
          2023年9月25日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          30k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">《Effective Modern C++》笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>42 Specific Ways to Improve Your Use of C++11 AND C++14</p>
<span id="more"></span>
<p>Scott Meyers 著</p>
<p>高博 译</p>
<p class="note note-primary">
摘录整理。
</p>
<p><a
target="_blank" rel="noopener" href="https://www.aristeia.com/BookErrata/emc++-errata.html">本书修订及更新网站</a></p>
<p><a
target="_blank" rel="noopener" href="https://github.com/CnTransGroup/EffectiveModernCppChinese">另一种翻译</a></p>
<h1 id="第1章-型别推导">第1章 型别推导</h1>
<h2 id="条款1-理解型别推导">条款1 理解型别推导</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParamType param)</span></span>; <br><span class="hljs-built_in">f</span>(expr);<br></code></pre></td></tr></table></figure>
<p>T与ParamType两个型别推导往往不同。</p>
<p><strong>情况1: ParamType是指针或引用，但不是万能引用</strong></p>
<p>实参的引用会被忽略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br><span class="hljs-comment">// 向持有T&amp;型别的模板传入const对象是安全的，常量性会传给T</span><br><span class="hljs-comment">// T不会被推导成引用，引用性会被忽略</span><br><span class="hljs-built_in">f</span>(x);  <span class="hljs-comment">// T的型别是int, param的型别是int&amp;</span><br><span class="hljs-built_in">f</span>(cx); <span class="hljs-comment">// T的型别是const int，param的型别是const int&amp;</span><br><span class="hljs-built_in">f</span>(rx); <span class="hljs-comment">// T的型别是const int，param的型别是const int&amp;</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span></span>;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = X;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = X;<br><br><span class="hljs-comment">// 符合直觉</span><br><span class="hljs-built_in">f</span>(x);  <span class="hljs-comment">// T的型别是int，param的型别是const int&amp;</span><br><span class="hljs-built_in">f</span>(cx); <span class="hljs-comment">// T的型别是int，param的型别是const int&amp;</span><br><span class="hljs-built_in">f</span>(rx); <span class="hljs-comment">// T的型别是int，param的型别是const int&amp;</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span></span>;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *px = &amp;x; <span class="hljs-comment">// px是指涉到x的指针，型别为const int</span><br><br><span class="hljs-comment">// 符合直觉</span><br><span class="hljs-built_in">f</span>(&amp;x); <span class="hljs-comment">// T的型别是int，param的型别是int*</span><br><span class="hljs-built_in">f</span>(px); <span class="hljs-comment">// T的型别是const int，param的型别是const int*</span><br></code></pre></td></tr></table></figure>
<p><strong>情况2: ParamType 是个万能引用</strong></p>
<p>采用右值来初始化万能引用会得到一个右值引用；采用左值来初始化万能引用，就会得到一个左值引用。</p>
<blockquote>
<p>这里涉及引用折叠，X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp;
&amp;都折叠成类型X&amp;；类型X&amp;&amp;
&amp;&amp;折叠成X&amp;&amp;。（参见C++ Primer 16.2或条款28）</p>
</blockquote>
<p>当遇到<strong>万能引用</strong>时，型别推导规则会<strong>区分实参是左值还是右值</strong>。而非万能引用是从来不会作这样的区分的。</p>
<p>向形参T&amp;&amp;传入实参左值，是T被推导为引用型别的<strong>唯一情形</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = X;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = X;<br><br><span class="hljs-built_in">f</span>(x); <span class="hljs-comment">// x是左值，所以T的型别是int&amp;， param的型别也是int&amp;</span><br><span class="hljs-built_in">f</span>(cx); <span class="hljs-comment">// cx是左值，所以T的型别是const int&amp;，param的型别也是const int&amp;</span><br><span class="hljs-built_in">f</span>(rx); <span class="hljs-comment">// rx是左值，所以T的型别是const int&amp;，param的型别也是const int&amp;</span><br><span class="hljs-built_in">f</span>(<span class="hljs-number">27</span>); <span class="hljs-comment">// 27是右值，所以T的型别是int，param的型别就成了int&amp;&amp;</span><br></code></pre></td></tr></table></figure>
<p><strong>情况3: ParamType既非指针也非引用</strong></p>
<p>因为是值传递，引用、顶层const、volatile均忽略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br><br><span class="hljs-type">int</span> x=<span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = X;<br><br><span class="hljs-built_in">f</span>(x); <span class="hljs-comment">// T和param的型别都是int</span><br><span class="hljs-built_in">f</span>(cx); <span class="hljs-comment">// T和param的型别还都是int</span><br><span class="hljs-built_in">f</span>(rx); <span class="hljs-comment">// T和param的型别仍都是int</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> ptr = <span class="hljs-string">&quot;Fun with pointers&quot;</span>; <span class="hljs-comment">// ptr是个指涉到const对象的const指针</span><br><span class="hljs-built_in">f</span>(ptr); <span class="hljs-comment">//传递型别为const char * const 的实参，param的型别被推导为const char *</span><br><span class="hljs-comment">// 底层const得到保留，即一个可修改的，指向const字符串的指针</span><br></code></pre></td></tr></table></figure>
<p><strong>数组实参</strong></p>
<p>数组会<strong>退化</strong>为指向到其首元素的指针，除了引用方式传参的时候。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 两种声明等价</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> param[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-type">int</span>* param)</span></span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;J. P. Briggs&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptrToName = name;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br><span class="hljs-built_in">f</span>(name); <span class="hljs-comment">// name是数组，但T的型别被推导成const char *</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;<br><span class="hljs-built_in">f</span>(name); <span class="hljs-comment">// T的型别是const char [13]，param的型别是const char (&amp;)[13]</span><br></code></pre></td></tr></table></figure>
<p>推导数组尺寸的模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">arraySize</span><span class="hljs-params">(T (&amp;)[N])</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> N;<br>&#125;<br><span class="hljs-type">int</span> keyVals[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">35</span>&#125;;<br><span class="hljs-type">int</span> mappedVals[<span class="hljs-built_in">arraySize</span>(keyVals)];<br>std::array&lt;<span class="hljs-type">int</span>, arraySize(keyVals)&gt; mappedVals;<br></code></pre></td></tr></table></figure>
<p><strong>函数实参</strong></p>
<p>函数型别会<strong>退化</strong>为函数指针，除了引用方式传参的时候。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(T param)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(T&amp; param)</span></span>;<br><br><span class="hljs-built_in">f1</span>(someFunc); <span class="hljs-comment">// param型别是void (*)(int, double)，函数指针</span><br><span class="hljs-built_in">f2</span>(someFunc); <span class="hljs-comment">// param型别是void (&amp;)(int, double)，函数引用</span><br></code></pre></td></tr></table></figure>
<h2 id="条款2-理解auto型别推导">条款2 理解auto型别推导</h2>
<p>在模板型别推导和
auto型别推导可以建立起<strong>一一映射</strong>。映射仅指概念上等价，并不是编译器真的生成了该模板和语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_for_x</span><span class="hljs-params">(T param)</span></span>;<br><span class="hljs-built_in">func_for_x</span>(<span class="hljs-number">27</span>);<br><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> cx = x;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_for_cx</span><span class="hljs-params">(<span class="hljs-type">const</span> T param)</span></span>;<br><span class="hljs-built_in">func_for_cx</span>(x);<br><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; rx = x;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_for_rx</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span></span>;<br><span class="hljs-built_in">func_for_rx</span>(x);<br></code></pre></td></tr></table></figure>
<p>条款1的规则也适用于auto型别推导，只有<strong>一个例外</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 四种初始化语法</span><br><span class="hljs-comment">// C++98的两种</span><br><span class="hljs-type">int</span> x1 = <span class="hljs-number">27</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x2</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span></span>;<br><span class="hljs-comment">// C++11增加的两种</span><br><span class="hljs-type">int</span> x3 = &#123; <span class="hljs-number">27</span> &#125;;<br><span class="hljs-type">int</span> x4&#123; <span class="hljs-number">27</span> &#125;;<br><br><span class="hljs-comment">// 型别是int,值是27</span><br><span class="hljs-keyword">auto</span> x1 = <span class="hljs-number">27</span>;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">x2</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span></span>;<br><span class="hljs-comment">// 型别是std::initializer_list&lt;int&gt;,值是&#123; 27 &#125;</span><br><span class="hljs-keyword">auto</span> x3 = &#123; <span class="hljs-number">27</span> &#125;;<br><span class="hljs-keyword">auto</span> x4&#123; <span class="hljs-number">27</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br><span class="hljs-built_in">f</span>(&#123; <span class="hljs-number">27</span> &#125;); <span class="hljs-comment">// 错误</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(std::initializer_list&lt;T&gt; initList)</span></span>;<br><span class="hljs-built_in">f</span>(&#123; <span class="hljs-number">27</span> &#125;); <span class="hljs-comment">// 正确，T推导为int</span><br></code></pre></td></tr></table></figure>
<p>C++14允许使用auto来说明函数返回值需要推导、lambda表达式会在形参声明中用到auto，这些auto是在<strong>使用模板型别推导而非auto型别推导</strong>。因此以下用法是错误的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">createInitList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// 错误</span><br>&#125;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">auto</span> resetV = [&amp;v](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; newValue) &#123; v = newValue; &#125;; <br><span class="hljs-built_in">resetV</span>(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>
<h2 id="条款3-理解decltype">条款3 理解decltype</h2>
<p>C++11的<strong>返回值型别尾序语法</strong> (trailing return type
syntax)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在指定返回值型别时可以使用函数形参</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(c[i])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">authenticateUser</span>();<br>    <span class="hljs-keyword">return</span> c[i];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>C++11允许单表达式的lambda式的<strong>返回值型别推导</strong>，而C++14则将这个允许范围扩张到了一切lambda式和一切函数，<strong>可以只保留auto</strong>，但不总是正确，因为auto推导会<strong>忽略引用</strong>。C++14使用decltype(auto)解决这个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">authenticateUser</span>();<br>    <span class="hljs-keyword">return</span> c[i];<br>&#125;<br><br>Widget w;<br><span class="hljs-type">const</span> Widget&amp; cw = w;<br><span class="hljs-keyword">auto</span> myWidget1 = cw;<span class="hljs-comment">// auto型别推导，myWidget1的型别是Widget</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) myWidget2 = cw; <span class="hljs-comment">// decltype型别推导，myWidget2的型别是const Widget&amp;</span><br></code></pre></td></tr></table></figure>
<p>再考虑到传递右值的情况，<code>authAndAccess</code>函数应使用万能引用和<code>std::forward</code>（参见条款25）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;</span><br><span class="hljs-function"><span class="hljs-title">dectype</span><span class="hljs-params">(<span class="hljs-keyword">auto</span>)</span> <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp;&amp; c, Index i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">authenticateUser</span>();<br>    <span class="hljs-keyword">return</span> std::forward&lt;Container&gt;(c)[i];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>decltype存在艰涩的例外情况，本书不完全展开。</p>
<p>对于型别为T的左值表达式，除非该表达式仅有一个名字，decltype总是得出型别T&amp;。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// decltype(x)是int，decltype((x))是int&amp;。因为C++定义表达式(x)也是一个左值。</span><br></code></pre></td></tr></table></figure>
<h2 id="条款4-掌握查看型别推导结果的方法">条款4
掌握查看型别推导结果的方法</h2>
<ol type="1">
<li><p>IDE的提示</p></li>
<li><p>编译器诊断信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TD</span>; <span class="hljs-comment">// Type Displayer</span><br>TD&lt;<span class="hljs-keyword">decltype</span>(x)&gt; xType; <span class="hljs-comment">// 因为模板未定义，所以编译器会输出包括x型别得诊断信息</span><br><span class="hljs-comment">// 如：error: aggregate &#x27;TD&lt;int&gt; xType&#x27; has incomplete type and cannot be defined</span><br></code></pre></td></tr></table></figure></li>
<li><p>运行时输出</p>
<p>不同编译器实现不同。<code>std::type_info::name</code>中处理型别的方式<strong>仿佛</strong>是向函数模板桉值传递形参那样，引用、顶层const、volatile会被忽略，因此并不可靠。</p>
<p><code>&lt;boost/type_index.hpp&gt;</code>库表现更好：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/type_index.hpp&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> boost::typeindex::type_id_with_cvr;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;T = &quot;</span> &lt;&lt; <span class="hljs-built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="hljs-built_in">pretty_name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;param = &quot;</span> &lt;&lt; <span class="hljs-built_in">type_id_with_cvr</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;().<span class="hljs-built_in">pretty_name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="第2章-auto">第2章 auto</h1>
<h2 id="条款5-优先选用auto而非显式型别声明">条款5
优先选用auto，而非显式型别声明</h2>
<p>std::function通常比起auto又大又慢，还可能导致内存耗尽异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::pair&lt;std::string, <span class="hljs-type">int</span>&gt;&amp; p : m) <span class="hljs-comment">// key应该是const std::string，写成这样会导致多余的复制开销</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-type">unsigned</span> sz = v.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// std::vector&lt;int&gt;::size_type和unsigned不一定位数相同</span><br></code></pre></td></tr></table></figure>
<h2
id="条款6-当auto推导的型别不符合要求时使用带显式型别的初始化物习惯用法">条款6
当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法</h2>
<p><strong>特例</strong>：<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>的返回值<strong>并不是容器中的一个元素的引用</strong>，而是<code>std::vector&lt;bool&gt;::reference</code>型别（嵌套在<code>std::vector&lt;bool&gt;</code>里的类，一个<strong>代理类</strong>）的对象。因为<code>std::vector&lt;bool&gt;</code>用一个比特表示一个bool元素，而<strong>C++禁止比特的引用</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">features</span><span class="hljs-params">(<span class="hljs-type">const</span> Widget&amp; w)</span></span>;<br>Widget w;<br><span class="hljs-type">bool</span> highPriority = <span class="hljs-built_in">features</span>(w)[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">auto</span> highPriority = <span class="hljs-built_in">features</span>(w)[<span class="hljs-number">5</span>]; <span class="hljs-comment">// highPriority型别不是bool，不符合预期</span><br><span class="hljs-built_in">processWidget</span>(w, highPriority);<br></code></pre></td></tr></table></figure>
<p>防止这样的代码：<code>auto someVar = ”隐形"代理型别表达式;</code></p>
<p>带显式型别的初始化物习惯用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> highPriority = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-built_in">features</span>(w)[<span class="hljs-number">5</span>]);<br></code></pre></td></tr></table></figure>
<h1 id="第3章-转向现代c">第3章 转向现代C++</h1>
<h2 id="条款7-在创建对象时注意区分和">条款7
在创建对象时注意区分()和</h2>
<p>条款2中提到过，C++有<strong>四种初始化语法</strong>。（初始化与赋值是两码事）</p>
<p>C++11引入<strong>大括号初始化</strong>，适用于<strong>所有场合</strong>。小括号初始化不适用于为非静态成员指定默认初始化值，等号初始化不适用于不可复制的对象（如<code>std::atomic</code>型别的对象）。</p>
<p>大括号初始化<strong>禁止内置型别的隐式窄化型别转换</strong>，如double到int。</p>
<p><strong>C++最令人苦恼之解析语法</strong>（most vexing
parse）：任何能够解析为声明的都要解析为声明。可以用大括号初始化解决。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 调用Widget的构造函数，传入形参10</span><br><span class="hljs-function">Widget <span class="hljs-title">w2</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 声明了一个名为w2，返回Widget型别对象的函数</span><br>Widget w3&#123;&#125;; <span class="hljs-comment">// 调用没有形参的Widget构造函数</span><br></code></pre></td></tr></table></figure>
<p>只要有可能，编译器就会优先把大括号初始化语法解读为带有<code>std::initializer_list</code>型别形参的构造函数。（类似的，条款2曾提到，使用<strong>大括号初始化物</strong>来初始化用auto声明的变量会使推导出的型别称为<code>std::initializer_list</code>）（空大括号优先表示没有实参而不是空的<code>std::initializer_list</code>）</p>
<p>对于vector，使用()还是{}有很大区别，例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomeWork</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用params创建局部对象T</span><br>    <span class="hljs-function">T <span class="hljs-title">localObject</span><span class="hljs-params">(std::forward&lt;Ts&gt;(params)...)</span></span>; <span class="hljs-comment">// 小括号</span><br>    T localObject&#123;std::forward&lt;Ts&gt;(params)...&#125;; <span class="hljs-comment">// 大括号</span><br>&#125;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>doSomeWork&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>); <br><span class="hljs-comment">// 如果doSomeWork在创建local0bject使用了小括号，结果会得到一个包含10个元素的std::vector。</span><br><span class="hljs-comment">// 如果doSomeWork使用了大括号，结果会得到一个包含2个元素的std::vector。</span><br><br><span class="hljs-comment">// std::make_unique和std::make_shared使用小括号</span><br></code></pre></td></tr></table></figure>
<h2 id="条款8-优先选用nullptr而非0或null">条款8
优先选用nullptr，而非0或NULL</h2>
<p>C++11以前，不要在指针型别和整型之间做重载。C++11的nullptr不具备整型类型。</p>
<p>nullptr的实际型别是<code>std::nullptr_t</code>，循环定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>    <span class="hljs-keyword">namespace</span> std<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(__nullptr)</span> <span class="hljs-type">nullptr_t</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">using</span> ::std::<span class="hljs-type">nullptr_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<h2 id="条款9-优先选用别名声明而非typedef">条款9
优先选用别名声明，而非typedef</h2>
<p>C++11引入别名声明。</p>
<p>更易理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 别名声明</span><br><span class="hljs-keyword">using</span> FP = <span class="hljs-built_in">void</span> (*)(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> std::string&amp;);<br><br><span class="hljs-comment">// typedef</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*FP)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> std::string&amp;)</span></span>;<br></code></pre></td></tr></table></figure>
<p>可以模板化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 别名声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;<br>MyAllocList&lt;Widget&gt; lw;<br><br><span class="hljs-comment">// typedef</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyAllocList</span> &#123;<br>    <span class="hljs-keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;<br>&#125;;<br>MyAllocList&lt;Widget&gt;::type lw;<br><span class="hljs-comment">// 并且，依赖于模板型别形参的型别前面必须加typename</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typename</span> MyAlloclist&lt;T&gt;::type list;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>头文件<code>&lt;type_traits&gt;</code>有可以修改型别的工具：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++11中，仍使用typedef实现</span><br>std::remove_const&lt;T&gt;::type<br>std::remove_reference&lt;T&gt;::type<br>std::add_lvalue_reference&lt;T&gt;::type<br><span class="hljs-comment">// C++14中，使用别名声明</span><br>std::<span class="hljs-type">remove_const_t</span>&lt;T&gt;<br>std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;<br>std::<span class="hljs-type">add_lvalue_reference_t</span>&lt;T&gt;<br></code></pre></td></tr></table></figure>
<h2
id="条款10-优先选用限定作用域的枚举型别而非不限作用域的枚举型别">条款10
优先选用限定作用域的枚举型别，而非不限作用域的枚举型别</h2>
<p>C++11的限定作用域的枚举防止了枚举量的名字<strong>泄漏</strong>到枚举型别所在作用域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; black, white, red &#125;;<br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 错误，已声明</span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123; black, white, red &#125;;<br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure>
<p>此外，限定作用域的枚举型别无法<strong>隐式</strong>转换到其它型别。</p>
<p>C++98不限定作用域的枚举无法进行前置声明，因为无法确认其<strong>底层型别</strong>。若取值范围小会用char，更大则用更大的整数型别。这时，即使只有一个函数用到这个枚举量，修改枚举会导致整个系统重新编译。</p>
<p>C++11限定作用域的枚举可以前置声明，因为其底层型别默认是int，并且可以手动指定。不限定作用域枚举手动指定底层型别后也可以前置声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Status</span>: std::<span class="hljs-type">uint32_t</span>; <br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>: std::<span class="hljs-type">uint8_t</span>;<br></code></pre></td></tr></table></figure>
<p>不限作用域的枚举唯一的优点：用来取<code>std::tuple</code>型别的各个域更方便。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> UserInfo = std::tuple&lt;std::string, <span class="hljs-comment">// 名字</span><br>                std::string, <span class="hljs-comment">// 电子邮件</span><br>                std::<span class="hljs-type">size_t</span>&gt;; <span class="hljs-comment">// 声望值</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;<br>UserInfo uInfo;<br><span class="hljs-keyword">auto</span> val = std::<span class="hljs-built_in">get</span>&lt;uiEmail&gt;(uInfo); <br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;<br>UserInfo uInfo;<br><span class="hljs-keyword">auto</span> val = std::get&lt;<span class="hljs-built_in">static_cast</span>&lt;std::<span class="hljs-type">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;(uInfo);<br><span class="hljs-comment">// 可以写一个函数对其进行简化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">toUType</span><span class="hljs-params">(E enumerator)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;std::<span class="hljs-type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);<br>&#125;<br><span class="hljs-keyword">auto</span> val = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-built_in">toUType</span>(UserInfoFields::uiEmail)&gt;(uInfo);<br></code></pre></td></tr></table></figure>
<h2 id="条款11-优先选用删除函数而非private未定义函数">条款11
优先选用删除函数，而非private未定义函数</h2>
<p>阻止C++自动生成的成员函数被调用，优先选用C++11的<code>=delete</code>。</p>
<p>删除函数习惯上声明为public，当被错误使用时报错信息更明确。</p>
<p><strong>非成员函数</strong>可以定义为删除函数，借此可以禁止非成员函数的指定重载版本。</p>
<p><strong>特化函数模板</strong>（包括特化成员函数模板）可以定义为删除函数。</p>
<h2 id="条款12-为意在改写的函数添加override声明">条款12
为意在改写的函数添加override声明</h2>
<p>override的要求：</p>
<ol type="1">
<li>基类中的函数必须是虚函数。</li>
<li>基类和派生类中的函数名字必须完全相同（析构函数例外）。</li>
<li>基类和派生类中的函数形参型别必须完全相同。</li>
<li>基类和派生类中的函数常量性（constness）必须完全相同。</li>
<li>基类和派生类中的函数返回值和异常规格必须兼容。</li>
<li>基类和派生类中的<strong>函数引用饰词</strong>（reference
qualifier）必须完全相同。（C++11新增）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> &amp;</span>; <span class="hljs-comment">// 这个版本的doWork仅在*this是左值时调用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> &amp;&amp;</span>; <span class="hljs-comment">// 这个版本的doWork仅在*this是右值时调用</span><br>&#125;;<br><br><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 工厂函数（返回右值）</span><br>Widget w; <span class="hljs-comment">// 普通对象（左值）</span><br><br>W.<span class="hljs-built_in">doWork</span>(); <span class="hljs-comment">// 以左值调用Widget::doWork</span><br><span class="hljs-built_in">makeWidget</span>().<span class="hljs-built_in">doWork</span>(); <span class="hljs-comment">// 以右值调用Widget::doWork</span><br><br><span class="hljs-comment">// 最佳实践</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = std::vector&lt;<span class="hljs-type">double</span>&gt;;<br>    <span class="hljs-function">DataType&amp; <span class="hljs-title">data</span><span class="hljs-params">()</span> &amp;</span><br><span class="hljs-function">    </span>&#123;<br>         <span class="hljs-keyword">return</span> values; <span class="hljs-comment">// 对于左值Widgets型别，返回左值</span><br>    &#125;<br>    <span class="hljs-function">DataType <span class="hljs-title">data</span><span class="hljs-params">()</span> &amp;&amp;</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(values); <span class="hljs-comment">// 对于右值Widgets型别，返回右值</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    DataType values;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>C++新增了两个<strong>语境关键字</strong>（contextual
keyword）：override和final。语言保留这两个关键字，但仅在特定语境下保留，以下代码升级到C++11后依然合法。</p>
<h2 id="条款13-优先选用const_iterator-而非iterator">条款13
优先选用const_iterator， 而非iterator</h2>
<p>从<code>const_ iterator</code>到<code>iterator</code><strong>不存在可移植的型别转换</strong>，连<code>static_cast</code>及<code>reinterpret_ cast</code>也不行。C++98和C++11皆然。</p>
<p>由于在标准化过程中的短视，C++11仅添加了<strong>非成员函数版本</strong>的begin和end，而没有添加cbegin、cend、rbegin、rend、crbegin和crend。C++14
纠正了这种短视。</p>
<h2 id="条款14-只要函数不会发射异常就为其加上noexcept声明">条款14
只要函数不会发射异常，就为其加上noexcept声明</h2>
<p>C++98异常规格已被废弃，C++11只关心<strong>是否</strong>发射异常。</p>
<p>noexcept声明使<strong>优化器</strong>可以更好地优化，不需要在异常传出函数的前提下，将执行期栈保持在可开解状态；也不需要在异常溢出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构。</p>
<p>C++98中<code>std::vector</code>的扩容做法是先把元素从旧内存复制到新内存，再析构旧内存中的对象。这个做法使<code>push_back</code>提供了<strong>强异常安全保证</strong>：若复制过程中抛出了异常，原对象保持原样不变。C++11引入了移动语义，仅在移动操作不会发射异常（带有noexcept声明）的前提下，<code>push_back</code>等函数会把C++98中的赋值操作替换为C++11中的移动操作。</p>
<p>默认地，<strong>内存释放函数</strong>和<strong>所有的析构函数</strong>（无论是用户定义的，还是编译器自动生成的）都隐式地具备noexcept性质。这么一来，它们就无须加上noexcept声明了。</p>
<blockquote>
<p>析构函数未隐式地具备noexcept性质的唯一场合：所在类中有数据成员（包括继承而来的成员，以及在其他数据成员中包含的数据成员）的型别显式地将其析构函数声明为可能发射异常的，为其加上<code>noexcept(false)</code>声明。这样的析构函数很少见，标准库里一个也没有，而如果标准库使用了某个对象（例如，被包含在容器内，或被传递给某个算法），而其析构函数发射了异常，则该程序行为是<strong>未定义</strong>的。</p>
</blockquote>
<p>有理由使得带有noexcept声明的函数依赖于缺乏noexcept保证的代码（调用不带noexcept声明的来此C或者C++98的函数），C++允许此类代码通过编译，并且编译器通常不会就此生成警告。</p>
<h2 id="条款15-只要有可能使用constexpr就使用它">条款15
只要有可能使用constexpr，就使用它</h2>
<p><strong>对于对象</strong>，constexpr代表不仅是const而且<strong>在编译阶段已知</strong>，因此可以放置在只读内存以进行优化，可以用于数组尺寸、枚举量的值、对齐规格等。</p>
<p><strong>对于函数</strong>，constexpr代表函数在调用时若传入的所有参数均是编译期常量，则产出编译期常量；若传入的参数含有直至运行期才知晓的值，则产出运行期值，与普通函数无异。</p>
<p>C++11中，constexpr函数不得包含多于一个可执行语句，即一条return语句；constexpr函数被隐式声明为const，无法修改对象的非mutable数据成员；返回型别void不是字面型别。C++14放宽以上限制。</p>
<p><strong>字面型别</strong>即可以持有编译期可以决议的值的型别，<strong>用户自定义型别同样可能也是字面型别</strong>，因为它的构造函数和其他成员函数可能也是constexpr函数。</p>
<h2 id="条款16-保证const成员函数的线程安全性">条款16
保证const成员函数的线程安全性</h2>
<p>对于单个要求同步的变量或内存区域，使用<code>std::atomic</code>足够且性能更好。</p>
<p>如果有两个或更多个变量或内存区域需要作为一整个单位进行操作时，应使用互斥量。</p>
<h2 id="条款17-理解特种成员函数的生成机制">条款17
理解特种成员函数的生成机制</h2>
<p>特种成员函数即C++会自行生成的成员函数，包括<strong>默认构造函数、析构函数、复制构造函数，复制赋值运算符、移动构造函数、移动赋值运算符</strong>。</p>
<p>自动生成的C++移动构造函数和移动赋值运算符执行作用于非静态成员的<strong>按成员移动</strong>操作。按成员移动由两部分组成的，一部分是在支持移动操作的成员上执行的移动操作，另一部分是在不支持移动操作的成员上执行的复制操作。</p>
<p>两种复制操作是彼此独立的，声明了其中一个，并不会阻止编译器生成另一个。</p>
<p>两种移动操作并不彼此独立，声明了其中一个，就会阻止编译器生成另一个。</p>
<p>声明了复制操作，不再会生成移动操作了。</p>
<p>声明了移动操作，复制操作会废除（=delete）。</p>
<p>大三律（Rule of
Three）：如果声明了复制构造函数、复制赋值运算符、析构函数中的任何个，就得同时声明所有个。</p>
<p><strong>默认构造函数</strong>：仅当类中不包含声明的构造函数时才生成。</p>
<p><strong>析构函数</strong>：仅当类中不包含声明的析构函数时才生成。仅当基类的析构函数为虚，派生类的析构函数才为虚。默认为noexcept。</p>
<p><strong>复制构造函数</strong>：当该类未声明复制构造函数时生成。声明移动操作会导致其被废除。已声明复制赋值运算符或析构函数时，仍然生成复制构造函数已经成为了被废弃的行为。</p>
<p><strong>复制赋值运算符</strong>：当该类未声明复制赋值运算符时生成。声明移动操作会导致其被废除。已声明复制构造函数或析构函数时，仍然生成复制赋值运算符已经成为了被废弃的行为。</p>
<p><strong>移动构造函数和移动赋值运算符</strong>：当该类未声明析构函数、复制操作、移动操作时生成。</p>
<p><strong>成员函数模板</strong>在任何情况下都不会抑制特种成员函数的生成。（条款26与之相关）</p>
<h1 id="第4章-智能指针">第4章 智能指针</h1>
<h2 id="条款18-使用stdunique_ptr管理具备专属所有权的资源">条款18
使用std::unique_ptr管理具备专属所有权的资源</h2>
<p><code>std::unique_ptr</code>不允许复制，是只移型别。</p>
<p><code>std::unique_ptr</code>可能不调用托管资源析构函数的情况：</p>
<ol type="1">
<li>异常传播开影响到某个线程的主函数</li>
<li>违反了noexcept异常规格</li>
<li><code>std::abort</code>、<code>std::_Exit</code>、<code>std::exit</code>、<code>std::quick_exit</code>（必定不调用局部对象析构函数）</li>
</ol>
<h2 id="条款19-使用stdshared_ptr管理具备共享所有权的资源">条款19
使用std::shared_ptr管理具备共享所有权的资源</h2>
<p><code>std::shared_ptr</code>可以通过访问某资源的<strong>引用计数</strong>来确定是否自己是最后一个指涉到该资源的。</p>
<p>引用计数带来的性能影响：</p>
<ol type="1">
<li>尺寸是裸指针的两倍（具体看实现）</li>
<li>引用计数的内存必须动态分配</li>
<li>引用计数的递增和递减必须是原子操作</li>
</ol>
<p>与<code>std::unique_ptr</code>不同，<code>std::shared_ptr</code>的析构器型别不是智能指针型别的一部分，更灵活。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> loggingDel = [](Widget *pw) <span class="hljs-comment">// 自定义析构器</span><br>&#123;<br>    <span class="hljs-built_in">makeLogEntry</span>(pw);<br>    <span class="hljs-keyword">delete</span> pw;<br>&#125;;<br><br><span class="hljs-comment">// 析构器型别是智能指针型别的一部分</span><br><span class="hljs-function">std::unique_ptr&lt;Widget, <span class="hljs-title">dec1type</span><span class="hljs-params">(<span class="hljs-number">1</span>oggingDe1)</span>&gt; <span class="hljs-title">upw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, <span class="hljs-number">1</span>oggingDel)</span></span>;<br><br><span class="hljs-comment">// 析构器型别不是智能指针型别的一部分</span><br><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spW</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, loggingDe1)</span></span>;<br></code></pre></td></tr></table></figure>
<p>与<code>std::unique_ptr</code>不同，自定义析构器不会改变<code>std::shared_ptr</code>的尺寸，无论析构器是怎样的型别，<code>std::shared_ptr</code>对象的尺寸都相当于裸指针的两倍。</p>
<p><img
src="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-09-22-shared_ptr.png" srcset="/img/loading.gif" lazyload /></p>
<p>避免将<strong>裸指针</strong>传递给一个<code>std::shared_ptr</code>的构造函数，以免创建多个控制块、拥有多个引用计数。</p>
<p>创建多控制块情形一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pw = <span class="hljs-keyword">new</span> Widget; <br><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spw1</span><span class="hljs-params">(pW, loggingDe1)</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(pw, loggingDel)</span></span>;<br></code></pre></td></tr></table></figure>
<p>创建多控制块情形二：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-type">void</span> Widget::process<br>&#123;<br>    processedWidgets.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 新创建控制块</span><br>&#125;<br><br><span class="hljs-comment">// 解决办法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123; <span class="hljs-comment">// 奇妙递归模板模式 (The Curiously Recurring Template Pattern, CRTP)</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-type">void</span> Widget::process<br>&#123;<br>    processedWidgets.<span class="hljs-built_in">emplace_back</span>((<span class="hljs-built_in">shared_from_this</span>()); <br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以由<code>std::unique_ptr</code>构造<code>std::shared_ptr</code>，反之不成立。</p>
<p>有<code>std::unique_ptr&lt;T[]&gt;</code>，没有<code>std::shared_ptr&lt;T[]&gt;</code>。</p>
<h2
id="条款20-对于类似stdshared_ptr但有可能空悬的指针使用stdweak_ptr">条款20
对于类似std::shared_ptr但有可能空悬的指针使用std:weak_ptr</h2>
<p><code>std::weak_ptr</code>并不是一种独立的智能指针，而是<code>std::shared_ptr</code>的一种扩充，一般通过后者创建。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> spw = std::<span class="hljs-built_in">make_shared</span>&lt;Widget&gt;();<br><span class="hljs-function">std::weak_ptr&lt;Widget&gt; <span class="hljs-title">wpw</span><span class="hljs-params">(spw)</span></span>;<br><span class="hljs-comment">// 可用wpw.expired()检查指针是否空悬</span><br></code></pre></td></tr></table></figure>
<p><code>std::weak_ptr</code>可用于缓存、观察者模式、避免循环引用等情况。</p>
<h2
id="条款21-优先选用stdmake_unique和stdmake_shared而非直接使用new">条款21
优先选用std::make_unique和std::make_shared，而非直接使用new</h2>
<p><code>std::make_shared</code>在C++11加入，<code>std::make_unique</code>在C++14加入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function">std::unique_ptr&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(std::forward&lt;Ts&gt;(params)...));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>new可能导致内存泄漏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">computePriority</span>()); <br><span class="hljs-comment">// 编译器未规定new Widget、shared_ptr构造函数、computePriority函数调用三个操作的顺序</span><br><span class="hljs-comment">// 若new Widget后直接进行computePriority函数调用并发生异常，将导致内存泄漏</span><br><span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">make_shared</span>&lt;Widget&gt;(), <span class="hljs-built_in">computePriority</span>());<br><span class="hljs-comment">// 可以通过make系列函数避免</span><br></code></pre></td></tr></table></figure>
<p>make系列函数的缺点：</p>
<ol type="1">
<li>无法自定义析构器。</li>
<li>无法完美转发大括号初始化物（对形参进行完美转发时使用圆括号）。</li>
</ol>
<p>对于<code>std::shared_ptr</code>，make系列函数额外的缺点：</p>
<ol type="1">
<li><p>不适用于有自身版本的opeator new和operator
delete的类。因为<code>std::allocate_shared</code>要求的内存数量并不等于动态分配对象的尺寸，而是该尺寸的基础上加上控制块的尺寸（参见条款19图）。</p></li>
<li><p><code>std::make_shared</code>使<code>std::shared_ptr</code>的<strong>控制块和托管对象在同一内存块上分配</strong>。此时，就算最后一个<code>std::shared_ptr</code>析构，只要还存在<code>std::weak_ptr</code>，托管对象内存也不会释放，因为与其关联的控制块内存没有释放（控制块有弱计数）。</p></li>
</ol>
<blockquote>
<p>弱计数（参见条款19图）对指涉到该控制块的<code>std::weak_ptr</code>进行计数。</p>
<p>实际上，弱计数的值并不始终等于指涉到控制块的<code>std::weak_ptr</code>的数量，因为库的实现者已经找到了某些方法向弱计数加入额外信息以促进更好的代码生成。</p>
</blockquote>
<h2
id="条款22-使用pimpl习惯用法时将特殊成员函数的定义放到实现文件中">条款22
使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h2>
<p>Pimpl即pointer to implementation。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br><span class="hljs-keyword">private</span>:<br>    std::string name;<br>    std::vector&lt;<span class="hljs-type">double</span>&gt; data;<br>    Gadget g1, g2, g3;<br>&#125;;<br><br><span class="hljs-comment">// Pimpl</span><br><span class="hljs-comment">// 减少了Wiget的客户需要包含的头文件</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    ~<span class="hljs-built_in">Widget</span>();<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Impl</span>;<br>    Imp1 *pImpl;<br>    <span class="hljs-comment">// Widget::Impl是一个已声明但未定义的不完整型别，可以声明指涉其的指针</span><br>    <span class="hljs-comment">// 因为Widget::Impl是不玩</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>现代C++中Pimpl通常使用<code>std::unique_ptr</code>实现，但是注意，应将析构函数和移动操作（引发析构）的定义放在<strong>实现文件中的不完整型别的定义之后</strong>，因为在实施delete运算符之前会使用C++11中的<code>static_assert</code>去确保裸指针未指涉到非完整型别。</p>
<blockquote>
<p>对于<code>std::unique_ptr</code>
而言，析构器型别是智能指针型别的一部分，这使得编译器会产生更小尺寸的运行期数据结构以及更快速的运行期代码。如此高效带来的后果是，欲使用编译器生成的特种函数（例如，析构函数或移动操作），就要求其指涉到的型别必须是完整型别。</p>
<p>对于<code>std::shared_ptr</code>而言，析构器的型别并非智能指针型别的一部分，这就需要更大尺寸的运行时期数据结构以及更慢一些的目标代码，但在使用编译器生成的特种函数时，其指涉到的型别却并不要求是完整型别。</p>
</blockquote>
<h1 id="第5章-右值引用移动语义和完美转发">第5章
右值引用、移动语义和完美转发</h1>
<p>移动语义使得创建<strong>只移型别</strong>对象成为可能，这些型别包括<code>std::unique_ ptr</code>、<code>std::future</code>、<code>std:: thread</code>等。</p>
<p><strong>形参总是左值</strong>，即使其型别是右值引用。</p>
<h2 id="条款23-理解stdmove和stdforward">条款23
理解std::move和std::forward</h2>
<p>这两者在运行期无所作为，不会生成任何可执行代码，仅仅执行强制型别转换。</p>
<p><code>std::move</code>只做一件事，把实参强制转换成右值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::move的示例实现（C++14）</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> ReturnType = <span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;ReturnType&gt;(param);<br>&#125;<br><span class="hljs-comment">// std::forward的示例实现见条款28</span><br></code></pre></td></tr></table></figure>
<p><code>std::move</code><strong>不保证经过其强制型别转换后的对象具备可移动的能力</strong>。针对常量对象执行的移动操作将一声不响地变换成复制操作，例如左值<code>const std::string</code>转换为右值<code>const std::string</code>，仍调用复制构造函数。</p>
<p>因为形参总是左值，<code>std::forward</code><strong>只在传入形参的实参使用右值初始化时</strong>，把实参强制转化为右值。</p>
<h2 id="条款24-区分万能引用和右值引用">条款24
区分万能引用和右值引用</h2>
<p>当&amp;&amp;涉及<strong>型别推导</strong>，如auto、函数模板形参（比如形如T&amp;&amp;）时，是万能引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 万能引用</span><br><span class="hljs-keyword">auto</span>&amp;&amp; var2 = var1;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;<br><br><span class="hljs-comment">//右值引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Widget&amp;&amp; param)</span></span>; <span class="hljs-comment">// 没有型别推导</span><br><br>Widget&amp;&amp; var1 = <span class="hljs-built_in">Widget</span>(); <span class="hljs-comment">// 没有型别推导</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="hljs-comment">// 不形如T&amp;&amp;</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;&amp; param)</span></span>; <span class="hljs-comment">// 有const饰词</span><br><br><span class="hljs-comment">// 注意！</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> = allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">push_back</span>(T&amp;&amp; x); <span class="hljs-comment">// 由std::vector模板具现化的实例决定，没有型别推导，是右值引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>.. Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>; <span class="hljs-comment">// 独立于std::vector模板的型别形参T，有型别推导，是万能引用</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="条款25-针对右值引用实施stdmove针对万能引用实施stdforward">条款25
针对右值引用实施std::move，针对万能引用实施std::forward</h2>
<p>在按值返回的函数中，如果返回的是绑定到一个右值引用或一个万能引用的对象，则当你返回该引用时，应该对其实施<code>std::move</code>或者<code>std::forward</code>。</p>
<p><strong>返回值优化</strong> （return value optimization,
RVO）：当局部对象型别和函数返回值型别相同<strong>且</strong>返回值就是局部对象本身（而不是引用），编译器<strong>可以选择</strong>在一个按值返回的函数里省略对局部对象的复制（或者移动），<strong>直接在为函数返回值分配的内存上创建局部变量</strong>。当编译器选择不执行RVO时，返回对象必须作为右值处理，相当于<code>std:: move</code>隐式地被实施于返回的局部对象上。所以若局部对象可能适用于RVO，请勿针对其实施<code>std::move</code>或<code>std:: forward</code>。</p>
<blockquote>
<p>有人对RVO实施在局部对象时，权据局部对象具名或不具名（亦即临时）的特性进行了区分，限制了
RVO对不具名对象的使用，并将其对具名对象实施者，特别地称为<strong>具名返回值优化</strong>（named
return value optimization, NRVO）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Widget w;<br>    ...<br>    <span class="hljs-keyword">return</span> w;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="条款26-避免依万能引用型别进行重载">条款26
避免依万能引用型别进行重载</h2>
<p>形参为万能引用的函数和几乎任何型别都会产生精确匹配（条款30描述了几种不属于该情况的实参），<strong>不要把万能引用作为重载候选型别</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 重载版本1</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">&quot;logAndAdd&quot;</span>);<br>    names.<span class="hljs-built_in">emplace</span>(std::forward&lt;T&gt;(name));<br>&#125;<br><span class="hljs-function">std::string <span class="hljs-title">nameFromIdx</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span>;<br><br><span class="hljs-comment">// 重载版本2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">&quot;logAndAdd&quot;</span>);<br>    names.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">nameFromIdx</span>(idx));<br>&#125;<br><br><span class="hljs-type">short</span> nameIdx;<br><span class="hljs-built_in">logAndAdd</span>(nameIdx); <span class="hljs-comment">// 调用了重载版本1，因为精确匹配优先于型别提升匹配（short提升到int）</span><br></code></pre></td></tr></table></figure>
<p><strong>完美转发构造函数</strong>会造成严重问题，对于非常量的左值型别而言，它一般会形成相对于复制构造函数的更佳匹配，并且它们还会劫持派生类中对基类的复制和移动构造函数的调用（调用基类的完美转发构造函数）。</p>
<h2 id="条款27-熟悉依万能引用型别进行重载的替代方案">条款27
熟悉依万能引用型别进行重载的替代方案</h2>
<ol type="1">
<li><p>放弃重载</p></li>
<li><p>传递<code>const T&amp;</code>型别的形参代替万能引用</p></li>
<li><p>传值代替万能引用</p></li>
<li><p>标签分派</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对条款26中代码的改进</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-number">1</span>ogAndAddImpl(std::forward&lt;T&gt;(name),<br>                  std::is_integral&lt;std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&gt;());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAndAddImp1</span><span class="hljs-params">(T&amp;&amp; name, std::false_type)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">&quot;logAndAdd&quot;</span> );<br>    names.<span class="hljs-built_in">emplace</span>(std::forward&lt;T&gt;(name));<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">nameFromIdx</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAndAddImpl</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, std::true_type)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">logAndAdd</span>(<span class="hljs-built_in">nameFromIdx</span>(idx)); <span class="hljs-comment">// 委托给前一个重载版本</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>对接受万能引用的模板施加限制</p>
<p><code>std::enable_if</code>可以强制编译器表现出来的行为如同特定的模板不存在一般。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<br>        <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>            !std::is_intergral_v&lt;std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&gt;<br>            &amp;&amp;<br>            !std::is_base_of_v&lt;Person, std::<span class="hljs-type">decay_t</span>&lt;T&gt;&gt;<br>        &gt;::type<br>    &gt;<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">Person</span>(T&amp;&amp; n) : <span class="hljs-built_in">name</span>(std::forward&lt;T&gt;(n))<br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> idx) : <span class="hljs-built_in">name</span>(<span class="hljs-built_in">nameFromIdx</span>(idx))<br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string name;<br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>SFINAE是使得<code>std::enable_if</code>得以运作的技术。</p>
</blockquote></li>
</ol>
<h2 id="条款28-理解引用折叠">条款28 理解引用折叠</h2>
<p>万能引用就是在型别推导的过程会区别左值和右值，以及会发生引用折叠的语境中的右值引用。</p>
<p>禁止声明引用的引用，但编译器却可以在<strong>特殊的语境</strong>中产生引用的引用，<strong>模板实例化</strong>就是这样的语境之一。当编译器生成引用的引用时，<strong>引用折叠</strong>机制便支配了接下来发生的事情。</p>
<blockquote>
<p>特殊的四个语境：</p>
<ol type="1">
<li>模板实例化</li>
<li>auto变量的型别生成</li>
<li>生成和使用typedef和别名声明</li>
<li>decltype的运用</li>
</ol>
</blockquote>
<p>引用折叠规则：如果任一引用为左值引用，则结果为左值引用。否则（即两个皆为右值引用）结果为右值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::forward的示例实现</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br><br><span class="hljs-comment">// 使用完美转发的函数f</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; fParam)</span> <span class="hljs-comment">// 万能引用</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 完成一些操作</span><br>    <span class="hljs-built_in">someFunc</span>(std::forward&lt;T&gt;(fParam)); <span class="hljs-comment">// 将fParam转发至someFunc</span><br>&#125;<br><br><span class="hljs-comment">// 若向函数f传入左值Widget，则T推导为Widget&amp;，则std::forward&lt;T&gt;实例化：</span><br><span class="hljs-function">Widget&amp; &amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;Widget&amp;&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);<br>&#125;<br><span class="hljs-comment">// 即，传入左值引用，返回左值引用</span><br><span class="hljs-function">Widget&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Widget&amp;&gt;(param);<br>&#125;<br><br><span class="hljs-comment">// 若向函数f传入右值Widget，则T为Widget，则std::forward&lt;T&gt;实例化：</span><br><span class="hljs-function">Widget&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;Widget&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);<br>&#125;<br><span class="hljs-comment">// 即，传入左值引用，返回右值引用</span><br><span class="hljs-function">Widget&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="条款29-假定移动操作不存在成本高未使用">条款29
假定移动操作不存在、成本高、未使用</h2>
<p>对于已知型别或已知对于移动语义的支持情况的代码，无需作以上假定。</p>
<p>移动语义不会更好的场景：</p>
<ol type="1">
<li>对象没有提供移动操作</li>
<li>移动不比复制快</li>
<li>要求不可发射异常，但移动操作未加上noexcept声明，不可用</li>
</ol>
<p>C++11引入带有STL接口的内建数组<code>std::array</code>，它和<code>std::vector</code>等其它容器不一样，内存不在堆上，而在对象内，移动无法通过移动指针实现。因此移动和复制都是线性复杂度。</p>
<p><code>std::string</code>采用了SSO(small string
optimization)，小型字符串存储在对象的某个缓冲区内，不适用堆上分配的内存。移动不比复制快。</p>
<h2 id="条款30-熟悉完美转发的失败情形">条款30
熟悉完美转发的失败情形</h2>
<p>完美转发的含义是不仅转发对象，还转发其显著特征：型别、是左值还是右值，以及是否带有const或volation饰词等。</p>
<p>给定目标函数<strong>f</strong>和转发函数<strong>fwd</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fwd</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(std::forward&lt;T&gt;(param));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fwd</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(std::forward&lt;Ts&gt; (params)...);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>完美转发失败指当以某特定实参调用<strong>f</strong>会执行某操作，而用同实参调用<strong>fwd</strong>会执行不同的操作。<strong>不能实施完美转发的实参</strong>如下：</p>
<ol type="1">
<li><p>大括号初始化物</p>
<p>由于<strong>fwd</strong>的形参未声明为<code>std::initializer_list</code>，编译器就会被禁止在<strong>fwd</strong>的调用过程中从表达式<code>&#123;1, 2, 3&#125;</code>出发来推导型别。</p>
<p>解决办法：auto可以完成上述推导，可以先用auto声明，再传递给<strong>fwd</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> il = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-built_in">fwd</span>(il);<br></code></pre></td></tr></table></figure></li>
<li><p>0和NULL用作空指针</p>
<p>推导为整型而非指针型别。</p>
<p>解决办法：用nullptr。</p></li>
<li><p>仅有声明的整型static const成员变量</p>
<p>不需要给出类中的整型static
const成员变量的定义，<strong>仅需声明之</strong>。编译器会根据这些成员的值实施常数传播，从而就不必再为它们保留内存。因此<strong>不能对其取址</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> MinVals = <span class="hljs-number">28</span>;<br>&#125;;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; widgetData;<br>widgetData.<span class="hljs-built_in">reserve</span>(Widget::MinVals); <span class="hljs-comment">// 编译器绕过缺少定义的事实，直接用28替换Widget::MinVals</span><br></code></pre></td></tr></table></figure>
<p>引用在编译器生成的机器码中当指针处理，所以也<strong>不能将其传给万能引用</strong>。（有的编译器和链接器可以，但这不可移植）</p>
<p>解决办法：对其提供定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> Widget::MinVals;<br><span class="hljs-comment">// 这里没有指定28，因为声明和定义只需有一个提供初始化物。</span><br><span class="hljs-comment">// ODR(one definition rule)</span><br></code></pre></td></tr></table></figure></li>
<li><p>重载的函数名字和模板名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> (*pf)(<span class="hljs-type">int</span>))</span></span>;<br><span class="hljs-comment">// 或 void f(int pf(int));</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">processVal</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">processVal</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> priority)</span></span>;<br><br><span class="hljs-built_in">f</span>(processVal); <span class="hljs-comment">// 没问题</span><br><span class="hljs-built_in">fwd</span>(processVal); <span class="hljs-comment">// 错误，无法确定用哪个重载版本</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">workOnVal</span><span class="hljs-params">(T param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-built_in">fwd</span>(work0nVal); <span class="hljs-comment">//错误，无法确定用模板的哪个实例</span><br></code></pre></td></tr></table></figure>
<p>解决办法：手动指定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> ProcessFuncType = <span class="hljs-built_in">int</span> (*)(<span class="hljs-type">int</span>);<br>ProcessFuncType processValPtr = processVal;<br><span class="hljs-built_in">fwd</span>(processValPtr); <span class="hljs-comment">// 重载指定</span><br><br><span class="hljs-built_in">fwd</span>(<span class="hljs-built_in">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal)); <span class="hljs-comment">// 模板指定</span><br></code></pre></td></tr></table></figure></li>
<li><p>位域</p>
<p>C++标准禁止非const引用绑定到位域。</p>
<blockquote>
<p>位域是由机器字的若干任意部分组成的（例如32
位int的第3到第5个比特），这样的实体是不可能有办法对其直接取址的。在硬件层次，引用和指针本是同一事物。</p>
<p>因此，常量引用也不可能绑定到位域，只是绑定到了复制了位域值的常规对象。</p>
</blockquote>
<p>解决办法：复制位域值再转发。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IPv4Header</span> &#123;<br>    std::<span class="hljs-type">uint32_t</span> version:<span class="hljs-number">4</span>,<br>    IHL:<span class="hljs-number">4</span>,<br>    DSCP:<span class="hljs-number">6</span>,<br>    ECN:<span class="hljs-number">2</span>,<br>    totalLength:<span class="hljs-number">16</span>;<br>&#125;;<br><span class="hljs-keyword">auto</span> length = <span class="hljs-built_in">static_cast</span>&lt;std::<span class="hljs-type">uint16_t</span>&gt;(h.totalLength);<br><span class="hljs-built_in">fwd</span>(length);<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="第6章-lambda表达式">第6章 lambda表达式</h1>
<p><strong>lambda表达式</strong>是表达式的一种，比如在下面这段代码中<code>std::find_if</code>的第三个实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">find_if</span>(container.<span class="hljs-built_in">begin</span>(), container.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> val) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt; val &amp;&amp; val &lt; <span class="hljs-number">10</span>; &#125;);<br></code></pre></td></tr></table></figure>
<p><strong>闭包</strong>是lambda式创建的运行期对象，根据不同的捕获模式，闭包会持有数据的副本或引用。在上面的代码中，闭包就是作为第三个实参在运行期传递给<code>std::find_if</code>的对象。</p>
<p><strong>闭包类</strong>就是实例化闭包的类。每个lambda式都会触发编译器生成一个独无二的闭包类。而闭包中的语句会变成它的闭包类成员函数的可执行指令。</p>
<h2 id="条款31-避免默认捕获模式">条款31 避免默认捕获模式</h2>
<p>按引用的默认捕获模式可能导致<strong>空悬引用</strong>（当闭包越过了其包含的局部变量或形参的生命期）。</p>
<p>按值的默认捕获模式可能会使程序员误解情况（不可能直接捕获对象的成员变量，只可能捕获this指针，让对象被析构后持有空悬指针）。</p>
<h2 id="条款32-使用初始化捕获将对象移入闭包">条款32
使用初始化捕获将对象移入闭包</h2>
<p>C++14为<strong>对象移动入闭包</strong>提供了直接支持。C++11中有近似达成移动捕获行为的做法。</p>
<p><strong>初始化捕获</strong> （init
capture）（也叫广义lambda捕获）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++14</span><br>std::vector&lt;<span class="hljs-type">double</span>&gt; data;<br><span class="hljs-keyword">auto</span> func = [data = std::<span class="hljs-built_in">move</span>(data)]&#123;&#125;;<br><br><span class="hljs-comment">// C++11模拟移动捕获</span><br>std::vector&lt;<span class="hljs-type">double</span>&gt; data;<br><span class="hljs-keyword">auto</span> func = std::<span class="hljs-built_in">bind</span>([](<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data)&#123;&#125;,<br>                      std::<span class="hljs-built_in">move</span>(data)<br>                     );<br></code></pre></td></tr></table></figure>
<h2 id="条款33-对auto型别的形参使用decltype以stdforward之">条款33
对auto&amp;&amp;型别的形参使用decltype，以std::forward之</h2>
<p>C++14的<strong>泛型lambda式</strong>可以在形参规格中<strong>使用auto</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 完美转发lambda式，C++14</span><br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span>&amp;&amp; param)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(param)&gt;(param))); <br>&#125;;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span>&amp;&amp;... params)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(params)&gt;(params)...);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>实例化<code>std::forward</code>时，使用一个右值引用型别和使用一个非引用型别，会产生相同结果。（<code>std::forward</code>实现参见条款28）</p>
</blockquote>
<h2 id="条款34-优先选用lambda式而非stdbind">条款34
优先选用lambda式，而非std::bind</h2>
<p><code>std::bind</code>是C++98中<code>std::bind1st</code>和<code>std::bind2nd</code>的后继特性，在2005年TR1文档就包含了<code>std::tr1::bind</code>。</p>
<p>lambda式优点：</p>
<ol type="1">
<li><p>lambda式可读性强于<code>std::bind</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> betweenL = [lowVal, highVal](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; val)<br>&#123;<br>    <span class="hljs-keyword">return</span> lowVal &lt;= val &amp;&amp; val &lt;= highVal;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;<br><span class="hljs-keyword">auto</span> betweenB = std::<span class="hljs-built_in">bind</span>(std::logical_ <span class="hljs-keyword">and</span>&lt;&gt;(),<br>                          std::<span class="hljs-built_in">bind</span>(std::less_ equal&lt;&gt;(),<br>                                    lowVal,<br>                                    _1),<br>                          std::<span class="hljs-built_in">bind</span>(std::less_equal&lt;&gt;(),<br>                                    _1, <br>                                    highVal));<br><span class="hljs-comment">// C++14中，标准运算符模板的模板型别实参大多数情况下可以省略不写，直接写&lt;&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p><code>std::bind</code>调用时刻进行表达式评估求值，并将结果存储到绑定对象中，等待绑定对象调用时使用。lambda式统一在调用时刻求值，不容易造成误解。（使用计时函数时）</p></li>
<li><p><code>std::bind</code>无法进行重载决议，需要显式指定（使用函数指针类型<code>static_cast</code>）。编译器不太会内联通过函数指针发起的函数调用，因而更慢。</p></li>
<li><p><code>std::bind</code>默认传值，传引用需要使用<code>std::ref</code>；<code>std::bind</code>返回的绑定对象所有实参都是按引用传递的（利用完美转发）。lambda式可以直观地手动指定。</p></li>
</ol>
<p>在C++14中，<strong>完全没必要用<code>std::bind</code></strong>。C++11中还可以在<strong>移动捕获</strong>（C++14用初始化捕获）或<strong>绑定函数调用符模板对象</strong>（C++14的lambda式可以使用lambda形参）时使用。</p>
<h1 id="第7章-并发api">第7章 并发API</h1>
<p>C++11将<strong>并发</strong>融入了语言和库中。</p>
<p>熟悉其他线程API
（例如，pthread或Windows线程库）的程序员有时会对C++提供的相对斯巴达式地简练的特性集感觉惊讶，但这是因为，<strong>C++对并发的支持中有一大部分是以对编译器厂商实施约束的形式提供的</strong>。在C++的历史上程序员首次可以跨越所有平台撰写具有标准行为的多线程程序。</p>
<p>标准库中为<strong>期值</strong>（future）准备了两个模板:
<code>std::future</code>和<code>std::shared_future</code>。在很多情况下，它们之间的区别并不重要，书中仅谈论期值概念，意思是指可以对这两种都适用。</p>
<h2 id="条款35-优先选用基于任务而非基于线程的程序设计">条款35
优先选用基于任务而非基于线程的程序设计</h2>
<p>异步方式运行函数<code>doAsyncWork</code>有两种选择：基于线程和基于任务。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doAsyncWork</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 基于线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(doAsyncWork)</span></span>; <br><span class="hljs-comment">// 无法直接获取返回值，doAsyncWork抛出异常时会调用std::terminate</span><br><span class="hljs-comment">// 即使doAsyncWork声明为noexcept，上述语句依然可能抛出异常（如创建线程数量已达上限），此时需要手工管理线程（在当前线程中运行doAsyncWork，或等待已存在线程完成工作）</span><br><br><span class="hljs-comment">// 基于任务</span><br><span class="hljs-keyword">auto</span> fut = std::<span class="hljs-built_in">async</span>(doAsyncWork); <br><span class="hljs-comment">// std::async返回的期值提供了返回函数get，可以获得返回值或异常</span><br><span class="hljs-comment">// 将线程管理交给标准库的实现者</span><br></code></pre></td></tr></table></figure>
<p>C++并发中线程的三种意义：</p>
<ol type="1">
<li>硬件线程。实际执行计算的线程。现代计算机体系结构会为每个CPU内核提供
一个或多个硬件线程。</li>
<li>软件线程。操作系统（无操作系统的嵌入式系统除外）用以实施跨进程管理以及进行硬件线程调度的线程。比硬件线程多，有上限。</li>
<li><code>std::thread</code>。C++进程里的对象，用作底层软件线程的句柄。</li>
</ol>
<blockquote>
<p><strong>超订</strong>（oversubscription）即就绪状态（非阻塞）的软件线程超过了硬件线程的数量，此时线程调度器会为软件线程在硬件线程上分配CPU时间片。当一个线程的时间片用完，另一个线程启动时，会执行语境切换，增加系统的总体线程管理开销。</p>
<p>超订难以避免。软件线程和硬件线程的比例取决于软件线程变成可运行状态的频繁程度，会<strong>动态改变</strong>（如一个线程如I/O密集型转换为计算密集型时）。因此使用std::async将管理交给标准库实现者更好。</p>
</blockquote>
<p>基于线程更合适的情况：</p>
<ol type="1">
<li>需要访问底层线程实现的API。</li>
<li>需要自己根据硬件特性优化线程用法，手动管理线程耗尽、超订、负载均衡，以及新平台适配</li>
<li>实现超越C++并发API的线程技术（如在C++实现中未提供线程池的平台上实现线程池）</li>
</ol>
<h2 id="条款36-如果异步是必要的则指定stdlaunchasync">条款36
如果异步是必要的，则指定std::launch::async</h2>
<p><code>std::async</code>的<strong>启动策略</strong>：</p>
<ol type="1">
<li><code>std::launch::async</code>启动策略意味着函数必须以异步方式运行，即在另一线程之上执行。</li>
<li><code>std::launch::deferred</code>启动策略意味函数只会在<code>std::async</code>所返回的期值的get或wait得到调用时才运行。当调用get或wait时，函数会同步运行，调用方会阻塞至函数运行结束为止。如果get或wait都没有得到调用，函数是不会运行的。</li>
</ol>
<p><strong>默认启动策略是两者均可</strong>（便于标准库管理线程）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fut1 = std::<span class="hljs-built_in">async</span>(f); <span class="hljs-comment">// 同下</span><br><span class="hljs-keyword">auto</span> fut2 = std::<span class="hljs-built_in">async</span>(std::launch::async | std::launch::deferred, f);<br></code></pre></td></tr></table></figure>
<p>使用<code>std::launch::async</code>启动策略的<code>std::async</code>函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-keyword">auto</span></span><br><span class="hljs-function"><span class="hljs-title">reallyAsync</span><span class="hljs-params">(F&amp;&amp; f, Ts&amp;&amp;... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">async</span>(std::launch::async,<br>                      std::forward&lt;F&gt;(f),<br>                      std::forward&lt;Ts&gt;(params)...);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="条款37-使stdthread型别对象在所有路径皆不可联结">条款37
使std::thread型别对象在所有路径皆不可联结</h2>
<p>若<code>std::thread</code>型别对象对应的底层线程处于已运行、阻塞、等待调度、运行结束等状态，认为其处于<strong>可联结状态</strong>（joinable）。</p>
<p><strong>不可联结状态</strong>（unjoinable）的<code>std::thread</code>型别对象包括：</p>
<ol type="1">
<li>默认构造对象。没有可以执行的函数，也就没有对应的底层执行线程。</li>
<li>已移动对象。对应的底层执行线程被对应到另外一个对象。</li>
<li>已join对象。join之后不再对应于已运行完的底层执行线程。</li>
<li>已detach对象。断开了对象和它对应的底层执行线程之间的连接。</li>
</ol>
<p><code>std::thread</code>型别对象的<strong>析构函数被调用时，若其还是可联结状态，会导致程序终止，而不是隐式join或者隐式detach</strong>。因为C++标准委员会规定可联结的线程的析构函数导致程序终止，避免产生性能问题或失去对线程的控制导致BUG。</p>
<p>覆盖所有路径是很复杂的（正常走完作用域，或由return、continue、break、goto或异常跳出作用域），为了确保覆盖，使用RAII机制（即智能指针的实现方法）。标准库没有，参考实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadRAII</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">DtorAction</span> &#123; join, detach &#125;;<br>    <span class="hljs-built_in">ThreadRAII</span>(std::thread&amp;&amp; t, DtorAction a) : <span class="hljs-built_in">action</span>(a), <span class="hljs-built_in">t</span>(std::<span class="hljs-built_in">move</span>(t)) &#123;&#125;<br>    ~<span class="hljs-built_in">ThreadRAII</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">joinable</span>()) <br>        &#123;<br>            <span class="hljs-keyword">if</span>(action == DtorAction::join) <br>            &#123;<br>                t.<span class="hljs-built_in">join</span>();<br>            &#125; <br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                t.<span class="hljs-built_in">detach</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">ThreadRAII</span>(ThreadRAII&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    ThreadRAII&amp; <span class="hljs-keyword">operator</span>=(ThreadRAII&amp;&amp;) = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function">std::thread&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> t; &#125;<br><span class="hljs-keyword">private</span>:<br>    DtorAction action;<br>    std::thread t;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="条款38-对变化多端的线程句柄析构函数行为保持关注">条款38
对变化多端的线程句柄析构函数行为保持关注</h2>
<p>期值对象和<code>std::thread</code>对象的<strong>析构函数行为</strong>不同。</p>
<p>调用方、被调方和共享状态之间的关系：</p>
<p><img
src="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-09-24-future.png" srcset="/img/loading.gif" lazyload /></p>
<p>条款36讲过<code>std::async</code>的启动策略，<strong>只有</strong>经由其启动的<strong>未推迟任务</strong>的共享状态的<strong>最后一个期值</strong>会<strong>保持阻塞直到该任务结束</strong>（析构函数对底层异步执行任务的线程实施了一次<strong>隐式join</strong>）；<strong>其它所有期值</strong>的析构函数仅进行常规析构行为就结束了（如果<strong>被推迟任务</strong>的所有期值被析构其就不可能运行）。（C++11和C++14中情况一致）</p>
<blockquote>
<p>常规析构行为即析构期值对象的成员，针对共享状态里的<strong>引用计数</strong>实施一次自减。共享状态由指涉到它的期值和被调方的<code>std::promise</code>共同操纵，引用计数使得库能够知道何时可以析构共享状态。</p>
</blockquote>
<h2
id="条款39-考虑针对一次性事件通信使用以void为模板型别实参的期值">条款39
考虑针对一次性事件通信使用以void为模板型别实参的期值</h2>
<p>如果仅限于一次性通信，不需要条件变量，互斥量和标志位，使用<code>std::promise</code>型别对象和期值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::promise&lt;<span class="hljs-type">void</span>&gt; p; <span class="hljs-comment">// 通信信道的promise</span><br><br> <span class="hljs-comment">// ...检测某个事件</span><br>p.<span class="hljs-built_in">set_value</span>(); <span class="hljs-comment">// 通知反应任务</span><br><br><span class="hljs-comment">// ...准备作出反应</span><br>p.<span class="hljs-built_in">get_future</span>().<span class="hljs-built_in">wait</span>(); <span class="hljs-comment">//等待对应于p的期值</span><br><span class="hljs-comment">// ...对事件作出反应</span><br></code></pre></td></tr></table></figure>
<h2 id="条款40-对并发使用stdatomic对特种内存使用volatile">条款40
对并发使用std:atomic，对特种内存使用volatile</h2>
<p><code>std::atomic</code><strong>用于多线程访问的数据且不用互斥量</strong>，是撰写并发软件的工具。</p>
<p>volatile<strong>用于读写操作不可以被优化掉的内存</strong>，是在面对特种内存时使用的工具</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ai</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <br>ai = <span class="hljs-number">10</span>; <span class="hljs-comment">// 原子操作</span><br>std::cout &lt;&lt; ai; <span class="hljs-comment">// 只能保证读取是原子操作。在读取ai的值和调用operator &lt;&lt;将其写人标准输出之间，另一个线程可能已经修改了ai 的值。</span><br>++ai; <span class="hljs-comment">// 原子操作</span><br>--ai; <span class="hljs-comment">// 原子操作</span><br></code></pre></td></tr></table></figure>
<p><code>std::atomic</code>型别对象的特点：</p>
<ol type="1">
<li>采用顺序一致性。有其它在代码重新排序方面更灵活的一致性模型，但难以维护。</li>
<li>所有成员函数都保证为原子的。不支持复制操作，硬件无法保证其为原子的。</li>
</ol>
<p><strong>常规内存</strong>：若多次写入之间没有读取操作，编译器可以消除多余的写入操作；若多次读取之间没有写入操作，编译器可以消除多余的读取操作。</p>
<p><strong>特种内存</strong>：用于内存映射I/O的内存，与显示器、打印机等外部设备通信。因为通信会有读取和写入，所以要求编译器不对在此内存上的操作做任何优化。</p>
<p><code>std::atomic</code>和volatile用于不同目的，所以它们可以一起使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">volatile</span> std::atomic&lt;<span class="hljs-type">int</span>&gt; vai;<br></code></pre></td></tr></table></figure>
<h1 id="第8章-微调">第8章 微调</h1>
<h2
id="条款41-针对可复制的形参在移动成本低并且一定会被复制的前提下考虑将其按值传递">条款41
针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1.本质上在做同一件事情的两个函数，增加程序足迹</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123; names.<span class="hljs-built_in">push_back</span>(newName); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(std::string&amp;&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123; names.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(newName)); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::string&gt; names;<br>&#125;;<br><br><span class="hljs-comment">// 2.万能引用会产生多个实例化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(T&amp;&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123;<br>        names.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(newName));<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 3.直接传值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(std::string newName)</span></span><br><span class="hljs-function">    </span>&#123; names.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(newName)); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>程序足迹（program
footprint）通常是指目标代码经常性占用内存的尺寸（动态分配的内存，或是从外存加载到内存的部分往往不计在内）</p>
</blockquote>
<p>使用以上三种方法进行以下实验：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget W;<br><span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">&quot;Bart&quot;</span>)</span></span>;<br>W.<span class="hljs-built_in">addName</span>(name); <span class="hljs-comment">// 传入左值</span><br>W.<span class="hljs-built_in">addName</span>(name + <span class="hljs-string">&quot;Jenne&quot;</span>); <span class="hljs-comment">// 传入右值</span><br></code></pre></td></tr></table></figure>
<p>方法1：两个重载函数的实参均按引用传递，无成本，接收左值的重载函数内一次复制，接收右值的重载函数内一次移动。</p>
<p>方法2：实参按引用传递，无成本。函数内对于左值一次复制，对于右值一次移动。</p>
<p>方法3：实参按值传递，对于左值一次复制，对于右值一次移动。函数内一次移动。</p>
<p>综上，方法三总是多一次移动操作。当且仅当<strong>形参可复制</strong>、<strong>移动成本低</strong>、<strong>形参在函数内一定会被复制</strong>时考虑方法三。</p>
<blockquote>
<p>一定会被复制指，形参传到函数后一定有复制操作，且该操作不会因为条件语句的判定不执行。</p>
<p>一定有复制操作时，传入左值，三种方法均有一次复制（方法1、2的复制发生在函数内，方法3的复制发生在传参时），方法3以额外多一次移动的代价克服了方法1增加程序足迹和方法2多个实例化的缺点。当移动成本低，这个交易就是划算的。</p>
</blockquote>
<h2 id="条款42-考虑置入而非插入">条款42 考虑置入而非插入</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">vs.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;xyzzy&quot;</span>);<br><span class="hljs-comment">// 从字符串字面量（const char [6]）出发，复制构造std::string型别的临时对象，传递给push_back的右值重载版本，绑定到右值引用形参，然后在函数内移动构造一个std::string型别的对象</span><br>vs.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;xyzzy&quot;</span>);<br><span class="hljs-comment">// 完美转发，直接在函数内移动构造一个std::string型别的对象</span><br></code></pre></td></tr></table></figure>
<p>下列情况置入比插入更高效：</p>
<ol type="1">
<li>欲添加的值是以构造而非赋值方式加入容器。</li>
<li>传递的实参型别与容器持有之物的型别不同。</li>
<li>容器不太可能由于出现重复情况而拒绝待添加的新值。</li>
</ol>
<p>置入存在的问题：</p>
<ol type="1">
<li><p>直接完美转发构造所需的参数时，把对象创建推迟到在容器的内存中构造，若发生异常会导致资源泄漏。</p></li>
<li><p>越过了explicit对构造函数的限制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;std::regex&gt; regexes;<br><span class="hljs-comment">// 接收const char *指针的std::regex构造函数声明为explicit，杜绝隐式转换</span><br><br>std::regex r = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 不能编译</span><br>regexes.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 不能编译</span><br><br>regexes.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 能编译！使用直接初始化</span><br></code></pre></td></tr></table></figure></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Notebook/" class="category-chain-item">Notebook</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/CPP/">#CPP</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>《Effective Modern C++》笔记</div>
      <div>https://reddish.fun/posts/Notebook/Effective-Modern-CPP-note/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>bit704</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年9月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/Notebook/Unity-Shader-note/" title="《Unity Shader入门精要》笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">《Unity Shader入门精要》笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/Notebook/More-Effective-CPP-note/" title="《More Effective C++》笔记">
                        <span class="hidden-mobile">《More Effective C++》笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br> 欢迎光临 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
