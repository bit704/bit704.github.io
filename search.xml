<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UE垃圾回收</title>
      <link href="//posts/Article/UE-GC/"/>
      <url>//posts/Article/UE-GC/</url>
      
        <content type="html"><![CDATA[<p>UE源码解析系列</p><span id="more"></span><p>本文参考UE5.0.3源码</p><h1 id="ue-gc">UE GC</h1><h2 id="uobject管理">UObject管理</h2><p><code>UObject</code>是UE的基石，其内部继承体系如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// UE_5.0\Engine\Source\Runtime\CoreUObject文件夹</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">COREUOBJECT_API</span> UObjectBase<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">COREUOBJECT_API</span> UObjectBaseUtility : <span class="hljs-keyword">public</span> UObjectBase<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">COREUOBJECT_API</span> UObject : <span class="hljs-keyword">public</span> UObjectBaseUtility<br></code></pre></td></tr></table></figure><p>其中，<code>UObjectBase</code>提供底层实现，<code>UObjectBaseUtility</code>提供功能函数，都不建议在游戏代码中直接使用。</p><blockquote><p><code>COREUOBJECT_API</code>是定义为<code>DLLEXPORT</code>的宏，后者用于导出函数到DLL，在MSVC下定义为<code>__declspec(dllexport)</code>，在GCC和Clang下定义为<code>__attribute__((visibility("default")))</code>。</p></blockquote><p><code>UObjectArray.h</code>中声明了用于全局<code>UObject</code>管理的<code>GUObjectArray</code>和<code>GUObjectClusters</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> COREUOBJECT_API FUObjectArray GUObjectArray; <span class="hljs-comment">// 变量定义在UObjectHash.cpp</span><br><span class="hljs-keyword">extern</span> COREUOBJECT_API FUObjectClusterContainer GUObjectClusters; <span class="hljs-comment">// 变量定义在UObjectArray.cpp</span><br></code></pre></td></tr></table></figure><p><code>FUObjectArray</code>内部持有<code>FChunkedFixedUObjectArray</code>对象，后者内部持有<code>FUObjectItem</code>二级指针，管理划分为固定大小（<spanclass="math inline">\(2^{16}\)</span>）的指针块。<code>FUObjectItem</code>内部持有<code>UObjectBase</code>指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 仅列出部分数据成员</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FUObjectItem</span><br>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UObjectBase</span>* Object; <span class="hljs-comment">// 持有EObjectFlags</span><br>int32 Flags; <span class="hljs-comment">// 即EInternalObjectFlags</span><br>int32 ClusterRootIndex;<br>int32 SerialNumber; <span class="hljs-comment">// 与此对象关联的序列号（弱对象指针）</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对象flag</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">EObjectFlags</span><br>&#123;<br>RF_NoFlags= <span class="hljs-number">0x00000000</span>,<br><br><span class="hljs-comment">// 本组flag决定对象类型，除了transient都是持久化flag，GC倾向于关注这些</span><br>RF_Public=<span class="hljs-number">0x00000001</span>,<span class="hljs-comment">// 其包外可见的对象</span><br>RF_Standalone=<span class="hljs-number">0x00000002</span>,<span class="hljs-comment">// 保留对象用于编辑，即使没有被引用</span><br>RF_MarkAsNative =<span class="hljs-number">0x00000004</span>,<span class="hljs-comment">// 对象（UField）将在构造时被标记为native（不要在HasAnyFlags()等处使用）</span><br>RF_Transactional=<span class="hljs-number">0x00000008</span>,<span class="hljs-comment">// 对象是事务性的</span><br>RF_ClassDefaultObject=<span class="hljs-number">0x00000010</span>,<span class="hljs-comment">// 对象是CDO</span><br>RF_ArchetypeObject=<span class="hljs-number">0x00000020</span>,<span class="hljs-comment">// 此对象是其它对象的模板，和CDO类似</span><br>RF_Transient=<span class="hljs-number">0x00000040</span>,<span class="hljs-comment">// 不保存对象</span><br><br><span class="hljs-comment">// 本组flag主要与GC有关</span><br>RF_MarkAsRootSet=<span class="hljs-number">0x00000080</span>,<span class="hljs-comment">// 对象将在构造时标记为根集，即使未引用也不会被GC（不要在HasAnyFlags()等处使用）</span><br>RF_TagGarbageTemp=<span class="hljs-number">0x00000100</span>,<span class="hljs-comment">// 需要使用GC的各种应用程序的临时用户标志，垃圾收集器本身不会解释它</span><br><br><span class="hljs-comment">// 本组flag跟踪UObject的生命周期阶段</span><br>RF_NeedInitialization=<span class="hljs-number">0x00000200</span>,<span class="hljs-comment">// 未完成初始化，当~FObjectInitializer完成时清除</span><br>RF_NeedLoad=<span class="hljs-number">0x00000400</span>,<span class="hljs-comment">// 加载中，指示对象需要加载</span><br>RF_KeepForCooker=<span class="hljs-number">0x00000800</span>,<span class="hljs-comment">// 在GC中保留此对象，因为它正被cooker使用</span><br>RF_NeedPostLoad =<span class="hljs-number">0x00001000</span>,<span class="hljs-comment">// 对象需要是加载后的</span><br>RF_NeedPostLoadSubobjects=<span class="hljs-number">0x00002000</span>,<span class="hljs-comment">// 加载中，指示对象仍然需要实例化子对象并修正序列化组件引用</span><br>RF_NewerVersionExists=<span class="hljs-number">0x00004000</span>,<span class="hljs-comment">// 对象由于其所有者包被重新加载而被丢弃，并且当前存在一个更新的版本</span><br>RF_BeginDestroyed=<span class="hljs-number">0x00008000</span>,<span class="hljs-comment">// 对象的BeginDestroy已被调用</span><br>RF_FinishDestroyed=<span class="hljs-number">0x00010000</span>,<span class="hljs-comment">// 对象的FinishDestroy已被调用</span><br><br><span class="hljs-comment">// 其它flag</span><br>RF_BeingRegenerated =<span class="hljs-number">0x00020000</span>,<span class="hljs-comment">// 标记用于创建UClass的UObject（比如蓝图），当它们在加载中重新生成它们的UClass时 （参见FLinkerLoad::CreateExport()）,以及被创建中的UClass对象</span><br>RF_DefaultSubObject =<span class="hljs-number">0x00040000</span>,<span class="hljs-comment">// 标记默认子对象</span><br>RF_WasLoaded=<span class="hljs-number">0x00080000</span>,<span class="hljs-comment">// 标记已经加载的UObject</span><br>RF_TextExportTransient=<span class="hljs-number">0x00100000</span>,<span class="hljs-comment">// 不将对象导出为文本格式，通常用于可以从他们的父对象的数据重生成的子对象</span><br>RF_LoadCompleted=<span class="hljs-number">0x00200000</span>,<span class="hljs-comment">// 对象已经被linkerload完全序列化过不止一次，不要使用，应用RF_WasLoaded代替</span><br>RF_InheritableComponentTemplate = <span class="hljs-number">0x00400000</span>, <span class="hljs-comment">// 对象的原型可以在它的超类中，补充说明：标记可以被子蓝图继承的组件模板</span><br>RF_DuplicateTransient=<span class="hljs-number">0x00800000</span>,<span class="hljs-comment">// 不应该被用于任何类型的复制的对象（复制、粘贴、二进制复制等）</span><br>RF_StrongRefOnFrame =<span class="hljs-number">0x01000000</span>,<span class="hljs-comment">// 来自持久化函数帧的对这个对象的引用被认为是强引用</span><br>RF_NonPIEDuplicateTransient =<span class="hljs-number">0x02000000</span>,<span class="hljs-comment">// 不应该用于复制的对象，除非它正在为PIE会话被复制</span><br>RF_Dynamic <span class="hljs-built_in">UE_DEPRECATED</span>(<span class="hljs-number">5.0</span>, <span class="hljs-string">&quot;RF_Dynamic should no longer be used. It is no longer being set by engine code.&quot;</span>) =<span class="hljs-number">0x04000000</span>,<br>RF_WillBeLoaded =<span class="hljs-number">0x08000000</span>,<span class="hljs-comment">// 此对象在加载中构造并会很快被加载</span><br>RF_HasExternalPackage=<span class="hljs-number">0x10000000</span>,<span class="hljs-comment">// 此对象分配有一个外部包，应该在获取最外层的包时查找它</span><br><br><span class="hljs-comment">// RF_Garbage和RF_PendingKill在EInternalObjectFlags中被镜像，这样GC检查flag时更快</span><br><br>RF_PendingKill <span class="hljs-built_in">UE_DEPRECATED</span>(<span class="hljs-number">5.0</span>, <span class="hljs-string">&quot;RF_PendingKill should not be used directly. Make sure references to objects are released using one of the existing engine callbacks or use weak object pointers.&quot;</span>) = <span class="hljs-number">0x20000000</span>,<br>RF_Garbage <span class="hljs-built_in">UE_DEPRECATED</span>(<span class="hljs-number">5.0</span>, <span class="hljs-string">&quot;RF_Garbage should not be used directly. Use MarkAsGarbage and ClearGarbage instead.&quot;</span>) =<span class="hljs-number">0x40000000</span>,<br>    <br>RF_AllocatedInSharedPage=<span class="hljs-number">0x80000000</span>,<span class="hljs-comment">// 标记分配在共享内存中的对象</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 用于GC的对象flag</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">EInternalObjectFlags</span> : int32<br>&#123;<br>None = <span class="hljs-number">0</span>,<br>LoaderImport = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>, <span class="hljs-comment">// 对象准备好在加载期间被另一个包导入</span><br>Garbage = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>, <span class="hljs-comment">// 从逻辑角度来看是垃圾，不应该被引用，出于性能考虑该标志在EObjectFlags中镜像为RF_Garbage</span><br>PersistentGarbage = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">22</span>, <span class="hljs-comment">// 和上面一样，但通过持久化引用被引用，所以无法被GC</span><br>ReachableInCluster = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">23</span>, <span class="hljs-comment">// 簇中存在对象的外部引用</span><br>ClusterRoot = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">24</span>, <span class="hljs-comment">// 簇的根</span><br>Native = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">25</span>, <span class="hljs-comment">// 仅是UClass对象</span><br>Async = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">26</span>, <span class="hljs-comment">// 对象只存在于与游戏线程不同的线程中</span><br>AsyncLoading = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">27</span>, <span class="hljs-comment">// 对象正在被异步加载</span><br>Unreachable = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">28</span>, <span class="hljs-comment">// 对象在对象图上不可达</span><br>    <br>PendingKill <span class="hljs-built_in">UE_DEPRECATED</span>(<span class="hljs-number">5.0</span>, <span class="hljs-string">&quot;PendingKill flag should no longer be used. Use Garbage flag instead.&quot;</span>) = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">29</span>, <span class="hljs-comment">// 正在等待析构的对象（游戏玩法中无效的有效对象），出于性能考虑该标志在EObjectFlags中镜像为RF_PendingKill</span><br>    <br>RootSet = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>, <span class="hljs-comment">// 即使没有被引用也不会被GC</span><br>PendingConstruction = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>, <span class="hljs-comment">// 对象还没有调用其构造函数（只有UObjectBase的构造函数初始化了最基础的成员）</span><br><br>    <span class="hljs-comment">// 以下flag的对象跳过GC</span><br>GarbageCollectionKeepFlags = Native | Async | AsyncLoading | LoaderImport,<br><br>    <span class="hljs-comment">// EObjectFlags中的镜像Flag</span><br>MirroredFlags = Garbage | PendingKill, <br><br>AllFlags = LoaderImport | Garbage | PersistentGarbage | ReachableInCluster | ClusterRoot | Native | Async | AsyncLoading | Unreachable | PendingKill | RootSet | PendingConstruction<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>FUObjectClusterContainer</code>内部持有<code>TArray&lt;FUObjectCluster&gt;</code>对象，<code>FUObjectCluster</code>对<code>UObject</code>进行分组管理以便于GC。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 仅列出数据成员</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FUObjectCluster</span><br>&#123;<br>int32 RootIndex; <span class="hljs-comment">// 根对象索引</span><br>TArray&lt;int32&gt; Objects; <span class="hljs-comment">// 属于此簇的对象</span><br>TArray&lt;int32&gt; ReferencedClusters; <span class="hljs-comment">// 此簇引用的其它簇</span><br>TArray&lt;int32&gt; MutableObjects; <span class="hljs-comment">// 不能添加到此簇但被此簇引用的对象</span><br>TArray&lt;int32&gt; ReferencedByClusters; <span class="hljs-comment">// 引用此簇的簇，当解散簇时使用</span><br><span class="hljs-type">bool</span> bNeedsDissolving; <span class="hljs-comment">// 可能因为PendingKill引用而需要解散的簇</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>UObjectBase</code>的<code>AddObject</code>函数中先根据<code>EObjectFlags</code>设置好<code>EInternalObjectFlags</code>，然后调用<code>GUObjectArray.AllocateUObjectIndex(this);</code>将自己添加到全局<code>UObject</code>数组并分配索引，最后调用<code>HashObject(this);</code>将自己添加到名称哈希表。</p><h2 id="gc调用">GC调用</h2><p>UE会在固定的时间间隔下自动调用GC（默认61.1秒），可以在<code>UE_5.0\Engine\Config\BaseEngine.ini</code>中配置GC。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[/Script/Engine.GarbageCollectionSettings]</span><br><span class="hljs-attr">gc.MaxObjectsNotConsideredByGC</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">gc.SizeOfPermanentObjectPool</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">gc.FlushStreamingOnGC</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">gc.NumRetriesBeforeForcingGC</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">gc.AllowParallelGC</span>=<span class="hljs-literal">True</span><br><span class="hljs-comment">; pick a fractional number to keep phase shifting and avoid collisions</span><br><span class="hljs-attr">gc.TimeBetweenPurgingPendingKillObjects</span>=<span class="hljs-number">61.1</span><br><span class="hljs-attr">gc.MaxObjectsInEditor</span>=<span class="hljs-number">25165824</span><br><span class="hljs-attr">gc.IncrementalBeginDestroyEnabled</span>=<span class="hljs-literal">True</span><br><span class="hljs-attr">gc.CreateGCClusters</span>=<span class="hljs-literal">True</span><br><span class="hljs-attr">gc.MinGCClusterSize</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">gc.AssetClustreringEnabled</span>=<span class="hljs-literal">False</span><br><span class="hljs-attr">gc.ActorClusteringEnabled</span>=<span class="hljs-literal">False</span><br><span class="hljs-attr">gc.BlueprintClusteringEnabled</span>=<span class="hljs-literal">False</span><br><span class="hljs-attr">gc.UseDisregardForGCOnDedicatedServers</span>=<span class="hljs-literal">False</span><br><span class="hljs-attr">gc.MultithreadedDestructionEnabled</span>=<span class="hljs-literal">True</span><br><span class="hljs-attr">gc.VerifyGCObjectNames</span>=<span class="hljs-literal">True</span><br><span class="hljs-attr">gc.VerifyUObjectsAreNotFGCObjects</span>=<span class="hljs-literal">False</span><br><span class="hljs-attr">gc.PendingKillEnabled</span>=<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>可以通过手动调用<code>GEngine-&gt;ForceGarbageCollection(true)</code>将<code>bFullPurgeTriggered</code>设置为True，从而强制引擎在<code>UWorld::Tick</code>在<code>ConditionalCollectGarbage()</code>中调用GC。</p><h2 id="gc流程">GC流程</h2><h3 id="加锁">加锁</h3><p>目的是阻止其它线程执行UObject操作。GCLock是不可重入的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 开始GC，尝试加锁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CollectGarbage</span><span class="hljs-params">(EObjectFlags KeepFlags, <span class="hljs-type">bool</span> bPerformFullPurge)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">AcquireGCLock</span>(); <span class="hljs-comment">// 加锁，FGCCSyncObject::Get().GCLock();</span><br><span class="hljs-built_in">CollectGarbageInternal</span>(KeepFlags, bPerformFullPurge); <span class="hljs-comment">// 执行GC</span><br><span class="hljs-built_in">ReleaseGCLock</span>(); <span class="hljs-comment">// 释放锁，FGCCSyncObject::Get().GCUnlock();</span><br>&#125;<br><br><span class="hljs-comment">// 没有其它线程持有GC锁的时候才开始GC，FGCCSyncObject::Get().TryGCLock()</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TryCollectGarbage</span><span class="hljs-params">(EObjectFlags KeepFlags, <span class="hljs-type">bool</span> bPerformFullPurge)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>void GCLock()</code>：自增原子变量<code>GCWantsToRunCounter</code>，通知其它线程想要执行GC，循环等待<code>AsyncCounter</code>（若有任何阻塞GC的非游戏线程则非0）归0，然后自增<code>GCCounter</code>（若GC在执行则非0），创建内存屏障，将<code>GCWantsToRunCounter</code>置为0。</p><blockquote><p><code>FPlatformMisc::MemoryBarrier()</code>用来创建内存屏障，确保内存屏障之前的所有读写操作都在内存屏障之前完成，内存屏障之后的所有读写操作都在内存屏障之后开始。这样可以保证内存操作的顺序性，避免因为指令重排序导致的问题。</p></blockquote><p><code>bool TryGCLock()</code>：若是<code>AsyncCounter</code>非0则返回false。</p><h3 id="标记与可达性分析">标记与可达性分析</h3><p>目的是找出所有不可达的对象。</p><p>这里分析<code>CollectGarbageInternal</code>函数中调用的<code>PerformReachabilityAnalysis</code>函数，其有两个主要步骤，标记与可达性分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 精简代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PerformReachabilityAnalysis</span><span class="hljs-params">(EObjectFlags KeepFlags, <span class="hljs-type">const</span> EFastReferenceCollectorOptions InOptions)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取UObject指针数组ObjectsToSerialize</span><br>    FGCArrayStruct* ArrayStruct = FGCArrayPool::<span class="hljs-built_in">Get</span>().<span class="hljs-built_in">GetArrayStructFromPool</span>();<br>    TArray&lt;UObject*&gt;&amp; ObjectsToSerialize = ArrayStruct-&gt;ObjectsToSerialize;<br><br>    <span class="hljs-comment">// 重设对象计数</span><br>    GObjectCountDuringLastMarkPhase.<span class="hljs-built_in">Reset</span>();<br><br>    <span class="hljs-comment">// 确保检查GC referencer对象对其他对象的引用，即使它在永久对象池中</span><br>    <span class="hljs-keyword">if</span> (FPlatformProperties::<span class="hljs-built_in">RequiresCookedData</span>() &amp;&amp; FGCObject::GGCObjectReferencer &amp;&amp; GUObjectArray.<span class="hljs-built_in">IsDisregardForGC</span>(FGCObject::GGCObjectReferencer))<br>    &#123;<br>        <span class="hljs-comment">// 加入FGCObject::GGCObjectReferencer</span><br>        ObjectsToSerialize.<span class="hljs-built_in">Add</span>(FGCObject::GGCObjectReferencer);<br>    &#125;<br>    <br>    <span class="hljs-type">const</span> EFastReferenceCollectorOptions OptionsForMarkPhase = InOptions &amp; ~EFastReferenceCollectorOptions::WithPendingKill;<br>    <br>    <span class="hljs-comment">// 1.标记</span><br>    (<span class="hljs-keyword">this</span>-&gt;*MarkObjectsFunctions[<span class="hljs-built_in">GetGCFunctionIndex</span>(OptionsForMarkPhase)])(ObjectsToSerialize, KeepFlags);<br><br>    <span class="hljs-comment">// 2.可达性分析</span><br>    (<span class="hljs-keyword">this</span>-&gt;*ReachabilityAnalysisFunctions[<span class="hljs-built_in">GetGCFunctionIndex</span>(InOptions)])(ArrayStruct);<br><br>    FGCArrayPool::<span class="hljs-built_in">Get</span>().<span class="hljs-built_in">ReturnToPool</span>(ArrayStruct);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中的<code>MarkObjectsFunctions</code>数组（长度为4）保存了<code>MarkObjectsAsUnreachable</code>函数模板的不同实例化，<code>ReachabilityAnalysisFunctions</code>数组（长度为8）保存了<code>PerformReachabilityAnalysisOnObjectsInternal</code>函数模板的不同实例化，实例化参数都是非类型参数<code>EFastReferenceCollectorOptions</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">EFastReferenceCollectorOptions</span> : uint32<br>&#123;<br>None = <span class="hljs-number">0</span>,<br>Parallel = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>,<br>AutogenerateTokenStream = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,<br>ProcessNoOpTokens = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,<br>WithClusters = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>, <br>ProcessWeakReferences = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>,<br>WithPendingKill = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>,<br>&#125;;<br><br><span class="hljs-comment">// 实例化举例</span><br>MarkObjectsFunctions[<span class="hljs-built_in">GetGCFunctionIndex</span>(EFastReferenceCollectorOptions::None)] = &amp;FRealtimeGC::MarkObjectsAsUnreachable&lt;<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>&gt;;<br><br>ReachabilityAnalysisFunctions[<span class="hljs-built_in">GetGCFunctionIndex</span>(EFastReferenceCollectorOptions::None)] = &amp;FRealtimeGC::PerformReachabilityAnalysisOnObjectsInternal&lt;EFastReferenceCollectorOptions::None | EFastReferenceCollectorOptions::None&gt;;<br><br><span class="hljs-comment">// 1.标记</span><br><span class="hljs-comment">// 将所有没有KeepFlags和EInternalObjectFlags::GarbageCollectionKeepFlags的对象标记为不可达的</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> bParallel, <span class="hljs-type">bool</span> bWithClusters&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MarkObjectsAsUnreachable</span><span class="hljs-params">(TArray&lt;UObject*&gt;&amp; ObjectsToSerialize, <span class="hljs-type">const</span> EObjectFlags KeepFlags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 2.可达性分析</span><br><span class="hljs-comment">// UObject对象对应的UClass对象持有的FGCReferenceTokenStream ReferenceTokenStream记录了对象引用的其它对象，可以据此去除可达对象的不可达标记</span><br><span class="hljs-comment">// FGCReferenceTokenStream持有TArray&lt;uint32&gt; Tokens</span><br><span class="hljs-comment">// 一个Token的结构如下：</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FGCReferenceInfo</span><br>&#123;<br><span class="hljs-keyword">union</span><br>&#123;<br><span class="hljs-keyword">struct</span><br>&#123;<br>uint32 ReturnCount: <span class="hljs-number">8</span>;  <span class="hljs-comment">// 当前引用的对象的嵌套深度</span><br>uint32 Type: <span class="hljs-number">5</span>;  <span class="hljs-comment">// 引用的类型，比如GCRT_ArrayObject </span><br>uint32 Offset: <span class="hljs-number">19</span>; <span class="hljs-comment">// 当前引用的对象相对于自己的偏移</span><br>&#125;;<br>uint32 Value;<br>&#125;;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;EFastReferenceCollectorOptions CollectorOptions&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PerformReachabilityAnalysisOnObjectsInternal</span><span class="hljs-params">(FGCArrayStruct* ArrayStruct)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="清理">清理</h3><p>目的是清理不可达的对象。</p><p><code>CollectGarbageInternal</code>函数中调用<code>IncrementalPurgeGarbage</code>函数进行清理。后者调用的<code>UnhashUnreachableObjects</code>函数调用了<code>UObject::ConditionalBeginDestroy()</code>，<code>IncrementalDestroyGarbage</code>函数调用了<code>UObject::ConditionalFinishDestroy()</code>。它们都没有真正调用析构函数，析构函数在<code>TickDestroyObjects</code>和<code>TickDestroyGameThreadObjects</code>中调用。</p><h1 id="conclusion">Conclusion</h1><p>基于引用计数的GC是实时的，但无法解决使用不当造成的循环引用。基于可达性的GC是非实时的，可以解决循环引用问题。</p><p>C++11的智能指针和微软的COM对象使用基于引用计数的GC。</p><p>UE使用基于可达性的GC，为标记-清除式。</p><p>Java虚拟机使用基于可达性的GC，采用分代机制（GC频率不同），新生代采用标记-复制式，老年代采用标记-整理式。</p><p>CPython使用基于引用计数的GC，辅助使用循环引用检测算法和分代机制。</p><p>Lua使用基于可达性的GC，为增量标记-清除式。</p><h1 id="参考资料">参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/401956734">原创 UE基础—GarbageCollection(垃圾回收) - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/25539690">Java性能优化之JVMGC（垃圾回收机制） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/295062531">GC 机制探究之 Python篇 - 知乎 (zhihu.com)</a></p><p><a href="https://www.runoob.com/lua/lua-garbage-collection.html">Lua垃圾回收 菜鸟教程 (runoob.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>specular anisotropic实现</title>
      <link href="//posts/Article/specular-anisotropy/"/>
      <url>//posts/Article/specular-anisotropy/</url>
      
        <content type="html"><![CDATA[<p>blender、UE、Unity</p><span id="more"></span><p>anisotropic即不同方向上不均匀的特性。在计算机图形学的材质方面，specular、transmission、subsuface、coat均可能为anisotropic。</p><p>常用的计算specularBRDF的Cook-Torrance微面模型的<strong>D项</strong>为<strong>GGX</strong>。</p><p>isotropic GGX： <span class="math display">\[D_{GGX}(H) = \frac{\alpha^2}{\pi((N\cdot H)^2 (\alpha^2 - 1) + 1)^2}\]</span> anisotropic GGX： <span class="math display">\[D_{GGXaniso}(H) = \frac{1}{\pi \alpha_x \alpha_y} \frac{1}{ \left(\frac{(X \cdot H)^2}{\alpha_x^2} + \frac{(Y \cdot H)^2}{\alpha_y^2} +(N\cdot H)^2 \right)^2 }\]</span> 其中<span class="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span>分别代表切线和副切线方向，<spanclass="math inline">\(\alpha_x\)</span>、<spanclass="math inline">\(\alpha_y\)</span>即对应方向上的roughness。</p><p>设anisotropic值为<spanclass="math inline">\(a\)</span>、roughness值为<spanclass="math inline">\(r\)</span>，不同的<spanclass="math inline">\(\alpha_x\)</span>、<spanclass="math inline">\(\alpha_y\)</span>参数化方法<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="OpenPBR issue: [Anisotropy parametrisation · Issue #82 · AcademySoftwareFoundation/OpenPBR](https://github.com/AcademySoftwareFoundation/OpenPBR/issues/82)">[1]</span></a></sup>如下：</p><ol type="1"><li>Burley 2012 (Disney model)</li></ol><p><span class="math display">\[aspect=\sqrt{1-0.9a}\]</span></p><p><span class="math display">\[\alpha_x=\frac{r^2}{aspect}\]</span></p><p><span class="math display">\[\alpha_y=r^2\cdot aspect\]</span></p><ol start="2" type="1"><li>Georgiev 2019 (Standard Surface)</li></ol><p><span class="math display">\[\alpha_x = \min(\frac{r^2}{\sqrt{1-a}}, 1.0)\]</span></p><p><span class="math display">\[\alpha_y = r^2 \sqrt{1-a}\]</span></p><ol start="3" type="1"><li>Kulla 2017 (Sony Pictures Imageworks)</li></ol><p><span class="math display">\[\alpha_x = r^2 (1 + a)\]</span></p><p><span class="math display">\[\alpha_y = r^2 (1 - a)\]</span></p><ol start="4" type="1"><li>Neubelt 2013 (The Order: 1886)</li></ol><p><span class="math display">\[\alpha_x = r^2\]</span></p><p><span class="math display">\[\alpha_y = \mathrm{lerp}(0, r^2, 1 - a)\]</span></p><ol start="5" type="1"><li>Kutz 2021 (Adobe Standard Material)</li></ol><p><span class="math display">\[\alpha_x = r^2 + a^4\]</span></p><p><span class="math display">\[\alpha_y = r^2\]</span></p><ol start="6" type="1"><li>OpenPBR proposed mapping 2023</li></ol><p><span class="math display">\[\alpha_x = r^2 \sqrt{\frac{2}{1 + (1 - a)^2}}\]</span></p><p><span class="math display">\[\alpha_y = (1 - a)\alpha_x\]</span></p><p><ahref="https://github.com/blender/blender">Blender</a>的cycles使用Burley2012：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// intern\cycles\kernel\osl\shaders\node_principled_bsdf.osl</span><br><br><span class="hljs-comment">// Roughness默认为0.5</span><br><br><span class="hljs-type">float</span> r2 = clamp(Roughness, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>r2 = r2 * r2;<br><span class="hljs-type">float</span> alpha_x = r2, alpha_y = r2;<br><br><span class="hljs-built_in">vector</span> T = Tangent;<br><span class="hljs-keyword">if</span> (Anisotropic &gt; <span class="hljs-number">0.0</span>) &#123;<br><span class="hljs-type">float</span> aspect = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - clamp(Anisotropic, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>) * <span class="hljs-number">0.9</span>);<br>alpha_x /= aspect;<br>alpha_y *= aspect;<br><span class="hljs-keyword">if</span> (AnisotropicRotation != <span class="hljs-number">0.0</span>)<br>  T = rotate(T, AnisotropicRotation * M_2PI, point(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>), Normal);<br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://github.com/EpicGames/UnrealEngine">UE</a>默认使用Kulla2017：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Engine\Shaders\Private\BRDF.ush</span><br><br><span class="hljs-comment">// Alpha为Roughness的平方</span><br><br><span class="hljs-comment">// Convert a roughness and an anisotropy factor into GGX alpha values respectively for the major and minor axis of the tangent frame</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">GetAnisotropicRoughness</span><span class="hljs-params">(<span class="hljs-type">float</span> Alpha, <span class="hljs-type">float</span> Anisotropy, out <span class="hljs-type">float</span> ax, out <span class="hljs-type">float</span> ay)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 1</span><br><span class="hljs-comment">// Anisotropic parameters: ax and ay are the roughness along the tangent and bitangent</span><br><span class="hljs-comment">// Kulla 2017, &quot;Revisiting Physically Based Shading at Imageworks&quot;</span><br>ax = max(Alpha * (<span class="hljs-number">1.0</span> + Anisotropy), <span class="hljs-number">0.001f</span>);<br>ay = max(Alpha * (<span class="hljs-number">1.0</span> - Anisotropy), <span class="hljs-number">0.001f</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-type">float</span> K = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0f</span> - <span class="hljs-number">0.95f</span> * Anisotropy);<br>ax = max(Alpha / K, <span class="hljs-number">0.001f</span>);<br>ay = max(Alpha * K, <span class="hljs-number">0.001f</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://unity.com/releases/editor/archive">Unity</a>的HDRP使用Kulla2017：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 2021.3.11f1c2\Editor\Data\Resources\PackageManager\BuiltInPackages\com.unity.render-pipelines.core\ShaderLibrary\CommonMaterial.hlsl</span><br><br>real <span class="hljs-title function_">PerceptualRoughnessToRoughness</span><span class="hljs-params">(real perceptualRoughness)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> perceptualRoughness * perceptualRoughness;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ConvertValueAnisotropyToValueTB</span><span class="hljs-params">(real value, real anisotropy, out real valueT, out real valueB)</span><br>&#123;<br>    <span class="hljs-comment">// Use the parametrization of Sony Imageworks.</span><br>    <span class="hljs-comment">// Ref: Revisiting Physically Based Shading at Imageworks, p. 15.</span><br>    valueT = value * (<span class="hljs-number">1</span> + anisotropy);<br>    valueB = value * (<span class="hljs-number">1</span> - anisotropy);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ConvertAnisotropyToRoughness</span><span class="hljs-params">(real perceptualRoughness, real anisotropy, out real roughnessT, out real roughnessB)</span><br>&#123;<br>    real roughness = PerceptualRoughnessToRoughness(perceptualRoughness);<br>    ConvertValueAnisotropyToValueTB(roughness, anisotropy, roughnessT, roughnessB);<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>OpenPBR issue: <ahref="https://github.com/AcademySoftwareFoundation/OpenPBR/issues/82">Anisotropyparametrisation · Issue #82 · AcademySoftwareFoundation/OpenPBR</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
            <tag> UE </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenPBR介绍</title>
      <link href="//posts/Article/OpenPBR-intro/"/>
      <url>//posts/Article/OpenPBR-intro/</url>
      
        <content type="html"><![CDATA[<p>OpenPBR Surface shading model</p><span id="more"></span><p><strong>超级着色器</strong>（über-shader）即覆盖各种情况的单一整体材质，它拥有一组定义明确的参数，可以调整这些参数来创作现实中和想象中的材质。例如Disney的PrincipledShader<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="McAuley S, Hill S, Hoffman N, et al. Practical physically-based shading in film and game production[M]//ACM SIGGRAPH 2012 Courses. 2012: 1-7.">[1]</span></a></sup>、Allegorithmic的PBRshadingmodel<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://argos.vu/wp-content/uploads/2016/03/PBR_Guide_Vol.1.pdf">[2]</span></a></sup>、Autodesk的StandardSurfaceshader<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://autodesk.github.io/standard-surface/">[3]</span></a></sup>、Adobe的StandardMaterial<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://helpx.adobe.com/substance-3d-general/adobe-standard-material.html">[4]</span></a></sup>、Blender的PrincipledBSDF<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/principled.html">[5]</span></a></sup>等。<strong>OpenPBR</strong>旨在成为不同产品之间的通用接口，覆盖大多数日常用例（未涵盖更专业的用例，如非常高端的皮肤、头发、布料或体积着色）。</p><p><ahref="https://github.com/AcademySoftwareFoundation/OpenPBR">OpenPBR(Github)</a>作为MaterialX的一个子项目于2023年8月2日由<ahref="https://www.aswf.io/">ASWF</a>发布。该项目由Autodesk和Adobe开发，用MaterialX编写，任何已经支持MaterialX都可以自动支持OpenPBR。</p><blockquote><p>已有Pixar USD、SideFX Houdini、Autodesk Maya、Autodesk 3ds Max、AppleVisionOS、Unreal Engine、NVIDIA Omniverse、Autodesk Arnold、PixarRenderMan、Chaos V-Ray支持MaterialX。</p></blockquote><p><ahref="https://github.com/AcademySoftwareFoundation/MaterialX">MaterialX(Github)</a>是在计算机图形学中表示丰富材质和外观开发内容的开放标准，它使美工能够以通用的网络形式描述材质，从而为资产提供<strong>跨渲染器和平台</strong>的一致外观。本质上，MaterialX是一种使用XML格式文件在不同DCC工具之间交换数据的机制。</p><p>使用MaterialX GraphEditor编辑OpenPBR的参考实现<code>open_pbr_surface.mtlx</code>的节点图：</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-18-open_pbr_surface_graph.png" /></p><p>节点图中空着的槽对应的属性可以在MaterialXView中调整：</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-18-open_pbr_surface_view.png" /></p><p>OpenPBR结构<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://academysoftwarefoundation.github.io/OpenPBR/">[6]</span></a></sup>如下：</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-18-openpbr_model_schematic.svg" /></p><ul><li><p>由金属或电介质的混合物构成的basesubstrate。该基层的界面（电介质或金属）提供<strong>主镜面反射波瓣</strong>。电介质基底代表三种成分中的任一种，可以统计混合：</p><ul><li>Glossy-diffuse：具有不透明内部介质的电介质，如木材、花岗岩、混凝土、纸板和墙漆。</li><li>Subsurface：具有致密高散射内部介质的电介质，如塑料、大理石、皮肤、植物和食物。</li><li>Translucent-base：具有半透明内部介质的电介质，如玻璃、晶体和液体。</li></ul></li><li><p>Coat：可选的电介质层，可具有吸收介质，充当basesubstrate顶部的涂层。该层的电介质界面提供<strong>次镜面反射波瓣</strong>。</p></li><li><p>Fuzz：可选层，表示来自在其他所有物体之上的微纤维（例如细毛、桃绒、纺织线和灰尘颗粒）的反射。</p></li></ul><p>参数设计如下：</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: left;">Identifier</th><th style="text-align: left;">Label</th><th style="text-align: left;">Type</th><th style="text-align: center;">Range</th><th style="text-align: center;">Norm</th><th style="text-align: center;">Default</th><th style="text-align: left;">Unit</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>Base</strong></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>base_weight</code></td><td style="text-align: left;">Weight</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>base_color</code></td><td style="text-align: left;">Color</td><td style="text-align: left;">color3</td><td style="text-align: center;"><spanclass="math inline">\([0,1]^3\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\((0.8,0.8,0.8)\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>base_roughness</code></td><td style="text-align: left;">Roughness</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>base_metalness</code></td><td style="text-align: left;">Metalness</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><strong>Specular</strong></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>specular_weight</code></td><td style="text-align: left;">Weight</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>specular_color</code></td><td style="text-align: left;">Color</td><td style="text-align: left;">color</td><td style="text-align: center;"><spanclass="math inline">\([0,1]^3\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\((1,1,1)\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>specular_roughness</code></td><td style="text-align: left;">Roughness</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0.3\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>specular_anisotropy</code></td><td style="text-align: left;">Anisotropy</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>specular_rotation</code></td><td style="text-align: left;">Rotation</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>specular_ior</code></td><td style="text-align: left;">IOR</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\((0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([1,3]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1.5\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>specular_ior_level</code></td><td style="text-align: left;">IOR level</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0.5\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><strong>Transmission</strong></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>transmission_weight</code></td><td style="text-align: left;">Weight</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>transmission_color</code></td><td style="text-align: left;">Color</td><td style="text-align: left;">color</td><td style="text-align: center;"><spanclass="math inline">\([0,1]^3\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\((1,1,1)\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>transmission_depth</code></td><td style="text-align: left;">Depth</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"><spanclass="math inline">\(length\)</span></td></tr><tr class="even"><td style="text-align: left;"><code>transmission_scatter</code></td><td style="text-align: left;">Scatter</td><td style="text-align: left;">color</td><td style="text-align: center;"><spanclass="math inline">\([0,1]^3\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\((0,0,0)\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><tdstyle="text-align: left;"><code>transmission_scatter_anisotropy</code></td><td style="text-align: left;">Anisotropy</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([-1,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><tdstyle="text-align: left;"><code>transmission_dispersion_abbe_number</code></td><td style="text-align: left;">Abbe number</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\((0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([9,91]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(20\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><tdstyle="text-align: left;"><code>transmission_dispersion_scale</code></td><td style="text-align: left;">Dispersion scale</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><strong>Subsurface</strong></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>subsurface_weight</code></td><td style="text-align: left;">Weight</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>subsurface_color</code></td><td style="text-align: left;">Color</td><td style="text-align: left;">color</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\((0.8,0.8,0.8)\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>subsurface_radius</code></td><td style="text-align: left;">Radius</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: left;"><spanclass="math inline">\(length\)</span></td></tr><tr class="even"><td style="text-align: left;"><code>subsurface_radius_scale</code></td><td style="text-align: left;">Radius scale</td><td style="text-align: left;">vector</td><td style="text-align: center;"><spanclass="math inline">\([0,1]^3\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\((1.0,0.5,0.25)\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>subsurface_anisotropy</code></td><td style="text-align: left;">Anisotropy</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([-1,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><strong>Coat</strong></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>coat_weight</code></td><td style="text-align: left;">Weight</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>coat_color</code></td><td style="text-align: left;">Color</td><td style="text-align: left;">color</td><td style="text-align: center;"><spanclass="math inline">\([0,1]^3\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\((1,1,1)\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>coat_roughness</code></td><td style="text-align: left;">Roughness</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>coat_anisotropy</code></td><td style="text-align: left;">Anisotropy</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>coat_rotation</code></td><td style="text-align: left;">Rotation</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>coat_ior</code></td><td style="text-align: left;">IOR</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\((0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([1,3]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1.6\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>coat_ior_level</code></td><td style="text-align: left;">IOR level</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0.5\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><strong>Fuzz</strong></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>fuzz_weight</code></td><td style="text-align: left;">Weight</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>fuzz_color</code></td><td style="text-align: left;">Color</td><td style="text-align: left;">color</td><td style="text-align: center;"><spanclass="math inline">\([0,1]^3\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\((1,1,1)\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>fuzz_roughness</code></td><td style="text-align: left;">Roughness</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(0.5\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><strong>Emission</strong></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>emission_luminance</code></td><td style="text-align: left;">Luminance</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([0,1000]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"><spanclass="math inline">\(nits\)</span></td></tr><tr class="even"><td style="text-align: left;"><code>emission_color</code></td><td style="text-align: left;">Color</td><td style="text-align: left;">color</td><td style="text-align: center;"><spanclass="math inline">\([0,1]^3\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\((1,1,1)\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><strong>Thin-film</strong></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>thin_film_thickness</code></td><td style="text-align: left;">Thickness</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([0,2000]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"><spanclass="math inline">\(nanometers\)</span></td></tr><tr class="odd"><td style="text-align: left;"><code>thin_film_ior</code></td><td style="text-align: left;">IOR</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\((0,\infty)\)</span></td><td style="text-align: center;"><spanclass="math inline">\([1,3]\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1.5\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><strong>Geometry</strong></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>geometry_opacity</code></td><td style="text-align: left;">Opacity</td><td style="text-align: left;">float</td><td style="text-align: center;"><spanclass="math inline">\([0,1]\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>geometry_thin_walled</code></td><td style="text-align: left;">Thin walled</td><td style="text-align: left;">boolean</td><td style="text-align: center;"><span class="math inline">\(\{false,true\}\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(false\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>geometry_normal</code></td><td style="text-align: left;">Normal</td><td style="text-align: left;">vector</td><td style="text-align: center;"><spanclass="math inline">\(N/A\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(unperturbed\  normal\)</span></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>geometry_tangent</code></td><td style="text-align: left;">Tangent</td><td style="text-align: left;">vector</td><td style="text-align: center;"><spanclass="math inline">\(N/A\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(unperturbed\  normal\)</span></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>geometry_coat_normal</code></td><td style="text-align: left;">Coat Normal</td><td style="text-align: left;">vector</td><td style="text-align: center;"><spanclass="math inline">\(N/A\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(unperturbed\  normal\)</span></td><td style="text-align: left;"></td></tr></tbody></table><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>McAuley S, Hill S, HoffmanN, et al. Practical physically-based shading in film and gameproduction[M]//ACM SIGGRAPH 2012 Courses. 2012: 1-7.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://argos.vu/wp-content/uploads/2016/03/PBR_Guide_Vol.1.pdf<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://autodesk.github.io/standard-surface/<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://helpx.adobe.com/substance-3d-general/adobe-standard-material.html<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/principled.html<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>https://academysoftwarefoundation.github.io/OpenPBR/<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++协程</title>
      <link href="//posts/Article/CPP-Coroutine/"/>
      <url>//posts/Article/CPP-Coroutine/</url>
      
        <content type="html"><![CDATA[<p>学习总结</p><span id="more"></span><h1 id="快速上手">1 快速上手</h1><p>协程（coroutine）可以看作函数的广义版本，允许函数暂停和恢复。</p><p>在C++20中，协程即包含<code>co_return</code>、<code>co_yield</code>、<code>co_await</code>的函数。本质上，C++20协程是函数对象之上的<strong>语法糖</strong>，编译器将围绕协程生成一个代码框架，此代码依赖于return和promise类型（若不使用C++23及未来版本会提供的高级抽象，需要由<strong>用户定义</strong>，所以比较麻烦）。以C++20协程实现的一个<ahref="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle">生成器</a>为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打印26个大写字母</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;std::movable T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Generator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span><br>    &#123;<br>        <span class="hljs-comment">// 当前值</span><br>        std::optional&lt;T&gt; current_value;<br><br>        <span class="hljs-comment">// 返回coroutine frame句柄</span><br>        <span class="hljs-function">Generator&lt;T&gt; <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> Generator&#123;Handle::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)&#125;;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">static</span> std::suspend_always <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">static</span> std::suspend_always <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br><br>        <span class="hljs-function">std::suspend_always <span class="hljs-title">yield_value</span><span class="hljs-params">(T value)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">        </span>&#123;<br>            current_value = std::<span class="hljs-built_in">move</span>(value);<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br><br>        <span class="hljs-comment">// 在生成器协程中不允许co_await</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_transform</span><span class="hljs-params">()</span> </span>= <span class="hljs-keyword">delete</span>;<br><br>        [[noreturn]] <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">throw</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// coroutine frame句柄类型</span><br>    <span class="hljs-keyword">using</span> Handle = std::coroutine_handle&lt;promise_type&gt;;<br><br><span class="hljs-keyword">private</span>:<br>    Handle m_coroutine;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Generator</span><span class="hljs-params">(<span class="hljs-type">const</span> Handle coroutine)</span> : m_coroutine&#123;</span>coroutine&#125;<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-built_in">Generator</span>() = <span class="hljs-keyword">default</span>;<br>    ~<span class="hljs-built_in">Generator</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (m_coroutine)<br>            m_coroutine.<span class="hljs-built_in">destroy</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">Generator</span>(<span class="hljs-type">const</span> Generator &amp;) = <span class="hljs-keyword">delete</span>;<br>    Generator &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Generator &amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 仅保留移动语义</span><br>    <span class="hljs-built_in">Generator</span>(Generator &amp;&amp;other) <span class="hljs-keyword">noexcept</span> : m_coroutine&#123;other.m_coroutine&#125;<br>    &#123;<br>        other.m_coroutine = &#123;&#125;;<br>    &#125;<br>    Generator &amp;<span class="hljs-keyword">operator</span>=(Generator &amp;&amp;other) <span class="hljs-keyword">noexcept</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (m_coroutine)<br>                m_coroutine.<span class="hljs-built_in">destroy</span>();<br>            m_coroutine = other.m_coroutine;<br>            other.m_coroutine = &#123;&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 迭代器</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iter</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>++()<br>        &#123;<br>            m_coroutine.<span class="hljs-built_in">resume</span>();<br>        &#125;<br>        <span class="hljs-type">const</span> T &amp;<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> *m_coroutine.<span class="hljs-built_in">promise</span>().current_value;<br>        &#125;<br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(std::<span class="hljs-type">default_sentinel_t</span>) <span class="hljs-type">const</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> !m_coroutine || m_coroutine.<span class="hljs-built_in">done</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Iter</span><span class="hljs-params">(<span class="hljs-type">const</span> Handle coroutine)</span> : m_coroutine&#123;</span>coroutine&#125;<br>        &#123;<br>        &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        Handle m_coroutine;<br>    &#125;;<br><br>    <span class="hljs-function">Iter <span class="hljs-title">begin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_coroutine)<br>            m_coroutine.<span class="hljs-built_in">resume</span>();<br>        <span class="hljs-keyword">return</span> Iter&#123;m_coroutine&#125;;<br>    &#125;<br><br>    <span class="hljs-function">std::<span class="hljs-type">default_sentinel_t</span> <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;std::integral T&gt;<br><span class="hljs-function">Generator&lt;T&gt; <span class="hljs-title">range</span><span class="hljs-params">(T first, <span class="hljs-type">const</span> T last)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (first &lt; last)<br>        <span class="hljs-keyword">co_yield</span> first++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> i : <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>))<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用C++23实现同样的<ahref="https://en.cppreference.com/w/cpp/coroutine/generator">生成器</a>：</p><blockquote><p>截至<code>gcc (GCC) 13.2.0</code>还未支持&lt;generator&gt;。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 打印26个大写字母</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;generator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br> <br><span class="hljs-function">std::generator&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">letters</span><span class="hljs-params">(<span class="hljs-type">char</span> first)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (;; <span class="hljs-keyword">co_yield</span> first++);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> ch : <span class="hljs-built_in">letters</span>(<span class="hljs-string">&#x27;A&#x27;</span>) | std::views::<span class="hljs-built_in">take</span>(<span class="hljs-number">26</span>))<br>        std::cout &lt;&lt; ch &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>python3中实现同样的生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打印26个大写字母</span><br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">async_generator</span>():<br>    <span class="hljs-comment"># python3中range本身就是一个生成器</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>):<br>        <span class="hljs-keyword">yield</span> <span class="hljs-built_in">chr</span>(i)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> async_generator():<br>        <span class="hljs-built_in">print</span>(value, end=<span class="hljs-string">&quot; &quot;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h1 id="activation-frame">2 Activation Frame</h1><p><strong>activationframe</strong>：保存函数调用的当前状态的内存块。此状态包括传递给函数的参数的值、局部变量的值、返回地址等。对于函数，所有activationframe都具有严格嵌套的生命周期，以允许使用高效的内存分配数据结构来为每个函数调用分配和释放activationframe。这种数据结构通常称为stack，stack上分配的activation frame称为stackframe，大多数CPU架构都有一个专用寄存器用于保存指向stack顶部的指针。</p><p><strong>coroutine activationframe</strong>：由于协程可以在不破坏activationframe的情况下暂停，因此activationframe不能再保证具有严格嵌套的生存期，通常不能使用stack进行分配，可能需要存储在heap上。</p><blockquote><p>C++协程TS（TechnicalSpecification）中有一些规定，如果编译器可以证明协程的生命周期确实严格嵌套在调用方的生命周期内，则允许从调用方的activationframe分配协程的coroutineframe的内存。如果有足够智能的编译器，在许多情况下可以避免heap分配。</p></blockquote><p>对于协程，activationframe的某些部分需要在暂停期间保留，而有些部分只需要在执行时保留。例如，范围不跨越任何协程暂停点的变量的生命周期可能会存储在stack上。可以从逻辑上认为协程的activationframe由两部分组成：<strong>coroutine frame</strong>和<strong>stackframe</strong>。coroutine frame保存协程activationframe的一部分，该部分在协程暂停时持续存在；stackframe部分仅在协程执行时存在，并在协程暂停并将执行转移回调用方/恢复方时释放。</p><p><strong>普通函数</strong>有2个操作：</p><ol type="1"><li><strong>Call</strong>：创建activationframe，暂停函数调用方的执行，将参数和返回地址写入并将执行转移到被调用函数的开头。</li><li><strong>Return</strong>：将返回值传递给调用方，销毁activationframe，在调用点恢复函数调用方的执行。</li></ol><p><strong>协程</strong>有5个操作：</p><ol type="1"><li><p><strong>Call</strong>：创建stackframe，将参数和返回地址写入并将执行转移到协程的开头。协程首先在heap上分配coroutineframe，并将数据从stack frame复制/移动到coroutineframe中，以使其生命周期超出第一个暂停点。</p></li><li><p><strong>Return</strong>：当协程执行返回操作时，它将返回值存储在某处（具体存储位置可以由协程自定义），然后销毁任何作用域内的局部变量（但不包括参数）。协程有机会在将执行转移回调用方/恢复方之前执行一些附加逻辑，如执行某些操作来发布返回值，或恢复另一个正在等待结果的协程，是完全可定制的。最后协程执行Suspend或Destroy操作，根据操作语义将执行转移回调用方/恢复方，将activationframe的stack frame组件从stack中弹出。</p><blockquote><p>返回语句以<code>co_return</code>标识。</p></blockquote></li><li><p><strong>Suspend</strong>：在函数内的当前点暂停协程的执行，并将执行转移回调用方/恢复方，而不破坏activationframe。协程有机会在执行转移回之前执行一些附加逻辑。协程执行暂停后，暂停时作用域内的任何对象仍然生存。</p><blockquote><p>与普通函数的return操作一样，协程只能在协程本身内部的明确定义的暂停点处暂停。</p><p>暂停点通过使用<code>co_await</code>或<code>co_yield</code>关键字来标识。</p></blockquote></li><li><p><strong>Resume</strong>：在协程的暂停点恢复其执行，重新激活协程的activationframe。</p><blockquote><p>在相应暂停操作提供的coroutineframe句柄上调用<code>void resume()</code>方法。</p></blockquote></li><li><p><strong>Destroy</strong>：销毁activationframe而不恢复协程的执行。暂停点范围内的任何对象都将被销毁，用于存储activationframe的内存被释放。</p><blockquote><p>与Resume操作类似，只能在暂停的协程上执行，在相应暂停操作提供的coroutineframe句柄上调用<code>void destroy()</code>方法。</p><p>它不是在最后一个暂停点将执行转移到协程，而是将执行转移到另一个代码路径，在释放coroutineframe的内存之前在暂停点调用作用域内所有局部变量的析构函数。</p></blockquote></li></ol><h1 id="参考资料">参考资料</h1><p>Lewis Baker：</p><p><ahref="https://lewissbaker.github.io/2017/09/25/coroutine-theory">CoroutineTheory</a></p><p><ahref="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">C++Coroutines: Understanding operator co_await</a></p><p><ahref="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">C++Coroutines: Understanding the promise type</a></p><p><ahref="https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer">C++Coroutines: Understanding Symmetric Transfer</a></p><p><ahref="https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform">C++Coroutines: Understanding the Compiler Transform</a></p><p>Šimon Tóth：</p><p><ahref="https://itnext.io/c-20-coroutines-complete-guide-7c3fc08db89d">C++20Coroutines — Complete* Guide</a></p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crash Course in BRDF Implementation【译】</title>
      <link href="//posts/Article/Crash-Course-in-BRDF-Implementation-translation/"/>
      <url>//posts/Article/Crash-Course-in-BRDF-Implementation-translation/</url>
      
        <content type="html"><![CDATA[<p>BRDF实现速成课</p><span id="more"></span><p><a href="https://boksajak.github.io/blog/BRDF">Crash Course in BRDFImplementation</a></p><p>by Jakub Boksansky</p><p class="note note-primary">个人翻译并注释。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-10-Figure_1.jpg" /></p><p><em>图1 使用本博文描述的BRDF的BEEPLEZero-Day场景渲染结果<sup><a class=n href="#ref1">[1]</a></sup>。使用Falcor路径追踪器<sup><a class=n href="#ref2">[2]</a></sup>，每像素两百万条光线。</em></p><h1 id="introduction">1 Introduction</h1><p>创造逼真的材质模型作为计算机图形学研究的一个主题已经有几十年了。多年来已经提出了许多模型——经验模型、基于物理的模型、基于物理表面测量数据的模型。早期的经验模型，例如Phong或Lambertian，在利用有限的计算资源求值的同时提供合理的结果。它们长盛不衰的关键之一是能够合理地再现一系列真实世界的材质，提供直观的参数供美工调整（而不是物理单位）。</p><p>用于有效求解场景中光传输的算法的进步，例如路径追踪、光子映射和其他方法，使我们能够基于光在有大量表面的场景中的多重交互求解复杂材质，同时隐式渲染焦散（caustics）、间接（全局）照明、软阴影等效果。光传输算法负责建立光在场景中传播的路径，材质模型则计算光如何与沿路径的表面相互作用。这种方法的形式模型由著名的渲染方程<sup><a class=n href="#ref3">[3]</a></sup>描述，其中表面上材质的贡献由BRDF给出。</p><blockquote><p>光栅化方法需要显示渲染焦散、间接（全局）照明、软阴影等效果。</p></blockquote><p>本文中，我们将探讨游戏中常用的一些基本BRDF的实现及其背后的理论。许多现有的BRDF代码都经过高度优化，使用了许多近似和技巧，使其难以理解和修改。为了更容易研究现有的实现，我们提供了带有内部工作原理解释和全部已讨论BRDF的推导的代码。我们还将讨论BRDF在间接照明中的使用，例如蒙特卡罗路径追踪，其中需要重要性采样及确保能量守恒。这些通常不在游戏引擎中实现，因为光栅化不需要，但对于使用新兴实时光线追踪的应用程序来说是必需的。</p><h1 id="so-what-is-the-brdf">2 So, what is the BRDF?</h1><p>BRDF描述了给定入射光和出射光方向组合下的表面反射率（reflectance）。换句话说，它决定了当一定量的光从另一个方向入射时，有多少光在给定方向上反射，具体取决于表面的属性。例如，对于漫反射表面，BRDF指定在所有方向上都有少量反射，而对于镜子，所有光都在一个方向上反射。这个公式非常灵活，因为它使我们能够将表面材质的响应封装到BRDF实现及其参数设置中，独立于光传输的底层算法。注意，BRDF不区分直接和间接入射光，意味着它可用于计算场景中放置的虚拟光（局部照明）和从其他表面反射一次或多次的间接光（全局照明）的贡献。这也意味着BRDF独立于光照的实现，可以单独开发和编辑（BRDF只需要知道入射光的方向及其在着色点的强度）。<span class="math display">\[L(P,\omega_o)=L_e+\int_{\Omega} \boldsymbol{f(P,\omega_i,\omega_o)}L_i(P,\omega_i)(\omega_i\cdot\hat{n}_p) d\omega_i\]</span> <em>图2渲染方程，BRDF以粗体高亮标记（这里使用latex公式，非图）</em></p><p>渲染算法和光照的独立性意味着我们可以将这种抽象的BRDF实现为“材质插件”，可以通过简单API访问，并且不同渲染器产生的视觉结果将相同。这导致了受技术美术人员青睐的材质库（如MDL<sup><a class=n href="#ref4">[4]</a></sup>）和通用材质创作工具（如SubstanceDesigner）的出现。材质也可以独立于渲染算法进行研究和开发。</p><p>为了使这种抽象发挥作用，并使BRDF基于物理（逼真），BRDF应遵循以下原则：</p><ul><li><strong>Helmholtz互易性</strong>：入射和出射方向可以交换（因此称为双向），并且所得的反射率相同。注意，某些算法会跟踪来自相机的光线（路径跟踪），某些算法会跟踪来自光源的光线（光子映射），或两者均有（双向路径跟踪）。Helmholtz互易性确保所有类型的算法得到一致的结果。</li><li><strong>能量守恒</strong>：从表面反射的能量应等于接收到的能量（对于具有完美白色反照率（albedo）且无吸收的表面）</li></ul><p>像Phong这样的早期经验模型通常不能满足这些要求，因此不适合真实感渲染。它们也无法正确再现许多材质的行为，如粗糙表面或金属，我们将在稍后更详细地讨论。一旦可编程且足够强大的GPU出现，从经验模型到基于物理模型的转变就会被推动，甚至对于实时渲染也是如此。</p><p>必须指出，一些成功的模型并不满足这些要求。Disney模型<sup><a class=n href="#ref5">[5]</a></sup>不是能量守恒的（但他们的后续文章<sup><a class=n href="#ref6">[6]</a></sup>讨论了以后的项目的能量守恒），Autodesk模型<sup><a class=n href="#ref7">[7]</a></sup>不一定满足Helmholtz互易性。迪士尼模型与单向路径追踪结合使用，缺乏互易性不会带来严重问题。完美的能量守恒也可能不是一个严格的要求，因为除非BRDF反射的能量多于它接收的能量，否则不太可能造成问题，除了能量损失的表面会变暗之外。最后，BRDF实现的高性能和美工的易用性可能比满足BRDF 的所有理论要求更可取，尤其是在渲染内容完全受控时。</p><h2 id="construction-of-brdf">2.1 Construction of BRDF</h2><p>游戏中使用的大多数BRDF由两个BRDF组成：漫反射（diffuse）波瓣和镜面反射（specular）波瓣。这种分解来自这样一个事实：当光与表面相互作用时，部分光被反射走（镜面反射BRDF），其余部分则散射到表面中。在材质内部，会发生更多的次表面散射，部分光最终再次集中表面并以随机方向离开材质（漫反射BRDF）。由于表面内部的散射，这种光被“过滤”并导致物体呈现出某一颜色。这也意味着光可以在表面下传播一段距离，将光带离入口点，从而产生“次表面散射”效果。常见的简化方法是忽略这种现象并将退出点设置为等于进入点。我们不会在本文中详细讨论次表面散射，推荐Pettineo<sup><a class=n href="#ref8">[8]</a></sup>最近发表的一篇博文，该文提供了有关这个主题的精彩总结。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-10-Figure_3.jpg" /></p><p><em>图3分解为漫反射（左）和镜面反射（右）波瓣。BRDF值以蓝色显示，余弦加权BRDF贡献以红色显示（散射能量/离开辐射贡献）。</em></p><p>早在1924年，Pokrowski<sup><a class=n href="#ref9">[9]</a></sup>就在光学文献中讨论了镜面反射和漫反射的分解。注意BRDF值（蓝色）和余弦加权的散射能量（红色）之间的重要区别。余弦项来自渲染方程，将在第3.1节中进一步讨论，但对于详细解释，我们推荐GraphicsCodex<sup><a class=n href="#ref10">[10]</a></sup>中有关材质的章节。</p><p>菲涅尔（Fresnel）方程描述了有多少光反射走（或散射进）材质。在掠射角下入射的光更有可能被反射，产生有时称为“菲涅耳反射”的效果（见图4）。菲涅耳项还负责对金属（metal）和电介质（dielectric）之间的区别进行建模。金属的吸收系数比电介质高得多，这意味着部分本来会反射的光被吸收了。由于这种吸收取决于波长，某些金属（例如金）的反射颜色取决于各个波长的吸收方式，而电介质的反射通常会呈现不变的光源颜色。关于菲涅耳项的更多细节将在4.3节中讨论。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-10-Figure_4.jpg" /></p><p><em>图4 静止水面上的“菲涅尔反射”</em></p><p>注意，由于贡献漫反射BRDF的光已两次穿过材质边界，从技术上讲我们也应该应用菲涅耳项两次，但通常会创建漫反射BRDF来解决此问题。</p><p>我们已经提到，光在离开之前会在表面下传播一段距离，从而产生次表面散射效应。这假设行进的距离相对较短，并且光通过它进入的相同（或非常相似）的表面射出。然而，对于全透明或半透明材质，光可以穿过物体并从另一侧射出。更复杂的是，材质内部和/或粗糙表面的散射会导致光扩散（以随机方向传播，如通过磨砂玻璃、冰……）。透明度和次表面散射都可以使用“体积光传输”方法来渲染，该方法模拟光在体积内的传播方式。这些方法通常代价很高昂，其效果可以使用以下方法来近似：</p><ul><li><strong>BTDF</strong>（Transmittance）：描述光线如何通过表面传输到另一侧（在物体边界上）的函数，由JosStam提出<sup><a class=n href="#ref11">[11]</a></sup>。</li><li><strong>参与介质</strong>（Participatingmedia）：由于光穿过物体而发生的简单消光。</li><li><strong>次表面散射算法</strong>：计算入射光的近似出口点。</li></ul><p>注意，BTDF仅描述表面边界上的透射率，而不描述对象内部的透射率。光仅在进入和离开体积的点处与材质相互作用，就好像网格是空心壳一样（实际上，这就是网格的建模方式），忽略了介质内部可能发生的散射。在这种情况下，必须显式应用可能发生的消光。</p><p>到目前为止，我们已经讨论了BRDF和BTDF来描述光的反射和透射，但文献中还常见一个总称“双向散射分布函数”（BSDF或BxDF），表示BRDF、BTDF、BSSRDF等。</p><p>最后，我们所有的BSDF（镜面反射BRDF、漫反射BRDF和BTDF）必须以有意义的方式组合，最关心的是能量守恒，我们将在5.1节中讨论。</p><h1 id="implementing-simple-brdfs">3 Implementing simple BRDFs</h1><p>本节中，我们将描述众所周知的简单BRDF——Lambertian、Phong等。我们还将定义一个接口，使我们能够实现更复杂的BRDF作为直接替代品。开始前，让我们借助图5定义一些常用的向量。</p><p>向量<spanclass="math inline">\(N\)</span>是给定表面的着色法线（可能来自法线贴图）。向量<spanclass="math inline">\(V\)</span>，视线矢量，指定从着色点到观察者（相机）的方向。更一般地说，它指定出射光方向，在典型的路径追踪器中，这与光线方向相反。矢量<spanclass="math inline">\(L\)</span>指向光源，或者指定入射光线反射的方向（根据上下文）。向量<spanclass="math inline">\(H\)</span>是位于<spanclass="math inline">\(V\)</span>和<spanclass="math inline">\(L\)</span>之间的半向量。它也等于第4节中讨论的微面模型的微表面法线。向量<spanclass="math inline">\(R\)</span>是向量<spanclass="math inline">\(L\)</span>沿法线<spanclass="math inline">\(N\)</span>的完美（镜面）反射方向，向量<spanclass="math inline">\(T\)</span>是三角形平面上垂直于<spanclass="math inline">\(N\)</span>的切线。所有这些向量都被标准化。向量<spanclass="math inline">\(v\)</span>和<spanclass="math inline">\(l\)</span>是<spanclass="math inline">\(V\)</span>和<spanclass="math inline">\(L\)</span>在三角形平面上的投影。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-10-Figure_5.jpg" /></p><p><em>图5 BRDF求值常用的向量</em></p><h2 id="lambertian-diffuse-brdf">3.1 Lambertian diffuse BRDF</h2><p>Lambertian函数是用于漫反射项的最简单的BRDF函数之一，假设入射光在所有可能的方向上均匀散射（在表面法线周围的半球内），但它仍然是许多现实世界材质的行为的良好近似，求解速度非常快。因此，对于次级光弹射（与合适的镜面反射BRDF结合），它可能是一个不错的选择。它也是UE4引擎中使用的默认漫反射BRDF<sup><a class=n href="#ref12">[12]</a></sup>。它不依赖于视线，因此对于涉及带有重投影的时间累积的算法（去噪、TAA等）很友好。对于从第一原理开始的完整推导，Saikia写了一篇很好的文章<sup><a class=n href="#ref13">[13]</a></sup>，在这里我们将从LambertianBRDF的定义开始：</p><blockquote><p>次级光即secondarylight，指来自被直接光照射的物体的散射光。直接光即primary light。</p><p>Saikia文章地址：<ahref="https://sakibsaikia.github.io/graphics/2019/09/10/Deriving-Lambertian-BRDF-From-First-Principles.html">DerivingLambertian BRDF from first principles</a></p></blockquote><p><span class="math display">\[f_{Lambertian}(L,V)=\frac{diffuse\_reflectance}{\pi}\]</span></p><p>计算来自已知方向<spanclass="math inline">\(L\)</span>（例如一个虚拟光源）并向观察者反射的光很直接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">brdfLambertian = (diffuseReflectance / PI) * <span class="hljs-built_in">dot</span>(N, L);<br></code></pre></td></tr></table></figure><p>通过这个，我们实现了BRDF接口的函数，称为<strong>eval</strong>。注意，我们已将余弦项从渲染方程（图2）移至求解函数。这是一种常见的做法，因为在某些情况下，它可以与BRDF中使用的另一个余弦项抵消。此类实现有时被称为“<strong>内置余弦项的BRDF</strong>”，必须注意不要再次应用它。漫反射率（通常用符号<spanclass="math inline">\(\rho\)</span>表示）指定有多少入射光在漫射波瓣中反射，通常根据“基色”（basecolor）参数计算得出，我们将在第4.3.1节中讨论该参数。有时也使用术语反照率（albedo），该术语可能含糊不清，因为反照率（定义为入射光和反射光的比率）可能取决于方向，尽管实践中它通常被指定为法向入射方向。</p><p>另一种常见的优化是将除以常数<spanclass="math inline">\(\pi\)</span>移至预处理步骤，离线预划分漫反射纹理。但是，所有使用基色的函数都必须进行相应调整，其中一些函数可能不包含除以<spanclass="math inline">\(\pi\)</span>的内容。另一种选择是预划分光强度（intensity），但对于光可能来自多次弹射的路径跟踪并不适用。为了让事情不那么混乱，我们在代码示例中的BRDF包含除以<spanclass="math inline">\(\pi\)</span>的内容。关于这个主题的深入讨论可以在Lagarde的文章“toPI or not to PI”中找到<sup><a class=n href="#ref14">[14]</a></sup>。</p><p>目前为止，我们可以使用eval函数计算来自已知方向的光的BRDF贡献。对于大多数光传输算法（如蒙特卡罗路径追踪），需要另一个函数来确定我们应该在哪个方向追踪下一条光线。我们将此函数称为<strong>sample</strong>。它将采用一个随机数作为参数，并返回<strong>新的射线方向</strong>和<strong>概率密度函数(PDF)的值</strong>，后者可以理解为选择该特定方向而不是其他可能方向的可能性。看看PDF在蒙特卡洛估计器中是如何使用的：<span class="math display">\[F=\frac{f(x)}{pdf(x)}\]</span></p><p>将<span class="math inline">\(f(L,V)\)</span>替换为LambertianBRDF得： <span class="math display">\[I=\frac{f_{Lambertian}(L,V)}{pdf(L)}\]</span></p><p><span class="math display">\[I=\frac{\frac{diffuse\_reflectance}{\pi}(N\cdot L)}{pdf(L)}\]</span></p><p>我们将值<spanclass="math inline">\(I\)</span>称为采样权重，将在下一段中介绍它。pdf的值取决于采样方法，并且它的选择可以是任意的，只要当BRDF非零时其PDF为正且非零即可。从最后一个方程可以看出，通过巧妙选择采样函数，它的PDF可以抵消一些BRDF项并简化计算。最基本的采样方法是在<strong>余弦加权半球</strong>中采样，<spanclass="math inline">\(PDF=\frac{N \cdotL}{\pi}\)</span>，这实际上是Lambertian和其他漫反射BRDF的极好选择。该采样方法的代码可以在RayTracing Gems<sup><a class=n href="#ref15">[15]</a></sup>的 SamplingTransformationsZoo中找到，并在我们的代码示例中使用。这些方法通常通过在圆盘（disk）中生成一个随机点（通过扭曲两个随机数将正方形变形为圆盘）并将该点向上投影到半球上（仅通过计算Z分量）来工作。</p><p>为了展示PDF和BRDF项如何相互抵消，用余弦加权PDF代替得： <spanclass="math display">\[I=\frac{\frac{diffuse\_reflectance}{\pi}(N\cdot L)}{\frac{N \cdotL}{\pi}}\]</span></p><p><span class="math display">\[I=diffuse\_reflectance\]</span></p><p>现在可以看出将余弦项从渲染方程移至BRDF求解中如何使其与<spanclass="math inline">\(\pi\)</span>一起被PDF抵消，以使最终方程中仅保留反射率。当使用蒙特卡罗积分时，例如在路径追踪中，该值很有用，我们将其称为采样权重。当光线击中表面时，我们根据BRDF对反射光线的方向进行采样，该光线可以“携带”的光量必须通过该权重进行调整，以考虑表面的材质属性。</p><p>这种用与BRDF紧密匹配的PDF构建采样函数的方法不仅简化了代码，而且还减少了蒙特卡洛估计器的方差（噪声），因此是BRDF实现的一个重要方面。这种方法的一个很好的例子是使用VNDF（可见法线分布）进行采样，将在4.4节中讨论。</p><p>使用这些，我们现在创建了一个称为<strong>evalIndirect</strong>的优化函数，它将eval和sample组合成一个函数，返回采样方向及其权重。注意，它还消除了真实PDF的计算，这对于某些算法（例如多重重要性采样）仍然有用。为了解决这个问题，我们引入了名为<strong>pdf</strong>的新方法，它只返回采样给定方向的PDF。为了验证我们优化的evalIndirect返回的结果是否与sample和pdf一致，我们总是可以通过显式调用eval和pdf来实现evalIndirect，并检查值<spanclass="math inline">\(\frac{eval}{pdf}\)</span>是否等于优化的evalIndirect函数的采样权重。</p><p>这4个函数定义了任何BRDF的接口，因此我们可以通过实现这些函数轻松实现不同的材质类型，并为不同的光传输算法重用代码。总结如下：</p><ul><li><strong>eval</strong>：对于已知的入射和出射方向求解BRDF</li><li><strong>sample</strong>：采样BRDF以返回新的出射光线方向</li><li><strong>pdf</strong>：返回采样给定出射方向的PDF值</li><li><strong>evalIndirect</strong>：组合这些函数到一个优化版本中</li></ul><h2 id="phong-reflection-model">3.2 Phong Reflection Model</h2><p>过去常与Lambertian一起使用的另一种流行的反射模型由Phong提出<sup><a class=n href="#ref16">[16]</a></sup>，为实时渲染（他将其定义为&gt;30FPS的渲染）提供了计算成本低廉的镜面反射高光。<strong>不要将Phong反射模型和Phong着色相混淆</strong>——Phong着色是一种用于实现平滑镜面反射高光的法线插值方法。虽然Phong最初的论文指出，他的反射模型是基于物理的（通过观察真实材质得到），但按照今天的标准它并不是基于物理的，因为它缺乏非镜面反射峰值（off-specularpeak）、菲涅耳反射等现象。它的公式实现起来很简单（注意<spanclass="math inline">\((N \cdotL)\)</span>是按照与Lambertian相同的方式添加到代码中的术语）：</p><p><span class="math display">\[f_{Phong}(L,V)=specular\_reflectance(R\cdot V)^{shininess}\]</span></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">brdfPhong = specularReflectance * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">dot</span>(R, V), shininess) * <span class="hljs-built_in">dot</span>(N, L);<br></code></pre></td></tr></table></figure><blockquote><p>Phong着色为逐像素计算光照，Gouraud着色为逐顶点计算光照。</p></blockquote><p>高光的宽度由指数（通常称为shininess或shine）控制，这是一个无界参数，但通常将其范围限制在10000左右。为了求解Phong模型，我们必须计算向量<spanclass="math inline">\(R\)</span>(向量<spanclass="math inline">\(L\)</span>沿法线反射），但正如Blinn在其优化版本<sup><a class=n href="#ref17">[17]</a></sup>中所示，可以使用半向量<spanclass="math inline">\(H\)</span>代替。为了在我们的代码中实现sample函数，我们使用了RayTracing Gems<sup><a class=n href="#ref15">[15]</a></sup>中的方法。</p><blockquote><p>Phong指数的典型取值：</p><p>10——"eggshell"</p><p>100——mildly shiny</p><p>1000——really glossy</p><p>10,000——nearly mirror-like</p><p>来自图形学虎书第五版</p></blockquote><p>由于它既不能量守恒也不互易，因此将其称为这种形式的称为“PhongBRDF”在技术上是不正确的，但是，已经有人尝试修复这些缺陷并使其适合路径跟踪。Lafortune<sup><a class=n href="#ref18">[18]</a></sup>和Lawrence<sup><a class=n href="#ref19">[19]</a></sup>的文章展示了此类解决方案，包括重要性采样。人们已经创建了各种归一化项来使Phong模型能量守恒（例如，参见Giesen的文章<sup><a class=n href="#ref20">[20]</a></sup>）。Blinn推出了一个优化版本<sup><a class=n href="#ref17">[17]</a></sup>，并将Phong的镜面反射高光与Lambertian漫反射和恒定环境（ambient）项相结合，创建了Blinn-Phong反射模型，该模型成为实时应用程序的标准，直到被更先进的基于物理的模型所取代。目前，大多数已过时的旨在解释间接照明的环境项已被基于图像的照明、实时光线追踪或类似方法所取代。</p><p>Ashikhmin和Shirley<sup><a class=n href="#ref21">[21]</a></sup>提出了基于Phong反射的最全面的模型之一，其特点是能量守恒的互易BRDF、各向异性反射，并与合适的漫反射BRDF和重要采样方法相结合。最近，Goanda<sup><a class=n href="#ref22">[22]</a></sup>提出了另一种基于Phong的模型，该模型为了低计算成本进行了高度优化。Gotanda后来还推出了他的模型的改进分层版本<sup><a class=n href="#ref23">[23]</a></sup>。</p><h2 id="oren-nayar-diffuse-reflectance-model">3.3 Oren-Nayar DiffuseReflectance Model</h2><p>Oren和Nayar<sup><a class=n href="#ref24">[24]</a></sup>提出了更先进的漫反射模型，该模型考虑了表面粗糙度。他们的模型基于这样的观察：当视线方向接近入射光方向时，粗糙表面反射的光比Lambertian模型预测的要多（这种效应称为反向散射（backscattering），这种非Lambertian表面的一个例子是月球）。Oren-Nayar模型通过推广朗伯模型并使其对表面粗糙度和视线方向敏感来解释这种现象。它是使用微面（microfacet）理论推导出来的，就和下一节将讨论的基于物理的镜面反射模型一样。</p><p>注意，当该模型与镜面反射BRDF结合使用时，底层的微面模型和分布函数可能不同（Oren-Nayar使用具有高斯斜率分布（Gaussiandistribution ofslopes）的V-cavity模型），并且粗糙度参数可能需要从一个到另一个转换或重新映射到合理的范围。由于Oren-Nayar模型中的粗糙度（表示为<spanclass="math inline">\(\sigma\)</span>）被定义为微面方向角的标准差，因此以角度单位指定。Lagarde关于Frostbite<sup><a class=n href="#ref25">[25]</a></sup>的文章中的附录B建议的将Beckmann粗糙度和OrenNayar粗糙度之间的转换为：</p><p><span class="math display">\[roughness_{OrenNayar}=\frac{1}{\sqrt{2}}\arctan(roughness_{Beckmann})\]</span>Oren和Nayar提出了他们模型的几个版本，并进行了不同程度的简化。本文附带的代码使用最简单的“定性(qualitative)”模型：<span class="math display">\[f_{OrenNayar}(L,V)=\frac{diffuse\_refelctance}{\pi}(N \cdotL)(A+B\max(0,\cos(\varphi_v-\varphi_l))\sin\alpha\tan\beta)\]</span></p><p><span class="math display">\[A=1.0-0.5\frac{\sigma^2}{\sigma^2+0.33};B=0.45\frac{\sigma^2}{\sigma^2+0.09};\alpha=\max(\theta_l,\theta_v);\beta=\min(\theta_l,\theta_v)\]</span></p><p><span class="math inline">\(\theta_l\)</span>和<spanclass="math inline">\(\theta_v\)</span>是<spanclass="math inline">\(N\)</span>和<spanclass="math inline">\(L\)</span>、<spanclass="math inline">\(V\)</span>之间的角，<spanclass="math inline">\(\varphi_v\)</span>和<spanclass="math inline">\(\varphi_l\)</span>是这些向量之间的方位角（azimuth）（它们在法线定义的平面上的投影之间的角度）。我们的代码示例计算这些向量到法线平面的投影以获得正确的角度，但优化版本也消除了一些三角函数的使用（以平方根为代价），可以在PBR<sup><a class=n href="#ref26">[26]</a></sup>中找到。</p><h2 id="disney-burley-diffuse-model">3.4 Disney (Burley) DiffuseModel</h2><p>另一种流行且广泛使用的模型是Disney漫反射<sup><a class=n href="#ref5">[5]</a></sup>，有时也称为Burley漫反射。它是通过观察测量数据得出的经验模型，包括依赖于粗糙度的掠射逆反射（grazingretroreflection）现象。在这方面，它类似于OrenNayar模型，但计算起来更简单。它基于Schlick的菲涅尔近似公式（参见第 4.3节），并扩展了基本Lambertian模型，以根据粗糙度在指定范围（0.5到2.5）内增加或减少掠射角的反射率：<span class="math display">\[F_{D90}=0.5+2\ roughness\ \cos^2\theta_d\]</span></p><p><span class="math display">\[f_{Disney}(L,V)=\frac{diffuse\_refelctance}{\pi}(1+(F_{D90}-1)(1-\cos\theta_l)^5)(1+(F_{D90}-1)(1-\cos\theta_v)^5)\]</span></p><p>由于该模型不是使用微面理论推导出的（与Oren-Nayar模型不同），此粗糙度参数没有与微面法线的统计分布相同的含义，并且可能与镜面反射BRDF使用的粗糙度不兼容。Burley的论文建议将粗糙度重新映射为镜面反射BRDF粗糙度 (<spanclass="math inline">\(\alpha\)</span>)，如下所示： <spanclass="math display">\[\alpha=roughness^2\]</span>此外，该模型能量不守恒，在能量守恒很重要的渲染器中使用可能会出现问题（如路径跟踪）。Lagarde在他关于Frostbite引擎渲染的优秀文章<sup><a class=n href="#ref25">[25]</a></sup>中描述了该模型的一个版本，该版本显著提高了能量守恒，确保反射的能量不会多于与基于GGX的镜面反射BRDF结合时接收到的能量。</p><h2 id="more-diffuse-brdfs">3.5 More diffuse BRDFs</h2><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-10-Figure_6.jpg" /></p><p><em>图6 细微的差别。粗糙物体（粗糙度 =0.5）上的漫反射BRDF的比较。从左到右：Lambertian、Oren-Nayar、Disneydiffuse、Frostbite diffuse。</em></p><p>本文未涉及的另一种值得研究的漫反射BRDF是Hanrahan-Krueger<sup><a class=n href="#ref27">[27]</a></sup>和Heitz-Dupuy<sup><a class=n href="#ref28f">[28]</a></sup>提出的。一个有趣的研究方向是寻找与广泛使用的基于GGX的微面BRDF良好结合的漫反射模型，以实现能量守恒和合理的视觉结果，例如Gotanda<sup><a class=n href="#ref29">[29]</a></sup>的工作中发现的模型。</p><h1 id="microfacet-model">4 Microfacet Model</h1><p>最近的许多BRDF都是基于微面理论的，该理论最初是在光学文献中提出，并在Blinn<sup><a class=n href="#ref17">[17]</a></sup>以及Cook和Torrance<sup><a class=n href="#ref30">[30]</a></sup>的文章中引入到图形社区。微面模型的动机是为了更好地理解和模拟来自粗糙表面的光反射，如测量所示，这与简单的Lambertian和菲涅尔反射预测的结果不匹配。例如，微面理论解释了称为非镜面峰值的现象，当偏离完美反射方向的方向达到最大反射率时，就会发生这种现象，如Torrance和Sparrow<sup><a class=n href="#ref31">[31]</a></sup>所讨论的。</p><p>使用微面模型的BRDF通常被称为基于物理的，以表明它们是根据物理定律（光学）设计的，而不是根据观察经验进行设计的，尽管在计算机图形学中，我们经常使用简化和近似来使计算可行，并通过消除物理单位和参数使BRDF更加实用。</p><p>这种简化的一个很好的例子是省略菲涅耳方程中使用的复杂折射率（index ofrefraction）。有时，“物理合理”一词也用于描述行为与观察到的现实世界材质相同的模型，但不一定是使用光学定律导出的。对于实时渲染，我们通常还使用几何光学和RGB三元组来表示光，而不是波动光学和光谱分布。权衡是此类渲染器无法考虑薄膜干涉引起的衍射和光偏振等效应。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-10-Figure_7.jpg" /></p><p><em>图7由许多<strong>微面</strong>（microfacet）组成的<strong>微表面</strong>（microsurface）（蓝色）。显示了一些选定微面的微表面法线<spanclass="math inline">\(H\)</span>（红色）。几何表面及其法线<spanclass="math inline">\(N\)</span>用灰色突出显示。注意，根据微表面模型，微表面本身不需要像该图像上的示例那样是连续的。</em></p><p>微面理论将表面建模为具有不同坡度和高度的微面的集合（见图7）。微面变化的程度和方式由微面分布函数<spanclass="math inline">\(D\)</span>描述（通常取决于粗糙度参数来控制表面外观）。这赋予了BRDF其形状，从而影响材质的最终外观。</p><p>通常，单个微面被假设为完美镜面，但任何BSDF也可以用于微面。注意，仅对几何表面进行建模，并且使用微面模型计算微面的效果，因此我们仅观察它们的聚合效果<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="但是Heitz发表了一篇有趣的论文，该论文以程序方式生成Beckmann分布表面的网格以用于研究目的[71]">[1]</span></a></sup>。</p><p>微面模型反射项定义为<sup><a class=n href="#ref30">[30]</a></sup><sup><a class=n href="#ref31">[31]</a></sup><sup><a class=n href="#ref32">[32]</a></sup>：<span class="math display">\[R=\frac{F(L,H)G(L,V,H)D(H)}{4(N \cdot L)(N \cdot V)}\]</span> &gt; 勘误：<spanclass="math inline">\(F(L,H)\)</span>应为<spanclass="math inline">\(F(V,H)\)</span>。</p><p>其中<span class="math inline">\(N\)</span>是着色法线，<spanclass="math inline">\(H\)</span>是指向<spanclass="math inline">\(L\)</span>和<spanclass="math inline">\(V\)</span>之间方向的半向量（<spanclass="math inline">\(H=\|L+V\|\)</span>）。它也称为微表面法线、高光向量或半程向量，之前被Blinn<sup><a class=n href="#ref17">[17]</a></sup>用于优化Phong着色计算。使用半向量的公式很方便，因为它也可以用于折射，如Walter<sup><a class=n href="#ref32">[32]</a></sup>所描述的，以及通过生成与给定正态分布函数<spanclass="math inline">\(D\)</span>相对应的半向量来进行重要性采样，我们将在稍后讨论。所有这些术语将在下面的部分中更详细地讨论，这里只是一个简短的总结：</p><ul><li><strong>DTerm</strong>：微面分布函数——告诉我们有多少微面面向方向<spanclass="math inline">\(H\)</span>，以便从方向<spanclass="math inline">\(L\)</span>入射的光沿方向<spanclass="math inline">\(V\)</span>反射。</li><li><strong>FTerm</strong>：菲涅耳项，计算给定入射角下从表面反射的光量。</li><li><strong>G Term</strong>：几何衰减项（即本文后面的掩蔽和阴影（maskingand shadowing ）项<span class="math inline">\(G_2\)</span>），解释了微面的相互阴影（和掩蔽），有时也用于BRDF的归一化。</li><li><strong>Denominator</strong>：来自使用完美镜面作为微面的微面模型的推导。注意，Cook和Torrance的原始论文<sup><a class=n href="#ref30">[30]</a></sup>在分母中使用常数<spanclass="math inline">\(\pi\)</span>而不是4。Walter指出<sup><a class=n href="#ref32">[32]</a></sup>这是由于<spanclass="math inline">\(D\)</span>项的不同归一化造成的，并且最近的文献都同意使用常数4。</li></ul><h2 id="distribution-term">4.1 Distribution Term</h2><p>分布项<span class="math inline">\(D\)</span>使用微面normaldistribution function (NDF)，该函数计算微面的哪些部分面向方向<spanclass="math inline">\(H\)</span>，以便从方向<spanclass="math inline">\(L\)</span>入射的光沿方向<spanclass="math inline">\(V\)</span>反射。换句话说，假设各个微面之间没有发生遮挡，给定的<spanclass="math inline">\(L\)</span>和<spanclass="math inline">\(V\)</span>方向之间可以反射多少光（下面讨论）。NDF不应与正态（即高斯）分布混淆，尽管它是NDF的可能实现之一（例如，由Torrance和Sparrow<sup><a class=n href="#ref31">[31]</a></sup>使用）。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-10-Figure_8.png" /></p><p><em>图8 GG-X分布的“Longer tail”，alpha值设为0.4。</em></p><p>在文献中可以找到各种分布函数。BeckmannNDF是广泛应用于光学领域的一个例子，也广泛应用于计算机图形学领域。Beckmann分布使用指定为微面均方根(RMS)斜率的直观粗糙度参数来控制其形状。另一个重要的NDF是由Trowbridge和Reitz提出的<sup><a class=n href="#ref33">[33]</a></sup>，并由Blinn于1977年推荐<sup><a class=n href="#ref17">[17]</a></sup>。后来Walter将其重新推导为GG-X<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="GG-X可能是“Ground Glass - roughness unknown”的缩写[72]，以用于光学测量的抛光至一定粗糙度的磨砂玻璃板命名。">[2]</span></a></sup><sup><a class=n href="#ref32">[32]</a></sup>。虽然Trowbridge-Reitz分布与GG-X相同并且早于它，我们将在本文中使用更简单的GG-X公式。与BeckmannNDF相比，它提供的镜面波瓣形状具有“Longertail”，这意味着镜面反射峰值的衰减更慢，如图8所示。这与许多测量的真实世界材质更接近，因此GG-X在游戏中广泛使用，但Pixar描述着色的论文<sup><a class=n href="#ref34">[34]</a></sup>中提到Beckmann分布仍然被使用。应该指出的是，由于图形社区贡献的许多优化和近似，GG-X的求解代价更小。</p><p>Beckmann分布定义为： <span class="math display">\[D_{Beckmann}=\frac{e^{\frac{-\tan^2(\theta_h)}{\alpha^2}}}{\pi\alpha^2\cos^4\theta_h}\]</span> <spanclass="math inline">\(\theta_h\)</span>是法线和半向量的夹角，<spanclass="math inline">\(\alpha\)</span>是粗糙度。<spanclass="math inline">\(\alpha\)</span>和微面的RMS斜率<spanclass="math inline">\(\sigma\)</span>的关系是：<spanclass="math inline">\(\alpha=\sqrt{2\sigma}\)</span><sup><a class=n href="#ref26">[26]</a></sup>。作为一个优化，我们可以使用Hoffman的文章<sup><a class=n href="#ref35">[35]</a></sup>中提出的等价<spanclass="math inline">\(\tan^2(\theta_h)=\frac{1-cos^2\theta_h}{cos^2\theta_h}\)</span>来消去正切函数，其中我们使用方便易得的<spanclass="math inline">\(\theta_h\)</span>的余弦，通过<spanclass="math inline">\(N \cdot H\)</span>就可计算： <spanclass="math display">\[D_{Beckmann}=\frac{e^{\frac{\cos^2\theta_h-1}{\alpha^2\cos^2\theta_h}}}{\pi\alpha^2\cos^4\theta_h}\]</span> GG-X分布定义为： <span class="math display">\[D_{GGX}=\frac{\alpha^2}{\pi\cos^4\theta_h(\alpha^2+tan^2(\theta_h))^2}\]</span>该公式还可以进一步简化<sup><a class=n href="#ref35">[35]</a></sup>。我们以与Beckmann分布相同的方式替换正切函数，并展开分母，然后可以将其表示为<spanclass="math inline">\(((\alpha^2-1)\cos^2\theta_h+1)\)</span>平方。得到的优化公式为：<span class="math display">\[D_{GGX}=\frac{\alpha^2}{\pi((\alpha^2-1)\cos^2\theta_h+1)^2}\]</span> 还有一个由Blinn使用Phong反射模型导出的NDF（称为Blinn-PhongNDF）<sup><a class=n href="#ref17">[17]</a></sup>，并且在 Walter的论文<sup><a class=n href="#ref32">[32]</a></sup>中也进行了讨论，他得出的结论是，对于某些粗糙度值，Beckmann和Blinn-Phong分布非常相似。这可以解释Phong着色模型的经久不衰，因为它能够准确地表示某些材质（尤其是塑料）。Walter的论文<sup><a class=n href="#ref32">[32]</a></sup>中还提供了Beckmann粗糙度和Phong指数之间的近似转换公式（该论文还表明，对于0.2左右的粗糙度值，Phong分布与Beckmann分布几乎相同）。今天它可能看起来已经过时，但在加载使用Phong指数的材质的旧模型时（如流行的OBJ格式）可能会很方便。<span class="math display">\[shininess=\frac{2}{\alpha^2}-2\]</span></p><p><span class="math display">\[\alpha=\sqrt{\frac{2}{shininess+2}}\]</span></p><p>正如我们所看到的，每个模型的粗糙度单位可能有很大不同。Torrance和Sparrow以及Oren-Nayar模型直接使用正态分布的标准差，Beckmann和Trowbridge-Reitz使用斜率的统计均方根，而Burley使用在合理范围内根据经验选择的值。当多个BRDF耦合在一起时（通常是镜面反射和漫反射BRDF），将美工指定的粗糙度仔细转换为底层BRDF使用的粗糙度单位非常重要。这种转换的一个很好的例子可以在Disney的PrincipledBRDF<sup><a class=n href="#ref5">[5]</a></sup>中找到。正如已经提到的，他们将粗糙度参数重新映射到用于镜面反射BRDF的<spanclass="math inline">\(\alpha\)</span>作为该值的平方。这使得粗糙度的变化在感知上呈线性，并且与底层漫反射BRDF兼容，但在计算<spanclass="math inline">\(D\)</span>和<spanclass="math inline">\(G\)</span>项时必须注意再次对<spanclass="math inline">\(\alpha\)</span>值进行平方（参见上面的公式）。或者，可以单独指定每个BRDF的粗糙度以实现更多的美术控制。</p><h2 id="geometric-attenuation-term">4.2 Geometric Attenuation Term</h2><p>几何衰减项𝐺解释了由于微表面的几何形状导致的反射光衰减（attenuation），这种衰减是在某些微面相互遮挡时发生的。它有时也用作BRDF的归一化项。正如Torrance和Sparrow<sup><a class=n href="#ref31">[31]</a></sup>所指出的，<spanclass="math inline">\(G\)</span>项抵消了菲涅尔项，并且导致了某些粗糙度的材质当菲涅尔预测的高反射率因<spanclass="math inline">\(G\)</span>项在掠射角处造成的显著阴影而减弱时出现的“非镜面峰值”，在更低角度处出现峰值反射率。</p><p>微表面的几何形状由用于建模其形状的轮廓（profile）给出。已经有两种重要的微表面轮廓：V-Cavity模型，假设微表面由一定宽度和高度的V形凹槽组成，以及基于斜率随机分布的Smith模型<sup><a class=n href="#ref36">[36]</a></sup>。Cook-Torrance和Oren-Nayar在他们的BRDF中使用了V-Cavity模型，但正如Heitz的一篇文章<sup><a class=n href="#ref37">[37]</a></sup>所示，Smith函数是使用这两个的正确模型，因此，本文中我们将只讨论Smith的<spanclass="math inline">\(G\)</span>函数，定义为： <spanclass="math display">\[G_1(H,S)=\frac{1}{1+\lambda(a)}\]</span></p><p><span class="math display">\[a=\frac{(H \cdot S)}{\alpha\sqrt{1-(H \cdot S)^2}}\]</span></p><p><span class="math inline">\(S\)</span>是<spanclass="math inline">\(L\)</span>或者<spanclass="math inline">\(V\)</span>向量，<spanclass="math inline">\(H\)</span>是微面法线，<spanclass="math inline">\(\lambda\)</span>是特定于所选NDF的函数。由给定NDF推导<spanclass="math inline">\(\lambda\)</span>的过程在Brown的论文<sup><a class=n href="#ref38">[38]</a></sup>中描述，Walter<sup><a class=n href="#ref32">[32]</a></sup>和Heitz<sup><a class=n href="#ref37">[37]</a></sup>的论文中展示了各种NDF（Beckmann，GG-X，Blinn-Phong）的<spanclass="math inline">\(\lambda\)</span>函数（和优化后的<spanclass="math inline">\(G_1\)</span>项）： <span class="math display">\[\lambda_{GGX}(a)=\frac{-1+\sqrt{1+\frac{1}{a^2}}}{2}\]</span></p><p><span class="math display">\[\lambda_{Beckmann}(a)=\begin{cases}  &amp; \frac{1-1.259a+0.396a^2}{3.535a+2.181a^2} &amp;,where\ a&lt;1.6\\  &amp; 0&amp;, where\ a\ge 1.6\end{cases}\]</span></p><p>在这里，我们展示了Walter<sup><a class=n href="#ref32">[32]</a></sup>导出的<spanclass="math inline">\(\lambda_{Beckmann}\)</span>的有理逼近，而不是需要高昂计算误差函数的原始函数。通过将<spanclass="math inline">\(\lambda\)</span>函数替换为通用<spanclass="math inline">\(G_1\)</span>公式并简化表达式，可以针对特定NDF优化<spanclass="math inline">\(G_1\)</span>的评估，如我们的代码示例中所做的那样。</p><p>Schlick<sup><a class=n href="#ref39">[39]</a></sup>提出了Beckmann分布的另一种常见有理近似，同一篇论文中出现了著名的Schlick菲涅尔近似。然而，他近似了不同版本的Smith<spanclass="math inline">\(G\)</span>函数<sup><a class=n href="#ref32">[32]</a></sup><sup><a class=n href="#ref35">[35]</a></sup><sup><a class=n href="#ref37">[37]</a></sup>，并不适合微面BRDF。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-10-Figure_9.jpg" /></p><p><em>图9当入射光被<strong>微表面</strong>（microsurface）（蓝色）上的其他<strong>微面</strong>（microfacet）阻挡时，就会出现<strong>阴影</strong>（shadowing）（左）。当反射光被另一微面阻挡时发生<strong>掩蔽</strong>（masking）（右）。</em></p><p>发生几何衰减是因为许多微面可以以某种方式定向以反射给定方向下入射的光，但最终只有最接近光源的微面成功反射光（其他微面被阴影，如图9所示）。这同样适用于反射光，反射光在离开微表面时可能会被其他微面掩蔽。Smith的<spanclass="math inline">\(G_1\)</span>函数可用于阴影<spanclass="math inline">\(G_1(H,L)\)</span>和掩蔽<spanclass="math inline">\(G_1(H,V)\)</span>，它们组合出掩蔽-阴影函数： <spanclass="math display">\[G_2=G_1(H,L)*G_1(H,V)\]</span>此组合公式假设遮蔽和阴影不相关，然而这是不准确的，因为微表面中更深的面被同时遮蔽和阴影的概率更高。这可以通过使用史密斯掩蔽-阴影函数的高度相关（height-correlated）形式解决：<span class="math display">\[G_2=\frac{1}{1+G_1(H,L)+G_1(H,V)}\]</span> 任一形式的<spanclass="math inline">\(G_2\)</span>都可以用于前面介绍的微面模型反射公式中的<spanclass="math inline">\(G\)</span>项，但相关版本更可取，因为它只是稍微费一点计算并且更准确。Lagarde<sup><a class=n href="#ref25">[25]</a></sup>的工作中可以找到GG-X分布的高度相关<spanclass="math inline">\(G_2\)</span>的显著优化实现。通过将GG-X分布的<spanclass="math inline">\(G_1\)</span>项代入的公式并化简，我们得到的表达式包含可以方便地与微面模型的分母相抵消的项，从而使计算成本更低。Hammon<sup><a class=n href="#ref40">[40]</a></sup>提出了GG-X的另一个有趣的高度相关<spanclass="math inline">\(G_2\)</span>近似，它的计算速度非常快，但会引入一些误差。对于Beckmann分布，我们的代码示例不提供此类优化而是直接计算所有项。</p><p>由于<spanclass="math inline">\(G\)</span>项有效地指定了可见微面的比例，因此组合NDF和<spanclass="math inline">\(G_1\)</span>项（<span class="math inline">\(D\cdotG_1\)</span>）给出了可见法线的分布<sup><a class=n href="#ref41">[41]</a></sup>，这是我们稍后将讨论的高效采样例程的基础。</p><p>到目前为止，我们假设被阴影或遮蔽的光会丢失，即使对于具有完全光滑微面的简化模型来说也是不正确的。这就是基于微面的BRDF发生能量损失的地方，不幸的是，微面之间的多重散射建模非常复杂且计算成本高昂，在实时渲染中通常被忽略。Heitz的论文<sup><a class=n href="#ref42">[42]</a></sup>、d’Eon的Hitchhiker’sGuide<sup><a class=n href="#ref43">[43]</a></sup>以及Imageworks使用的技术<sup><a class=n href="#ref44">[44]</a></sup>（也在RTR<sup><a class=n href="#ref45">[45]</a></sup>中进行了讨论）详细介绍了该主题。</p><h3 id="anisotropic-materials">4.2.1 Anisotropic materials</h3><p>表现出各向异性反射的材质（例如拉丝金属）可以使用NDF的各向异性版本及其相应的几何项进行建模。关于这个主题的深入讨论可以在Heitz<sup><a class=n href="#ref37">[37]</a></sup>和Ward<sup><a class=n href="#ref46">[46]</a></sup>的论文中找到。这些函数的计算通常比较复杂，并且由二元粗糙度值（两个垂直方向的不同粗糙度）控制。必须在切线空间中进行计算，以确保整个网格上各向异性镜面高光的方向正确且一致。关于DisneyPrincipledBRDF的文章<sup><a class=n href="#ref5">[5]</a></sup>展示了使用附加的各向异性参数的直观参数化（在文章最新版本的附录中）。这与标准粗糙度参数结合使用来计算合理范围内的2D粗糙度。</p><p>PBR第543页<sup><a class=n href="#ref26">[26]</a></sup>中建议的更简单的解决方案是仍然使用NDF和<spanclass="math inline">\(G\)</span>项的各向同性版本，但根据各向异性高光发生的方向调整粗糙度值。</p><h2 id="fresnel-term">4.3 Fresnel Term</h2><p>菲涅耳项<spanclass="math inline">\(F\)</span>决定了有多少光将从表面反射，有效地告诉我们有多少光将用于计算BRDF。剩余部分<spanclass="math inline">\(1-F\)</span>将传递到底层材质层（如漫反射BRDF或透射BTDF）。到目前为止，我们的实现仅讨论了两层（镜面反射和漫反射），但可以创建具有多个层的复杂材质。菲涅耳项应在光从一层传播到另一层的每个界面上进行计算。为简单起见，各个层的厚度通常为零，但可以结合光谱渲染对一些厚度进行建模，当层界面比穿过它的光的波长薄时产生衍射（diffraction）（虹彩（iridescence））等效果。为了进一步讨论分层材质，我们推荐Autodesk的文章<sup><a class=n href="#ref7">[7]</a></sup>和Jakob等人<sup><a class=n href="#ref47">[47]</a></sup>、Weidlich和Wilkie<sup><a class=n href="#ref48">[48]</a></sup>的作品。对于实现虹彩，Belcour和Parla最近发表的论文很有趣<sup><a class=n href="#ref49">[49]</a></sup>。</p><p>菲涅耳项取决于视线方向、表面法线、材料属性（折射率和消光系数），并由相对复杂的菲涅耳方程表示，但该方程也考虑了光的偏振。菲涅耳项对于掠射角始终接近统一，这意味着所有光都会被反射，尽管对于中间角度，如Cook和Torrance<sup><a class=n href="#ref30">[30]</a></sup>所讨论的那样，会发生“colorshift”。</p><p>ChristopheSchlick引入了一种广泛使用的菲涅尔近似值，用于计算机图形学<sup><a class=n href="#ref39">[39]</a></sup>。正如他指出的那样，完整的菲涅尔方程不仅计算成本昂贵，而且依赖于不直观的折射率<spanclass="math inline">\(n\)</span>和消光<spanclass="math inline">\(k\)</span>，这不符合我们对可预测且易用的参数的需求。更复杂的是，完整的折射率是一个由实部（折射率）和虚部（消光系数）组成的复数，并且是按波长指定的。这不适合使用RGB三元组进行渲染。NatyHoffman题为“被认为有害的菲涅尔方程”的文章<sup><a class=n href="#ref50">[50]</a></sup>对该主题进行了进一步讨论，并得出结论除非使用光谱渲染完整的菲涅尔方程并不比Schlick近似更精确。</p><p>Schlick近似使用这样的观察结果：在90度下观察时，所有材质都表现出完美的反射率，并且我们可以仅使用一个参数——法线入射（0度——<spanclass="math inline">\(F_0\)</span>）下的表面反射率来近似完整的菲涅尔方程：</p><p><span class="math display">\[F=F_0+(F_{90}-F_0)*(1-u^5)\]</span> 其中<spanclass="math inline">\(u\)</span>是法线与视线方向之间角度的余弦 （<spanclass="math inline">\(u=N \cdot V\)</span>），并且<spanclass="math inline">\(F_{90}\)</span>等于1，除了下节讨论的情况。注意，折射率和消光系数已被去掉，但我们现在需要指定法线入射时的反射率<spanclass="math inline">\(F_{0}\)</span>。使用Schlick公式的另一个结果是着色无法解释光的偏振。Mojzik等人在该领域完成了一项有趣的工作<sup><a class=n href="#ref51">[51]</a></sup>。</p><h3 id="specifying-reflectance-at-normal-incidence">4.3.1 Specifyingreflectance at normal incidence</h3><p>消除<span class="math inline">\(n\)</span>和<spanclass="math inline">\(k\)</span>简化了计算，但也导致失去对材质是否表现为电介质（低吸收系数——塑料、木材等）或导体（高吸收系数——铜、金等）的控制。这些之间的差异最好通过金属反射的色调（colortint）来观察（因为部分光谱被吸收），而电介质的反射则接手光源的不变颜色。正如Cook和Torrance<sup><a class=n href="#ref30">[30]</a></sup>所指出的，金属反射是根据法线入射（表示为<spanclass="math inline">\(F_{0}\)</span>，有时也表示为<spanclass="math inline">\(R_{F0}\)</span>）的材质的基色着色的。利用这些知识，我们可以通过引入一个称为金属度<sup><a class=n href="#ref52">[52]</a></sup>（metalness）的参数来“修复”金属菲涅尔反射的颜色，该参数将<spanclass="math inline">\(F_{0}\)</span>作为电介质的默认反射率和金属的基色之间的混合计算<sup><a class=n href="#ref53">[53]</a></sup>：<span class="math display">\[F_0=lerp(F_{0Dielectricss},base\_color,metalness)\]</span> <spanclass="math inline">\(F_{0Dielectricss}\)</span>的一个常用值是0.04（4%反射率），UE4<sup><a class=n href="#ref12">[12]</a></sup>和Frostbite<sup><a class=n href="#ref25">[25]</a></sup>均用此值。一些现实世界材质的反射率甚至更低，水为2%，但某些电介质材质的反射率也可能更高，钻石为0.18<sup><a class=n href="#ref35">[35]</a></sup>。该值不会随材质而变化，在渲染器中是固定的，其选择对最终外观有重大影响。金属度还会减弱金属的漫反射率<sup><a class=n href="#ref30">[30]</a></sup><sup><a class=n href="#ref52">[52]</a></sup>，这是根据基色计算得出的：<span class="math display">\[diffuse\_reflectance=base\_color*(1-metalness)\]</span></p><p>这个参数组合（基色和金属度）有时称为金属度工作流，并且具有限制性，无法为漫反射和镜面反射设置不同的色相（colorhue）。另一种方法是镜面工作流，它可以直接指定漫反射和镜面反射率<sup><a class=n href="#ref54">[54]</a></sup>，而不是根据基色计算它。它需要更多的存储空间，但可以创建更广泛的材质，包括具有显著不同的漫反射和镜面反射率的非真实材料，从而提供更大的美术自由。</p><blockquote><p>Schlick近似求<span class="math inline">\(F_0\)</span>公式：</p><p><span class="math display">\[F_0=(\frac{n1-n2}{n1+n2})^2\]</span></p><p>空气折射率为1，取塑料折射率为1.5： <span class="math display">\[F_0=(\frac{1.5-1}{1.5+1})^2=0.04\]</span> 取水的折射率为1.33，同理可求得<spanclass="math inline">\(F_0=0.02\)</span>。</p><p>Metallic/Roughness工作流和Specular/Glossiness工作流对应的材质贴图不同。</p><table><thead><tr class="header"><th>Metallic/Roughness工作流</th><th>Specular/Glossiness工作流</th></tr></thead><tbody><tr class="odd"><td>Base Color贴图<br/>（三通道）<br/>（对于金属存<spanclass="math inline">\(F_0\)</span>，对于电介质存漫反射颜色（此时<spanclass="math inline">\(F_0\)</span>设为0.04），混合材质可以认为同时存了这两种数据）<br/>（除了微观遮蔽信息外不该含有任何光照信息）</td><td>Diffuse贴图<br/>（三通道）<br/>（对于金属存0，对于电介质存漫反射颜色）<br/>（除了微观遮蔽信息外不该含有任何光照信息）</td></tr><tr class="even"><td>Metallic贴图<br/>（单通道，相当于图层遮罩）<br/>（0代表非金属，1代表纯金属，中间值代表锈蚀等中间状态）</td><td>Specular贴图<br/>（三通道）<br/>（存<spanclass="math inline">\(F_0\)</span>）</td></tr><tr class="odd"><td>Roughness<br/>（单通道）<br/>（0代表平滑，1代表粗糙）</td><td>Glossiness贴图<br/>（单通道）<br/>（0代表粗糙，1代表光滑）</td></tr></tbody></table><p>当贴图分辨率与纹素密度过小时，在金属与电介质交界产生白边（金属工作流）/黑边（高光工作流）。</p><table><thead><tr class="header"><th></th><th>Metallic/Roughness工作流</th><th>Specular/Glossiness工作流</th></tr></thead><tbody><tr class="odd"><td>优点</td><td>由于电介质的<spanclass="math inline">\(F_0\)</span>规定为0.04，所以设计师在对其赋值时不易出错。如需调整，在大多实现流程中有控制器可以直接覆写这个值。<br/>内存需求小。<br/>兼容性广。</td><td>边缘效应不明显。<br/>可以在Specular贴图中自由调整电介质的<spanclass="math inline">\(F_0\)</span>。</td></tr><tr class="even"><td>缺点</td><td>边缘效应较明显。</td><td>自由调整电介质的<spanclass="math inline">\(F_0\)</span>可能导致错误，打破能量守恒，渲染不正确。<br/>内存需求大。<br/>需要设计师了解PBR。</td></tr></tbody></table></blockquote><p>对于某些材质，可能需要对从<spanclass="math inline">\(F_0\)</span>到1的过渡进行更多控制，以减少Schlick近似的误差。<spanclass="math inline">\(F_0\)</span>的RGB值已针对法向入射进行测量或计算，但对于某些材质，中间角度的色相可能会略有不同（例如，某些金属和涂层表面），或者当我们想要创建非真实的材质——unobtainiums。Gulbrandsen<sup><a class=n href="#ref55">[55]</a></sup>通过引入两个参数来控制反射率和他称为edge-tint的参数来解决这个问题。最近，Hoffman提供了一种改进的解决方案<sup><a class=n href="#ref50">[50]</a></sup>，通过引入表示为<spanclass="math inline">\(h\)</span>的附加参数来控制edge-falloff，其中包括Lazanyi的误差项<sup><a class=n href="#ref56">[56]</a></sup>以减少Schlick的近似误差。<spanclass="math inline">\(h\)</span>参数可以理解为<spanclass="math inline">\(F_{82}\)</span><sup><a class=n href="#ref57">[57]</a></sup>——82度的反射率，可以使用真实解决方案进行计算，也可以针对给定材质进行测量。</p><p>注意，<spanclass="math inline">\(F_0\)</span>最初取决于表面两侧的折射率，并且通常假设表面被空气包围。如果情况并非如此（例如，在水下），则应相应调整<spanclass="math inline">\(F_0\)</span>（例如，参见RTR第324页<sup><a class=n href="#ref45">[45]</a></sup>）。</p><p>上述提到的Lazanyi的修复重新引入了<spanclass="math inline">\(n\)</span>和<spanclass="math inline">\(k\)</span>参数（但在Hoffman的解决方案中不需要）。如果需要，可以Polyanskiy<sup><a class=n href="#ref58">[58]</a></sup>创建的优秀数据库中找到各种材质的这些，但是仍然按波长指定。</p><p>Lagarde提出了对Schlick菲涅耳项的一个有趣的优化，它使用球面高斯近似<sup><a class=n href="#ref59">[59]</a></sup>，并已在UE4<sup><a class=n href="#ref12">[12]</a></sup>中使用：<span class="math display">\[F=F_0+(F_{90}-F_0)*2^{(-5.55473*u-6.983146)*u}\]</span>重要的实现细节是，菲涅尔项必须针对采样微面的法线（半向量）进行计算，而不是表面（或着色）法线，否则菲涅尔项基本上会忽略材料的粗糙度，并且物体会出现比实际情况更具反射性。</p><p>一个相关的问题来自于这样一个事实：法线贴图通常用于创建空洞、划痕或铜锈，美工会将底色变暗以减少这些特征的反射。由于菲涅尔项在90度时总是接近1，因此效果通常与美工的意图相反，并且空洞变得更具反射性，因为它们的法线与视线方向接近90度角。可能的解决方案之一是Schüler<sup><a class=n href="#ref60">[60]</a></sup>引入的修复，它可以防止菲涅耳项在某些条件下接近1。我们不设置<spanclass="math inline">\(F_{90}=1\)</span>，而是将<spanclass="math inline">\(F_{90}\)</span>计算为<spanclass="math inline">\(F_{90}=min(1,60\luminance(F_0))\)</span>。这会为反射率小于1/60的<spanclass="math inline">\(F_0\)</span>值创建平滑但非常快速的从1开始的衰减。数字1/50或值<spanclass="math inline">\(F_{0Dielectric}\)</span>的倒数也经常用在这个地方。我们知道现实世界中没有材质的反射率低于2%，因此这些低值可以被认为是为限制菲涅耳项而保留的。最后注意，当使用金属度计算<spanclass="math inline">\(F_0\)</span>时，此方法不会产生任何效果，因为它是我们代码示例中默认的，因为没有<spanclass="math inline">\(F_0\)</span>会小于<spanclass="math inline">\(F_{0Dielectric}\)</span>。为了完整性，我们在代码中提供了此修复，因为它对于使用不同方式计算<spanclass="math inline">\(F_0\)</span>或由美工直接设置的情况非常有用。某些引擎提供的遮挡（occlusion）值可应用于镜面反射组件或用于Schüler的修复以获得类似的效果。注意当来自8位纹理时，只有少数<spanclass="math inline">\(F_0\)</span>值会触发此修复。有关此主题的更多讨论可以在Hoffman的文章<sup><a class=n href="#ref61">[61]</a></sup>的末尾找到。</p><h2 id="sampling-the-microfacet-brdf">4.4 Sampling the microfacetBRDF</h2><p>有了所有这些知识，我们现在可以实现微面镜面反射BRDF的eval函数，请参阅本文附带的代码示例以获取完整列表。</p><p>为了高效实现采样方法，我们需要一个例程，对使用选定的<spanclass="math inline">\(D\)</span>和<spanclass="math inline">\(G\)</span>函数构建的微面BRDF进行重要性采样。本文中我们使用Heitz提出的基于VNDF的采样<sup><a class=n href="#ref41">[41]</a></sup>，他还在另一篇文章<sup><a class=n href="#ref62">[62]</a></sup>中提供了针对GG-X分布采样的改进和优化版本。</p><p>此采样例程使用局部空间中指定的向量，其中正Z轴与着色法线对齐（与大多数采样函数一样）。因此，我们必须在采样之前将我们的视线向量变换到这个局部空间，并使用这种变换的逆变换将得到的光向量变换回来。注意，许多渲染器在切线空间中进行着色，例如由于法线贴图，这与VNDF采样的局部空间类似但不相同。虽然切线空间可以围绕几何法线构建，但我们的局部空间围绕着色法线。因此，对于已经在切线空间中指定的向量也需要进行额外的变换。</p><p>单位四元数是一种表示旋转的优雅方式，因为我们的目标是找到着色法线和标准基向量<spanclass="math inline">\((0,0,1)\)</span>之间的旋转，所以这种四元数的构造可以显著简化。因此，我们使用四元数旋转将向量变换到VNDF局部空间并变换回来（通过简单地反转四元数的轴即可找到逆变换）。</p><p>为了获得采样方向的权重，我们必须计算BRDF除以该采样方法的PDF，如3.1节中所述。得益于VNDF采样的构造，BRDF的许多项与PDF的项相互抵消，得到的权重仅为<spanclass="math inline">\(F*(\frac{G_2}{G_1(H,V)})\)</span>。<spanclass="math inline">\(G_2\)</span>和<spanclass="math inline">\(G_1\)</span>的分数可以仅使用<spanclass="math inline">\(G_{1L}\)</span>和<spanclass="math inline">\(G_{1V}\)</span>项重写，如Heitz关于漫发射BRDF的论文<sup><a class=n href="#ref28">[28]</a></sup>的附录所示。因为这里的向量<spanclass="math inline">\(H\)</span>被构造为恰好在<spanclass="math inline">\(L\)</span>和<spanclass="math inline">\(V\)</span>之间，所以<spanclass="math inline">\(G_{1L}\)</span>项等于<spanclass="math inline">\(G_{1V}\)</span>项，我们可以像代码示例中那样进一步优化其计算。</p><p>VNDF采样的原始实现（在VNDF论文<sup><a class=n href="#ref41">[41]</a></sup>的补充材料中提供）依赖于初始化期间的预计算数据，正如WenzelJakob<sup><a class=n href="#ref63">[63]</a></sup>所指出的，Beckmann分布的版本包含不连续性，这可能会在使用低差异序列（例如蓝噪声）时导致问题，或对于诸如Metropolis的光传输算法。Jakob的论文包含一种改进的方法，可以修复这些缺陷，包括代码。Walter<sup><a class=n href="#ref32">[32]</a></sup>提出了以前广泛使用的应该被提到的方法，但其效率低于VNDF，并且有生成可能具有非常大的采样权重的样本的不良特性，从而导致萤火虫（尽管对于Beckmann分布这可以使用“Walter’strick”部分缓解，通过将粗糙度调整为<spanclass="math inline">\(\alpha^{’}=(1.2-0.2\sqrt{|N \cdotL|})\alpha\)</span>）。</p><h1 id="combining-brdfs">5 Combining BRDFs</h1><p>本文中我们为了将镜面反射BRDF与漫反射BRDF结合起来，使用了一种基于菲涅耳项将镜面反射和漫反射BRDF混合在一起的简单方法。注意，微面模型已经用<spanclass="math inline">\(F\)</span>衡量镜面BRDF的权重，因此我们还用<spanclass="math inline">\((1-F)\)</span>衡量漫反射BRDF的权重。这是受到分层材料的启发，其中光与每一层相互作用，菲涅耳项用于计算有多少光从表面反射（有助于镜面波瓣）以及有多少散射到表面里（有助于下层，在我们的例子是漫反射波瓣）。使用这种方法，任意BRDF可以一起使用并组合成多层<sup><a class=n href="#ref48">[48]</a></sup>，例如，广泛使用的基于微面的GG-X镜面反射BRDF与Lambertian或Disney漫反射BRDF的组合。更复杂的多层材质通常使用一个或两个镜面波瓣（其中额外的镜面波瓣模拟基础表面顶部的透明涂层）、具有可选次表面散射的漫反射BRDF、用于透射的BTDF。注意，分层材质中的每个BRDF 本身应该是能量守恒的。</p><p>注意，为了计算漫反射BRDF层，我们需要知道镜面反射BRDF层的菲涅耳项。在代码中，我们对镜面反射BRDF的半向量进行采样并将其用于菲涅耳项计算，即使仅计算漫反射项也是如此。这开销可能很大，因此使用近似归一化项或表格数据可能是更好的方法。</p><p>更正确但也更严格的解决方案是使用同时包含漫反射和镜面反射模型的模型，这些模型被设计为很好地协同工作，例如Ashikhmin-Shirley<sup><a class=n href="#ref21">[21]</a></sup>和Kelemen-Szirmay-Kalos<sup><a class=n href="#ref64">[64]</a></sup>的模型。另一种选择是选择偏爱的BRDF并找到合适的漫反射BRDF，然后将其简单地求和。这种方法的一个例子是Lagarde对Disney漫反射所做的修改<sup><a class=n href="#ref25">[25]</a></sup>。有关实践中使用的多层材质的更多信息，可参见关于《使命召唤》里的材质的演讲<sup><a class=n href="#ref65">[65]</a></sup>。</p><p>当组合多个BRDF时，所得的BRDF仍应遵循确保能量守恒和Helmholtz互易的基本原则，但这在实践中通常很难实现。</p><h2 id="energy-conservation">5.1 Energy Conservation</h2><p>引言部分中提到的BRDF必须遵守的基本原则之一是要求能量守恒——表面反射的光不应多于其接收的光。此外，如果表面是完美的反射器（白色反照率），也不会发生能量损失。在实践中，即使对于从微面模型导出的基于物理的BRDF，通常也会发生一些能量损失。能量损失的主要来源是缺乏微面之间的多次反射。</p><p>过去在构建用于实时渲染的材质模型时，能量守恒问题经常被忽视，特别是在仅使用单次弹射照明时。对于路径光线追踪和全局照明算法，重要的是要确保光线从表面反射时不会产生能量，否则无法保证路径追踪器的收敛。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-10-Figure_10.jpg" /></p><p><em>图10 Whitefurnace测试显示具有完美能量守恒的BRDF（左）和具有能量损失的BRDF（右）。</em></p><p>一个易于实施且实用的能量守恒测试测试是whitefurnace测试<sup><a class=n href="#ref37">[37]</a></sup>，它是由各个方向的白光照射的白色球体的渲染结果。如果材质是能量守恒的，则球体将在白色背景下消失。任何差异都表明能量损失或增益（见图10）。由于球体的渲染包含视线和光向量的所有可能配置，我们可以很好地了解能量增益或损失发生的角度。</p><h1 id="parametrizing-the-brdf">6 Parametrizing the BRDF</h1><p>在本节中，我们将总结所描述的BRDF参数如何与美工设置的材质属性相关。到目前为止，我们已经使用了以下参数：</p><ul><li>镜面反射BRDF<ul><li>法向入射的镜面反射率<span class="math inline">\(F_0\)</span></li><li>82度角入射的镜面反射率<spanclass="math inline">\(F_{82}\)</span>（可选）</li><li>粗糙度</li></ul></li><li>漫反射BRDF<ul><li>漫反射率</li><li>粗糙度</li></ul></li></ul><p>所有这些参数都可以直接设置以获得更大的美术自由度（作为单个值或从纹理加载），或者使用已知值（测量的或预先计算的）对材质进行建模，但通常会限制可以为反射率和粗糙度设置的值以使指定物理上合理的材质变得更加容易，并使材质属性更加紧凑以便存储。</p><p>我们没有直接使用漫反射和镜面反射率，而是使用基色和金属度参数来计算它们，如4.3节中所述。这确保了物理上不可能的材质不容易创建，并且还使我们能够模拟电介质和金属之间的区别。粗糙度值直接指定并为镜面反射BRDF重新映射，与DisneyPrincipled BRDF中的方式相同（通过平方）。<spanclass="math inline">\(F_{82}\)</span>仅与Hofmann改进的菲涅尔近似一起使用，对于改善具有已知<spanclass="math inline">\(F_{82}\)</span>值的金属（例如铬或金）的外观特别有用。</p><h2 id="transmission">6.1 Transmission</h2><p>为了引入渲染半透明表面所需的透射效果，我们可以重用本文中已经讨论过的概念——即菲涅耳项、微面模型和分层材质。菲涅尔方程告诉我们有多少光被反射走并散射进表面，因此我们只需决定散射到内部的光的哪一部分将贡献给漫反射BRDF，而其余部分将贡献给BTDF。我们在材质模型中引入了一个新参数——漫反射概率或透射率（transmittance），它直接指定了有多少比例的散射光将分别贡献给漫反射BRDF和BTDF。注意，此参数与不透明度（opacity）不同，不透明度也会影响镜面反射BRDF，因为对于高透射率的材质我们在掠射角下仍然会得到菲涅耳反射，但零不透明度的物体则完全消失（无法影响镜面反射BRDF）。</p><p>光的透射部分可以根据Snell定律完美折射，也可以使用微面BTDF来创建粗糙折射，就像我们创造粗糙反射一样。Walter的论文<sup><a class=n href="#ref32">[32]</a></sup>对该方法进行了广泛的总结，所得的折射模型近似于微面反射项。</p><h1 id="code-sample">7 Code Sample</h1><p>本文附带的<ahref="https://github.com/boksajak/brdf">代码示例</a>实现了所有讨论的BRDF。文件是用HLSL编写的，但也可以在C++环境中编译（添加支持HLSL类型和函数的库，例如GLM），并且可以轻松集成到光栅化器或路径跟踪器中。注意，可以针对将使用的所选BRDF组合进一步优化代码。</p><p>默认设置是基于GG-X的微面镜面反射BRDF与Lambertian漫反射BRDF的组合，它们经过高度优化并且可以很好地协同工作。可以通过调用evalCombinedBRDF来集成代码示例，以计算给定光源对给定点的贡献。evalIndirectCombinedBRDF根据所选BRDF（漫反射或镜面反射）采样新光线方向及其权重，以确定路径追踪器中下一条光线的方向。</p><h1 id="conclusion-and-further-reading">8 Conclusion and FurtherReading</h1><p>在电影和游戏的制作中，创建基于物理且合理的材质模型比完全真实的材质模型更为重要。这意味着模型不会（太多）违反物理定律，但也可以通过暴露直观且易于理解的参数来实现足够的美术控制，即使是以省略折射率等物理量为代价。</p><p>看看各个模型暴露了哪些参数（及其范围）是很有趣的。BrentBurley</sup>撰写的一篇关于Disney PrincipledBRDF的文章<sup><a class=n href="#ref5">[5]</a></sup>是一个很好的起点，其中讨论了参数、范围及其映射的选择，以及选择底层BRDF来构建成功的材质模型的技术决策。还有关于与MERL数据库中测量的现实世界材质进行比较的有趣讨论。它还提供了按时间顺序排列的值得研究的著名作品列表（但直到2012年他的论文发表为止），并且有一个Github仓库<sup><a class=n href="#ref66">[66]</a></sup>，其中的代码可以免费获得。Burley于2015年发表了一篇后续文章<sup><a class=n href="#ref6">[6]</a></sup>，根据他们的模型的实际使用进行了更多改进。</p><p>对于游戏中使用的实现，有Lagarde(Frostbite)<sup><a class=n href="#ref25">[25]</a></sup>、Karis(Unreal)<sup><a class=n href="#ref12">[12]</a></sup>和 Lazarov (Call ofDuty)<sup><a class=n href="#ref67">[67]</a></sup>的出色作品。有趣的是能看出不同的开发人员对相同的问题得出不同的结论（例如，使用Lambertian还是Disney漫反射、选择GG-X还是BeckmannNDF分布，等等），这表明这些问题没有单一的通用答案。</p><p>关于基于物理的BRDF的更深入的理论背景，可以学习RTR<sup><a class=n href="#ref45">[45]</a></sup>中的第9章（该章提供了更多相关工作的介绍）、PBR<sup><a class=n href="#ref26">[26]</a></sup>中的第8章和第9章、Background:Physics and Math ofShading<sup><a class=n href="#ref35">[35]</a></sup>（来自NatyHoffman）、GraphicsCodex<sup><a class=n href="#ref10">[10]</a></sup>、EricHeitz关于BRDF的著作。基于物理的着色课程网页包含大量供进一步研究的资源。SubstancePBRguide<sup><a class=n href="#ref54">[54]</a></sup>也值得熟悉，以了解技术美术如何使用PBR材质。</p><p>关于电影制作和离线渲染中使用的BRDF，可以学习Burley<sup><a class=n href="#ref5">[5]</a></sup><sup><a class=n href="#ref6">[6]</a></sup>的文章、Arnold渲染器的描述<sup><a class=n href="#ref68">[68]</a></sup>、Pixar的渲染<sup><a class=n href="#ref34">[34]</a></sup>以及Autodesk使用的材质<sup><a class=n href="#ref7">[7]</a></sup>。这些通常比游戏中使用的BRDF向美工公开更多的参数（例如清漆（clearcoat）和光泽（sheen）参数）。</p><p>由于计算机图形学学术界和工业界使用的BRDF和材质术语经常令人困惑，并且许多术语被互换使用或错误使用，我们建议阅读McGuire等人为渲染工程师撰写的BSDF波瓣分类法<sup><a class=n href="#ref69">[69]</a></sup>。</p><p>为了获得使用什么特定值来模拟不同种类金属的灵感，JarrodHasenjager进行了一项精彩的材质研究<sup><a class=n href="#ref70">[70]</a></sup>。</p><p>另一个有趣的研究主题是开发专用BRDF来解决特定问题，例如皮肤、头发、纺织品、划痕表面、时变材质、水和许多其他特殊材质的渲染。</p><h1 id="references">9 References</h1><p><a name="ref1">[1] M. Winkelmann, "Zero-Day, Open Research ContentArchive (ORCA)," 2019. [Online]. Available:https://developer.nvidia.com/orca/beeple-zero-day. </a></p><p><a name="ref2">[2] N. Benty, K.-H. Yao, P. Clarberg, L. Chen, S.Kallweit, T. Foley, M. Oakes, C. Lavelle and C. Wyman, "The FalcorRendering Framework," 2020. [Online]. Available:https://github.com/NVIDIAGameWorks/Falcor. </a></p><p><a name="ref3">[3] J. T. Kajiya, "The rendering equation,"Proceedings of the 13th annual conference on Computer graphics andinteractive techniques, pp. pp. 143-150, 1986. </a></p><p><a name="ref4">[4] L. Kettner, M. Raab, D. Seibert, J. Jordan and A.Keller, "The Material Definition Language," 2015. </a></p><p><a name="ref5">[5] B. Burley, "Physically Based Shading at Disney,"2012. </a></p><p><a name="ref6">[6] B. Burley, "Extending the Disney BRDF to a BSDFwith," 2015. </a></p><p><a name="ref7">[7] I. Georgiev, J. Portsmouth, Z. Andersson, A.Herubel, A. King, S. Ogaki and F. Servant, "Autodesk Standard Surface,"2019. [Online]. Available: https://autodesk.github.io/standard-surface/.</a></p><p><a name="ref8">[8] M. Pettineo, "An Introduction To Real-TimeSubsurface Scattering," 2019. [Online]. Available:https://therealmjp.github.io/posts/sss-intro/.</a></p><p><a name="ref9">[9] G. I. Pokrowski, "Zur Theorie der diffusenLichtreflexion," pp. 66-72, 1924. </a></p><p><a name="ref10">[10] M. McGuire, "Graphics Codex," [Online].Available: http://graphicscodex.com/. </a></p><p><a name="ref11">[11] J. Stam, "An illumination model for a skin layerbounded by rough surfaces," in Rendering Techniques, 2001. </a></p><p><a name="ref12">[12] B. Karis, "Real shading in unreal engine 4," inProc. Physically Based Shading Theory Practice 4, 2013. </a></p><p><a name="ref13">[13] S. Saikia, "Deriving Lambertian BRDF from firstprinciples," 2019. </a></p><p><a name="ref14">[14] S. Lagarde, "PI or not to PI in game lightingequation," 2012. </a></p><p><a name="ref15">[15] P. Shirley, S. Laine, D. Hart, M. Pharr, P.Clarberg, E. Haines, M. Raab and D. Cline, "Sampling TransformationsZoo," in Ray Tracing Gems, 2019. </a></p><p><a name="ref16">[16] B. Phong, "Illumination for computer generatedpictures," Communications of the ACM, 1975. </a></p><p><a name="ref17">[17] J. F. Blinn, "Models of light reflection forcomputer synthesized pictures," in Proceedings of the 4th annualconference on Computer graphics and interactive techniques, 1977.</a></p><p><a name="ref18">[18] E. P. Lafortune and Y. D. Willems, "Using themodified phong reflectance model for physically based rendering," 1994.</a></p><p><a name="ref19">[19] J. Lawrence, "Importance Sampling of the PhongReflectance Model," 2008. </a></p><p><a name="ref20">[20] F. Giesen, "Phong Normalization Factorderivation," 2009. </a></p><p><a name="ref21">[21] M. Ashikhmin and P. Shirley, "An anisotropicphong BRDF model," Journal of graphics tools, 2000. </a></p><p><a name="ref22">[22] Y. Gotanda, "Physically Based Shading Models inFilm and Game Production: Practical Implementation at tri-Ace," 2010.</a></p><p><a name="ref23">[23] Y. Gotanda, "Practical Physically Based Shadingin Film and Game Production: Beyond a Simple Physically BasedBlinn-Phong Model in Real-Time," 2012. </a></p><p><a name="ref24">[24] M. Oren and S. K. Nayar, "Generalization ofLambert's reflectance model," in Proceedings of the 21st annualconference on Computer graphics and interactive techniques, 1994.</a></p><p><a name="ref25">[25] S. Lagarde and C. de Rousiers, "Moving Frostbiteto Physically Based Rendering," 2014. </a></p><p><a name="ref26">[26] M. Pharr, W. Jakob and G. Humphreys, Physicallybased rendering: From theory to implementation, Morgan Kaufmann, 2016.</a></p><p><a name="ref27">[27] P. Hanrahan and W. Krueger, "Reflection fromlayered surfaces due to subsurface scattering," in Proceedings of the20th annual conference on Computer graphics and interactive techniques,1993. </a></p><p><a name="ref28">[28] E. Heitz and J. Dupuy, "Implementing a SimpleAnisotropic Rough Diffuse Material with Stochastic Evaluation," 2015.</a></p><p><a name="ref29">[29] Y. Gotanda, "Designing Reflectance Models forNew Consoles," 2014. </a></p><p><a name="ref30">[30] R. L. Cook and K. E. Torrance, "A reflectancemodel for computer graphics," ACM Transactions on Graphics, 1982.</a></p><p><a name="ref31">[31] K. E. Torrance and E. M. Sparrow, "Theory foroff-specular reflection from roughened surfaces," Josa, 1967. </a></p><p><a name="ref32">[32] B. Walter, S. R. Marschner, H. Li and K. E.Torrance, "Microfacet Models for Refraction through Rough Surfaces,"Rendering techniques, 2007. </a></p><p><a name="ref33">[33] T. S. Trowbridge and K. P. Reitz, "Averageirregularity representation of a rough surface for ray reflection,"JOSA, 1975. </a></p><p><a name="ref34">[34] C. Hery and R. Villemin, "Physically BasedLighting at Pixar," 2013. </a></p><p><a name="ref35">[35] N. Hoffman, "Background: Physics and Math ofShading," 2012. </a></p><p><a name="ref36">[36] B. Smith, "Geometrical shadowing of a randomrough surface," IEEE Trans. on Antennas and Propagation, 1967. </a></p><p><a name="ref37">[37] E. Heitz, "Understanding the Masking-ShadowingFunction in Microfacet-Based BRDFs," 2014. </a></p><p><a name="ref38">[38] G. Brown, "Shadowing by non-Gaussian randomsurfaces," IEEE Transactions on Antennas and Propagation, 1980. </a></p><p><a name="ref39">[39] C. Schlick, "An inexpensive BRDF model forphysically-based rendering," Computer graphics forum, 1994. </a></p><p><a name="ref40">[40] E. J. Hammon, "PBR Diffuse Lighting forGGX+Smith Microsurfaces," GDC, 2005.</a></p><p><a name="ref41">[41] E. Heitz and E. d'Eon, "Importance samplingmicrofacet-based BSDFs using the distribution of visible normals,"Computer Graphics Forum, 2014. </a></p><p><a name="ref42">[42] E. Heitz, J. Hanika, E. d'Eon and C.Dachsbacher, "Multiple-scattering microfacet BSDFs with the Smithmodel," ACM Transactions on Graphics (TOG), 2016. </a></p><p><a name="ref43">[43] E. d’Eon, A Hitchhiker’s Guide to MultipleScattering, 2016. </a></p><p><a name="ref44">[44] C. Kulla and A. Conty, "Revisiting PhysicallyBased Shading at Imageworks," 2017. </a></p><p><a name="ref45">[45] T. Akenine-Möller, E. Haines, N. Hoffman, A.Pesce, M. Iwanicki and S. Hillaire, Real-time Rendering, CRC Press,2019. </a></p><p><a name="ref46">[46] G. J. Ward, "Measuring and modeling anisotropicreflection," 1992. </a></p><p><a name="ref47">[47] W. Jakob, E. d'Eon, O. Jakob and S. Marschner,"A comprehensive framework for rendering layered materials," 2014.</a></p><p><a name="ref48">[48] A. Weidlich and A. Wilkie, "Arbitrarily layeredmicro-facet surfaces," in Proceedings of the 5th internationalconference on Computer graphics and interactive techniques in Australiaand Southeast Asia, 2007.</a></p><p><a name="ref49">[49] L. Belcour and P. Barla, "A Practical Extensionto Microfacet Theory for the Modeling of Varying Iridescence," 2017.</a></p><p><a name="ref50">[50] N. Hoffman, "Fresnel Equations ConsideredHarmful," 2019. </a></p><p><a name="ref51">[51] M. Mojzík, T. Skřivan, A. Wilkie and J.Křivánek, "Bi-directional Polarised Light Transport," EGSR, 2016.</a></p><p><a name="ref52">[52] P. S. Strauss, "A realistic lighting model forcomputer animators," IEEE Computer Graphics and Applications, 1990.</a></p><p><a name="ref53">[53] B. Smith, "Reflection Model Design for WALL-Eand Up," 2012. </a></p><p><a name="ref54">[54] Allegorithmic, "The PBR guide by Allegorithmic,"2018. [Online]. Available:https://academy.substance3d.com/courses/the-pbr-guide-part-2. </a></p><p><a name="ref55">[55] O. Gulbrandsen, "Artist friendly metallicfresnel," Journal of Computer Graphics Techniques, 2014. </a></p><p><a name="ref56">[56] I. Lazániy and L. Szirmay-Kalos, "Fresnel termapproximations for metals," 2005. </a></p><p><a name="ref57">[57] N. Hoffman, "Fresnel Equations ConsideredHarmful (slides)," 2019. [Online]. Available:http://renderwonk.com/publications/mam2019/naty_mam2019.pdf. </a></p><p><a name="ref58">[58] M. Polyanskiy, "Refractive index database,"[Online]. Available: refractiveindex.info. </a></p><p><a name="ref59">[59] S. Lagarde, "Spherical Gaussian approximationfor Blinn-Phong, Phong and Fresnel," 2012. [Online]. Available:https://seblagarde.wordpress.com/2012/06/03/spherical-gaussienapproximation-for-blinn-phong-phong-and-fresnel/.</a></p><p><a name="ref60">[60] C. Schüler, "An efficient and PhysicallyPlausible Real Time Shading Model," in ShaderX7, 2009. </a></p><p><a name="ref61">[61] N. Hoffman, "Crafting Physically MotivatedShading Models for Game Development," 2010. </a></p><p><a name="ref62">[62] E. Heitz, "Sampling the GGX distribution ofvisible normals," Journal of Computer Graphics Techniques, 2018.</a></p><p><a name="ref63">[63] W. Jakob, "An Improved Visible Normal Sampling,"2014. </a></p><p><a name="ref64">[64] C. Kelemen and L. Szirmay-Kalos, "A microfacetbased coupled specular-matte BRDF model with importance sampling," 2001.</a></p><p><a name="ref65">[65] M. Drobot and A. Micciulla, "PracticalMultilayered Materials - Call of Duty Infinite Warfare," in SIGGRAPH,2017. </a></p><p><a name="ref66">[66] B. Burley, "Disney BRDF Explorer Githubrepository," 2012. [Online]. Available: https://github.com/wdas/brdf.</a></p><p><a name="ref67">[67] D. Lazarov, "Physically Based Lighting in Callof Duty: Black Ops," 2011. </a></p><p><a name="ref68">[68] A. Langlands, "Physically Based Shader Design inArnold," 2014. </a></p><p><a name="ref69">[69] M. McGuire, J. Dorsey, E. Haines, J. F. Hughes,S. Marschner, M. Pharr and P. Shirley, "A Taxonomy of BidirectionalScattering Distribution Function Lobes for Rendering Engineers," inWorkshop on Material Appearance Modeling, 2020. </a></p><p><a name="ref70">[70] J. Hasenjager, "Material Studies: Metals," 2016.[Online]. Available:https://www.behance.net/gallery/35636521/Material-Studies-Metals.</a></p><p><a name="ref71">[71] E. Heitz, "Generating Procedural BeckmannSurfaces," 2015. </a></p><p><a name="ref72">[72] M. McGuire, "Tweet #1174191724694032387," 2019.[Online]. Available:https://twitter.com/CasualEffects/status/1174191724694032387. </a></p><p><a name="ref73">[73] P. Shirley, Ray Tracing in One Weekend,2018.</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>但是Heitz发表了一篇有趣的论文，该论文以程序方式生成Beckmann分布表面的网格以用于研究目的<sup><a class=n href="#ref71">[71]</a></sup><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>GG-X可能是“Ground Glass -roughnessunknown”的缩写<sup><a class=n href="#ref72">[72]</a></sup>，以用于光学测量的抛光至一定粗糙度的磨砂玻璃板命名。<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可重入锁与不可重入锁权衡</title>
      <link href="//posts/Article/tradeoff-between-reentrant-and-non-reentrant-lock/"/>
      <url>//posts/Article/tradeoff-between-reentrant-and-non-reentrant-lock/</url>
      
        <content type="html"><![CDATA[<p>观点整理</p><span id="more"></span><p><strong>可重入锁</strong>（reentrant）也称为递归锁（recursive），意味着同一个线程可以重复对其加锁。</p><p>可重入锁可以看作不可重入锁的超集，除记录持有锁的线程ID外还关联一个计数器，当重复加锁时计数器递增，当计数器为0时释放锁。</p><p>C++中<code>std::mutex</code>是不可重入锁，<code>std::recursive_mutex</code>是可重入锁。</p><p>Windows的<code>CRITICAL_SECTION</code>是可重入的。</p><p>Java里只要以Reentrant开头命名的锁都是可重入锁，而且JDK提供的所有现成的Lock实现类，包括<code>synchronized</code>关键字锁都是可重入的。</p><p><strong>认为不可重入锁更好</strong>的一方认为，其能快速暴露设计上的缺陷，方便debug。</p><p>David Butenhof（Programming with POSIX Threads的作者）认为：</p><blockquote><p>A correct and well understood design does not require recursivemutexes.（<ahref="https://groups.google.com/g/comp.programming.threads/c/tcrTKnfP8HI/m/me2K7_byNdgJ">recursivemutexes</a>）</p></blockquote><p>《Linux多线程服务端编程》（陈硕著）认为：</p><blockquote><p>只用非递归的mutex（即不可重入的mutex）。</p><p>我还没有遇到过需要使用recursivemutex的情况，我想将来遇到了都可以借助wrapper改用non-recursivemutex，代码只会更清晰。（<ahref="https://www.cnblogs.com/Solstice/archive/2010/02/12/multithreaded_server.html">多线程服务器的常用编程模型</a>）</p></blockquote><p>《C++并发编程实战》第二版（Anthony Williams著）认为：</p><blockquote><p>我们通常可以采取更好的方法（避免使用递归锁）：根据这两个公有函数的共同部分，提取出一个新的私有函数，新函数由这两个公有函数调用，而它假定互斥已经被锁住，遂无须重复加锁。经过上面的改良设计，读者可以更进一步地仔细推敲，什么情形应当调用新函数，以及数据在该情形中处于什么状态。</p></blockquote><p><strong>认为可重入锁更好</strong>的一方认为，没有一定需要不可重入锁的业务场景。</p><p>HBLOG认为：</p><blockquote><p>99%的业务场景用可重入锁就可以了，剩下的1%是什么呢？我也不知道，谁可以在评论里告诉我？（<ahref="https://mp.weixin.qq.com/s/aWm3SWDLIh7FbUkzALZ-bQ">各种锁及其Java实现</a>）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lumen和Nanite学习</title>
      <link href="//posts/Article/learn-Lumen-and-Nanite/"/>
      <url>//posts/Article/learn-Lumen-and-Nanite/</url>
      
        <content type="html"><![CDATA[<p>Lumen &amp; Nanite in UE5</p><span id="more"></span><h1 id="lumen-livestream">Lumen Livestream</h1><p><a href="https://www.youtube.com/watch?v=QdV_e-U7_pQ">Lumen | InsideUnreal - YouTube</a> / 2021年6月11日</p><p>开场之前的5分钟的鸡蛋不能飞动画片确实没有看懂……</p><p>标题自行组织，与视频章节不一一对应。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-pre.png"alt="pre" /><figcaption aria-hidden="true">pre</figcaption></figure><h2 id="goals">Goals</h2><p>以次世代主机为目标，扩展到高端PC。</p><p>全动态GI和完美反射。</p><p>无缝同时支持：</p><ul><li><p>大型开放世界</p></li><li><p>室内GI</p></li></ul><p>室内的光照往往只来自一小块区域，所以非常困难。</p><h2 id="features">Features</h2><p>没有烘焙光照，ms级GI。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-indoor%20GI.png"alt="indoor GI" /><figcaption aria-hidden="true">indoor GI</figcaption></figure><p>带阴影的天空光照，让室内比室外更暗，只需在场景中放置一个可移动的天空光照。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-shadowed%20skylight.png"alt="shadowed skylight" /><figcaption aria-hidden="true">shadowed skylight</figcaption></figure><p>自发光。不可以替换光源，需要保持其subtle。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-emissive.png"alt="emissive" /><figcaption aria-hidden="true">emissive</figcaption></figure><p>与GI集成的反射。如果材质足够光滑，它会追踪额外的光线。这很重要否则除了太阳光照射的地方一切都是黑的。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-reflections.png"alt="reflections" /><figcaption aria-hidden="true">reflections</figcaption></figure><p>反射只影响屏幕上的内容，没有caustics。</p><blockquote><p>焦散，比如太阳照进窗户，从地板高光反射到天花板形成图案。计算机图形学的定义是：焦散是任何从光源到高光（反射或折射）、到漫反射表面、再到眼睛（或摄影机）的光照贡献。</p><p><ahref="http://vraymasters.cn/magazine/what-are-caustics-and-how-to-render-them-the-right-way/">焦散是什么？如何正确地渲染焦散？– V-Ray中文资讯站 (vraymasters.cn)</a></p></blockquote><p>Daniel Wright：如果有焦散，那将是在UE6。</p><p>Lumen支持clear coat，实际上有两层反射。比如汽车油漆。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-clear%20coat.png"alt="clear coat" /><figcaption aria-hidden="true">clear coat</figcaption></figure><p>支持半透明和体积雾的GI和带阴影天空光照，但是质量很低。这很难解决，因为每个像素都有任意数量的层。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-translucency%20and%20volumetric%20fog.png"alt="translucency and volumetric fog" /><figcaption aria-hidden="true">translucency and volumetricfog</figcaption></figure><h2 id="settings">Settings</h2><p>创建项目时，Lumen是默认开启的。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-default%20settings.png"alt="default settings" /><figcaption aria-hidden="true">default settings</figcaption></figure><p>要获得顶级光照，必须打开硬光追。LUMEN-&gt;Use Hardware Ray Tracingwhen available &amp;&amp; HADRWARE RAY TRACING -&gt; Support HardwareRay Tracing。</p><p>可以在Post ProcessVolume中重写GI和反射的方法，用作QA（质量保证）。还可以对场景的不同地方提高Lumen的质量，但这会带来更多消耗。</p><p>Lumen可设置的不多，主要有光照属性、材质属性、曝光。</p><h2 id="how-lumen-works">How Lumen Works</h2><p>从高级别看，Lumen默认使用软光追，这专为UE5开发。</p><ul><li>首先利用深度缓存追踪（屏幕追踪）。</li><li>如果光线被挡住或者射出屏幕外，在computeshader里使用SDF追踪。首先追踪单个物体的距离场，这个代价比较高，因此当光线变得更远时只追踪全局距离场。</li><li>当光线击中SDF，通过surface cache获得击中点的光照。</li></ul><h2 id="hybrid-tracing-pipeline">Hybrid tracing pipeline</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-21-hybird-tracing-pipeline.png"alt="hybird tracing pipeline" /><figcaption aria-hidden="true">hybird tracing pipeline</figcaption></figure><p>每个像素的GI都是通过不同类型追踪组合而成。</p><h2 id="mesh-distance-fields">Mesh Distance Fields</h2><p>相比UE4，UE5的距离场全部重写了，它们是稀疏的，并且生成距离场的mipmap，只需要根据距离选择版本。默认体素密度提高2倍（相当于数据量提高8倍），每个网格的默认分辨率提高4倍，净内存消耗降低一半。建立网格距离场速度增加10倍。在简单光照下视觉效果更好。</p><h2 id="surface-cache">Surface Cache</h2><p>从不同方向捕获网格并将它们存储到图集中，并整理出所有材料属性。在场景中漫游时，将会重新捕获。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-21-surface%20cache.png"alt="surface cache" /><figcaption aria-hidden="true">surface cache</figcaption></figure><p>但是，它仅当网格有简单interiors时有效。比如复杂的墙面必需由单独的网格组成。</p><h2 id="lumenscene">LumenScene</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-lumen%20scene.png"alt="lumen scene" /><figcaption aria-hidden="true">lumen scene</figcaption></figure><p>如果LumenScene中的场景与屏幕上的不匹配，GI中就会出现view-dependentartifacts。</p><p>优化方法：</p><ul><li>将所有网格距离场合并为全局距离场。</li><li>将Surface Cache合并到Voxel Lighting</li></ul><p>LUMEN-&gt;Software Ray Tracing Mode:</p><p>Detail Tracing - 默认在两米内追踪网格距离场。</p><p>Global Tracing - 跳过网格距离场全局追踪。</p><h2 id="limitations">Limitations</h2><p>软光追的限制：</p><ul><li><p>只支持Static Mesh和Instanced Static Mesh</p></li><li><p>Landscape支持将在5.0版本发布</p></li><li><p>世界位置偏移会导致artifacts，因为无法在距离场中复制每个顶点的变形。</p></li><li><p>更多的可以直接看Lumen文档，很详细</p></li></ul><p>软光追可以在任何DX11以上硬件上运行，但只支持有限的几何类型。</p><h2 id="hardware-ray-tracing">Hardware Ray Tracing</h2><p>在PC上，只有在D3D12下运行时有效。</p><p>显卡需要是Nvidia RTX2000以上或AMD RX6000以上。</p><p>只支持用于反射和部分final gather。</p><p>Nanite可以实现几个数量级的更高详细几何形状，但这依赖于光栅化器特定技术和解压缩顶点格式，这与硬光追的API不兼容。因此不能对原始的Nanite三角形进行追踪，Nanite提供了一个简化的代理几何以供追踪。</p><p>也可以用屏幕追踪解决这种不匹配，因为屏幕上是全分辨率的实际的Nanite光栅化几何。当这被阻塞时将使用代理几何。可以在Nanite里设置。</p><p>在大多数情况下可以只使用代理几何，除了汽车之类的。汽车表面非常薄，代理几何做的简化会过于简单。</p><p>Proxy TrianglePercent默认情况下仅为1%，设置为2%~4%即可修复所有错误。</p><p>对于SkinnedMesh这样的动态几何，每一帧都要重建光线追踪加速结构BVH，耗费非常大。</p><p>小心！对于硬光追kitbashing耗费很大，因为网格重叠。</p><p>硬光追比软光追慢50%，但是更准确。</p><h2 id="final-gather">Final Gather</h2><p>指最终到屏幕上的像素的处理过程。</p><p>光线追踪很慢，只能承担每个像素大约半条光线的成本。但是对于室内场景，可接受的图像质量需要每个像素200条光线的成本！</p><p>两种方法解决：</p><ul><li>Irradiance Fields<ul><li>需要艺术家手动设置探针</li></ul></li><li>Screen Space Denoiser<ul><li>输入仅来自屏幕，质量有限</li></ul></li></ul><p>Lumen使用<strong>Screen Space RadianceCaching</strong>。仅对很小的一组位置追踪然后插值（与Nanite表面细节法线结合）。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-ds%20tracing.png"alt="ds tracing" /><figcaption aria-hidden="true">ds tracing</figcaption></figure><p>还需要<strong>World Space RadianceCaching</strong>来实现稳定的远距离光照。这通过放置少得多的探针来实现。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-compare0.png"alt="compare" /><figcaption aria-hidden="true">compare</figcaption></figure><h2 id="reflections">Reflections</h2><p>对于粗糙度&lt;0.4的，追踪额外光线。 &gt;0.4的，重用finalgather追踪。</p><p>默认情况下反射使用Surface Cache，即使打开硬光追。</p><p>可以在设置中把REFLECTIONS -&gt; Lumen Reflections-&gt;Quality调整到<strong>4.0</strong>，来使Lumen真正评估击中点的光照。但是，天空和多次弹射仍然使用SurfaceCache。</p><p>对比：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-22-compare1.png"alt="compare" /><figcaption aria-hidden="true">compare</figcaption></figure><h2 id="best-practice">Best Practice</h2><h3 id="emissive">Emissive</h3><p>不能使用Lumen+Emissive meshed代替光源。</p><p>Emissive越小越亮越嘈杂，最好是large dim或small dim+光源。</p><h3 id="basecolor">BaseColor</h3><p>对GI影响很大。</p><p>Dark and noisy BaseColor = poor GI</p><p>官方的 Lumen in the Land of Nanite 就提升了BaseColor。</p><h3 id="indirect-lighting-intensity">Indirect Lighting Intensity</h3><p>非间接光照的强度，可以直接设置。</p><h3 id="surface-cache-1">Surface Cache</h3><p>记得关注LumenScene视图并调整使其与主场景同步。之前提过，有复杂interiors的网格使其无效。</p><p>这确实麻烦，但比创建lightmap UVs并等待10分钟的构建要好。</p><h3 id="platforms">Platforms</h3><ul><li>只支持下一代主机和高端PC。</li><li>不支持移动端。</li><li>不支持VR。除了VR对分辨率要求很高之外，Lumen 需要 deferred shadingpipeline，但是VR项目大多依赖forward shadingpipeline来降低开销和MSAA。</li><li>硬光追有额外的要求-见文档。</li></ul><h3 id="performance">Performance</h3><p>很大程度上依赖Temporal Super Resolution。</p><p>1080p internal -&gt; 4k output</p><p>主机默认上采样，但PC不是，如果用带4k屏的PC，可以自己设置一下ScreenPercentage。</p><h2 id="history">History</h2><p>Daniel Wright (Engineering Fellow, Graphics - <ahref="http://twitter.com/EpicShaders">EpicShaders</a>)等一共3个人从19年3月开始工作了约两年完成lumen。</p><p>Daniel：在过去12个月硬光追甚至还不存在，因此这段时间为这做了很多改进。（这个视频的时间是21年6月份）</p><h2 id="lumen-content-examples">Lumen Content Examples</h2><p>演示了Lumen in the Land of Nanite，LakeHouse。</p><p>对于比较薄的物体和镜面反射，只有硬光追work。</p><h2 id="qa">QA</h2><p>仅记录部分。</p><p>Q: UE5支持三个以上光照通道吗？</p><p>A: 0个。光追时不记录光线来自哪个光源，这样成本太高。</p><p>Q: Lumen用于基于光照的粒子效果，自发光的粒子效果如何影响场景？</p><p>A: 不能很好工作。小亮度的组合不适用于Lumenemissive。快速移动的光比如枪口闪光需要将间接光照强度设为0，这样就看不到延迟了。</p><p>Q:能不能将特定的网格体排除在Lumen的影响之外，举个例子，假设有一个科幻主题的走廊，里面装饰着很多自发光灯管，那么在当前或者未来有没有可能将这些自发光物体排除在Lumen的影响之外？</p><p>A:如果你想使用Lumen构建一个有很多小型自发光材质的科幻场景，那么就会产生很多噪点，目前我们还没有办法控制这种影响，这是因为屏幕空间追踪的原因。屏幕空间追踪会命中屏幕上的所有表面，然后捕捉相应的颜色，如果想单独呈现一个可以将自发光物体隐藏起来的Lumen视图屏幕追踪是不支持的，所以这个方面我们还要再研究一下。</p><p>Q:有没有可能让Lumen在影片渲染队列等工具上加快计算和收敛？因为它会逐帧发生。这是有可能的吗？</p><p>A:这是我们必须要做的一件事，尤其是针对摄像机切换。因为Lumen的目标是实时，它需要多个帧来收敛，如果有摄像机切换就会产生噪点图像，几帧后图像又会改变，呈现出弹出的切换效果。所以我们需要预热为早期的帧提供更多的预算，让渲染更顺畅，让Lumen与过场动画配合得更好。如果是做渲染，那么我们就要使用更高的质量设置，因为性能将不再是一个问题，但是现在我们还没有实现。</p><p>Q: 是否会将Lumen GI转换成光照贴图，加快烘焙速度？</p><p>A: 不会。我们其实可以通过GPUlightmass获得非常好的光照贴图预览。Lumen是在屏幕上工作的，不经过光照贴图纹理，因此不适合预览光照贴图。因为它不能像光照贴图UV一样准确呈现光照贴图失真，又比如贴图分辨率过低、网格体上的UV丢失、网格体重叠等等。你可能想在预览中看到这些瑕疵，然后在开始长时间的构建之前修复好。但是Lumen无法显示这些瑕疵，GPULightmass预览可以。</p><p>Q: 网格体距离场在UE4中具有非均匀缩放的限制，现在还有吗？</p><p>A:大多数情况下，没有非均匀缩放基本上已经不成问题。如果缩放得过大，比如说一个方向上的缩放是另一个方向上的4倍，这个时候可能会出现失真。</p><p>Q:次表面或者半透明材质是怎样的？之前我有看到过你展示的玻璃，但是次表面呢？</p><p>A:之后我们打算为次表面阴影模型提供支持，但是现在还没有完成。我们还计划通过Lumen的追踪功能支持光的散射，但是现在还不行。</p><p>Q:Lumen与烘焙光照结合使用？比如Lumen用于某些场景，烘焙光照用于其他场景。</p><p>A:我们研究过烘焙室内光照的可行性，尤其是室内有很多光源而且需要提供高品质光照的室内场景，然后在室外利用Lumen实现动态光照。最终的结论是两者结合并不是一个很好的解决方案。因为Lumen的性能开销很大程度上依赖于屏幕，取决于屏幕分辨率，即使是在烘焙光照的区域Lumen也会产生开销。我们的目的是在两者之间实现无缝过渡，因此我们最终决定不提供这样的支持，但是我们希望光照贴图GI可以为Lumen反射提供支持，就像今天的光线追踪反射一样。这是未来我们希望实现的目标。</p><p>Q: 能不能举个例子展示一下水体效果？我很想知道Lumen对水体的作用。</p><p>A:Lumen反射在单层水面上不起作用，就是你给水体选择的阴影模型。但是我们正在努力实现这项功能，我不确定会不会在5.0版本推出。</p><h1 id="lumen-siggraph-course">Lumen / SIGGRAPH course</h1><p>2022 SIGGRAPH course 里的一节，<ahref="https://advances.realtimerendering.com/s2022/index.html#Lumen">Lumen:Real-time Global Illumination in Unreal Engine 5</a></p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-11-29-pre.png"alt="pre" /><figcaption aria-hidden="true">pre</figcaption></figure><p>ppt首页作者依然是官方直播那三个人。官方直播是Daniel主讲，主持人主持，另外两个嘉宾交互。这个是这三个人依次讲，Daniel介绍整个架构和屏幕追踪部分，Krzysztof讲软光追和屏幕缓存部分，Patrick讲硬光追部分。</p><p>内容相比官方直播增加了Lumen开发的思路和实现细节。</p><h2 id="基础问题">基础问题</h2><h3 id="如何追踪光线">#1 如何追踪光线？</h3><p>硬光追受硬件设备限制；使用二级加速结构处理具有大量重叠网格的场景会很慢。因此开发解决这些问题的软光追。</p><ul><li><p>尝试使用一堆2D正交相机捕捉表面，得到卡片，对卡片高度场光追，击中时对卡片照明采样。因为这是2D表面表示，与体素这种3D表示相比空间分辨率高，并且和视差遮挡映射（POM）一样利用高度场实现了快速软光追。但不可能用高度场覆盖整个场景，缺失的区域会漏光。</p></li><li><p>使用符号距离场（SDF）可以覆盖所有区域，并且通过球体追踪实现快速软光追。但是求交只能得到击中位置和法线，得不到材质属性或光照。</p></li></ul><p>结合以上两种方法，根据卡片在SDF光追击中的地方进行光照插值，没有覆盖到的区域仅会损失能量，而不会漏光。</p><p>卡片（cards）即为<strong>表面缓存</strong>（SurfaceCache）。优点如下：</p><ol type="1"><li>在间接光线之间共享材质评估和照片。</li><li>跨帧缓存，直接控制更新成本。</li><li>为硬光追提供快速路径。</li></ol><p><strong>Lumen光追管线：</strong></p><p><strong>屏幕追踪 -&gt; 硬光追 / 软光追（取决于配置）-&gt;表面缓存（击中） / 天空光（未击中）</strong>（P56）</p><h3 id="整个间接照明路径如何解决">#2 整个间接照明路径如何解决？</h3><p>对于室内场景需要多次反弹的漫反射，并且需要在反射中看到全局照明。</p><p>第一次反弹是最重要的，把他分开并用专门的技术解决，对于漫反射这称为最终聚集，对于镜面反射这就是反射去噪。</p><p><strong>↻表面缓存 -&gt; 最终聚集（Final Gather） / 反射 -&gt;图片</strong> （P11）</p><p>第一次反弹之后的任何反弹都通过表面缓存使用反馈解决。表面缓存从自身读取数据，我们从它收集数据，每次更新传播另一次间接光照的反弹。</p><h3 id="如何解决光传输中的噪声">#3 如何解决光传输中的噪声？</h3><p>甚至无法承担每个像素一条光线的开支。</p><p>最终聚集技术：</p><ul><li>自适应下采样</li><li>时空重用</li><li>Product 重要性采样</li></ul><p>最终聚集域：</p><p>不透明 - 屏幕空间 - 连续2.5d</p><p>透明和雾 - 相机对齐体积- 连续3d</p><p>表面缓存 - 纹理空间- 不连续2d</p><p>反射降噪：</p><ul><li>时空重用</li><li>双边滤波</li><li>重用漫反射光线</li></ul><h2 id="大纲">大纲</h2><ul><li>光追管线<ul><li>屏幕追踪</li><li>软光追</li><li>表面缓存</li><li>硬光追</li><li>追踪表现</li></ul></li><li>最终聚集</li><li>反射</li><li>表现和可扩展性</li></ul><h3 id="光追管线">光追管线</h3><p>混合光追管线：屏幕追踪 -&gt; 硬光追 / 软光追（取决于配置）-&gt;天空光（未击中）。</p><p>每种追踪方法从上一个方法停止的地方开始。</p><h4 id="屏幕追踪">屏幕追踪</h4><p>屏幕追踪优点：</p><ul><li>光追场景和GBuffer不匹配，需要其解决</li><li>处理主要追踪方法未表示的几何类型，比如蒙皮网格</li><li>适用于任何比例，对细节GI有效</li></ul><p>屏幕追踪使用线性步长会跳过薄物体。因此，使用HZB（Hierarchical ZBuffer）遍历，具体是Closet HZB mips无堆栈遍历。</p><p>屏幕追踪结束后，一些光线已经解决，移除空的追踪通道，进行压缩后再运行下一个追踪路径。</p><h4 id="软光追">软光追</h4><p>无法代替硬光追，但是可以做出不同的权衡。</p><p>基元（Primitive）</p><ul><li>网格距离场</li><li>景观高度场</li></ul><p>基元存储在两层结构中，底层是基元，顶层是扁平的实例描述符数组。</p><p>在网格导入期间生成网格距离场(性能：~0.6ms建造1.5M三角形网格）。使用Embree点查询找到最近三角形距离，从每个体素投射64条光线计算命中数来决定是否在几何体内部。在mip映射的虚拟体积纹理中存储一个窄带距离场，以节省内存。</p><p>每一帧调度一个着色器遍历所有实例，着色器由每个距离场到摄像机的距离计算mip级别。然后将请求下载到CPU。</p><p>距离场存储在一个固定大小的池中，由简单的线性分配器管理。</p><p>使用mipmap加速光线行进，步数限制为64。击中后用6个采样点的中心差分计算几何法线，用来在表面缓存中采样材质和光照。</p><p>景观被分成多个组件，每个组件的表面缓存有一个高度场。顶层处理与网格距离场相同，底层对高度场进行光线行进，尝试找到零交叉点。找到两个样本后，一个在高度场上方，一个在高度场下方，在它们之间进行线性插值找到最终击中点。在击中点根据不透明度决定是接受还是继续追踪。接受后评估表面缓存计算光线辐射率。</p><p><strong>Mesh SDF -&gt; Global SDF</strong></p><p>BVH和网格等加速结构对于长不连贯光线来说太慢了，需要检查每一个重叠的网格。仅在追踪短光线时使用这个办法。</p><p>只对光线的第一段（2m）进行精确的场景表示，之后切换到粗糙的场景表示。在运行时合并实例，全局距离场将所有网格距离场和高度场合并为一组以相机为中心的裁剪图。这消耗巨大，使用缓存加速场景修改时所做的更新。</p><p>追踪全局距离场时，从最小的开始遍历clipmaps，对每一个进行光线行进，直到击中。</p><p><strong>SDF追踪存在的问题和解决方法</strong></p><ol type="1"><li>许多网格没有关闭，会产生负区域。在4个体素后插入负区域。</li><li>受分辨率限制，小于两个体素之间距离的薄网格距离场无法正确计算。在运行时扩展距离场，为避免扩展导致的过度遮挡，需要使用表面偏差逃离表面，打破接触阴影（P48-P54）。</li></ol><h4 id="表面缓存">表面缓存</h4><p>SDF没有顶点属性，只有位置、法线和网格实例。需要使用表面缓存缓存材质、光照、多次反弹。</p><p><strong>材质</strong></p><p>对于Lumen，使用投影卡片（cards）——均匀的矩形面元簇。卡片是基于投影的，不需要用顶点属性评估。可以在运行时捕获和缩放，无需烘焙。</p><p>在网格导入期间进行预计算（性能：~0.2ms to build a large 1.5M trimesh）。所有卡片都是轴对齐的，简化生成和查找。</p><p>将输入的网格的三角形数据体素化为轴对齐面元，对面元进行聚类，聚类转化为卡片。如果网格太难展开或太小，回退到像投影一样的6边立方体贴图。</p><p>使用网格和材质数据填充卡片，之后将其投影到表面上。</p><p><strong>光照</strong></p><p>使用缓存，每帧仅更新表面缓存的一个子集。对于全局辐射场使用体素照明。</p><p><strong>优点和缺点</strong></p><p>快速评估光照和材质，同时对软光追和硬光追有用。高质量的多次反弹。</p><p>体素照明太粗糙了。表面层数量有限制。</p><h4 id="硬光追">硬光追</h4><p>硬光追在Lumen中的初始部署是为了反射。可以直接将UE4的光追反射模型集成进来，但是它缺少正确的镜面发射遮挡，造成未加阴影的天空光。</p><p>使用表面缓存管线，用一个最近命中着色器替换一组依赖于材质的最近命中着色器，这个着色器只获取提取几何法线和表面缓存参数化所需的数据。然后光线着色器将光照应用为法线加权表面缓存评估。</p><p>UE4需要64字节来存储用于动态光照的类似GBuffer参数（BaseColor、Normal、Roughness、Opacity、Specular等），而表面缓存管道只需要20个字节来存储查询表面缓存照明所需的参数。</p><p>表面缓存管线简化了着色器绑定表的构造，绑定循环不再需要依赖于材质的资源。（P97）</p><p>对于以下3个部分：</p><ul><li>Albedo</li><li>Direct Lighting</li><li>Indirect Lighting</li></ul><p>在用于速度的Surface Cache光照配置中，全部使用表面缓存。</p><p>在用于质量的HitLighting光照配置中，前两者动态评估，后者使用表面缓存。(仅反射使用)</p><p>因为强制BVH中的所有对象不透明以避免使用任意命中着色器，对于部分不透明的几何体，需要采用额外的策略。对于半透明材料，完全跳过这些网格，对于alpha蒙版材质，评估表面缓存不透明度并跳过不透明度低于50%的网格。由于省略任意命中着色器，因此每当遇到部分不透明的表面时，必须迭代遍历光线生成着色器中的场景。此迭代计数由MaxTranslucentSkipCount着色器参数控制。</p><p>DXR内联光追。（P105）</p><p>通过矩阵觉醒讲解了硬光追过程中遇到的问题和解决方法，特别是介绍了从高质量近场几何级联到低质量远场几何的几何表示。（P106-P130）</p><p>管线结构：</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-12-02-HWRT.png" /></p><h4 id="追踪表现">追踪表现</h4><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-12-02-tracing-tradeoffs.png" /></p><p>软光追</p><ul><li>快但质量很低</li><li>适合高度重叠的网格（kitbashing）</li></ul><p>硬光追</p><ul><li>高质量但慢</li><li>适合镜面反射和蒙皮网格</li></ul><h3 id="最终聚集">最终聚集</h3><p>预过滤圆锥追踪高效地解决了噪声，但是无法完全解决漏光或者过度遮挡，永远无法解决远处小窗户的照明问题，只适用于软光追。</p><p>使用蒙特卡洛积分将质量提升至最高，将噪声问题交给最终聚集解决。</p><p><strong>屏幕空间辐射缓存</strong></p><p>实际上是自适应下采样。从放置在屏幕像素上的探针开始追踪，将它们的辐射内插到同一平面内的任何其他像素。</p><p>在帧上抖动探针的放置网格，随时间累积以获得良好的覆盖。</p><p><strong>不透明最终聚集</strong></p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-12-02-opaque-final-gather.png" /></p><p>最终聚集技术利用不同距离照明承受的延迟不同这一特点，将辐射分离到不同范围，使用不同技术解决。</p><p>通过时间累积利用屏幕空间辐射缓存允许的延迟，通过复用之前帧的所有探针利用世界辐射缓存允许的延迟，而天空光只需要在许多帧中缓慢更新就可以了。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-12-02-caching-by-distance.png" /></p><p><strong>半透明和雾GI挑战</strong></p><ul><li><p>必须支持任意数量的发光半透明层</p></li><li><p>雾的可见深度范围内的任何地方都需要GI</p></li><li><p>体积 vs 表面</p></li><li><p>比不透明的预算小得多</p></li></ul><p>体积最终聚集覆盖了带有探针体积（froxel 网格）的视锥体。</p><ol type="1"><li>追踪八面体探针并跳过通过 HZB 测试确定的不可见探针。</li><li>在跟踪找到辐射率后，对辐射率进行空间过滤和时间累积以减少噪声。</li><li>预先集成到球谐辐照度和前向半透明Pass（或体积雾Pass）中，对辐照度进行插值。</li></ol><p>为远距离照明使用另一个世界空间辐射缓存。</p><h3 id="反射">反射</h3><p>对于反射，基于 Tomasz Stachowiak的精彩演讲，使用基于屏幕空间去噪的随机集成。</p><ol type="1"><li>通过对可见 GGX波瓣的重要性采样生成光线，然后使用光追管道追踪光线。</li><li>使用空间重用Pass查看屏幕空间邻居并根据它们的 BRDF重新加权它们。</li><li>进行时间累积。</li><li>进行双边滤波以清除任何剩余的噪声。</li></ol><p>Dealing with incoherency（P182-P184）</p><p>反射管线基于tile，因此能够非常有效地跳过重复使用漫射光线的天空和区域。这很重要，因为管线中有许多分派，在跟踪管道中甚至更多，可以只在屏幕上需要工作的部分进行操作。实际上多次运行整个反射管道，具体取决于场景。至少为不透明运行一次，可能为半透明反射和水反射再次运行它，所以只在需要它的屏幕部分上运行很重要。</p><p><strong>半透明反射挑战</strong></p><ul><li>需要支持任意层数，而且不能直接从像素着色器中追踪。需要在像素着色器之外解决它们，然后插值到像素着色器中。</li><li>玻璃需要镜面反射，所以不能在那里做任何插值。</li></ul><p>为了提供玻璃反射，使用深度剥离将半透明的最前层提取到最小的 GBuffer中，然后再次运行反射管线，仅在有效像素上运行，并禁用降噪器以减少管线开销。</p><p>对于其余层，使用与不透明最终聚集相同的辐射缓存，只需要放置更多的探针。通过以低分辨率光栅化半透明表面来标记新探针，然后在每个像素位置标记所需的探针。然后用任意数量的层光栅化半透明，它们的像素着色器从辐射缓存插值以获得光泽反射。</p><h3 id="表现和可扩展性">表现和可扩展性</h3><p>P191-P196</p><h1 id="nanite-siggraph-course">Nanite / SIGGRAPH course</h1><p>2021 SIGGRAPH course 里的一节，<ahref="https://advances.realtimerendering.com/s2021/index.html">A DeepDive into Nanite Virtualized Geometry</a></p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-12-03-Nanite-pre.png"alt="Nanite-pre" /><figcaption aria-hidden="true">Nanite-pre</figcaption></figure><p>目标</p><blockquote><p>Getting on my soapbox for a second, I think as an industry we shouldbe working more on how to make high fidelity games cheaper than weare.</p></blockquote><p>虚拟几何比虚拟纹理要难很多：</p><ul><li>不仅需要内存管理</li><li>几何细节直接影响渲染成本</li><li>几何不是平凡可过滤的</li></ul><h2 id="几何表示形式">几何表示形式</h2><p><strong>体素</strong></p><p>体素化网格是将矢量图形转化为像素图形的3D等价物，意味着准确率下降。精细采样意味着数据量大大增加。另外，使用体素代替网格意味着要改变整个CG工作流程，纹理、材质、工具等等。</p><p><strong>细分表面</strong></p><p>对于创作的艺术家来说不能做到所见即所得，渲染成本与艺术家的选择挂钩。</p><p><strong>位移贴图</strong></p><p>无法处理镂空几何等情况（增加亏格（genus））。</p><p>几何图像本质上类似于相对于原点而不是另一个表面的矢量位移图。</p><p><strong>点</strong></p><p>需要解决连通性等问题。</p><p><strong>三角形</strong></p><p>Nanite的核心</p><h2 id="sota三角形渲染管线">SOTA三角形渲染管线</h2><p>UE的渲染器是保留模式设计，场景的完整版本存储在显存中跨帧保留。在事情发生变化的地方稀疏更新。</p><p>所有Nanite网格数据存在单个大资源中，可以直接触碰，不需要无绑定资源来这样做。</p><p>对于每个视图，都可以在单个调度中确定可见实例。如果只绘制深度，可以在一次DrawIndirect中光栅化所有三角形。</p><h3 id="遮挡剔除">遮挡剔除</h3><p>将三角形分组为簇并为每个簇构建一个边界框，然后可以根据它们的边界剔除簇。针对HZB使用遮挡剔除，从边界计算屏幕矩形，针对屏幕矩形小于4X4的最低mip进行测试。</p><p>如果获取HZB？2 Pass 遮挡剔除：</p><ul><li>渲染上一帧可见的内容</li><li>从中建立HZB</li><li>测试HZB，确认现在可见但在上一帧不可见的内容，绘制任何新内容</li></ul><h3 id="可见性与材质解耦">可见性与材质解耦</h3><p>目的是消除光栅化期间材质的切换、过度绘制、密集网格的像素四边形低效率。</p><p>使用可见性缓存，将<code>Depth : InstanceID : TriangleID</code>形式的数据写入屏幕。</p><ol type="1"><li><p>加载可见性缓存</p></li><li><p>加载三角形数据</p></li><li><p>转换顶点位置到屏幕</p></li><li><p>导出像素重心坐标</p></li><li><p>对顶点属性插值</p></li></ol><blockquote><p>作者：在屏幕缓存 IMO 中存储任何顶点属性（如 UV或法线）不再是可见性缓存，那些我称之为延迟纹理。</p></blockquote><p>通常，可见性缓存方法会将材质评估与着色相结合，但这里写入GBuffer。这是为了与延迟着色渲染器的其余部分集成。</p><p>现在只需要一个drawcall绘制所有不透明几何，CPU成本与场景中对象数量无关，材质是逐着色器绘制，但远少于对象。不需要更多次光栅化来减少过度绘制。</p><h3 id="簇层次树">簇层次树</h3><p><strong>次线性缩放</strong></p><p>渲染成本应该与屏幕分辨率成比例，而不是场景复杂性。每帧绘制相同数量的簇，而不管有多少对象或它们有多密集。</p><p>使用簇层次树规划<strong>LOD</strong>，运行时找到与所需 LOD相匹配的树的切割，也就是说同一网格的不同部分可以根据需要处于不同的细节级别。这是基于簇的屏幕空间投影误差以视图相关的方式完成的。如果我们您无法从这个角度分辨出差异，那么父母节点将代替其孩子节点，简化细节。</p><p>不需要在内存中存整棵树，可以在任何时候将树的一部分标记为叶子节点，并且不将它之后的任何内容存储在RAM 中。就像虚拟纹理一样，根据需要请求数据。</p><p>但是，当独立的簇做出不同的 LOD决策并且它们边界处的边缘不再匹配时，就会形成<strong>裂缝</strong>。可以在简化过程中锁定集群之间的共享边界边，但共享边的簇很多，并且边界上聚集了密集的三角形。好的方法是对簇进行分组，每组做出相同的LOD决策。</p><p>其它可能的裂缝解决方案（P40-P44）。</p><p>构建树时，首先构建叶子节点（128个三角形），然后对于每个 LOD级别：</p><ol type="1"><li><p>将聚类<strong>分组</strong>以清理它们的共享边界</p></li><li><p>将组中的三角形<strong>合并</strong>到一个共享列表中</p></li><li><p><strong>简化</strong>三角形数量的一半</p></li><li><p>然后将简化的三角形列表<strong>拆分</strong>回聚类（128个三角形）</p></li></ol><p>重复此过程，直到有根部只剩下 1 个簇。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-12-03-Nanite-build-op.png" /></p><p><strong>合并</strong>和<strong>拆分</strong>步骤使其其实是<strong>DAG</strong>而不是树。所以从LOD0绘制到根必穿过边，不会有锁定的边界保持锁定并收集碎片。</p><p>如何决定对哪些集群进行分组？将共享边界边最多的边分组，因为边界边越少，锁定的边就越少。锁定边越少越好，因为锁定边限制简化步骤减少三角形。</p><p>这个问题被称为<strong>图划分</strong>。图划分算法将图划分为指定数量的分区，使得从一个分区到另一个分区的所有边的总权重（称为边切割成本）最小化。</p><p>在这里的例子中，图节点是簇。边连接具有直接连接的相邻三角形的簇。边权重是这些簇之间共享的三角形边的数量。为空间上接近但不连接的簇添加额外的边，以确保图中没有任意分组的岛。该图的最小割边（edgecut）对应于该级别网格中锁定边的最小数量，这基本上是要优化的理想对象。</p><p>图划分是一项非常复杂的任务，有一些现有的库可以用来完成它。这里使用流行的METIS库。</p><p>如何构建叶子节点？这是一个多维优化问题：</p><ul><li>为了提高剔除效率，需要最小化聚类边界范围</li><li>使用光栅化器时，每个簇的三角形数量需要接近但不超过128个</li><li>顶点数不能超过使用图元着色器的限制</li><li>最小化簇之间的边界边的数量，再给简化器尽可能多的未锁定边，以允许它完成工作</li></ul><p>对第2个维度优化，尽可能解决其它问题。构建叶子节点与构建树的第4步<strong>拆分</strong>实际上是一样的。</p><p>与之前的工作对比（P53）。</p><p><strong>简化</strong>步骤使用典型的边缘折叠抽取。</p><p>未来的工作（P60-P61）。</p><h3 id="运行时视点相关lod">运行时视点相关LOD</h3><p>运行时每一帧都需要根据视图选择要绘制的簇。</p><p>根据屏幕空间误差决定LOD，一个组的簇做相同的决定。</p><p>整个图的LOD决策其实就是切分DAG。切割发生在父节点的误差太高，但子节点的误差小到足以有效绘制的地方（因此需要沿路径的误差函数是单调的）。这是本地操作，可以并行计算。</p><p>为了保证运行时簇无缝切换，只选择误差小于1像素的簇绘制。</p><p>层次剔除（P69-P74）。</p><p>当为LOD进行所有这些剔除时，也应该根据可见性进行剔除。之前的2 Pass遮挡方法存在一个问题：跟踪先前可见的集合会使一帧到一帧的LOD选择变得复杂，这可能是不同的，并且由于流式传输，上一帧的可见簇可能不再存在于内存中。因此，测试当前选定的簇在最后一帧中是否可见。为了做到这一点，使用前面的变换，根据前一帧的HZB测试它们的边界。</p><p>更新后的2 Pass 遮挡剔除：</p><ul><li>使用先前的变换测试先前的HZB</li><li>绘制可见内容，保存遮挡以备以后使用</li><li>然后从深度缓存构建此帧的初始HZB</li><li>使用此HZB，再次测试我们认为被遮挡的内容</li><li>绘制现在可见但以前被遮挡的内容</li><li>最后，从现在完整的深度缓存构建完整的HZB，以便在下一帧中使用。</li></ul><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-12-03-culling-dataflow.png" /></p><ol type="1"><li>使用前一帧的HZB测试来评估遮挡。它从GPUScene的实例开始，以每个实例为基础评估可见性。</li><li>可见实例转到持久线程分层集群筛选。这同时执行LOD和可见性，并输出可见簇。</li><li>将其光栅化到可见性缓存。</li><li>HZB是基于刚刚光栅化的内容为当前帧构建的。</li><li>重复所有剔除阶段，其中基于先前帧信息发现被遮挡的实例、节点和簇用当前帧HZB和当前帧变换重新测试。</li><li>有了完整的可见性缓存，我们为下一帧构建HZB，并应用延迟材质Pass。</li></ol><h3 id="光栅化">光栅化</h3><p>因为硬光栅对于Nanite要用的小三角形来说效率很低，使用软光栅。最快的图元着色器实现平均速度比硬件快3倍。对于纯微聚合物情况甚至更多，如果与旧的VS/PS路径相比则更多。</p><p>放弃硬光栅会丢失ROP（Raster OperationsUnits）和深度测试硬件，但仍然需要Z-Buffer。使用64b原子，高位有深度（深度测试），低位有有效载荷（可见簇索引和三角形索引）。</p><p>InterlockedMax</p><table><thead><tr class="header"><th>30</th><th>27</th><th>7</th></tr></thead><tbody><tr class="odd"><td>深度</td><td>可见簇索引</td><td>三角形索引</td></tr></tbody></table><p>Micropoly 软光栅化器：</p><ul><li><p>在结构上类似于网格着色器。</p></li><li><p>共享顶点工作，无需任何变换后缓存。</p></li><li><p>线程组大小为128。在第一阶段，一个线程被映射到簇顶点缓存中的一个顶点。获取顶点位置，对其进行变换，并存储在组共享中。如果超过128个，则获取并转换另一个以支持每个簇最多256个。在第二阶段切换到映射到一个三角形的一个线程，每个簇最多128个三角形。获取该三角形的索引。使用它们从组共享中获取变换后的位置。</p></li><li><p>计算三角形的边缘方程和深度梯度。对于三角形边界矩形内的所有像素。测试是否在三角形内，如果在三角形内则写入像素</p></li></ul><p>软光栅三角形长度小于32像素的任何簇。对大三角形等不会更快的情况使用硬光栅。DirectX对光栅化规则有非常严格的规范。我们可以精确匹配硬件，这意味着软光栅簇和硬光栅簇之间没有像素裂缝。</p><p>过度绘制（P93）。</p><p>小实例优化（P95-P97）。</p><h3 id="延迟材质评估">延迟材质评估</h3><p>可以绘制一个覆盖屏幕的四边形，解码可见性缓存<code>Depth : InstanceID : TriangleID</code>并评估材质像素着色器，就像它在光栅化期间绑定一样。</p><p>VisibleCluster =&gt; InstanceID, ClusterID</p><p>ClusterID + TriangleID =&gt; MaterialSlotID</p><p>InstanceID + MaterialSlotID =&gt; MaterialID</p><h3 id="阴影">阴影</h3><p>真实几何体和法线贴图之间最大的视觉差异通常来自于详细的自阴影。</p><p>Nanite支持正常的阴影贴图绘制，但这种新架构支持以前不实用的新技术。现在对所有内容都使用16k 阴影贴图。根据光的类型，可能会有一个或多个阴影贴图。</p><p>如果阴影贴图的那个区域没有投射到屏幕上的任何东西上，就不会绘制它。与优化阴影渲染的更常见方法相比，不仅剔除了光栅化工作，甚至不为不打算采样的阴影贴图空间分配内存。</p><h3 id="流">流</h3><p>几何体的虚拟内存类比在概念上与虚拟纹理非常相似，但细节不同、存在一些独特的挑战。类似之处在于GPU在发现质量不足时请求数据，而CPU通过从磁盘加载数据来异步完成这些请求；不同之处在于，当加载和卸载数据时，需要确保它始终是整个DAG的有效切割，几何体中才不会出现裂缝。</p><p>为避免内存碎片，我们希望使用固定大小的页面，但这也意味着我们必须在每页中容纳可变数量的几何图形。为了避免渲染不正确，用至少高于组的粒度填充固定大小的页面。在决定将哪些组放在同一页面上时，会考虑DAG中的空间局部性和级别。这些都是为了尽量减少运行时可能需要的页面数量。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-12-04-Nanite-page.png"alt="Nanite-page" /><figcaption aria-hidden="true">Nanite-page</figcaption></figure><p>第一个页面，即根页面，总是驻留的，并且包含页面中可以容纳的尽可能多的DAG 顶部。总是有根页面意味着我们总是有东西要呈现。常驻页面存储在 GPU上的一个大 ByteAddressBuffer 中。</p><p>组可能非常大，因此用整个组填充页面会导致大量松弛。以簇粒度将组分成多个部分。因为在加载其所有兄弟节点之前无法绘制集群，所以拆分组仅在加载其所有部分时才被视为活跃的。</p><h3 id="压缩">压缩</h3><p>对于Nanite，实际上有两种压缩的几何格式。它们表示相同的数据，但针对不同的目标进行了优化。</p><p><strong>内存表示</strong>是渲染代码在光栅化期间和延迟材质过程中直接使用的表示。这需要在解码和随机访问时接近即时，因为可以从可见性缓存查找中请求任何三角形。这里的目标是降低流媒体池所需的内存。即使我们有足够的内存来烧录，将更多的数据放入缓存也意味着更少的缓存未命中，这意味着更少IO和弹出的机会。</p><p><strong>磁盘表示</strong>是磁盘中的数据表示，当数据流进来时，它会被转码为内存表示。这种格式不需要随机访问，因为流传输的频率低于渲染，所以我们可以在这里提供更先进的技术。</p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
            <tag> UE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形API中的矩阵表示与运算</title>
      <link href="//posts/Article/matrix-in-graphics-API/"/>
      <url>//posts/Article/matrix-in-graphics-API/</url>
      
        <content type="html"><![CDATA[<p>图形API范畴</p><span id="more"></span><h1 id="左乘与右乘">左乘与右乘</h1><p>用列向量<span class="math inline">\(x\)</span>右乘矩阵<spanclass="math inline">\(A\)</span>： <span class="math display">\[\begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}=x_1\begin{bmatrix}a_{11}\\a_{21}\\a_{31}\end{bmatrix}+x_2\begin{bmatrix}a_{12}\\a_{22}\\a_{32}\end{bmatrix}+x_3\begin{bmatrix}a_{13}\\a_{23}\\a_{33}\end{bmatrix}\]</span> 相当于列向量<spanclass="math inline">\(x\)</span>每一项作为系数对矩阵<spanclass="math inline">\(A\)</span>中的列向量线性组合。</p><p>用行向量<span class="math inline">\(x\)</span>左乘矩阵<spanclass="math inline">\(A\)</span>： <span class="math display">\[\begin{bmatrix}x_1 &amp;x_2 &amp;x_3\end{bmatrix}\begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\end{bmatrix}=x_1\begin{bmatrix}a_{11} &amp;a_{12} &amp;a_{13}\end{bmatrix}+x_2\begin{bmatrix}a_{21} &amp;a_{22} &amp;a_{23}\end{bmatrix}+x_3\begin{bmatrix}a_{31} &amp;a_{32} &amp;a_{33}\end{bmatrix}\]</span> 相当于行向量<spanclass="math inline">\(x\)</span>每一项作为系数对矩阵<spanclass="math inline">\(A\)</span>中的行向量线性组合。</p><p>矩阵<span class="math inline">\(A\)</span>和矩阵<spanclass="math inline">\(B\)</span>的乘法，可以看作<spanclass="math inline">\(B\)</span>右乘<spanclass="math inline">\(A\)</span>： <span class="math display">\[\begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\end{bmatrix}\begin{bmatrix}b_{11} &amp; b_{12} &amp; b_{13}\\b_{21} &amp; b_{22} &amp; b_{23}\\b_{31} &amp; b_{32} &amp; b_{33}\end{bmatrix}=\begin{bmatrix}b_{11}\begin{bmatrix}a_{11}\\a_{21}\\a_{31}\end{bmatrix}+b_{21}\begin{bmatrix}a_{12}\\a_{22}\\a_{32}\end{bmatrix}+b_{31}\begin{bmatrix}a_{13}\\a_{23}\\a_{33}\end{bmatrix}&amp;b_{12}\begin{bmatrix}a_{11}\\a_{21}\\a_{31}\end{bmatrix}+b_{22}\begin{bmatrix}a_{12}\\a_{22}\\a_{32}\end{bmatrix}+b_{32}\begin{bmatrix}a_{13}\\a_{23}\\a_{33}\end{bmatrix}&amp;b_{13}\begin{bmatrix}a_{11}\\a_{21}\\a_{31}\end{bmatrix}+b_{23}\begin{bmatrix}a_{12}\\a_{22}\\a_{32}\end{bmatrix}+b_{33}\begin{bmatrix}a_{13}\\a_{23}\\a_{33}\end{bmatrix}\end{bmatrix}\]</span> 也可以看作<span class="math inline">\(A\)</span>左乘<spanclass="math inline">\(B\)</span>： <span class="math display">\[\begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\end{bmatrix}\begin{bmatrix}b_{11} &amp; b_{12} &amp; b_{13}\\b_{21} &amp; b_{22} &amp; b_{23}\\b_{31} &amp; b_{32} &amp; b_{33}\end{bmatrix}=\begin{bmatrix}a_{11}[b_{11} &amp;b_{12} &amp;b_{13}] +a_{12}[b_{21} &amp;b_{22}&amp;b_{23}]  +a_{13}[b_{31} &amp;b_{32} &amp;b_{33}] \\a_{21}[b_{11} &amp;b_{12} &amp;b_{13}] +a_{22}[b_{21} &amp;b_{22}&amp;b_{23}]  +a_{23}[b_{31} &amp;b_{32} &amp;b_{33}] \\a_{31}[b_{11} &amp;b_{12} &amp;b_{13}] +a_{32}[b_{21} &amp;b_{22}&amp;b_{23}]  +a_{33}[b_{31} &amp;b_{32} &amp;b_{33}]\end{bmatrix}\]</span></p><h1 id="行优先与列优先">行优先与列优先</h1><p>同样将一维元素数组表示为矩阵，<strong>列优先</strong>矩阵指矩阵中的元素是按列解释的，<strong>行优先</strong>矩阵指矩阵中的元素是按行解释的。两种矩阵可以通过转置相互转换。（也翻译为行主序和列主序）</p><p>例如数组<spanclass="math inline">\(m_{11}m_{12}m_{13}m_{14}m_{21}m_{22}m_{23}m_{24}m_{31}m_{32}m_{33}m_{34}m_{41}m_{42}m_{43}m_{44}\)</span></p><p>解释为行优先矩阵 <span class="math display">\[\mathbf{M}=\begin{bmatrix} m_{11} &amp; m_{12} &amp; m_{13} &amp; m_{14}\\m_{21} &amp; m_{22} &amp; m_{23} &amp; m_{24} \\m_{31} &amp; m_{32} &amp; m_{33} &amp; m_{34}\\m_{41} &amp; m_{42} &amp; m_{43} &amp; m_{44}\end{bmatrix}\]</span> 解释为列优先矩阵 <span class="math display">\[\mathbf{M}=\begin{bmatrix} m_{11} &amp; m_{21} &amp; m_{31} &amp; m_{41}\\m_{12} &amp; m_{22} &amp; m_{32} &amp; m_{42} \\m_{13} &amp; m_{23} &amp; m_{33} &amp; m_{43}\\m_{14} &amp; m_{24} &amp; m_{34} &amp; m_{44} \end{bmatrix}\]</span></p><h1 id="不同图形api下的情况">不同图形API下的情况</h1><p>前面讲了左乘与右乘、行优先与列优先，这两者在数学概念上是没有关系的。可以用列向量右乘一个行优先矩阵或者列优先矩阵，没什么限制，但是翻译为汇编代码后可以看出在实现上有区别。</p><h2 id="directx">DirectX</h2><p>DirectXMath中的的<code>XMFLOAT4</code>和<code>XMVECTOR</code>均是行向量。</p><p>向量与矩阵相乘需要使用函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">XMVECTOR XM_CALLCONV <span class="hljs-title">XMVector4Transform</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] FXMVECTOR V,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] FXMMATRIX M</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><p>在DirectX中，矩阵乘法的顺序是从左到右，变换生效的先后顺序也是从左到右。</p><p>DirectXMath中的<code>XMFLOAT4X4</code>和<code>XMMATRIX</code>均是<strong>行优先</strong>矩阵，它的数据流如下：</p><p><spanclass="math inline">\(m_{11}m_{12}m_{13}m_{14}m_{21}m_{22}m_{23}m_{24}m_{31}m_{32}m_{33}m_{34}m_{41}m_{42}m_{43}m_{44}\)</span></p><p>传递到HLSL后，若是传递给cb0的寄存器的前4个向量，那么它内存布局一定如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">cb0[<span class="hljs-number">0</span>].xyzw = (m11, m12, m13, m14);<br>cb0[<span class="hljs-number">1</span>].xyzw = (m21, m22, m23, m24);<br>cb0[<span class="hljs-number">2</span>].xyzw = (m31, m32, m33, m34);<br>cb0[<span class="hljs-number">3</span>].xyzw = (m41, m42, m43, m44);<br></code></pre></td></tr></table></figure><p>而在HLSL中，默认的<code>matrix</code>或<code>float4x4</code>采用的是<strong>列优先</strong>矩阵。</p><p>假设在HLSL的<code>cbuffer</code>为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">cbuffer cb : <span class="hljs-keyword">register</span>(b0)<br>&#123;<br>    (row_major) matrix g_World;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<code>g_World</code>是<code>matrix</code>或<code>float4x4</code>类型，由于是列优先矩阵，上面的4个寄存器存储的数据会被看作：<span class="math display">\[\begin{bmatrix}m_{11} &amp; m_{21} &amp; m_{31} &amp; m_{41} \\m_{12} &amp; m_{22} &amp; m_{32} &amp; m_{42} \\m_{13} &amp; m_{23} &amp; m_{33} &amp; m_{43} \\m_{14} &amp; m_{24} &amp; m_{34} &amp; m_{44} \\\end{bmatrix}\]</span>如果<code>g_World</code>是<code>row_major matrix</code>或<code>row_major float4x4</code>类型，则为行优先矩阵，上面的4个寄存器存储的数据则依然被视作：<span class="math display">\[\begin{bmatrix}m_{11} &amp; m_{12} &amp; m_{13} &amp; m_{14} \\m_{21} &amp; m_{22} &amp; m_{23} &amp; m_{24} \\m_{31} &amp; m_{32} &amp; m_{33} &amp; m_{34} \\m_{41} &amp; m_{42} &amp; m_{43} &amp; m_{44} \\\end{bmatrix}\]</span>因此，将矩阵从DirectX传递到HLSL中时需要注意，可能要经过转置。</p><p>HLSL中的<strong><code>mul</code>函数</strong>，<code>mul(x,y)</code>：</p><ul><li><p>要求矩阵x的列数与矩阵y的行数相等。</p></li><li><p>如果x是一个向量，那么它将被解释为行向量。</p></li><li><p>如果y是一个向量，那么它将被解释为列向量。</p></li></ul><p>它使用<code>dp4</code>指令优化运算。对于<code>dp4</code>来说，最好是能够对一个<strong>行向量</strong>和<strong>列优先矩阵</strong>(取列优先矩阵的列，也就是取一行寄存器向量与行向量做点乘)操作，又或者是对一个<strong>行优先矩阵</strong>(取行优先矩阵的行与列向量做点乘)和<strong>列矩阵</strong>操作，这样能避免转置。</p><p>4种正常传递与运算矩阵的情况：</p><blockquote><ol type="1"><li><p>C++代码端不进行转置，HLSL中使用<code>row_major matrix</code>(行优先矩阵)，mul函数让向量放在左边(行向量)，这样实际运算就是(行向量X 行优先矩阵)。这种方法易于理解，但是这样做dp4运算取矩阵的列很不方便，在HLSL中会产生用于转置矩阵的大量指令，性能上有损失。</p></li><li><p>C++代码端进行转置，HLSL中使用<code>matrix</code>(列优先矩阵)，mul函数让向量放在左边(行向量)，这样就是(行向量 X列优先矩阵)，但C++这边需要进行一次矩阵转置，HLSL内部不产生转置。这是<strong>官方例程</strong>所使用的方式，这样可以使得dp4运算可以直接取列主序矩阵的行，从而避免内部产生大量的转置指令。<ahref="https://directx11.tech/#/">教程</a>的项目也使用这种方式。</p></li><li><p>C++代码端不进行转置，HLSL中使用<code>matrix</code>(列主序矩阵)，mul函数让向量放在右边(列向量)，实际运算是(列主序矩阵X列向量)。这种方法的确可行，取列矩阵的行也比较方便，效率上又和2等同，就是HLSL那边的矩阵乘法都要反过来写，然而DX本身就是崇尚行主矩阵的，把OpenGL的习惯带来这边有点。。。</p></li><li><p>C++代码端进行转置，HLSL中使用<code>row_major matrix</code>(行主序矩阵)，mul函数让向量放在右边(列向量)，实际运算是(行主序矩阵X 列向量)。就算这种方法也可以绘制出来，但还是很让人难受，比第2点还难受，我甚至不想去说它。</p></li></ol><p>引用自[1]</p></blockquote><p>值得一提的是，按照矩阵预算律，对于矩阵<spanclass="math inline">\(A\)</span>和列向量<spanclass="math inline">\(x\)</span>，<span class="math inline">\(A\timesx\)</span>等价于<span class="math inline">\((x^{T} \timesA^{T})^{T}\)</span>。由于<code>mul</code>函数会自动对向量进行转置，所以可以通过调换矩阵和向量的顺序避免手动转置矩阵，<spanclass="math inline">\(mul(x,A^{T})\)</span>等价于<spanclass="math inline">\(mul(A,x)\)</span>。</p><h2 id="unity-shader">Unity Shader</h2><p>UnityShader用名为ShaderLab的声明性语言编写，实现了跨平台。其中的<code>CGPROGRAM</code>代码片段是用常规 HLSL/Cg着色语言编写</p><p>在UnityShader中，通常在变换顶点时，使用列向量右乘矩阵进行乘法，因为Unity提供的内置矩阵（如UNITY_MATRIX_MVP等）都是按列存储的。但有时也会使用左乘的方式，因为可以省去对矩阵转置的操作（<spanclass="math inline">\(Ax=(x^TA^T)^T\)</span>）。</p><p>Unity在脚本中提供了一种矩阵类型——Matrix4x4。脚本中的这个矩阵类型则是采用<strong>列优先</strong>的方式。UnityShader中Cg的矩阵采用<strong>行优先</strong>。</p><h2 id="其它图形api">其它图形API</h2><p>矩阵在OpenGL和GLSL中都是列优先的，不像DirectX和HLSL前者行优先、后者列优先。</p><h1 id="参考资料">参考资料</h1><p>[1] <ahref="https://www.cnblogs.com/X-Jun/p/9808727.html#_lab2_1_0">DirectX11--HLSL中矩阵的内存布局和mul函数探讨- X_Jun - 博客园 (cnblogs.com)</a></p><p>[2]《Unity Shader 入门精要》</p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Unity Shader入门精要》笔记</title>
      <link href="//posts/Notebook/Unity-Shader-note/"/>
      <url>//posts/Notebook/Unity-Shader-note/</url>
      
        <content type="html"><![CDATA[<p>冯乐乐 著</p><span id="more"></span><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-UnityShader入门精要_s.jpg"alt="封面" /><figcaption aria-hidden="true">封面</figcaption></figure><p><ahref="https://github.com/candycat1992/Unity_Shaders_Book">代码仓库</a></p><p class="note note-primary">摘录整理。</p><p class="note note-info">我的实验环境：Windows 10, Unity 2020.3.26f1c1</p><h1 id="前言">前言</h1><p>概括来说，Unity Shader是Shader上层的一个抽象。</p><h1 id="第1篇-基础篇">第1篇 基础篇</h1><h2 id="第1章-欢迎来到shader的世界">第1章 欢迎来到shader的世界</h2><p>我们之所以会觉得学习Shader比学习C#这样的编程语言更加困难，一个原因是因为Shader需要牵扯到整个渲染流程。当学习C++、C#这样的高级语言时，我们可以在不了解计算机架构的情况下仍然编写出实现各种功能的代码，这样的高级语言更符合人类的思维方式。然而，Shader并不是这样的。我们之所以要学习Shader，是想要学习如何把物体按照自己的意愿渲染到屏幕上，但是，Shader只是整个渲染流程中的一个子部分。虽然它很关键，但想要学习它，我们就需要了解整个渲染流程是如何进行的。和C++这样的高级语言不同，尽管Shader的编写语言已经达到了我们可以理解的程度，但Shader更多地是面向GPU的工作方式，所以它的一些语法对我们来说并不那么直观。</p><h2 id="第2章-渲染流水线">第2章 渲染流水线</h2><h3 id="综述">2.1 综述</h3><p>《Render-Time Rendering, ThirdEdition》一书中将一个渲染流程分成3个<strong>概念</strong>阶段：</p><ul><li><p>应用阶段（Application Stage）</p><p>这个阶段由应用主导，通常由CPU负责实现。</p><ul><li>准备好场景数据</li><li>culling</li><li>设置材质、纹理、shader</li><li>输出渲染图元</li></ul></li><li><p>几何阶段（Geometry Stage）</p><p>负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作。通常在GPU上进行。</p><ul><li>通过对输入的渲染图元进行多步处理后，这一阶段将会输出屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一个阶段。</li></ul></li><li><p>光栅化阶段（Rasterizer Stage）</p><p>决定每个渲染图元中的哪些像素应该被绘制在屏幕上，在GPU上运行。</p><ul><li>对上一个阶段得到的逐顶点数据（例如纹理坐标、顶点颜色等）进行插值，然后再进行逐像素处理。</li></ul></li></ul><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-渲染流水线中的3个概念阶段.jfif"alt="渲染流水线中的3个概念阶段" /><figcaption aria-hidden="true">渲染流水线中的3个概念阶段</figcaption></figure><h3 id="cpu和gpu之间的通信">2.2 CPU和GPU之间的通信</h3><p>渲染流水线的起点是CPU，即应用阶段。应用阶段大致可分为下面3个阶段：</p><p>（1）把数据加载到显存中。</p><p>（2）设置渲染状态。</p><p>（3）调用Draw Call。</p><h3 id="gpu流水线">2.3 GPU流水线</h3><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-GPU-render-pipeline.jfif"alt="GPU的渲染流水线实现" /><figcaption aria-hidden="true">GPU的渲染流水线实现</figcaption></figure><ol type="1"><li><p>顶点着色器（VertexShader）是完全可编程的，它通常用于实现顶点的<strong>空间变换、顶点着色</strong>等功能。一个最基本的顶点着色器必须完成的一个工作是，把顶点坐标<strong>从模型空间转换到齐次裁剪空间</strong>，接着通常再由硬件做透视除法后，最终得到归一化的设备坐标（NormalizedDevice Coordinates , NDC）。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-变换到齐次裁剪坐标空间.jfif"alt="变换到齐次裁剪坐标空间" /><figcaption aria-hidden="true">变换到齐次裁剪坐标空间</figcaption></figure><p><strong>图中给出的坐标范围是OpenGL同时也是Unity使用的NDC，它的z分量范围在[-1,1]之间，而在DirectX中，NDC的z分量范围是[0, 1]。</strong></p></li><li><p>曲面细分着色器（TessellationShader）是一个可选的着色器，它用于细分图元。</p></li><li><p>几何着色器（GeometryShader）同样是一个可选的着色器，它可以被用于执行逐图元（Per-Primitive）的着色操作，或者被用于产生更多的图元。</p></li><li><p>裁剪（Clipping）的目的是将那些不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片。这个阶段是可配置的。例如，我们可以使用自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角图元的正面还是背面。</p></li><li><p>屏幕映射（ScreenMapping）是不可配置和编程的，它负责把每个图元的坐标转换到屏幕坐标系中。<strong>OpenGL把屏幕的左下角当成最小的窗口坐标值，而DirectX则定义了屏幕的左上角为最小的窗口坐标值。</strong></p></li><li><p>三角形设置（Triangle Setup）和三角形遍历（TriangleTraversal）阶段都是固定函数（Fixed-Function）的阶段。以三角形网格表示数据，找到哪些像素被三角网格覆盖。对应像素会生成一个片元，而片元中的状态是对3个顶点的信息迚行插值得到的。</p></li><li><p>片元着色器（FragmentShader）是完全可编程的，它用于实现逐片元（Per-Fragment）的着色操作。在DirectX中，片元着色器被称为<strong>像素着色器</strong>（PixelShader），但片元着色器是一个更合适的名字，因为此时的片元并不是一个真正意义上的像素。为了在片元着色器中进行<strong>纹理采样</strong>，我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理坐标进行插值后，就可以得到其覆盖的片元的纹理坐标。其局限在于仅可以影响单个片元，不可以将自己的任何结果直接发送给它的邻居们。有一个情况例外，就是片元着色器可以访问到导数信息（gradient，或者说是derivative）。</p></li><li><p>逐片元操作（Per-FragmentOperations）阶段负责执行很多重要的操作，例如修改颜色、深度缓冲、进行混合等，它不是可编程的，但具有很高的可配置性。<strong>逐片元操作（Per-FragmentOperations）是OpenGL中的说法，在DirectX中，这一阶段被称为输出合并阶段（Output-Merger）。</strong></p><p>片元 -&gt; 模板测试-&gt; 深度测试-&gt; 混合 -&gt; 颜色缓冲区</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-模板测试和深度测试.jfif"alt="模板测试和深度测试" /><figcaption aria-hidden="true">模板测试和深度测试</figcaption></figure><p>对于不透明物体，开发者可以关闭混合（Blend）操作。这样片元着色器计算得到的颜色值就会直接覆盖掉颜色缓冲区中的像素值。但对于半透明物体，我们就需要使用混合操作来让这个物体看起来是透明的。</p><p>将深度测试提前执行的技术通常也被称为Early-Z技术。</p></li><li><p>为了避免我们看到那些正在进行光栅化的图元，GPU会使用双重缓冲（DoubleBuffering）的策略。这意味着，对场景的渲染是在幕后发生的，即在后置缓冲（BackBuffer）中。一旦场景已经被渲染到了后置缓冲中，GPU就会交换后置缓冲区和前置缓冲（FrontBuffer）中的内容，而前置缓冲区是之前显示在屏幕上的图像。</p></li></ol><h3 id="一些容易困惑的地方">2.4 一些容易困惑的地方</h3><p>OpenGL和DirectX是图像应用编程接口，在硬件的基础上实现了一层抽象。这些接口用于渲染二维或三维图形。</p><p>一个应用程序向这些接口发送渲染命令，而这些接口会依次向显卡驱动（GraphicsDriver）发送渲染命令，这些显卡驱动是真正知道如何和GPU通信的角色，正是它们把OpenGL或者DirectX的函数调用翻译成了GPU能够听懂的语言，同时它们也负责把纹理等数据转换成GPU所支持的格式。</p><p>着色语言是专门用于编写着色器的，常见的着色语言有DirectX的HLSL（HighLevel Shading Language）、OpenGL的GLSL（OpenGL ShadingLanguage）以及NVIDIA的CG（C forGraphic）。HLSL、GLSL、CG都是“高级（High-Level）”语言，但这种高级是相对于汇编语言来说的，而不是像C#相对于C的高级那样。这些语言会被编译成与机器无关的汇编语言，也被称为中间语言（IntermediateLanguage,IL）。这些中间语言再交给显卡驱动来翻译成真正的机器语言，即GPU可以理解的语言。</p><p>在游戏开发过程中，为了减少DrawCall的开销，有两点需要注意。（1）避免使用大量很小的网格。当不可避免地需要使用很小的网格结构时，考虑是否可以合并它们。（2）避免使用过多的材质。尽量在不同的网格之间共用同一个材质。</p><h3 id="那么你明白什么是shader了吗">2.5那么，你明白什么是Shader了吗</h3><p>Shader就是：</p><ul><li>GPU流水线上一些可高度编程的阶段，而由着色器编译出来的最终代码是会在GPU上运行的（对于固定管线的渲染来说，着色器有时等同于一些特定的渲染设置）；</li><li>有一些特定类型的着色器，如顶点着色器、片元着色器等；</li><li>依靠着色器我们可以控制流水线中的渲染细节，例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</li></ul><h2 id="第3章-unity-shader基础">第3章 Unity Shader基础</h2><h3 id="unity-shader概述">3.1 Unity Shader概述</h3><p>使用流程：</p><p>（1）创建一个材质；</p><p>（2）创建一个Unity Shader，并把它赋给上一步中创建的材质；</p><p>（3）把材质赋给要渲染的对象；</p><p>（4）在材质面板中调整Unity Shader的属性，以得到满意的效果。</p><p>在Unity 5.2及以上版本中，Unity一共提供了4种UnityShader模板供我们选择——Standard Surface Shader, Unlit Shader, ImageEffect Shader以及Compute Shader。</p><h3 id="unity-shader的基础shaderlab">3.2 UnityShader的基础：ShaderLab</h3><p>Unity Shader是Unity为开发者提供的高层级的渲染抽象层。</p><p>从设计上来说，ShaderLab类似于CgFX和Direct3DEffects（.FX）语言，它们都定义了要显示一个材质所需的所有东西，而不仅仅是着色器代码。</p><p>Unity在背后会根据使用的平台来把这些结构编译成真正的代码和Shader文件，而开发者只需要和UnityShader打交道即可。</p><h3 id="unity-shader的结构">3.3 Unity Shader的结构</h3><p>一个Unity Shader的基础结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//第一行都需要通过Shader语义来指定该Unity Shader的名字。</span><br><span class="hljs-comment">//通过在字符串中添加斜杠（“/”），可以控制Unity Shader在材质面板中出现的位置。</span><br>Shader  <span class="hljs-string">&quot;category/ShaderName&quot;</span>  &#123;            <br>    Properties  &#123;              <br>        <span class="hljs-comment">// 属性            </span><br>    &#125;            <br>    SubShader  &#123;                <br>        <span class="hljs-comment">// 显卡A使用的子着色器            </span><br>    &#125;            <br>    SubShader  &#123;                <br>        <span class="hljs-comment">// 显卡B使用的子着色器            </span><br>    &#125;            <br>    Fallback  <span class="hljs-string">&quot;VertexLit&quot;</span>        <br>&#125;<br></code></pre></td></tr></table></figure><p>这些属性将会出现在材质面板中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader  <span class="hljs-string">&quot;Custom/ShaderLabProperties&quot;</span>  &#123;<br>    Properties  &#123;<br>        <span class="hljs-comment">//  Name  (&quot;display  name&quot;,  PropertyType)  =  DefaultValue</span><br>        <span class="hljs-comment">//  Numbers  and  Sliders              </span><br>        _Int  (<span class="hljs-string">&quot;Int&quot;</span>,  Int)  =  <span class="hljs-number">2</span>              <br>        _Float  (<span class="hljs-string">&quot;Float&quot;</span>,  Float)  =  <span class="hljs-number">1.5</span>              <br>        _Range(<span class="hljs-string">&quot;Range&quot;</span>,  Range(<span class="hljs-number">0.0</span>,  <span class="hljs-number">5.0</span>))  =  <span class="hljs-number">3.0</span>              <br>        <span class="hljs-comment">//  Colors  and  Vectors              </span><br>        _Color  (<span class="hljs-string">&quot;Color&quot;</span>,  Color)  =  (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)             <br>        _Vector  (<span class="hljs-string">&quot;Vector&quot;</span>,  Vector)  =  (<span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">1</span>)              <br>        <span class="hljs-comment">//  Textures              </span><br>        _2D  (<span class="hljs-string">&quot;2D&quot;</span>,  <span class="hljs-number">2</span>D)  =  <span class="hljs-string">&quot;&quot;</span>  &#123;&#125;              <br>        _Cube  (<span class="hljs-string">&quot;Cube&quot;</span>,  Cube)  =  <span class="hljs-string">&quot;white&quot;</span>  &#123;&#125;              <br>        _3D  (<span class="hljs-string">&quot;3D&quot;</span>,  <span class="hljs-number">3</span>D)  =  <span class="hljs-string">&quot;black&quot;</span>  &#123;&#125;            <br>    &#125;            <br>    FallBack  <span class="hljs-string">&quot;Diffuse&quot;</span>        <br>&#125;<br></code></pre></td></tr></table></figure><p>每一个UnityShader文件可以包含多个SubShader语义块，但最少要有一个。当Unity需要加载这个UnityShader时，Unity会扫描所有的SubShader语义块，然后选择第一个能够在目标平台上运行的SubShader。如果都不支持的话，Unity就会使用<strong>Fallback</strong>语义指定的UnityShader。也可以使用Fallback Off关闭Fallback功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">SubShader  &#123;            <br>    <span class="hljs-comment">// 可选的            </span><br>    [Tags]            <br>    <span class="hljs-comment">// 可选的            </span><br>    [RenderSetup]            <br>    Pass  &#123;            <br>    &#125;            <br>    <span class="hljs-comment">//  Other  Passes        </span><br>&#125;<br></code></pre></td></tr></table></figure><p>SubShader中定义了一系列<strong>Pass</strong>以及可选的<strong>状态</strong>（[RenderSetup]）和<strong>标签</strong>（[Tags]）设置。</p><p>每个Pass定义了一次完整的渲染流程，但如果Pass的数目过多，往往会造成渲染性能的下降。因此，我们应尽量使用最小数目的Pass。</p><p>状态和标签同样可以在Pass声明。对于状态设置来说语法相同，SubShader得设置会用于所有的Pass。但是，SubShader中的一些标签设置是特定的，这些标签设置和Pass中使用的标签不一样。</p><p><strong>状态</strong></p><p>ShaderLab提供了一系列渲染状态的设置指令，这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-常见的渲染状态设置选项.jfif"alt="常见的渲染状态设置选项" /><figcaption aria-hidden="true">常见的渲染状态设置选项</figcaption></figure><p><strong>标签</strong></p><p>标签是一个键值对，它的键和值都是字符串类型。这些键值对是SubShader和渲染引擎之间的沟通桥梁。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-SubShader-tag-type.jfif"alt="SubShader的标签类型" /><figcaption aria-hidden="true">SubShader的标签类型</figcaption></figure><p><strong>Pass</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">Pass  &#123;            <br>    [Name]            <br>    [Tags]            <br>    [RenderSetup]            <br>    <span class="hljs-comment">//  Other  code        </span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Name  <span class="hljs-string">&quot;MyPassName&quot;</span><br></code></pre></td></tr></table></figure><p>通过这个名称，我们可以使用ShaderLab的UsePass命令来直接使用其他UnityShader中的Pass。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">UsePass  <span class="hljs-string">&quot;MyShader/MYPASSNAME&quot;</span><br></code></pre></td></tr></table></figure><p>由于Unity内部会把所有Pass的名称转换成大写字母的表示，因此，在使用UsePass命令时必须使用<strong>大写形式的名字</strong>。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-pass-tag-type.jfif"alt="Pass的标签类型" /><figcaption aria-hidden="true">Pass的标签类型</figcaption></figure><p>Unity Shader还支持一些特殊的Pass:</p><ul><li>UsePass：如我们之前提到的一样，可以使用该命令来复用其他UnityShader中的Pass</li><li>GrabPass：该Pass负责抓取屏幕并将结果存储在一张纹理中，以用于后续的Pass处理</li></ul><h3 id="unity-shader的形式">3.4 Unity Shader的形式</h3><p>表面着色器是Unity对顶点/片元着色器的更高一层的抽象。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader  <span class="hljs-string">&quot;Custom/Simple  Surface  Shader&quot;</span>  &#123;            <br>    SubShader  &#123;<br>        Tags  &#123;  <span class="hljs-string">&quot;RenderType&quot;</span>  =  <span class="hljs-string">&quot;Opaque&quot;</span>  &#125;<br>        CGPROGRAM<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span>  surface  surf  Lambert</span><br>        <span class="hljs-keyword">struct</span>  Input  &#123;<br>        float4  color  :  COLOR;<br>        &#125;;              <br>        <span class="hljs-type">void</span>  <span class="hljs-title function_">surf</span>  <span class="hljs-params">(Input  IN,  inout  SurfaceOutput  o)</span>  &#123;<br>        o.Albedo  =  <span class="hljs-number">1</span>;              <br>        &#125;              <br>        ENDCG            <br>    &#125;            <br>Fallback  <span class="hljs-string">&quot;Diffuse&quot;</span>        <br>&#125;<br></code></pre></td></tr></table></figure><p>表面着色器被定义在SubShader语义块（而非Pass语义块）中的CGPROGRAM和ENDCG之间。原因是，表面着色器不需要开发者关心使用多少个Pass、每个Pass如何渲染等问题，Unity会在背后为我们做好这些事情。</p><p>CGPROGRAM和ENDCG之间的代码是使用CG/HLSL编写的，它的语法和标准的CG/HLSL语法几乎一样，但还是有细微的不同，例如有些原生的函数和用法Unity并没有提供支持。</p><p>一个非常简单的顶点/片元着色器示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader  <span class="hljs-string">&quot;Custom/Simple  VertexFragment  Shader&quot;</span>  &#123;<br>SubShader  &#123;              <br>    Pass  &#123;                <br>            CGPROGRAM                  <br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span>  vertex  vert                  </span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span>  fragment  frag                  </span><br>            float4  <span class="hljs-title function_">vert</span><span class="hljs-params">(float4  v  :  POSITION)</span>  :  SV_POSITION  &#123;                      <br>                <span class="hljs-keyword">return</span>  mul  (UNITY_MATRIX_MVP,  v);                  <br>            &#125;                  <br>            fixed4  <span class="hljs-title function_">frag</span><span class="hljs-params">()</span>  :  SV_Target  &#123;                      <br>                <span class="hljs-keyword">return</span>  fixed4(<span class="hljs-number">1.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>);                 <br>            &#125;                  <br>            ENDCG              <br>        &#125;            <br>    &#125;        <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="附录">附录</h3><p>在传统的Shader中，我们仅可以编写特定类型的Shader，例如顶点着色器、片元着色器等。而在UnityShader中，我们可以在同一个文件里同时包含需要的顶点着色器和片元着色器代码。</p><p>在传统的Shader中，我们无法设置一些渲染设置，例如是否开启混合、深度测试等，这些是开发者在另外的代码中自行设置的。而在UnityShader中，我们通过一行特定的指令就可以完成这些设置。</p><p>在传统的Shader中，我们需要编写冗长的代码来设置着色器的输入和输出，要小心地处理这些输入输出的位置对应关系等。而在UnityShader中，我们只需要在特定语句块中声明一些属性，就可以依靠材质来方便地改变这些属性。而且对于模型自带的数据（如顶点位置、纹理坐标、法线等）,UnityShader也提供了直接访问的方法，不需要开发者自行编码来传给着色器。</p><h2 id="第4章-学习shader所需的数学基础">第4章学习Shader所需的数学基础</h2><h3 id="unity-shader的内置变量数学篇">4.8 UnityShader的内置变量（数学篇）</h3><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-Unity内置的变换矩阵.jfif"alt="Unity内置的变换矩阵" /><figcaption aria-hidden="true">Unity内置的变换矩阵</figcaption></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-Unity内置的摄像机和屏幕参数.jfif"alt="Unity内置的摄像机和屏幕参数" /><figcaption aria-hidden="true">Unity内置的摄像机和屏幕参数</figcaption></figure><h3 id="附录-1">附录</h3><p>通常在变换顶点时，我们都是使用右乘的方式来按列矩阵进行乘法。这是因为，Unity提供的内置矩阵（如UNITY_MATRIX_MVP等）都是按列存储的。但有时，我们也会使用左乘的方式，这是因为可以省去对矩阵转置的操作（<spanclass="math inline">\(Ax=(x^TA^T)^T\)</span>）。</p><p>Unity在脚本中提供了一种矩阵类型——Matrix4x4。脚本中的这个矩阵类型则是采用列优先的方式。这与UnityShader中的规定不一样。</p><blockquote><p>参见<ahref="https://reddish.fun/posts/Article/%E5%9B%BE%E5%BD%A2API%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/">图形API中的矩阵表示与运算- Homeworld</a></p></blockquote><p>OpenGL和DirectX10以后的版本认为<strong>像素中心</strong>对应的是浮点值中的0.5。VPOS/WPOS语义定义的输入是一个float4类型的变量。我们已经知道它的xy值代表了在屏幕空间中的像素坐标。如果屏幕分辨率为400× 300，那么x的范围就是[0.5,400.5],y的范围是[0.5,300.5]。(VPOS是HLSL中对屏幕坐标的语义，而WPOS是CG中对屏幕坐标的语义。)</p><p>在Unity中，VPOS/WPOS的z分量范围是[0,1]，在摄像机的近裁剪平面处，z值为0，在远裁剪平面处，z值为1。对于w分量，我们需要考虑摄像机的投影类型。如果使用的是透视投影，那么w分量的范围是<spanclass="math inline">\([\frac{1}{Near},\frac{1}{Far}]\)</span>,Near和Far对应了在Camera组件中设置的近裁剪平面和远裁剪平面距离摄像机的远近；如果使用的是正交投影，那么w分量的值恒为1。</p><h1 id="第2篇-初级篇">第2篇 初级篇</h1><h2 id="第5章-开始unity-shader学习之旅">第5章 开始UnityShader学习之旅</h2><h3 id="本书使用的软件和环境">5.1 本书使用的软件和环境</h3><p>本书使用的Unity版本是Unity 5.2.1免费版。</p><p>本书工程编写的系统环境是Mac OS X10.9.5。如果读者使用的是其他系统，绝大部分情况也不会有任何问题。但有时会由于图像编程接口的种类和版本不同而有一些差别，这是因为Mac使用的图像编程接口是基于OpenGL的，而其他平台如Windows，可能使用的是DirectX。例如，在OpenGL中，渲染纹理（RenderTexture）的(0, 0)点是在左下角，而在DirectX中，(0, 0)点是在左上角。</p><p>这本书是2016年写的，比较老了。这里我使用<strong>2020.3.26f1c1</strong>。</p><h3 id="一个最简单的顶点片元着色器">5.2 一个最简单的顶点/片元着色器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Upgrade <span class="hljs-doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span><br><br>Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 5/Simple Shader&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>&#125;<br>SubShader &#123;<br>        Pass &#123;<br>            CGPROGRAM<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br>            <br>            uniform fixed4 _Color;<br>            <span class="hljs-comment">//定义顶点着色器的输入，由使用该材质的Mesh Render组件提供</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>                <span class="hljs-comment">//POSITION语义：顶点坐标</span><br>                float4 vertex : POSITION;<br>                <span class="hljs-comment">//NORMAL语义：法线方向</span><br>float3 normal : NORMAL;<br>                <span class="hljs-comment">//TEXCOORD0语义：第一套纹理坐标</span><br>float4 texcoord : TEXCOORD0;<br>            &#125;;<br>            <br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>                float4 pos : SV_POSITION;<br>                fixed3 color : COLOR0;<br>            &#125;;<br>            <br>            v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            o.color = v.normal * <span class="hljs-number">0.5</span> + fixed3(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>            fixed3 c = i.color;<br>            c *= _Color.rgb;<br>                <span class="hljs-keyword">return</span> fixed4(c, <span class="hljs-number">1.0</span>);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果1.png"alt="结果1" /><figcaption aria-hidden="true">结果1</figcaption></figure><h3 id="强大的援手unity提供的内置文件和变量">5.3强大的援手：Unity提供的内置文件和变量</h3><p>包含文件（includefile），是类似于C++中头文件的一种文件。在Unity中，它们的文件后缀是．cginc。在编写Shader时，我们可以使用#include指令把这些文件包含进来，这样我们就可以使用Unity为我们提供的一些非常有用的变量和帮助函数。</p><p>CGIncludes文件夹在Mac上位于：/Applications/Unity/Unity.app/Contents/CGIncludes；在Windows上位于：Unity的安装路径/Data/CGIncludes。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-Unity-using.jfif"alt="Unity中一些常用的包含文件" /><figcaption aria-hidden="true">Unity中一些常用的包含文件</figcaption></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-UnityCG.cginc-struct.jfif"alt="UnityCG.cginc中一些常用的结构体" /><figcaptionaria-hidden="true">UnityCG.cginc中一些常用的结构体</figcaption></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-UnityCG.cginc-helper-func.jfif"alt="UnityCG.cginc中一些常用的帮助函数" /><figcaptionaria-hidden="true">UnityCG.cginc中一些常用的帮助函数</figcaption></figure><h3 id="unity提供的cghlsl语义">5.4 Unity提供的CG/HLSL语义</h3><p>语义可以让Shader知道从哪里读取数据，并把数据输出到哪里，它们在CG/HLSL的Shader流水线中是不可或缺的。需要注意的是，Unity并没有支持所有的语义。</p><p>在DirectX10以后，有了一种新的语义类型，就是系统数值语义（system-valuesemantics）。这类语义是以SV开头的，SV代表的含义就是系统数值（system-value）。这些语义在渲染流水线中有特殊的含义。例如在上面的代码中，我们使用SV_POSITION语义去修饰顶点着色器的输出变量pos，那么就表示pos包含了可用于光栅化的变换后的顶点坐标（即齐次裁剪空间中的坐标）。用这些语义描述的变量是不可以随便赋值的，因为流水线需要使用它们来完成特定的目的，例如渲染引擎会把用SV_POSITION修饰的变量经过光栅化后显示在屏幕上。</p><blockquote><p>一些Shader会使用POSITION而非SV_POSITION来修饰顶点着色器的输出。SV_POSITION是DirectX10中引入的系统数值语义，在绝大多数平台上，它和POSITION语义是等价的，但在某些平台（例如索尼PS4）上必须使用SV_POSITION来修饰顶点着色器的输出，否则无法让Shader正常工作。同样的例子还有COLOR和SV_Target。因此，为了让我们的Shader有更好的跨平台性，对于这些有特殊含义的变量我们最好使用以SV开头的语义进行修饰。</p></blockquote><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-从应用阶段传递模型数据给顶点着色器时Unity支持的常用语义.jfif"alt="从应用阶段传递模型数据给顶点着色器时Unity支持的常用语义" /><figcaptionaria-hidden="true">从应用阶段传递模型数据给顶点着色器时Unity支持的常用语义</figcaption></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-从顶点着色器传递数据给片元着色器时Unity使用的常用语义.jfif"alt="从顶点着色器传递数据给片元着色器时Unity使用的常用语义" /><figcaptionaria-hidden="true">从顶点着色器传递数据给片元着色器时Unity使用的常用语义</figcaption></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-片元着色器输出时Unity支持的常用语义.jfif"alt="片元着色器输出时Unity支持的常用语义" /><figcaptionaria-hidden="true">片元着色器输出时Unity支持的常用语义</figcaption></figure><h3 id="程序员的烦恼debug">5.5 程序员的烦恼：Debug</h3><p>Shader可以直接使用颜色代表数据进行可视化来Debug。也可以借助帧调试器一类的工具。</p><h3 id="小心渲染平台的差异">5.6 小心：渲染平台的差异</h3><p>在OpenGL（OpenGL ES也是）中，(0,0)点对应了屏幕的左下角，而在DirectX（Meta l也是）中，(0,0)点对应了左上角。</p><p>大多数情况下，这样的差异并不会对我们造成任何影响。但当我们要使用<strong>渲染到纹理技术</strong>，把屏幕图像渲染到一张渲染纹理中时，如果不采取行任何措施的话，就会出现纹理翻转的情况。幸运的是，Unity在背后为我们处理了这种翻转问题——当在DirectX平台上使用渲染到纹理技术时，Unity会为我们翻转屏幕图像纹理，以便在不同平台上达到一致性。</p><p>如果我们需要同时处理多张渲染图像（前提是开启了抗锯齿），例如需要同时处理屏幕图像和法线纹理，这些图像在竖直方向的朝向就可能是不同的（只有在DirectX这样的平台上才有这样的问题）。</p><h3 id="shader整洁之道">5.7 Shader整洁之道</h3><p>CG/HLSL中3种精度的数值类型</p><table><thead><tr class="header"><th>类型</th><th>精度</th></tr></thead><tbody><tr class="odd"><td>float</td><td>最高精度，通常32位存储</td></tr><tr class="even"><td>half</td><td>中等精度，通常16位存储，精度范围-60000~+60000</td></tr><tr class="odd"><td>fixed</td><td>最低精度，通常11位存储，精度范围-2.0~+2.0</td></tr></tbody></table><p>ShaderModel是由微软提出的一套规范，通俗地理解就是它们决定了Shader中各个特性（feature）的能力（capability）。这些特性和能力体现在Shader能使用的运算指令数目、寄存器个数等各个方面。ShaderModel等级越高，Shader的能力就越大。</p><p>GPU使用了不同于CPU的技术来实现分支语句，在最坏的情况下，我们花在一个分支语句的时间相当于运行了所有分支语句的时间。因此，我们不鼓励在Shader中使用流程控制语句，因为它们会降低GPU的并行处理操作（尽管在现代的GPU上已经有了改进）。</p><h2 id="第6章-unity中的基础光照">第6章 Unity中的基础光照</h2><h3 id="我们是如何看到这个世界的">6.1 我们是如何看到这个世界的</h3><p><strong>着色</strong>（shading）指的是，根据材质属性（如漫反射属性等）、光源信息（如光源方向、辐照度等），使用一个等式去计算沿某个观察方向的出射度的过程。我们也把这个等式称为光照模型（LightingModel）。</p><p>当给定模型表面上的一个点时，BRDF包含了对该点外观的完整的描述。在图形学中，<strong>BRDF</strong>（BidirectionalReflectance DistributionFunction）大多使用一个数学公式来表示，并且提供了一些参数来调整材质属性。通俗来讲，当给定入射光线的方向和辐照度后，BRDF可以给出在某个出射方向上的光照能量分布。</p><p>本章涉及的BRDF都是对真实场景进行理想化和简化后的模型，也就是说，它们并不能真实地反映物体和光线之间的交互，这些光照模型被称为是<strong>经验模型</strong>。</p><h3 id="标准光照模型">6.2 标准光照模型</h3><p>虽然光照模型有很多种类，但在早期的游戏引擎中往往只使用一个光照模型，这个模型被称为<strong>标准光照模型</strong>。实际上，在BRDF理论被提出之前，标准光照模型就已经被广泛使用了。</p><blockquote><p>在1975年，著名学者裴祥风（Bui TuongPhong）提出了标准光照模型背后的基本理念。标准光照模型只关心直接光照（directlight），也就是那些直接从光源发射出来照射到物体表面后，经过物体表面的一次反射直接进入摄像机的光线。</p></blockquote><p>它把进入到摄像机内的光线分为4个部分，每个部分使用一种方法来计算它的贡献度:</p><ul><li><p><strong>自发光</strong>（emissive）部分，本书使用cmissive来表示。这个部分用于描述当给定一个方向时，一个表面本身会向该方向发射多少辐射量。需要注意的是，如果没有使用全局光照（globalillumination）技术，这些自发光的表面并不会真的照亮周围的物体，而是它本身看起来更亮了而已。</p></li><li><p><strong>漫反射</strong>（diffuse）部分，本书使用cdiffuse来表示。这个部分用于描述，当光线从光源照射到模型表面时，该表面会向每个方向散射多少辐射量。</p><p>因为反射完全随机，可以认为在任何反射方向上的分布都是一样的，因此入射光线的角度很重要。</p><p>漫反射光照符合兰伯特定律（Lambert'slaw）：反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比。 <spanclass="math display">\[c_{diffuse}=(c_{light}·m_{diffuse})\max(0,\hat{n}·\hat{l})\]</span> <spanclass="math inline">\(c_{light}\)</span>是光源颜色，<spanclass="math inline">\(m_{diffuse}\)</span>是材质的漫反射颜色， <spanclass="math inline">\(\hat{n}\)</span>是表面法线， <spanclass="math inline">\(\hat{l}\)</span>是指向光源的单位矢量。max防止物体被从后面来的光源照亮。</p></li><li><p><strong>高光反射</strong>（specular）部分，本书使用cspecular来表示。这个部分用于描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量。</p><p>计算高光反射需要知道表面法线<spanclass="math inline">\(\hat{n}\)</span>、视角方向<spanclass="math inline">\(\hat{v}\)</span>、光源方向<spanclass="math inline">\(\hat{l}\)</span>、反射方向<spanclass="math inline">\(\hat{r}\)</span>。反射方向可以由表面法线和光源方向计算。<span class="math display">\[\hat{r}=2(\hat{n}·\hat{I})\hat{n}-\hat{l}\]</span> 利用<strong>Phong模型</strong>来计算高光反射: <spanclass="math display">\[c_{specular}=(c_{light}·m_{specular})\max(0,\hat{v}·\hat{r})^{m_{gloss}}\]</span> <spanclass="math inline">\(m_{gloss}\)</span>是材质的光泽度（gloss），也被称为反光度（shininess）。它用于控制高光区域的“亮点”有多宽，<strong>gloss越大，亮点就越小</strong>。</p><p><strong>Blinn模型</strong>引入了一个新的矢量<spanclass="math inline">\(\hat{h}\)</span>，<spanclass="math inline">\(\hat{h}=\frac{\hat{v}+\hat{l}}{ | \hat{v}+\hat{l}| }\)</span>： <span class="math display">\[c_{specular}=(c_{light}·m_{specular})\max(0,\hat{n}·\hat{h})^{m_{gloss}}\]</span></p></li><li><p><strong>环境光</strong>（ambient）部分，本书使用cambient来表示。它用于描述其他所有的间接光照。</p><p>通常是一个全局变量，即场景中的所有物体都使用这个环境光。</p></li></ul><p><strong>逐像素光照</strong>:以每个像素为基础，得到它的法线（可以是对顶点法线插值得到的，也可以是从法线纹理中采样得到的），然后进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为Phong着色（Phongshading），也被称为Phong插值或法线插值着色技术。这不同于我们之前讲到的Phong光照模型。</p><p><strong>逐顶点光照</strong>: 被称为高洛德着色（Gouraudshading）,每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。由于顶点数目往往远小于像素数目，因此逐顶点光照的计算量往往要小于逐像素光照。但是，由于逐顶点光照依赖于线性插值来得到像素光照，因此，当光照模型中有非线性的计算（例如计算高光反射时）时，逐顶点光照就会出问题。而且，由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值，这在某些情况下会产生明显的棱角现象。</p><blockquote><p>标准光照模型有很多不同的叫法。例如，一些资料中称它为Phong光照模型，因为裴祥风（BuiTuongPhong）首先提出了使用漫反射和高光反射的和来对反射光照进行建模的基本思想，并且提出了基于经验的计算高光反射的方法（用于计算漫反射光照的兰伯特模型在那时已经被提出了）。而后，由于Blinn的方法简化了计算而且在某些情况下计算更快，我们把这种模型称为Blinn-Phong光照模型。</p></blockquote><p><strong>局限</strong>:首先，有很多重要的物理现象无法用Blinn-Phong模型表现出来，例如菲涅耳反射（Fresnelreflection）。其次，Blinn-Phong模型是各项同性（isotropic）的，也就是说，当我们固定视角和光源方向旋转这个表面时，反射不会发生任何改变。但有些表面是具有各向异性（anisotropic）反射性质的，例如拉丝金属、毛发等。</p><h3 id="unity中的环境光和自发光">6.3 Unity中的环境光和自发光</h3><p>环境光在window-&gt;Rendering-&gt;Lighting-&gt;Environment中调节。</p><p>计算自发光只需要在片元着色器输出最后的颜色之前，把材质的自发光颜色添加到输出颜色上。</p><h3 id="在unity-shader中实现漫反射光照模型">6.4 在UnityShader中实现漫反射光照模型</h3><p>逐顶点的漫反射光照着色器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Upgrade <span class="hljs-doctag">NOTE:</span> replaced &#x27;_World2Object&#x27; with &#x27;unity_WorldToObject&#x27;</span><br><span class="hljs-comment">// Upgrade <span class="hljs-doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span><br><br>Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 6/Diffuse Vertex-Level&quot;</span> &#123;<br>Properties &#123;<br>_Diffuse (<span class="hljs-string">&quot;Diffuse&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>&#125;<br>SubShader &#123;<br>Pass &#123; <br>            <span class="hljs-comment">//定义该Pass在Unity的光照流水线中的角色</span><br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>fixed4 _Diffuse;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>fixed3 color : COLOR;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br><span class="hljs-comment">// Transform the vertex from object space to projection space</span><br>o.pos = UnityObjectToClipPos(v.vertex);<br><br><span class="hljs-comment">// Get ambient term</span><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br><span class="hljs-comment">// Transform the normal from object space to world space</span><br>fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));<br><span class="hljs-comment">// Get the light direction in world space</span><br>fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);<br><span class="hljs-comment">// Compute diffuse term</span><br>fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight));<br><br>o.color = ambient + diffuse;<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br><span class="hljs-keyword">return</span> fixed4(i.color, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125;<br>FallBack <span class="hljs-string">&quot;Diffuse&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，管线会自动在顶点着色器和片元着色器之间进行插值。</p><p>逐像素的漫反射光照着色器类似，只是把颜色的计算放在了片元着色器中。</p><p>半兰伯特光照模型： <span class="math display">\[c_{diffuse}=(c_{light}·m_{diffuse})(0.5(\hat{n}·\hat{I})+0.5)\]</span> 不使用max，而是把<spanclass="math inline">\(\hat{n}·\hat{I}\)</span>从<spanclass="math inline">\([-1,1]\)</span>映射到<spanclass="math inline">\([0,1]\)</span>。没有任何物理依据，仅仅是一个视觉加强技术。</p><p>左起逐顶点漫反射光照、逐像素漫反射光照、逐像素半兰伯特光照：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果2.png"alt="结果2" /><figcaption aria-hidden="true">结果2</figcaption></figure><h3 id="在unity-shader中实现高光反射光照模型">6.5 在UnityShader中实现高光反射光照模型</h3><p>该部分主干代码与上节相同，把计算公式换掉即可。</p><p>包括逐顶点的高光反射光照、逐像素的高光反射光照（Phong光照模型）和Blinn-Phong高光反射光照。</p><h3 id="召唤神龙使用unity内置的函数">6.6召唤神龙：使用Unity内置的函数</h3><p>以下列举了三处内置函数替代手动计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 6/Blinn-Phong Use Built-in Functions&quot;</span> &#123;<br>Properties &#123;<br>_Diffuse (<span class="hljs-string">&quot;Diffuse&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Specular (<span class="hljs-string">&quot;Specular&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (<span class="hljs-string">&quot;Gloss&quot;</span>, Range(<span class="hljs-number">1.0</span>, <span class="hljs-number">500</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Pass &#123; <br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>fixed4 _Diffuse;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float4 worldPos : TEXCOORD1;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br>                <span class="hljs-comment">// o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>o.worldPos = mul(unity_ObjectToWorld, v.vertex);<br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>fixed3 worldNormal = normalize(i.worldNormal);<br><span class="hljs-comment">// fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br>fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br><br>fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(<span class="hljs-number">0</span>, dot(worldNormal, worldLightDir));<br><br><span class="hljs-comment">// fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br>fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));<br>fixed3 halfDir = normalize(worldLightDir + viewDir);<br>fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(max(<span class="hljs-number">0</span>, dot(worldNormal, halfDir)), _Gloss);<br><br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack <span class="hljs-string">&quot;Specular&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第7章-基础纹理">第7章 基础纹理</h2><p>纹理最初的目的就是使用一张图片来控制模型的外观。使用<strong>纹理映射</strong>（texturemapping）技术，我们可以把一张图“黏”在模型表面，逐纹素（texel）（纹素的名字是为了和像素进行区分）地控制模型的颜色。</p><p>在美术人员建模的时候，通常会<strong>在建模软件中利用纹理展开技术把纹理映射坐标（texture-mappingcoordinates）存储在每个顶点上</strong>。纹理映射坐标定义了该顶点在纹理中对应的2D坐标。通常，这些坐标使用一个二维变量(u,v)来表示，其中u是横向坐标，而v是纵向坐标。因此，纹理映射坐标也被称为<strong>UV坐标</strong>，通常都被归一化到[0,1]范围内。对于不在[0,1]范围内的纹理坐标，与之关系紧密的是纹理的平铺模式。</p><h3 id="单张纹理">7.1 单张纹理</h3><p>通常会使用一张纹理来代替物体的漫反射颜色。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 7/Single Texture&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_MainTex (<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Specular (<span class="hljs-string">&quot;Specular&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (<span class="hljs-string">&quot;Gloss&quot;</span>, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Pass &#123; <br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>fixed4 _Color;<br>sampler2D _MainTex;<br>            <span class="hljs-comment">//在Unity中，我们需要使用纹理名_ST的方式来声明某个纹理的属性。其中，ST是缩放（scale）和平移（translation）的缩写。_MainTex_ST可以让我们得到该纹理的缩放和平移（偏移）值，_MainTex_ST.xy存储的是缩放值，而_MainTex_ST.zw存储的是偏移值。这些值可以在材质面板的纹理属性中调节。</span><br>float4 _MainTex_ST;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float3 worldPos : TEXCOORD1;<br>float2 uv : TEXCOORD2;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br><span class="hljs-comment">// Or just call the built-in function o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed3 worldNormal = normalize(i.worldNormal);<br>fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br><br><span class="hljs-comment">// Use the texture to sample the diffuse color</span><br>fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="hljs-number">0</span>, dot(worldNormal, worldLightDir));<br><br>fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));<br>fixed3 halfDir = normalize(worldLightDir + viewDir);<br>fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(max(<span class="hljs-number">0</span>, dot(worldNormal, halfDir)), _Gloss);<br><br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack <span class="hljs-string">&quot;Specular&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果3.png"alt="结果3" /><figcaption aria-hidden="true">结果3</figcaption></figure><p>Wrap Mode :一种是Repeat，在这种模式下，如果纹理坐标超过了1，那么它的整数部分将会被舍弃，而直接使用小数部分进行采样，这样的结果是纹理将会不断重复；另一种是Clamp，在这种模式下，如果纹理坐标大于1，那么将会截取到1，如果小于0，那么将会截取到0。</p><p>Filter Mode : Point模式使用了最近邻（nearestneighbor）滤波，在放大或缩小时，它的采样像素数目通常只有一个，因此图像会看起来有种像素风格的效果。而Bilinear滤波则使用了线性滤波，对于每个目标像素，它会找到4个邻近像素，然后对它们进行线性插值混合后得到最终像素，因此图像看起来像被模糊了。而Trilinear滤波几乎是和Bilinear一样的，只是Trilinear还会在多级渐远纹理之间进行混合。如果一张纹理没有使用多级渐远纹理技术，那么Trilinear得到的结果是和Bilinear就一样的。</p><h3 id="凹凸映射">7.2 凹凸映射</h3><p><strong>凹凸映射</strong>（bumpmapping）的目的是使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节。这种方法不会真的改变模型的顶点位置，只是让模型看起来好像是“凹凸不平”的，但可以从模型的轮廓处看出“破绽”。</p><p>有两种主要的方法可以用来进行凹凸映射</p><ul><li>使用一张高度纹理（heightmap）来模拟表面位移（displacement），然后得到一个修改后的法线值，这种方法也被称为高度映射（heightmapping）</li><li>使用一张法线纹理（normalmap）来直接存储表面法线，这种方法又被称为法线映射（normalmapping）。</li></ul><p>由于法线方向的分量范围在[-1, 1]，而像素的分量范围为[0,1]，因此我们需要做一个映射将法线方向存储到法线纹理中。</p><p>法线纹理分类 :</p><ul><li><p><strong>模型空间的法线纹理</strong>（object-space normalmap）</p><ul><li><p>实现简单</p></li><li><p>这是因为模型空间下的法线纹理存储的是同一坐标系下的法线信息，因此在边界处通过插值得到的法线可以平滑变换</p></li></ul></li><li><p><strong>切线空间的法线纹理</strong>（tangent-space normalmap）</p><blockquote><p>对于模型的每个顶点，它都有一个属于自己的切线空间，这个切线空间的原点就是该顶点本身，而z轴是顶点的法线方向（n）,x轴是顶点的切线方向（t），而y轴可由法线和切线叉积而得，也被称为是副切线（bitangent,b）或副法线。</p></blockquote><ul><li>自由度很高，可以重用。模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型，而应用到其他模型上效果就完全错误了。而切线空间下的法线纹理记录的是相对法线信息，这意味着，即便把该纹理应用到一个完全不同的网格上，也可以得到一个合理的结果。</li><li>可进行UV动画。比如，我们可以移动一个纹理的UV坐标来实现一个凹凸移动的效果，但使用模型空间下的法线纹理会得到完全错误的结果。原因同上。这种UV动画在水或者火山熔岩这种类型的物体上会经常用到。</li><li>可压缩。由于切线空间下的法线纹理中法线的Z方向总是正方向，因此我们可以仅存储XY方向，而推导得到Z方向。而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储3个方向的值，不可压缩。</li></ul></li></ul><p>我们需要在计算光照模型中统一各个方向矢量所在的坐标空间。由于法线纹理中存储的法线是切线空间下的方向，因此我们通常有<strong>两种方法</strong>：</p><ol type="1"><li>在切线空间下进行光照计算，此时我们需要把光照方向、视角方向变换到切线空间下。</li><li>在世界空间下进行光照计算，此时我们需要把采样得到的法线方向变换到世界空间下，再和世界空间下的光照方向和视角方向进行计算。</li></ol><p>从效率上来说，第一种方法往往要优于第二种方法，因为我们可以在顶点着色器中就完成对光照方向和视角方向的变换，而第二种方法由于要先对法线纹理进行采样，所以变换过程必须在片元着色器中实现，这意味着我们需要在片元着色器中进行一次矩阵操作。</p><p>但从通用性角度来说，第二种方法要优于第一种方法，因为有时我们需要在世界空间下进行一些计算，例如在使用Cubemap进行环境映射时，我们需要使用世界空间下的反射方向对Cubemap进行采样。如果同时需要进行法线映射，我们就需要把法线方向变换到世界空间下。</p><p>对于第一种方法，P148在切线空间下计算法线光照一节是有问题的：<ahref="https://github.com/candycat1992/Unity_Shaders_Book/issues/45">Issue#45 · candycat1992/Unity_Shaders_Book · GitHub</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 7/Normal Map In Tangent Space&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_MainTex (<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_BumpMap (<span class="hljs-string">&quot;Normal Map&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;bump&quot;</span> &#123;&#125;<br>_BumpScale (<span class="hljs-string">&quot;Bump Scale&quot;</span>, Float) = <span class="hljs-number">1.0</span><br>_Specular (<span class="hljs-string">&quot;Specular&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (<span class="hljs-string">&quot;Gloss&quot;</span>, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Pass &#123; <br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>fixed4 _Color;<br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>sampler2D _BumpMap;<br>float4 _BumpMap_ST;<br><span class="hljs-type">float</span> _BumpScale;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br><span class="hljs-comment">// 和法线方向normal不同，tangent的类型是float4，而非float3，这是因为我们需要使用tangent.w分量来决定切线空间中的坐标轴——副切线的方向性。</span><br>float4 tangent : TANGENT;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float4 uv : TEXCOORD0;<br>float3 lightDir: TEXCOORD1;<br>float3 viewDir : TEXCOORD2;<br>&#125;;<br><br><span class="hljs-comment">// Unity doesn&#x27;t support the &#x27;inverse&#x27; function in native shader</span><br><span class="hljs-comment">// so we write one by our own</span><br><span class="hljs-comment">// Note: this function is just a demonstration, not too confident on the math or the speed</span><br><span class="hljs-comment">// Reference: http://answers.unity3d.com/questions/218333/shader-inversefloat4x4-function.html</span><br>float4x4 <span class="hljs-title function_">inverse</span><span class="hljs-params">(float4x4 input)</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> minor(a,b,c) determinant(float3x3(input.a, input.b, input.c))</span><br><br>float4x4 cofactors = float4x4(<br>     minor(_22_23_24, _32_33_34, _42_43_44), <br>    -minor(_21_23_24, _31_33_34, _41_43_44),<br>     minor(_21_22_24, _31_32_34, _41_42_44),<br>    -minor(_21_22_23, _31_32_33, _41_42_43),<br>    <br>    -minor(_12_13_14, _32_33_34, _42_43_44),<br>     minor(_11_13_14, _31_33_34, _41_43_44),<br>    -minor(_11_12_14, _31_32_34, _41_42_44),<br>     minor(_11_12_13, _31_32_33, _41_42_43),<br>    <br>     minor(_12_13_14, _22_23_24, _42_43_44),<br>    -minor(_11_13_14, _21_23_24, _41_43_44),<br>     minor(_11_12_14, _21_22_24, _41_42_44),<br>    -minor(_11_12_13, _21_22_23, _41_42_43),<br>    <br>    -minor(_12_13_14, _22_23_24, _32_33_34),<br>     minor(_11_13_14, _21_23_24, _31_33_34),<br>    -minor(_11_12_14, _21_22_24, _31_32_34),<br>     minor(_11_12_13, _21_22_23, _31_32_33)<br>);<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> minor</span><br><span class="hljs-keyword">return</span> transpose(cofactors) / determinant(input);<br>&#125;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br>o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;<br><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Note that the code below can handle both uniform and non-uniform scales</span><br><span class="hljs-comment">///</span><br><br><span class="hljs-comment">// Construct a matrix that transforms a point/vector from tangent space to world space</span><br>fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  <br>fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  <br>fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">float4x4 tangentToWorld = float4x4(worldTangent.x, worldBinormal.x, worldNormal.x, 0.0,</span><br><span class="hljs-comment">   worldTangent.y, worldBinormal.y, worldNormal.y, 0.0,</span><br><span class="hljs-comment">   worldTangent.z, worldBinormal.z, worldNormal.z, 0.0,</span><br><span class="hljs-comment">   0.0, 0.0, 0.0, 1.0);</span><br><span class="hljs-comment">// The matrix that transforms from world space to tangent space is inverse of tangentToWorld</span><br><span class="hljs-comment">float3x3 worldToTangent = inverse(tangentToWorld);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//wToT = the inverse of tToW = the transpose of tToW as long as tToW is an orthogonal matrix.</span><br><span class="hljs-comment">// xyz轴</span><br>float3x3 worldToTangent = float3x3(worldTangent, worldBinormal, worldNormal);<br><br><span class="hljs-comment">// Transform the light and view dir from world space to tangent space</span><br>o.lightDir = mul(worldToTangent, WorldSpaceLightDir(v.vertex));<br>o.viewDir = mul(worldToTangent, WorldSpaceViewDir(v.vertex));<br><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Note that the code below can only handle uniform scales, not including non-uniform scales</span><br><span class="hljs-comment">/// </span><br><br><span class="hljs-comment">// Compute the binormal</span><br><span class="hljs-comment">//float3 binormal = cross( normalize(v.normal), normalize(v.tangent.xyz) ) * v.tangent.w;</span><br><span class="hljs-comment">//// Construct a matrix which transform vectors from object space to tangent space</span><br><span class="hljs-comment">//float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);</span><br><span class="hljs-comment">// Or just use the built-in macro</span><br><span class="hljs-comment">//TANGENT_SPACE_ROTATION;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// Transform the light direction from object space to tangent space</span><br><span class="hljs-comment">//o.lightDir = mul(rotation, normalize(ObjSpaceLightDir(v.vertex))).xyz;</span><br><span class="hljs-comment">//// Transform the view direction from object space to tangent space</span><br><span class="hljs-comment">//o.viewDir = mul(rotation, normalize(ObjSpaceViewDir(v.vertex))).xyz;</span><br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed3 tangentLightDir = normalize(i.lightDir);<br>fixed3 tangentViewDir = normalize(i.viewDir);<br><br><span class="hljs-comment">// Get the texel in the normal map</span><br>fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);<br>fixed3 tangentNormal;<br><span class="hljs-comment">// If the texture is not marked as &quot;Normal map&quot;</span><br><span class="hljs-comment">//tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span><br><span class="hljs-comment">//tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><br><span class="hljs-comment">// Or mark the texture as &quot;Normal map&quot;, and use the built-in funciton</span><br>tangentNormal = UnpackNormal(packedNormal);<br>tangentNormal.xy *= _BumpScale;<br>tangentNormal.z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - saturate(dot(tangentNormal.xy, tangentNormal.xy)));<br><br>fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="hljs-number">0</span>, dot(tangentNormal, tangentLightDir));<br><br>fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);<br>fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(max(<span class="hljs-number">0</span>, dot(tangentNormal, halfDir)), _Gloss);<br><br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack <span class="hljs-string">&quot;Specular&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 7/Normal Map In World Space&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_MainTex (<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_BumpMap (<span class="hljs-string">&quot;Normal Map&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;bump&quot;</span> &#123;&#125;<br>_BumpScale (<span class="hljs-string">&quot;Bump Scale&quot;</span>, Float) = <span class="hljs-number">1.0</span><br>_Specular (<span class="hljs-string">&quot;Specular&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (<span class="hljs-string">&quot;Gloss&quot;</span>, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Pass &#123; <br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>fixed4 _Color;<br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>sampler2D _BumpMap;<br>float4 _BumpMap_ST;<br><span class="hljs-type">float</span> _BumpScale;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 tangent : TANGENT;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float4 uv : TEXCOORD0;<br>                <span class="hljs-comment">// 从切线空间到世界空间的变换矩阵</span><br>                <span class="hljs-comment">// 一个插值寄存器最多只能存储float4大小的变量，对于矩阵这样的变量，我们可以把它们按行拆成多个变量再进行存储。</span><br>float4 TtoW0 : TEXCOORD1;  <br>float4 TtoW1 : TEXCOORD2;  <br>float4 TtoW2 : TEXCOORD3; <br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br>o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;<br><br>float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  <br>fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  <br>fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  <br>fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; <br><br><span class="hljs-comment">// Compute the matrix that transform directions from tangent space to world space</span><br><span class="hljs-comment">// Put the world position in w component for optimization</span><br>o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);<br>o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);<br>o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br><span class="hljs-comment">// Get the position in world space</span><br>float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br><span class="hljs-comment">// Compute the light and view dir in world space</span><br>fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));<br>fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));<br><br><span class="hljs-comment">// Get the normal in tangent space</span><br>fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<br>bump.xy *= _BumpScale;<br>bump.z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - saturate(dot(bump.xy, bump.xy)));<br><span class="hljs-comment">// Transform the normal from tangent space to world space</span><br>bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));<br><br>fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="hljs-number">0</span>, dot(bump, lightDir));<br><br>fixed3 halfDir = normalize(lightDir + viewDir);<br>fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(max(<span class="hljs-number">0</span>, dot(bump, halfDir)), _Gloss);<br><br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack <span class="hljs-string">&quot;Specular&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果4.png"alt="结果4" /><figcaption aria-hidden="true">结果4</figcaption></figure><h3 id="渐变纹理">7.3 渐变纹理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 7/Ramp Texture&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_RampTex (<span class="hljs-string">&quot;Ramp Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Specular (<span class="hljs-string">&quot;Specular&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (<span class="hljs-string">&quot;Gloss&quot;</span>, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Pass &#123; <br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>fixed4 _Color;<br>sampler2D _RampTex;<br>float4 _RampTex_ST;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float3 worldPos : TEXCOORD1;<br>float2 uv : TEXCOORD2;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>o.worldPos = UnityObjectToWorldNormal(v.vertex);<br>o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);<br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed3 worldNormal = normalize(i.worldNormal);<br>fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br><span class="hljs-comment">// 半兰伯特光照模型 Use the texture to sample the diffuse color</span><br>fixed halfLambert  = <span class="hljs-number">0.5</span> * dot(worldNormal, worldLightDir) + <span class="hljs-number">0.5</span>;<br>                <span class="hljs-comment">// 由于_RampTex实际就是一个一维纹理（它在纵轴方向上颜色不变），因此纹理坐标的u和v方向我们都使用了halfLambert。</span><br>fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;<br><br>fixed3 diffuse = _LightColor0.rgb * diffuseColor;<br><br>fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));<br>fixed3 halfDir = normalize(worldLightDir + viewDir);<br>fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(max(<span class="hljs-number">0</span>, dot(worldNormal, halfDir)), _Gloss);<br><br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack <span class="hljs-string">&quot;Specular&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果5.png"alt="结果5" /><figcaption aria-hidden="true">结果5</figcaption></figure><h3 id="遮罩纹理">7.4 遮罩纹理</h3><p>使用遮罩纹理的流程一般是：通过采样得到遮罩纹理的纹素值，然后使用其中某个（或某几个）通道的值（例如texel.r）来与某种表面属性进行相乘，这样，当该通道的值为0时，可以保护表面不受该属性的影响。总而言之，使用遮罩纹理可以让美术人员更加精准（像素级别）地控制模型表面的各种性质。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 7/Mask Texture&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_MainTex (<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_BumpMap (<span class="hljs-string">&quot;Normal Map&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;bump&quot;</span> &#123;&#125;<br>_BumpScale(<span class="hljs-string">&quot;Bump Scale&quot;</span>, Float) = <span class="hljs-number">1.0</span><br>_SpecularMask (<span class="hljs-string">&quot;Specular Mask&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_SpecularScale (<span class="hljs-string">&quot;Specular Scale&quot;</span>, Float) = <span class="hljs-number">1.0</span><br>_Specular (<span class="hljs-string">&quot;Specular&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (<span class="hljs-string">&quot;Gloss&quot;</span>, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Pass &#123; <br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>fixed4 _Color;<br>sampler2D _MainTex;<br><span class="hljs-comment">// 为主纹理_MainTex、法线纹理_BumpMap和遮罩纹理_SpecularMask定义了它们共同使用的纹理属性变量_MainTex_ST。这意味着，在材质面板中修改主纹理的平铺系数和偏移系数会同时影响3个纹理的采样。使用这种方式可以让我们节省需要存储的纹理坐标数目，如果我们为每一个纹理都使用一个单独的属性变量TextureName_ST，那么随着使用的纹理数目的增加，我们会迅速占满顶点着色器中可以使用的插值寄存器。</span><br>float4 _MainTex_ST;<br>sampler2D _BumpMap;<br><span class="hljs-type">float</span> _BumpScale;<br>sampler2D _SpecularMask;<br><span class="hljs-type">float</span> _SpecularScale;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 tangent : TANGENT;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>float3 lightDir: TEXCOORD1;<br>float3 viewDir : TEXCOORD2;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br>o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br>TANGENT_SPACE_ROTATION;<br>o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;<br>o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;<br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br> fixed3 tangentLightDir = normalize(i.lightDir);<br>fixed3 tangentViewDir = normalize(i.viewDir);<br><br>fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));<br>tangentNormal.xy *= _BumpScale;<br>tangentNormal.z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - saturate(dot(tangentNormal.xy, tangentNormal.xy)));<br><br>fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="hljs-number">0</span>, dot(tangentNormal, tangentLightDir));<br><br> fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);<br> <span class="hljs-comment">// Get the mask value</span><br> fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;<br> <span class="hljs-comment">// Compute specular term with the specular mask</span><br> fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(max(<span class="hljs-number">0</span>, dot(tangentNormal, halfDir)), _Gloss) * specularMask;<br><br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack <span class="hljs-string">&quot;Specular&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在真实的游戏制作过程中，遮罩纹理已经不止限于保护某些区域使它们免于某些修改，而是可以存储任何我们希望逐像素控制的表面属性。通常，我们会充分利用一张纹理的RGBA四个通道，用于存储不同的属性。例如，我们可以把高光反射的强度存储在R通道，把边缘光照的强度存储在G通道，把高光反射的指数部分存储在B通道，最后把自发光强度存储在A通道。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果6.png"alt="结果6" /><figcaption aria-hidden="true">结果6</figcaption></figure><h2 id="第8章-透明效果">第8章 透明效果</h2><p>在Unity中，我们通常使用两种方法来实现透明效果：</p><ul><li><p><strong>透明度测试</strong>（Alpha Test）</p><p>这种方法其实无法得到真正的半透明效果。</p><p>透明度测试是不需要关闭深度写入的，它和其他不透明物体最大的不同就是它会根据透明度来舍弃一些片元。虽然简单，但是它产生的效果也很极端，要么完全透明，即看不到，要么完全不透明，就像不透明物体那样。</p></li><li><p><strong>透明度混合</strong>（Alpha Blending）</p><p>这种方法可以得到真正的半透明效果。</p><p>它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序；但没有关闭深度测试，当使用透明度混合渲染一个片元时，还是会比较它的深度值与当前深度缓冲中的深度值，如果它的深度值距离摄像机更远，那么就不会再进行混合操作。</p><p>因此，当一个不透明物体出现在一个透明物体的前面，而我们先渲染了不透明物体，它仍然可以正常地遮挡住透明物体。对于透明度混合来说深度缓冲是<strong>只读</strong>的。</p></li></ul><h3 id="为什么渲染顺序很重要">8.1 为什么渲染顺序很重要</h3><p>对于透明度混合技术，需要关闭深度写入。否则，一个半透明表面背后的表面本来是可以透过它被我们看到的，但由于深度测试时判断结果是该半透明表面距离摄像机更近，导致后面的表面将会被剔除，我们也就无法透过半透明表面看到后面的物体了。</p><p>当关闭了深度写入后，应该在不透明物体渲染完之后再渲染半透明物体。</p><ol type="1"><li>先渲染所有不透明物体，并开启它们的深度测试和深度写入。</li><li>把半透明物体按它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启它们的深度测试，但关闭深度写入。</li></ol><p><strong>排序问题</strong>很难解决。</p><h3 id="unity-shader的渲染顺序">8.2 Unity Shader的渲染顺序</h3><p>Unity为了解决渲染顺序的问题提供了<strong>渲染队列</strong>（renderqueue）,可以使用SubShader的Queue标签来决定我们的模型将归于哪个渲染队列。</p><p>Unity在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染。在Unity5中，Unity提前定义了5个渲染队列（与Unity5之前的版本相比多了一个AlphaTest渲染队列），在每个队列中间我们可以使用其他队列。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-Unity提前定义的5个渲染队列.jfif"alt="Unity提前定义的5个渲染队列" /><figcaption aria-hidden="true">Unity提前定义的5个渲染队列</figcaption></figure><h3 id="透明度测试">8.3 透明度测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 8/Alpha Test&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_MainTex (<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Cutoff (<span class="hljs-string">&quot;Alpha Cutoff&quot;</span>, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">0.5</span><br>&#125;<br>SubShader &#123;<br>        <span class="hljs-comment">// 通常，使用了透明度测试的Shader都应该在SubShader中设置这三个标签。</span><br>Tags &#123;<span class="hljs-string">&quot;Queue&quot;</span>=<span class="hljs-string">&quot;AlphaTest&quot;</span> <span class="hljs-string">&quot;IgnoreProjector&quot;</span>=<span class="hljs-string">&quot;True&quot;</span> <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;TransparentCutout&quot;</span>&#125;<br><br>Pass &#123;<br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>fixed4 _Color;<br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>fixed _Cutoff;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float3 worldPos : TEXCOORD1;<br>float2 uv : TEXCOORD2;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed3 worldNormal = normalize(i.worldNormal);<br>fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br><br>fixed4 texColor = tex2D(_MainTex, i.uv);<br><br><span class="hljs-comment">// Alpha test</span><br>clip (texColor.a - _Cutoff);<br><span class="hljs-comment">// Equal to </span><br><span class="hljs-comment">//if ((texColor.a - _Cutoff) &lt; 0.0) &#123;</span><br><span class="hljs-comment">//discard;</span><br><span class="hljs-comment">//&#125;</span><br><br>fixed3 albedo = texColor.rgb * _Color.rgb;<br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="hljs-number">0</span>, dot(worldNormal, worldLightDir));<br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack <span class="hljs-string">&quot;Transparent/Cutout/VertexLit&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果7.png"alt="结果7" /><figcaption aria-hidden="true">结果7</figcaption></figure><h3 id="透明度混合">8.4 透明度混合</h3><p>为了进行混合，我们需要使用Unity提供的混合命令——Blend。Blend是Unity提供的设置混合模式的命令。想要实现半透明的效果就需要把当前自身的颜色和已经存在于颜色缓冲中的颜色值进行混合，混合时使用的函数就是由该指令决定的。</p><figure><imgsrc="https://tvax3.sinaimg.cn/large/0077Un8Egy1h69dhwnrenj30rs07kjsm.jpg"alt="ShaderLab的Blend命令" /><figcaption aria-hidden="true">ShaderLab的Blend命令</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 8/Alpha Blend&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_MainTex (<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_AlphaScale (<span class="hljs-string">&quot;Alpha Scale&quot;</span>, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">1</span><br>&#125;<br>SubShader &#123;<br>Tags &#123;<span class="hljs-string">&quot;Queue&quot;</span>=<span class="hljs-string">&quot;Transparent&quot;</span> <span class="hljs-string">&quot;IgnoreProjector&quot;</span>=<span class="hljs-string">&quot;True&quot;</span> <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Transparent&quot;</span>&#125;<br><br>Pass &#123;<br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>ZWrite Off<br>            <span class="hljs-comment">// 上面表格中第二种语义</span><br>            <span class="hljs-comment">// DstColor_new = SrcAlpha × SrcColor + (1 - SrcAlpha) × DstColor_old</span><br>Blend SrcAlpha OneMinusSrcAlpha<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>fixed4 _Color;<br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>fixed _AlphaScale;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float3 worldPos : TEXCOORD1;<br>float2 uv : TEXCOORD2;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed3 worldNormal = normalize(i.worldNormal);<br>fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br><br>fixed4 texColor = tex2D(_MainTex, i.uv);<br>fixed3 albedo = texColor.rgb * _Color.rgb;<br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="hljs-number">0</span>, dot(worldNormal, worldLightDir));<br><span class="hljs-comment">//与上节相比，只是移除了透明度测试的代码，并设置了该片元着色器返回值中的透明通道，它是纹理像素的透明通道和材质参数_AlphaScale的乘积。</span><br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack <span class="hljs-string">&quot;Transparent/VertexLit&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果8.png"alt="结果8" /><figcaption aria-hidden="true">结果8</figcaption></figure><h3 id="开启深度写入的半透明效果">8.5 开启深度写入的半透明效果</h3><p>如果使用上一节的shader渲染Knot模型，会得到以下结果。</p><p>当模型本身有复杂的遮挡关系或是包含了复杂的非凸网格的时候，就会有各种各样因为排序错误而产生的错误的透明效果。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果9.png"alt="结果9" /><figcaption aria-hidden="true">结果9</figcaption></figure><p>只需要在渲染Pass之前增加一个Pass：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Pass &#123;<br>    ZWrite On<br>    ColorMask <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个新添加的Pass的目的仅仅是为了把模型的深度信息写入深度缓冲中，从而剔除模型中被自身遮挡的片元。因此，Pass的第一行开启了深度写入。在第二行，我们使用了一个新的渲染命令——ColorMask。在ShaderLab中，ColorMask用于设置颜色通道的写掩码（writemask）。它的语义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ColorMask RGB | A | <span class="hljs-number">0</span> | 其他任何R、G、B、A的组合<br></code></pre></td></tr></table></figure><p>设为0时，意味着该Pass不写入任何颜色通道，即不会输出任何颜色。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果10.png"alt="结果10" /><figcaption aria-hidden="true">结果10</figcaption></figure><h3 id="shaderlab的混合命令">8.6 ShaderLab的混合命令</h3><p>混合还有很多其他用处，不仅仅是用于透明度混合。</p><p>当片元着色器产生一个颜色的时候，可以选择与颜色缓存中的颜色进行混合。这样一来，混合就和两个操作数有关：源颜色（sourcecolor）和目标颜色（destinationcolor）。源颜色，我们用S表示，指的是由片元着色器产生的颜色值；目标颜色，我们用D表示，指的是从颜色缓冲中读取到的颜色值。对它们进行混合后得到的输出颜色，我们用O表示，它会重新写入到颜色缓冲中。需要注意的是，当我们谈及混合中的源颜色、目标颜色和输出颜色时，它们都包含了RGBA四个通道的值，而并非仅仅是RGB通道。</p><p>参考8.4中列出的Blend命令。命令使用的混合因子如下：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-ShaderLab-blend-factor.jfif"alt="ShaderLab中的混合因子" /><figcaption aria-hidden="true">ShaderLab中的混合因子</figcaption></figure><p>可以使用ShaderLab的BlendOpBlendOperation命令决定源颜色和目标颜色与它们对应的混合因子相乘后两者之间的操作。</p><p>当使用Min或Max混合操作时，混合因子实际上是不起任何作用的，它们仅会判断原始的源颜色和目的颜色之间的比较结果。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-ShaderLab-blend-op.jfif"alt="ShaderLab中的混合操作" /><figcaption aria-hidden="true">ShaderLab中的混合操作</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 正常（Normal），即透明度混合</span><br>Blend  SrcAlpha  OneMinusSrcAlpha<br><br><span class="hljs-comment">// 柔和相加（Soft Additive）</span><br>Blend  OneMinusDstColor  One<br>    <br><span class="hljs-comment">// 正片叠底（Multiply），即相乘</span><br>Blend  DstColor  Zero<br><br><span class="hljs-comment">// 两倍相乘（2x Multiply）</span><br>Blend  DstColor  SrcColor<br>    <br><span class="hljs-comment">// 变暗（Darken）</span><br>BlendOp  Min<br>Blend  One  One<br><br><span class="hljs-comment">// 变亮（Lighten）</span><br>BlendOp  Max<br>Blend  One  One<br><br><span class="hljs-comment">// 滤色（Screen）</span><br>Blend  OneMinusDstColor  One<br><span class="hljs-comment">// 等同于</span><br>Blend  One  OneMinusSrcColor<br><br><span class="hljs-comment">// 线性减淡（Linear Dodge）</span><br>Blend  One  One<br></code></pre></td></tr></table></figure><h3 id="双面渲染的透明效果">8.7 双面渲染的透明效果</h3><p>默认情况下渲染引擎剔除了物体背面（相对于摄像机的方向）的渲染图元，而只渲染了物体的正面。如果我们想要得到双面渲染的效果，可以使用Cull指令来控制需要剔除哪个面的渲染图元。在Unity中，Cull指令的语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Cull  Back  |  Front  |  Off<br></code></pre></td></tr></table></figure><p>Back：背对着摄像机的渲染图元就不会被渲染，这也是默认情况下</p><p>Front：那么那些朝向摄像机的渲染图元就不会被渲染</p><p>Off：就会关闭剔除功能</p><p>对于透明度测试，只需要在8.3的Shader的Pass中添加<code>Cull Off</code>即可。</p><p>对于透明度混合，只需要把8.4的Shader的Pass复制一个，在两个Pass中分别使用Cull指令剔除不同朝向的渲染图元。这是因为关闭了深入写入，无法保证同一个物体的正面和背面图元的渲染顺序，就有可能得到错误的半透明效果。(这个例子我只用一个PassCull Off也没有区别)</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-结果11.png"alt="结果11" /><figcaption aria-hidden="true">结果11</figcaption></figure><h1 id="第3篇-中级篇">第3篇 中级篇</h1><h2 id="第9章-更复杂的光照">第9章 更复杂的光照</h2><h3 id="unity的渲染路径">9.1 Unity的渲染路径</h3><p>在Unity里，渲染路径（Rendering Path）决定了光照是如何应用到UnityShader中的。只有为Shader正确地选择和设置了需要的渲染路径，该Shader的光照计算才能被正确执行。</p><p>在Unity 5.0版本之前，主要有3种：前向渲染路径（Forward RenderingPath）、延迟渲染路径（Deferred RenderingPath）和顶点照明渲染路径（Vertex Lit Rendering Path）。但在Unity5.0版本以后，Unity做了很多更改，主要有两个变化：首先，顶点照明渲染路径已经被Unity抛弃（但目前仍然可以对之前使用了顶点照明渲染路径的UnityShader兼容）；其次，新的延迟渲染路径代替了原来的延迟渲染路径（同样，目前也提供了对较旧版本的兼容）。</p><p>2020.3.26版本在Edit-&gt;Project Settings-&gt;Graphics-&gt;TierSettings中设置默认Rendering Path。每个相机可以单独覆盖设置。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-22-LightMode标签支持的渲染路径设置选项.jfif"alt="LightMode标签支持的渲染路径设置选项" /><figcaptionaria-hidden="true">LightMode标签支持的渲染路径设置选项</figcaption></figure><p><strong>前向渲染路径</strong></p><p>每进行一次完整的前向渲染，我们需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区，一个是深度缓冲区。我们利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。</p><p>假设场景中有N个物体，每个物体受M个光源的影响，那么要渲染整个场景一共需要N*M个Pass。可以看出，如果有大量逐像素光照，那么需要执行的Pass数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。</p><p>在Unity中，前向渲染路径有3种处理光照（即照亮物体）的方式：<strong>逐顶点处理</strong>、<strong>逐像素处理</strong>、<strong>球谐函数</strong>（SphericalHarmonics, SH）处理。</p><p>Unity使用的判断规则如下：</p><ul><li>场景中最亮的平行光总是按逐像素处理的。</li><li>渲染模式被设置成Not Important的光源，会按逐顶点或者SH处理。</li><li>渲染模式被设置成Important的光源，会按逐像素处理。</li><li>如果根据以上规则得到的逐像素光源数量小于QualitySetting中的逐像素光源数量(Pixel LightCount)，会有更多的光源以逐像素的方式进行渲染。</li></ul><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-24-epub_22691473_355.jfif"alt="前向渲染的两种Pass" /><figcaption aria-hidden="true">前向渲染的两种Pass</figcaption></figure><p>对于前向渲染来说，一个Unity Shader通常会定义一个Base Pass（BasePass也可以定义多次，例如需要双面渲染等情况）以及一个AdditionalPass。一个Base Pass仅会执行一次（定义了多个BasePass的情况除外），而一个AdditionalPass会根据影响该物体的其他逐像素光源的数目被多次调用，即每个逐像素光源会执行一次AdditionalPass。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-24-前向渲染可以使用的内置光照变量.jfif"alt="前向渲染可以使用的内置光照变量" /><figcaptionaria-hidden="true">前向渲染可以使用的内置光照变量</figcaption></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-24-前向渲染可以使用的内置光照函数.jfif"alt="前向渲染可以使用的内置光照函数" /><figcaptionaria-hidden="true">前向渲染可以使用的内置光照函数</figcaption></figure><p><strong>顶点照明渲染路径</strong></p><p>略过</p><p><strong>延迟渲染路径</strong></p><p>延迟渲染主要包含了两个Pass。在第一个Pass中，我们不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要是通过深度缓冲技术来实现，当发现一个片元是可见的，我们就把它的相关信息存储到G缓冲区中（Geometry）。然后，在第二个Pass中，我们利用G缓冲区的各个片元信息，例如表面法线、视角方向、漫反射系数等，进行真正的光照计算。</p><p>延迟渲染的缺点：</p><ul><li>不支持真正的抗锯齿（anti-aliasing）功能。</li><li>不能处理半透明物体。</li><li>对显卡有一定要求。如果要使用延迟渲染的话，显卡必须支持MRT（MultipleRender Targets）、Shader Mode3.0及以上、深度渲染纹理以及双面的模板缓冲。</li></ul><h3 id="unity的光源类型">9.2 Unity的光源类型</h3><p>Unity一共支持4种光源类型：平行光、点光源、聚光灯和面光源（arealight）。面光源仅在烘焙时才可发挥作用，因此不在本节讨论范围内。</p><p><strong>平行光</strong></p><p>位置方向不变，没有衰减</p><p><strong>点光源</strong></p><p>位置方向均变化，有衰减</p><p><strong>聚光灯</strong></p><p>位置方向均变化，有衰减，照明区域为锥形</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 9/Forward Rendering&quot;</span> &#123;<br>Properties &#123;<br>_Diffuse (<span class="hljs-string">&quot;Diffuse&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Specular (<span class="hljs-string">&quot;Specular&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (<span class="hljs-string">&quot;Gloss&quot;</span>, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br><br>Pass &#123;<br><span class="hljs-comment">// Pass for ambient light &amp; first pixel light (directional light)</span><br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>CGPROGRAM<br><br><span class="hljs-comment">// Apparently need to add this declaration </span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile_fwdbase</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>fixed4 _Diffuse;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float3 worldPos : TEXCOORD1;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed3 worldNormal = normalize(i.worldNormal);<br>fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br> fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(<span class="hljs-number">0</span>, dot(worldNormal, worldLightDir));<br><br> fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br> fixed3 halfDir = normalize(worldLightDir + viewDir);<br> fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(max(<span class="hljs-number">0</span>, dot(worldNormal, halfDir)), _Gloss);<br><br>fixed atten = <span class="hljs-number">1.0</span>;<br><br><span class="hljs-keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br><br>Pass &#123;<br><span class="hljs-comment">// Pass for other pixel lights</span><br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardAdd&quot;</span> &#125;<br><br>Blend One One<br><br>CGPROGRAM<br><br><span class="hljs-comment">// Apparently need to add this declaration</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile_fwdadd</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AutoLight.cginc&quot;</span></span><br><br>fixed4 _Diffuse;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float3 worldPos : TEXCOORD1;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed3 worldNormal = normalize(i.worldNormal);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USING_DIRECTIONAL_LIGHT</span><br>fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(<span class="hljs-number">0</span>, dot(worldNormal, worldLightDir));<br><br>fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br>fixed3 halfDir = normalize(worldLightDir + viewDir);<br>fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(max(<span class="hljs-number">0</span>, dot(worldNormal, halfDir)), _Gloss);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USING_DIRECTIONAL_LIGHT</span><br>fixed atten = <span class="hljs-number">1.0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined (POINT)</span><br>        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="hljs-number">1</span>)).xyz;<br>        fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>    <span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined (SPOT)</span><br>        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="hljs-number">1</span>));<br>        fixed atten = (lightCoord.z &gt; <span class="hljs-number">0</span>) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + <span class="hljs-number">0.5</span>).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        fixed atten = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">return</span> fixed4((diffuse + specular) * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125;<br>FallBack <span class="hljs-string">&quot;Specular&quot;</span><br></code></pre></td></tr></table></figure><h3 id="unity的光照衰减">9.3 Unity的光照衰减</h3><p>9.2代码中使用一张纹理作为查找表来在片元着色器中计算逐像素光照的衰减。这样的好处在于，计算衰减不依赖于数学公式的复杂性，我们只要使用一个参数值去纹理中采样即可。但使用纹理查找来计算衰减也有一些弊端。</p><ul><li>需要预处理得到采样纹理，而且纹理的大小也会影响衰减的精度。</li><li>不直观，同时也不方便，因此一旦把数据存储到查找表中，我们就无法使用其他数学公式来计算衰减。</li></ul><h3 id="unity的阴影">9.4 Unity的阴影</h3><p>在实时渲染中，我们最常使用的是一种名为<strong>ShadowMap</strong>的技术。这种技术理解起来非常简单，它会首先把摄像机的位置放在与光源重合的位置上，那么场景中该光源的阴影区域就是那些摄像机看不到的地方。而Unity就是使用的这种技术。</p><p>Unity选择使用一个额外的Pass来专门更新光源的阴影映射纹理，这个Pass就是LightMode标签被设置为ShadowCaster的Pass。这个Pass的渲染目标不是帧缓存，而是阴影映射纹理（或深度纹理）。Unity首先把摄像机放置到光源的位置上，然后调用该Pass，通过对顶点变换后得到光源空间下的位置，并据此来输出深度信息到<strong>阴影映射纹理</strong>中。</p><p><strong>传统的阴影映射纹理的实现</strong>：</p><p>在正常渲染的Pass中把顶点位置变换到光源空间下，以得到它在光源空间中的三维位置信息。然后，我们使用xy分量对阴影映射纹理进行采样，得到阴影映射纹理中该位置的深度信息。如果该深度值小于该顶点的深度值（通常由z分量得到），那么说明该点位于阴影中。</p><p><strong>屏幕空间的阴影映射技术</strong>（Screenspace ShadowMap）：</p><p>通过调用LightMode为ShadowCaster的Pass来得到可投射阴影的光源的阴影映射纹理以及摄像机的深度纹理。然后，根据光源的阴影映射纹理和摄像机的深度纹理来得到屏幕空间的阴影图。如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，就说明该表面虽然是可见的，但是却处于该光源的阴影中。通过这样的方式，阴影图就包含了屏幕空间中所有有阴影的区域。如果我们想要一个物体接收来自其他物体的阴影，只需要在Shader中对阴影图进行采样。由于阴影图是屏幕空间下的，因此，我们首先需要把表面坐标从模型空间变换到屏幕空间中，然后使用这个坐标对阴影图进行采样即可。</p><p>使用阴影的两个过程：</p><ul><li>如果我们想要一个物体接收来自其他物体的阴影，就必须在Shader中对阴影映射纹理（包括屏幕空间的阴影图）进行采样，把采样结果和最后的光照结果相乘来产生阴影效果。</li><li>如果我们想要一个物体向其他物体投射阴影，就必须把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。在Unity中，这个过程是通过为该物体执行LightMode为ShadowCaster的Pass来实现的。（如果使用了屏幕空间的投影映射技术，Unity还会使用这个Pass产生一张摄像机的深度纹理。）</li></ul><p>Mesh Renderer组件的Cast Shadows和ReceiveShadows属性可以控制该物体是否投射/接收阴影。</p><p>通过对9.2中的Shader做如下改造，使使用该Shader的物体<strong>接受阴影</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//包含头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AutoLight.cginc&quot;</span></span><br><span class="hljs-comment">//顶点着色器输出添加宏SHADOW_COORDS,宏的参数需要是下一个可用的插值寄存器的索引值。声明一个用于对阴影纹理采样的坐标。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">v2f</span>  &#123;</span><br>    float4  pos  :  SV_POSITION;<br>    float3  worldNormal  :  TEXCOORD0;<br>    float3  worldPos  :  TEXCOORD1;<br>    SHADOW_COORDS(<span class="hljs-number">2</span>)<br>&#125;;<br><span class="hljs-comment">//在顶点着色器返回之前添加另一个内置宏TRANSFER_SHADOW,计算上一步中声明的阴影纹理坐标。</span><br>v2f  <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v  v)</span>  &#123;<br>    v2f  o;<br>    ...<br>        <span class="hljs-comment">//  Pass  shadow  coordinates  to  pixel  shader</span><br>        TRANSFER_SHADOW(o);<br>    <span class="hljs-keyword">return</span>  o;<br>&#125;<br><span class="hljs-comment">//使用了一个内置宏SHADOW_ATTENUATION在片元着色器中计算阴影值</span><br><span class="hljs-comment">//  Use  shadow  coordinates  to  sample  shadow  map</span><br>fixed  shadow  =  SHADOW_ATTENUATION(i);<br><span class="hljs-comment">//最后只需要把阴影值shadow和漫反射以及高光反射颜色相乘即可。</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">由于这些宏中会使用上下文变量来进行相关计算，例如TRANSFER_SHADOW会使用v.vertex或a.pos来计算坐标，因此为了能够让这些宏正确工作，我们需要保证自定义的变量名和这些宏中使用的变量名相匹配。我们需要保证：a2v结构体中的顶点坐标变量名必须是vertex，顶点着色器的输出结构体v2f必须命名为v，且v2f中的顶点位置变量必须命名为pos。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>统一管理光照衰减和阴影</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//前面顶点着色器中的操作和接受阴影相同</span><br><span class="hljs-comment">//UNITY_LIGHT_ATTENUATION是Unity内置的用于计算光照衰减和阴影的宏，它接受3个参数，它会将光照衰减和阴影值相乘后的结果存储到第一个参数中。</span><br><span class="hljs-comment">//Unity针对不同光源类型、是否启用cookie等不同情况声明了多个版本的UNITY_LIGHT_ATTENUATION。</span><br>fixed4  <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f  i)</span>  :  SV_Target  &#123;<br>    ...<br><br>        <span class="hljs-comment">//  UNITY_LIGHT_ATTENUATION  not  only  compute  attenuation,  but  also  shadow  infos</span><br>        UNITY_LIGHT_ATTENUATION(atten,  i,  i.worldPos);<br><br>    <span class="hljs-keyword">return</span>  fixed4(ambient  +  (diffuse  +  specular)  ＊  atten,  <span class="hljs-number">1.0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>透明度测试的阴影</strong></p><p>为了让使用透明度测试的物体得到正确的阴影效果，我们只需要在UnityShader中更改一行代码，即把Fallback设置为Transparent/Cutout/VertexLit。但需要注意的是，由于Transparent/Cutout/VertexLit中计算透明度测试时，使用了名为_Cutoff的属性来进行透明度测试，因此，这要求我们的Shader中也必须提供名为_Cutoff的属性。否则，同样无法得到正确的阴影结果。</p><p><strong>透明度混合的阴影</strong></p><p>由于透明度混合需要关闭深度写入，由此带来的问题也影响了阴影的生成。总体来说，要想为这些半透明物体产生正确的阴影，需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染，这会让阴影处理变得非常复杂，而且也会影响性能。因此，在Unity中，<strong>所有内置的半透明Shader是不会产生任何阴影效果的</strong>。当然，我们可以使用一些dirtytrick来强制为半透明物体生成阴影，这可以通过把它们的Fallback设置为VertexLit、Diffuse这些不透明物体使用的UnityShader，这样Unity就会在它的Fallback找到一个阴影投射的Pass。然后，我们可以通过物体的MeshRenderer组件上的Cast Shadows和ReceiveShadows选项来控制是否需要向其他物体投射或接收阴影。</p><h3 id="本书使用的标准unity-shader">9.5 本书使用的标准Unity Shader</h3><p>本书资源的Assets/ Shaders/Common文件夹下提供了两个这样标准的UnityShader——BumpedDiffuse和BumpedSpecular。这两个UnityShader都包含了对法线纹理、多光源、光照衰减和阴影的相关处理，唯一不同的是，BumpedDiffuse使用了Phong光照模型，而BumpedSpecular使用了Blinn-Phong光照模型。</p><h2 id="第10章-高级纹理">第10章 高级纹理</h2><h3 id="立方体纹理">10.1 立方体纹理</h3><p>在图形学中，立方体纹理（Cubemap）是环境映射（EnvironmentMapping）的一种实现方法。环境映射可以模拟物体周围的环境，而使用了环境映射的物体可以看起来像镀了层金属一样反射出周围的环境。</p><p>立方体纹理也仅可以反射环境，但不能反射使用了该立方体纹理的物体本身。想要得到令人信服的渲染结果，我们应该尽量对凸面体而不要对凹面体使用立方体纹理（因为凹面体会反射自身）。</p><p>立方体纹理在实时渲染中有很多应用，最常见的是用于天空盒子（Skybox）以及环境映射。</p><p><strong>Skybox</strong></p><p>创建一个Skybox材质，再把它赋在Window-&gt;Rendering-&gt;Lighting中。</p><p>保证渲染场景的摄像机的Camera组件中的Clear Flags被设置为Skybox。</p><p>在Unity中，天空盒子是在所有不透明物体之后渲染的，而其背后使用的网格是一个立方体或一个细分后的球体。</p><p><strong>环境映射</strong></p><p>在Unity5中，创建用于环境映射的立方体纹理的方法有三种：第一种方法是直接由一些特殊布局的纹理创建；第二种方法是手动创建一个Cubemap资源，再把6张图赋给它；第三种方法是由脚本生成。</p><p>可以利用环境映射在物体表面模拟反射和折射。</p><p><strong>折射</strong></p><p>Snell's Law : <spanclass="math inline">\(η_1\sinθ_1=η_2\sinθ_2\)</span></p><p>入射光与折射光位于法线两侧，夹角为<spanclass="math inline">\(\theta\)</span>。<spanclass="math inline">\(η\)</span>是介质的折射率。例如真空的折射率是1，而玻璃的折射率一般是1.5。</p><p><strong>菲涅耳反射</strong></p><p>Schlick菲涅耳近似等式： <span class="math display">\[F_{schlick}(v, n)=F_0+(1-F_0)(1-v\cdot n)^5\]</span> <spanclass="math inline">\(F_0\)</span>是一个反射系数，用于控制菲涅耳反射的强度，v是视角方向，n是表面法线。</p><h3 id="渲染纹理">10.2 渲染纹理</h3><p>现代的GPU允许我们把整个三维场景渲染到一个中间缓冲中，即渲染目标纹理（RenderTarget Texture, RTT），而不是传统的帧缓冲或后备缓冲（backbuffer）。与之相关的是多重渲染目标（Multiple Render Target,MRT），这种技术指的是GPU允许我们把场景同时渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。延迟渲染就是使用多重渲染目标的一个应用。</p><p>在Unity中使用<strong>渲染纹理</strong>（RenderTexture）通常有两种方式：</p><ul><li>在Project目录下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样一来该摄像机的渲染结果就会实时更新到渲染纹理中，而不会显示在屏幕上。使用这种方法，我们还可以选择渲染纹理的分辨率、滤波模式等纹理属性。</li><li>在屏幕后处理时使用GrabPass命令或OnRenderImage函数来获取当前屏幕图像，Unity会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中，下面我们可以在自定义的Pass中把它们当成普通的纹理来处理，从而实现各种屏幕特效。</li></ul><p><strong>镜子效果</strong></p><p>使用一个渲染纹理作为输入属性，并把该渲染纹理在水平方向上翻转后直接显示到镜子上即可。</p><p><strong>玻璃效果</strong></p><p>通过一个Cubemap来模拟玻璃的反射，而在模拟折射时，则使用了GrabPass获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。</p><h3 id="程序纹理">10.3 程序纹理</h3><p>程序纹理（Procedural Texture）指的是那些由计算机生成的图像。</p><p>在Unity中，可以编写脚本自动生成纹理赋给材质。</p><p>也可以使用了名为<strong>SubstanceDesigner</strong>的软件在Unity外部生成程序材质。很多3A的游戏项目都使用了由它生成的材质。我们可以从Unity的资源商店或网络中获取到很多免费或付费的Substance材质。这些材质都是以.sbsar为后缀的。新版本的Unity已经不内置支持。</p><h2 id="第11章-让画面动起来">第11章 让画面动起来</h2><h3 id="unity-shader中的内置变量时间篇">11.1 UnityShader中的内置变量（时间篇）</h3><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-24-Unity内置的时间变量.jfif"alt="Unity内置的时间变量" /><figcaption aria-hidden="true">Unity内置的时间变量</figcaption></figure><h3 id="纹理动画">11.2 纹理动画</h3><p><strong>序列帧动画</strong></p><p>连续播放一系列纹理来形成动画。可以将一系列纹理存入一张纹理图片，根据时间选择变化纹理坐标播放不同的纹理。</p><p><strong>滚动的背景</strong></p><p>根据时间在同一张纹理上进行滚动。还可以多张纹理叠加。</p><h3 id="顶点动画">11.3 顶点动画</h3><p><strong>流动的河流</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 11/Water&quot;</span> &#123;<br>Properties &#123;<br>_MainTex (<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Magnitude (<span class="hljs-string">&quot;Distortion Magnitude&quot;</span>, Float) = <span class="hljs-number">1</span><br> _Frequency (<span class="hljs-string">&quot;Distortion Frequency&quot;</span>, Float) = <span class="hljs-number">1</span><br> _InvWaveLength (<span class="hljs-string">&quot;Distortion Inverse Wave Length&quot;</span>, Float) = <span class="hljs-number">10</span><br> _Speed (<span class="hljs-string">&quot;Speed&quot;</span>, Float) = <span class="hljs-number">0.5</span><br>&#125;<br>SubShader &#123;<br><span class="hljs-comment">// Need to disable batching because of the vertex animation</span><br>        <span class="hljs-comment">//批处理会合并所有相关的模型，而这些模型各自的模型空间就会丢失。而在本例中，我们需要在物体的模型空间下对顶点位置进行偏移。因此，在这里需要取消对该Shader的批处理操作。</span><br>Tags &#123;<span class="hljs-string">&quot;Queue&quot;</span>=<span class="hljs-string">&quot;Transparent&quot;</span> <span class="hljs-string">&quot;IgnoreProjector&quot;</span>=<span class="hljs-string">&quot;True&quot;</span> <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Transparent&quot;</span> <span class="hljs-string">&quot;DisableBatching&quot;</span>=<span class="hljs-string">&quot;True&quot;</span>&#125;<br><br>Pass &#123;<br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>ZWrite Off<br>Blend SrcAlpha OneMinusSrcAlpha<br>Cull Off<br><br>CGPROGRAM  <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert </span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnityCG.cginc&quot;</span> </span><br><br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>fixed4 _Color;<br><span class="hljs-type">float</span> _Magnitude;<br><span class="hljs-type">float</span> _Frequency;<br><span class="hljs-type">float</span> _InvWaveLength;<br><span class="hljs-type">float</span> _Speed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br><br>float4 offset;<br>offset.yzw = float3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br>offset.x = <span class="hljs-built_in">sin</span>(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;<br>o.pos = UnityObjectToClipPos(v.vertex + offset);<br><br>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>o.uv +=  float2(<span class="hljs-number">0.0</span>, _Time.y * _Speed);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed4 c = tex2D(_MainTex, i.uv);<br>c.rgb *= _Color.rgb;<br><br><span class="hljs-keyword">return</span> c;<br>&#125; <br><br>ENDCG<br>&#125;<br>&#125;<br>FallBack <span class="hljs-string">&quot;Transparent/VertexLit&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>广告牌技术（Billboarding）</strong></p><p>广告牌技术会根据视角方向来旋转一个被纹理着色的多边形（通常就是简单的四边形，这个多边形就是广告牌），使得多边形看起来好像总是面对着摄像机。广告牌技术被用于很多应用，比如渲染烟雾、云朵、闪光效果等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 11/Billboard&quot;</span> &#123;<br>Properties &#123;<br>_MainTex (<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_VerticalBillboarding (<span class="hljs-string">&quot;Vertical Restraints&quot;</span>, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">1</span> <br>&#125;<br>SubShader &#123;<br><span class="hljs-comment">// Need to disable batching because of the vertex animation</span><br>Tags &#123;<span class="hljs-string">&quot;Queue&quot;</span>=<span class="hljs-string">&quot;Transparent&quot;</span> <span class="hljs-string">&quot;IgnoreProjector&quot;</span>=<span class="hljs-string">&quot;True&quot;</span> <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Transparent&quot;</span> <span class="hljs-string">&quot;DisableBatching&quot;</span>=<span class="hljs-string">&quot;True&quot;</span>&#125;<br><br>Pass &#123; <br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>ZWrite Off<br>Blend SrcAlpha OneMinusSrcAlpha<br>Cull Off<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>fixed4 _Color;<br>fixed _VerticalBillboarding;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span> <span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br><br><span class="hljs-comment">// Suppose the center in object space is fixed</span><br>float3 center = float3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, <span class="hljs-number">1</span>));<br><br>float3 normalDir = viewer - center;<br><span class="hljs-comment">// If _VerticalBillboarding equals 1, we use the desired view dir as the normal dir</span><br><span class="hljs-comment">// Which means the normal dir is fixed</span><br><span class="hljs-comment">// Or if _VerticalBillboarding equals 0, the y of normal is 0</span><br><span class="hljs-comment">// Which means the up dir is fixed</span><br>normalDir.y =normalDir.y * _VerticalBillboarding;<br>normalDir = normalize(normalDir);<br><span class="hljs-comment">// Get the approximate up dir</span><br><span class="hljs-comment">// If normal dir is already towards up, then the up dir is towards front</span><br>float3 upDir = <span class="hljs-built_in">abs</span>(normalDir.y) &gt; <span class="hljs-number">0.999</span> ? float3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) : float3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>float3 rightDir = normalize(cross(upDir, normalDir));<br>upDir = normalize(cross(normalDir, rightDir));<br><br><span class="hljs-comment">// Use the three vectors to rotate the quad</span><br>float3 centerOffs = v.vertex.xyz - center;<br>float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;<br>              <br>o.pos = UnityObjectToClipPos(float4(localPos, <span class="hljs-number">1</span>));<br>o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span> <span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed4 c = tex2D (_MainTex, i.uv);<br>c.rgb *= _Color.rgb;<br><br><span class="hljs-keyword">return</span> c;<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack <span class="hljs-string">&quot;Transparent/VertexLit&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要对顶点动画添加阴影，需要提供自定义的ShadowCaster Pass。</p><h1 id="第4篇-高级篇">第4篇 高级篇</h1><h2 id="第12章-屏幕后处理效果">第12章 屏幕后处理效果</h2><p>屏幕后处理效果（screen post-processingeffects）是游戏中实现屏幕特效的常见方法。</p><h3 id="建立一个基本的屏幕后处理脚本系统">12.1建立一个基本的屏幕后处理脚本系统</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//当我们在脚本中声明此函数后，Unity会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数中的一系列操作后，再把目标渲染纹理，即第二个参数对应的渲染纹理显示到屏幕上。</span><br>MonoBehaviour.OnRenderImage  (RenderTexture  src,  RenderTexture  dest)<br><span class="hljs-comment">//在OnRenderImage函数中，我们通常是利用Graphics.Blit函数来完成对渲染纹理的处理。</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">参数src对应了源纹理，在屏幕后处理技术中，这个参数通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理。参数dest是目标渲染纹理，如果它的值为null就会直接将结果显示在屏幕上。参数mat是我们使用的材质，这个材质使用的Unity Shader将会进行各种屏幕后处理操作，而src纹理将会被传递给Shader中名为_MainTex的纹理属性。参数pass的默认值为-1，表示将会依次调用Shader内的所有Pass。否则，只会调用给定索引的Pass。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title">Blit</span>(<span class="hljs-params">Texture  src,  RenderTexture  dest</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Blit</span>(<span class="hljs-params">Texture src, RenderTexture dest, Material mat, <span class="hljs-built_in">int</span> pass = <span class="hljs-number">-1</span></span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title">Blit</span>(<span class="hljs-params">Texture  src,  Material  mat,  <span class="hljs-built_in">int</span>  pass  =  <span class="hljs-number">-1</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>在Unity中实现屏幕后处理效果，过程通常如下：</p><ol type="1"><li>在摄像中添加一个用于屏幕后处理的脚本。在这个脚本中，我们会实现OnRenderImage函数来获取当前屏幕的渲染纹理。</li><li>调用Graphics.Blit函数使用特定的UnityShader来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效，我们可能需要多次调用Graphics.Blit函数来对上一步的输出结果进行下一步处理。</li></ol><p>一个用于屏幕后处理效果的基类，在实现各种屏幕特效时，我们只需要继承自该基类，再实现派生类中不同的操作即可:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br>[<span class="hljs-meta">ExecuteInEditMode</span>]<br>[<span class="hljs-meta">RequireComponent (typeof(Camera))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PostEffectsBase</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br><span class="hljs-comment">// Called when start</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CheckResources</span>()</span> &#123;<br><span class="hljs-built_in">bool</span> isSupported = CheckSupport();<br><br><span class="hljs-keyword">if</span> (isSupported == <span class="hljs-literal">false</span>) &#123;<br>NotSupported();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Called in CheckResources to check support on this platform</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckSupport</span>()</span> &#123;<br><span class="hljs-keyword">if</span> (SystemInfo.supportsImageEffects == <span class="hljs-literal">false</span> || SystemInfo.supportsRenderTextures == <span class="hljs-literal">false</span>) &#123;<br>Debug.LogWarning(<span class="hljs-string">&quot;This platform does not support image effects or render textures.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Called when the platform doesn&#x27;t support this effect</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotSupported</span>()</span> &#123;<br>enabled = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>CheckResources();<br>&#125;<br><br><span class="hljs-comment">// Called when need to create the material used by this effect</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Material <span class="hljs-title">CheckShaderAndCreateMaterial</span>(<span class="hljs-params">Shader shader, Material material</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (shader == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)<br><span class="hljs-keyword">return</span> material;<br><br><span class="hljs-keyword">if</span> (!shader.isSupported) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>material = <span class="hljs-keyword">new</span> Material(shader);<br>            <span class="hljs-comment">//该对象不保存到场景。加载新场景时，也不会销毁它。</span><br>material.hideFlags = HideFlags.DontSave;<br><span class="hljs-keyword">if</span> (material)<br><span class="hljs-keyword">return</span> material;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调整屏幕的亮度饱和度和对比度">12.2调整屏幕的亮度、饱和度和对比度</h3><p>继承上一节的PostEffectsBase编写脚本挂载在相机上，加载briSatConShader实现后处理。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BrightnessSaturationAndContrast</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader briSatConShader;<br><span class="hljs-keyword">private</span> Material briSatConMaterial;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);<br><span class="hljs-keyword">return</span> briSatConMaterial;<br>&#125;  <br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> brightness = <span class="hljs-number">1.0f</span>;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> saturation = <span class="hljs-number">1.0f</span>;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> contrast = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_Brightness&quot;</span>, brightness);<br>material.SetFloat(<span class="hljs-string">&quot;_Saturation&quot;</span>, saturation);<br>material.SetFloat(<span class="hljs-string">&quot;_Contrast&quot;</span>, contrast);<br><br>Graphics.Blit(src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 12/Brightness Saturation And Contrast&quot;</span> &#123;<br>Properties &#123;<br>_MainTex (<span class="hljs-string">&quot;Base (RGB)&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Brightness (<span class="hljs-string">&quot;Brightness&quot;</span>, Float) = <span class="hljs-number">1</span><br>_Saturation(<span class="hljs-string">&quot;Saturation&quot;</span>, Float) = <span class="hljs-number">1</span><br>_Contrast(<span class="hljs-string">&quot;Contrast&quot;</span>, Float) = <span class="hljs-number">1</span><br>&#125;<br>SubShader &#123;<br>Pass &#123;  <br>ZTest Always Cull Off ZWrite Off<br><br>CGPROGRAM  <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert  </span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag  </span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnityCG.cginc&quot;</span>  </span><br>  <br>sampler2D _MainTex;  <br>half _Brightness;<br>half _Saturation;<br>half _Contrast;<br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>half2 uv: TEXCOORD0;<br>&#125;;<br>  <br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(appdata_img v)</span> &#123;<br>v2f o;<br><br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.uv = v.texcoord;<br> <br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed4 renderTex = tex2D(_MainTex, i.uv);  <br>  <br><span class="hljs-comment">// Apply brightness</span><br>fixed3 finalColor = renderTex.rgb * _Brightness;<br><br><span class="hljs-comment">// Apply saturation</span><br>fixed luminance = <span class="hljs-number">0.2125</span> * renderTex.r + <span class="hljs-number">0.7154</span> * renderTex.g + <span class="hljs-number">0.0721</span> * renderTex.b;<br>fixed3 luminanceColor = fixed3(luminance, luminance, luminance);<br>finalColor = lerp(luminanceColor, finalColor, _Saturation);<br><br><span class="hljs-comment">// Apply contrast</span><br>fixed3 avgColor = fixed3(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);<br>finalColor = lerp(avgColor, finalColor, _Contrast);<br><br><span class="hljs-keyword">return</span> fixed4(finalColor, renderTex.a);  <br>&#125;  <br>  <br>ENDCG<br>&#125;  <br>&#125;<br><br>Fallback Off<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="边缘检测">12.3 边缘检测</h3><p>利用一些边缘检测算子对图像进行卷积（convolution）操作。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-27-3种常见的边缘检测算子.jfif"alt="3种常见的边缘检测算子" /><figcaption aria-hidden="true">3种常见的边缘检测算子</figcaption></figure><h3 id="高斯模糊">12.4 高斯模糊</h3><p>高斯模糊使用高斯核卷积。 <span class="math display">\[G(x,y)=\frac{1} {2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2} }\]</span> σ是标准方差（一般取值为1）,x和y分别对应了当前位置到卷积核中心的整数距离。</p><p>为了保证滤波后的图像不会变暗，我们需要对高斯核中的权重进行归一化，即让每个权重除以所有权重的和，这样可以保证所有权重的和为1。因此，高斯函数中e前面的系数实际不会对结果有任何影响。</p><h3 id="bloom效果">12.5 Bloom效果</h3><p>首先根据一个阈值提取出图像中的较亮区域，把它们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行混合，得到最终的效果。</p><h3 id="运动模糊">12.6 运动模糊</h3><p>运动模糊的实现有多种方法。</p><p>一种实现方法是利用一块累积缓存（accumulationbuffer）来混合多张连续的图像。当物体快速移动产生多张图像后，我们取它们之间的平均值作为最后的运动模糊图像。然而，这种暴力的方法对性能的消耗很大，因为想要获取多张帧图像往往意味着我们需要在同一帧里渲染多次场景。</p><p>另一种应用广泛的方法是创建和使用速度缓存（velocitybuffer），这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</p><h2 id="第13章-使用深度和法线纹理">第13章 使用深度和法线纹理</h2><h3 id="获取深度和法线纹理">13.1 获取深度和法线纹理</h3><p>在Unity中，深度纹理可以直接来自于真正的深度缓存，也可以是由一个单独的Pass渲染而得，这取决于使用的渲染路径和硬件。</p><ol type="1"><li><p>通常来讲，当使用延迟渲染路径（包括遗留的延迟渲染路径）时，深度纹理理所当然可以访问到，因为延迟渲染会把这些信息渲染到G-buffer中。</p></li><li><p>而当无法直接获取深度缓存时，深度和法线纹理是通过一个单独的Pass渲染而得的。具体实现是，Unity会使用着色器替换（ShaderReplacement）技术选择那些渲染类型（即SubShader的RenderType标签）为Opaque的物体，判断它们使用的渲染队列是否小于等于2500（内置的Background、Geometry和AlphaTest渲染队列均在此范围内），如果满足条件，就把它渲染到深度和法线纹理中。因此，要想让物体能够出现在深度和法线纹理中，就必须在Shader中设置正确的RenderType标签。</p></li></ol><p>在脚本中设置摄像机，在Shader中通过声明变量来访问：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//C#</span><br>camera.depthTextureMode  =  DepthTextureMode.Depth;<br><span class="hljs-comment">//Shader</span><br>_CameraDepthTexture<br><span class="hljs-comment">//C#</span><br>camera.depthTextureMode  =  DepthTextureMode.DepthNormals;<br><span class="hljs-comment">//Shader</span><br>_CameraDepthNormalsTexture<br><br><span class="hljs-comment">//由纹理坐标对深度纹理进行采样</span><br><span class="hljs-built_in">float</span> d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,  i.uv);<br><span class="hljs-comment">//i.scrPos是在顶点着色器中通过调用ComputeScreenPos(o.pos)得到的屏幕坐标。</span><br><span class="hljs-built_in">float</span> d = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.scrPos));<br><span class="hljs-comment">//输出线性深度值</span><br><span class="hljs-built_in">float</span>  depth  =  SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,  i.uv);<br><span class="hljs-built_in">float</span>  linearDepth  =  Linear01Depth(depth);<br><span class="hljs-keyword">return</span>  fixed4(linearDepth,  linearDepth,  linearDepth,  <span class="hljs-number">1.0</span>);<br><span class="hljs-comment">//输出法线方向</span><br>fixed3  normal  =  DecodeViewNormalStereo(tex2D(_CameraDepthNormalsTexture,  i.uv).xy);<br><span class="hljs-keyword">return</span>  fixed4(normal  ＊  <span class="hljs-number">0.5</span>  +  <span class="hljs-number">0.5</span>,  <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><h3 id="再谈运动模糊">13.2 再谈运动模糊</h3><p>在C#端求得两个变换矩阵——前一帧的视角投影矩阵以及当前帧的视角投影矩阵的逆矩阵。</p><p>在Shader端的片元着色器中：</p><ol type="1"><li><p>使用内置的SAMPLE_DEPTH_TEXTURE宏和纹理坐标对深度纹理进行采样，得到了深度值d，由d和纹理坐标映射回NDC（（NDC下的xyz分量范围均为[-1,1]）），得到NDC坐标（w设为1）。</p></li><li><p>用视角投影矩阵的逆矩阵左乘NDC坐标，整体除w得到世界坐标。（<ahref="https://www.cnblogs.com/sword-magical-blog/p/10483459.html">为什么将NDC坐标变换到世界坐标下需要除w</a>）</p></li><li><p>使用前一帧的视角投影矩阵左乘世界坐标，得到其在前一帧下的NDC坐标。</p></li><li><p>计算前一帧和当前帧在屏幕空间下的位置差，得到该像素的速度。</p></li><li><p>使用该速度值对它的邻域像素进行采样，相加后取平均值得到一个模糊的效果。</p></li></ol><p>本节实现的运动模糊适用于<strong>场景静止、摄像机快速运动</strong>的情况，这是因为我们在计算时只考虑了摄像机的运动。因此，如果读者把本节中的代码应用到一个物体快速运动而摄像机静止的场景，会发现不会产生任何运动模糊效果。如果我们想要对快速移动的物体产生运动模糊的效果，就需要生成更加精确的速度映射图。读者可以在Unity自带的ImageEffect包中找到更多的运动模糊的实现方法。</p><h3 id="全局雾效">13.3 全局雾效</h3><p>Unity内置的<strong>雾效</strong>可以产生基于距离的线性或指数雾效。然而，要想在自己编写的顶点/片元着色器中实现这些雾效，我们需要在Shader中添加#pragmamulti_compile_fog指令，同时还需要使用相关的内置宏，例如UNITY_FOG_COORDS、UNITY_TRANSFER_FOG和UNITY_APPLY_FOG等。这种方法的缺点在于，我们不仅需要为场景中所有物体添加相关的渲染代码，而且能够实现的效果也非常有限。当我们需要对雾效进行一些个性化操作时，例如使用基于高度的雾效等，仅仅使用Unity内置的雾效就变得不再可行。</p><p>本节基于屏幕后处理实现全局雾效。</p><p>基于屏幕后处理的全局雾效的关键是，<strong>根据深度纹理来重建每个像素在世界空间下的位置</strong>：</p><ul><li>在上一节中，我们在模拟运动模糊时已经实现了这个要求，即构建出当前像素的NDC坐标，再通过当前摄像机的视角投影矩阵的逆矩阵来得到世界空间下的像素坐标，但是，这样的实现需要在片元着色器中进行矩阵乘法的操作，而这通常会影响游戏性能。</li><li>在本节中，使用一个快速从深度纹理中重建世界坐标的方法。这种方法首先对图像空间下的视锥体射线（从摄像机出发，指向图像上的某点的射线）进行插值，这条射线存储了该像素在世界空间下到摄像机的方向信息。然后，我们把该射线和线性化后的视角空间下的深度值相乘，再加上摄像机的世界位置，就可以得到该像素在世界空间下的位置。当我们得到世界坐标后，就可以轻松地使用各个公式来模拟全局雾效了。</li></ul><h3 id="再谈边缘检测">13.4 再谈边缘检测</h3><p>在深度和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。</p><h2 id="第14章-非真实感渲染">第14章 非真实感渲染</h2><h3 id="卡通风格的渲染">14.1 卡通风格的渲染</h3><p>要实现卡通渲染有很多方法，其中之一就是使用基于色调的着色技术（tone-basedshading）。</p><p>在实时渲染中，<strong>轮廓线渲染</strong>是应用非常广泛的一种效果。近20年来，有许多绘制模型轮廓线的方法被先后提出来。在《RealTime Rendering, third edition》一书中，作者把这些方法分成了5种类型。</p><ul><li><p>基于观察角度和表面法线的轮廓线渲染。这种方法使用视角方向和表面法线的点乘结果来得到轮廓线的信息。这种方法简单快速，可以在一个Pass中就得到渲染结果，但局限性很大，很多模型渲染出来的描边效果都不尽如人意。</p></li><li><p>过程式几何轮廓线渲染。这种方法的核心是使用两个Pass渲染。第一个Pass渲染背面的面片，并使用某些技术让它的轮廓可见；第二个Pass再正常渲染正面的面片。这种方法的优点在于快速有效，并且适用于绝大多数表面平滑的模型，但它的缺点是不适合类似于立方体这样平整的模型。</p></li><li><p>基于图像处理的轮廓线渲染。我们在第12、13章介绍的边缘检测的方法就属于这个类别。这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张。</p></li><li><p>基于轮廓边检测的轮廓线渲染。上面提到的各种方法，一个最大的问题是，无法控制轮廓线的风格渲染。对于一些情况，我们希望可以渲染出独特风格的轮廓线，例如水墨风格等。为此，我们希望可以检测出精确的轮廓边，然后直接渲染它们。</p></li><li><p>最后一个种类就是混合了上述的几种渲染方法。例如，首先找到精确的轮廓边，把模型和轮廓边渲染到纹理中，再使用图像处理的方法识别出轮廓线，并在图像空间下进行风格化渲染。</p></li></ul><p>这里使用第二种方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 14/Toon Shading&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_MainTex (<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>        <span class="hljs-comment">//控制漫反射色调的渐变纹理</span><br>_Ramp (<span class="hljs-string">&quot;Ramp Texture&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>        <span class="hljs-comment">//轮廓线宽度和颜色</span><br>_Outline (<span class="hljs-string">&quot;Outline&quot;</span>, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">0.1</span><br>_OutlineColor (<span class="hljs-string">&quot;Outline Color&quot;</span>, Color) = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>_Specular (<span class="hljs-string">&quot;Specular&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>         <span class="hljs-comment">//计算高光反射时使用的阈值</span><br>_SpecularScale (<span class="hljs-string">&quot;Specular Scale&quot;</span>, Range(<span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>)) = <span class="hljs-number">0.01</span><br>&#125;<br>    SubShader &#123;<br>Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Opaque&quot;</span> <span class="hljs-string">&quot;Queue&quot;</span>=<span class="hljs-string">&quot;Geometry&quot;</span>&#125;<br><br>Pass &#123;<br>NAME <span class="hljs-string">&quot;OUTLINE&quot;</span><br>Cull Front<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnityCG.cginc&quot;</span></span><br><br><span class="hljs-type">float</span> _Outline;<br>fixed4 _OutlineColor;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;; <br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>    float4 pos : SV_POSITION;<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span> <span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br><br>float4 pos = mul(UNITY_MATRIX_MV, v.vertex); <br>float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);  <br>                <span class="hljs-comment">//在视角空间下把模型顶点沿着法线方向向外扩张一段距离，以此来让背部轮廓线可见。</span><br>                <span class="hljs-comment">//在扩张背面顶点之前，我们首先对顶点法线的z分量进行处理，使它们等于一个定值，然后把法线归一化后再对顶点进行扩张。这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性。</span><br>normal.z = <span class="hljs-number">-0.5</span>;<br>pos = pos + float4(normalize(normal), <span class="hljs-number">0</span>) * _Outline;<br>o.pos = mul(UNITY_MATRIX_P, pos);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>float4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123; <br><span class="hljs-keyword">return</span> float4(_OutlineColor.rgb, <span class="hljs-number">1</span>);               <br>&#125;<br><br>ENDCG<br>&#125;<br><br>Pass &#123;<br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>Cull Back<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile_fwdbase</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnityCG.cginc&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AutoLight.cginc&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnityShaderVariables.cginc&quot;</span></span><br><br>fixed4 _Color;<br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>sampler2D _Ramp;<br>fixed4 _Specular;<br>fixed _SpecularScale;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 texcoord : TEXCOORD0;<br>float4 tangent : TANGENT;<br>&#125;; <br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : POSITION;<br>float2 uv : TEXCOORD0;<br>float3 worldNormal : TEXCOORD1;<br>float3 worldPos : TEXCOORD2;<br>SHADOW_COORDS(<span class="hljs-number">3</span>)<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span> <span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br><br>o.pos = UnityObjectToClipPos( v.vertex);<br>o.uv = TRANSFORM_TEX (v.texcoord, _MainTex);<br>o.worldNormal  = UnityObjectToWorldNormal(v.normal);<br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>TRANSFER_SHADOW(o);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>float4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123; <br>fixed3 worldNormal = normalize(i.worldNormal);<br>fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));<br>fixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);<br><br>fixed4 c = tex2D (_MainTex, i.uv);<br>fixed3 albedo = c.rgb * _Color.rgb;<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br><br>fixed diff =  dot(worldNormal, worldLightDir);<br>diff = (diff * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>) * atten;<br><br>fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;<br><br>fixed spec = dot(worldNormal, worldHalfDir);<br>                <span class="hljs-comment">//w是一个很小的值，当spec - threshold小于-w时，返回0，大于w时，返回1，否则在0到1之间进行插值。这样的效果是，我们可以在[-w, w]区间内，即高光区域的边界处，得到一个从0到1平滑变化的spec值，从而实现抗锯齿的目的。尽管我们可以把w设为一个很小的定值，但在本例中，我们选择使用邻域像素之间的近似导数值，这可以通过CG的fwidth函数来得到。</span><br>fixed w = fwidth(spec) * <span class="hljs-number">2.0</span>;<br>fixed3 specular = _Specular.rgb * lerp(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, smoothstep(-w, w, spec + _SpecularScale - <span class="hljs-number">1</span>)) * step(<span class="hljs-number">0.0001</span>, _SpecularScale);<br><br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125;<br>FallBack <span class="hljs-string">&quot;Diffuse&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="素描风格的渲染">14.2 素描风格的渲染</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">///</span><br><span class="hljs-comment">///  Reference: Praun E, Hoppe H, Webb M, et al. Real-time hatching[C]</span><br><span class="hljs-comment">///Proceedings of the 28th annual conference on Computer graphics and interactive techniques. ACM, 2001: 581.</span><br><span class="hljs-comment">///</span><br>Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 14/Hatching&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_TileFactor (<span class="hljs-string">&quot;Tile Factor&quot;</span>, Float) = <span class="hljs-number">1</span><br>_Outline (<span class="hljs-string">&quot;Outline&quot;</span>, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">0.1</span><br>_Hatch0 (<span class="hljs-string">&quot;Hatch 0&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Hatch1 (<span class="hljs-string">&quot;Hatch 1&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Hatch2 (<span class="hljs-string">&quot;Hatch 2&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Hatch3 (<span class="hljs-string">&quot;Hatch 3&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Hatch4 (<span class="hljs-string">&quot;Hatch 4&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_Hatch5 (<span class="hljs-string">&quot;Hatch 5&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>&#125;<br><br>SubShader &#123;<br>Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Opaque&quot;</span> <span class="hljs-string">&quot;Queue&quot;</span>=<span class="hljs-string">&quot;Geometry&quot;</span>&#125;<br><br>UsePass <span class="hljs-string">&quot;Unity Shaders Book/Chapter 14/Toon Shading/OUTLINE&quot;</span><br><br>Pass &#123;<br>Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment frag </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> multi_compile_fwdbase</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnityCG.cginc&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AutoLight.cginc&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnityShaderVariables.cginc&quot;</span></span><br><br>fixed4 _Color;<br><span class="hljs-type">float</span> _TileFactor;<br>sampler2D _Hatch0;<br>sampler2D _Hatch1;<br>sampler2D _Hatch2;<br>sampler2D _Hatch3;<br>sampler2D _Hatch4;<br>sampler2D _Hatch5;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a2v</span> &#123;</span><br>float4 vertex : POSITION;<br>float4 tangent : TANGENT; <br>float3 normal : NORMAL; <br>float2 texcoord : TEXCOORD0; <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span> &#123;</span><br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>fixed3 hatchWeights0 : TEXCOORD1;<br>fixed3 hatchWeights1 : TEXCOORD2;<br>float3 worldPos : TEXCOORD3;<br>SHADOW_COORDS(<span class="hljs-number">4</span>)<br>&#125;;<br><br>v2f <span class="hljs-title function_">vert</span><span class="hljs-params">(a2v v)</span> &#123;<br>v2f o;<br><br>o.pos = UnityObjectToClipPos(v.vertex);<br><span class="hljs-comment">//求纹理采样坐标</span><br>o.uv = v.texcoord.xy * _TileFactor;<br><br>fixed3 worldLightDir = normalize(WorldSpaceLightDir(v.vertex));<br>fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);<br>fixed diff = max(<span class="hljs-number">0</span>, dot(worldLightDir, worldNormal));<br><br>o.hatchWeights0 = fixed3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>o.hatchWeights1 = fixed3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-type">float</span> hatchFactor = diff * <span class="hljs-number">7.0</span>;<br><br>                <span class="hljs-comment">//计算对应的纹理混合权重</span><br><span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">6.0</span>) &#123;<br><span class="hljs-comment">// Pure white, do nothing</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">5.0</span>) &#123;<br>o.hatchWeights0.x = hatchFactor - <span class="hljs-number">5.0</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">4.0</span>) &#123;<br>o.hatchWeights0.x = hatchFactor - <span class="hljs-number">4.0</span>;<br>o.hatchWeights0.y = <span class="hljs-number">1.0</span> - o.hatchWeights0.x;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">3.0</span>) &#123;<br>o.hatchWeights0.y = hatchFactor - <span class="hljs-number">3.0</span>;<br>o.hatchWeights0.z = <span class="hljs-number">1.0</span> - o.hatchWeights0.y;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">2.0</span>) &#123;<br>o.hatchWeights0.z = hatchFactor - <span class="hljs-number">2.0</span>;<br>o.hatchWeights1.x = <span class="hljs-number">1.0</span> - o.hatchWeights0.z;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hatchFactor &gt; <span class="hljs-number">1.0</span>) &#123;<br>o.hatchWeights1.x = hatchFactor - <span class="hljs-number">1.0</span>;<br>o.hatchWeights1.y = <span class="hljs-number">1.0</span> - o.hatchWeights1.x;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>o.hatchWeights1.y = hatchFactor;<br>o.hatchWeights1.z = <span class="hljs-number">1.0</span> - o.hatchWeights1.y;<br>&#125;<br><br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>TRANSFER_SHADOW(o);<br><br><span class="hljs-keyword">return</span> o; <br>&#125;<br><br>fixed4 <span class="hljs-title function_">frag</span><span class="hljs-params">(v2f i)</span> : SV_Target &#123;<br>fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;<br>fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;<br>fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;<br>fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;<br>fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;<br>fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;<br>                <span class="hljs-comment">//通过从1中减去所有6张纹理的权重来得到纯白在渲染中的贡献度</span><br>fixed4 whiteColor = fixed4(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - <br>i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);<br><br>fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;<br><br>UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br><br><span class="hljs-keyword">return</span> fixed4(hatchColor.rgb * _Color.rgb * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125;<br>FallBack <span class="hljs-string">&quot;Diffuse&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第15章-使用噪声">第15章 使用噪声</h2><h3 id="消融效果">15.1 消融效果</h3><p><strong>消融</strong>（dissolve）效果常见于游戏中的角色死亡、地图烧毁等效果。在这些效果中，消融往往从不同的区域开始，并向看似随机的方向扩张，最后整个物体都将消失不见。</p><p>在C#端随时间更新材质参数——消融程度_BurnAmount。</p><p>在Shader端对噪声纹理进行采样，并将采样结果和用于控制消融程度的属性_BurnAmount相减，传递给clip函数。当结果小于0时，该像素将会被剔除，从而不会显示到屏幕上。如果通过了测试，则进行正常的光照计算。为了模拟烧焦效果，还要以_BurnAmount为参数插值多种颜色。</p><h3 id="水波效果">15.2 水波效果</h3><p>使用GrabPass来获取当前屏幕的渲染纹理，并使用切线空间下的法线方向对像素的屏幕坐标进行偏移，再使用该坐标对渲染纹理进行屏幕采样，从而模拟近似的折射效果。</p><p>与<strong>10.2.2</strong>节中的实现不同的是，水波的法线纹理是由一张噪声纹理生成而得，而且会随着时间变化不断平移，模拟波光粼粼的效果。除此之外，我们没有使用一个定值来混合反射和折射颜色，而是使用之前提到的菲涅耳系数来动态决定混合系数。</p><h3 id="再谈全局雾效">15.3 再谈全局雾效</h3><p>相比<strong>13.3</strong>节的全局雾效实现，在Shader的片元着色器中对高度的计算添加了噪声的影响，实现非均匀雾效。</p><h3 id="扩展阅读">15.4 扩展阅读</h3><p>这些噪声纹理都是如何构建出来的？这些噪声纹理可以被认为是一种程序纹理（ProcedureTexture），它们都是由计算机利用某些算法生成的。<ahref="https://en.wikipedia.org/wiki/Perlin_noise">Perlin噪声</a>和<ahref="https://en.wikipedia.org/wiki/Worley_noise">Worley噪声</a>是两种最常使用的噪声类型，例如我们在15.3节中使用的噪声纹理由Perlin噪声生成而来。Perlin噪声可以用于生成更自然的噪声纹理，而Worley噪声则通常用于模拟诸如石头、水、纸张等多孔噪声。</p><h2 id="第16章-unity中的渲染优化技术">第16章 Unity中的渲染优化技术</h2><h3 id="移动平台的特点">16.1 移动平台的特点</h3><p>移动设备上的GPU架构专注于尽可能使用更小的带宽和功能。</p><h3 id="影响性能的因素">16.2 影响性能的因素</h3><ol type="1"><li>CPU<ul><li>过多的draw call。（使用批处理技术减少draw call数目。）</li><li>复杂的脚本或者物理模拟。</li></ul></li><li>GPU<ul><li>顶点处理。（减少需要处理的顶点数目。化几何体； 使用模型的LOD（Levelof Detail）技术； 使用遮挡剔除（Occlusion Culling）技术。）<ul><li>过多的顶点。</li><li>过多的逐顶点计算。</li></ul></li><li>片元处理。（减少需要处理的片元数目。控制绘制顺序；警惕透明物体；减少实时光照。）<ul><li>过多的片元（既可能是由于分辨率造成的，也可能是由于overdraw造成的）。</li><li>过多的逐片元计算。</li></ul></li></ul></li><li>带宽<ul><li>使用了尺寸很大且未压缩的纹理。（减少纹理大小。）</li><li>分辨率过高的帧缓存。（利用分辨率缩放。）</li></ul></li></ol><h3 id="unity中的渲染分析工具">16.3 Unity中的渲染分析工具</h3><p><strong>渲染统计窗口（Rendering Statistics Window）</strong></p><p>Game -&gt; Stats</p><p><strong>性能分析器（Profiler）</strong></p><p>Window -&gt; Analysis -&gt; Profiler</p><p><strong>帧调试器（Frame Debugger）</strong></p><p>Window -&gt; Analysis -&gt; Frame Debugger</p><h3 id="减少draw-call数目">16.4 减少draw call数目</h3><p>批处理的思想很简单，就是在每次面对drawcall时尽可能多地处理多个物体。</p><p>Unity中支持两种批处理方式：一种是动态批处理，另一种是静态批处理。</p><p>对于<strong>动态批处理</strong>来说，优点是一切处理都是Unity自动完成的，不需要我们自己做任何操作，而且物体是可以移动的，但缺点是，限制很多，可能一不小心就会破坏了这种机制，导致Unity无法动态批处理一些使用了相同材质的物体。</p><p>而对于<strong>静态批处理</strong>来说，它的优点是自由度很高，限制很少；但缺点是可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了（即便在脚本中尝试改变物体的位置也是无效的）。静态批处理的实现非常简单，只需要把物体面板上的Static复选框勾选上即可（实际上我们只需要勾选BatchingStatic即可）。</p><p>如果两个材质之间只有使用的纹理不同，我们可以把这些纹理合并到一张更大的纹理中，这张更大的纹理被称为是一张<strong>图集</strong>（atlas）。一旦使用了同一张纹理，我们就可以使用同一个材质，再使用不同的采样坐标对纹理采样即可。</p><h3 id="减少需要处理的顶点数目">16.5 减少需要处理的顶点数目</h3><p><strong>优化几何体</strong></p><p>Unity中显示的数目往往要多于建模软件里显示的顶点数:</p><p>三维软件更多地是站在我们人类的角度理解顶点的，即组成几何体的每一个点就是一个单独的点。而Unity是站在GPU的角度上去计算顶点数的。在GPU看来，有时需要把一个顶点拆分成两个或更多的顶点。这种将顶点一分为多的原因主要有两个：一个是为了分离纹理坐标（uvsplits），另一个是为了产生平滑的边界（smoothingsplits）。它们的本质，其实都是因为对于GPU来说，顶点的每一个属性和顶点之间必须是一对一的关系。而分离纹理坐标，是因为建模时一个顶点的纹理坐标有多个。例如，对于一个立方体，它的6个面之间虽然使用了一些相同的顶点，但在不同面上，同一个顶点的纹理坐标可能并不相同。对于GPU来说，这是不可理解的，因此，它必须把这个顶点拆分成多个具有不同纹理坐标的顶点。平滑边界也是类似的，不同的是，此时一个顶点可能会对应多个法线信息或切线信息。这通常是因为我们要决定一个边是一条硬边（hardedge）还是一条平滑边（smooth edge）。</p><p><strong>LOD技术</strong></p><p>在Unity中，我们可以使用LODGroup组件来为一个物体构建一个LOD。我们需要为同一个对象准备多个包含不同细节程序的模型，然后把它们赋给LODGroup组件中的不同等级，Unity就会自动判断当前位置上需要使用哪个等级的模型。</p><p><strong>遮挡剔除技术</strong></p><p>需要把遮挡剔除和摄像机的视锥体剔除（FrustumCulling）区分开来。视锥体剔除只会剔除掉那些不在摄像机的视野范围内的对象，但不会判断视野中是否有物体被其他物体挡住。而遮挡剔除会使用一个虚拟的摄像机来遍历场景，从而构建一个潜在可见的对象集合的层级结构。在运行时刻，每个摄像机将会使用这个数据来识别哪些物体是可见的，而哪些被其他物体挡住不可见。使用遮挡剔除技术，不仅可以减少处理的顶点数目，还可以减少overdraw，提高游戏性能。</p><h3 id="减少需要处理的片元数目">16.6 减少需要处理的片元数目</h3><p>这部分优化的重点在于减少overdraw。简单来说，overdraw指的就是同一个像素被绘制了多次。</p><p><strong>控制绘制顺序</strong></p><p>在Unity中，那些渲染队列数目小于2500（如“Background”“Geometry”和“AlphaTest”）的对象都被认为是不透明（opaque）的物体，这些物体总体上是从前往后绘制的，而使用其他的队列（如“Transparent”“Overlay”等）的物体，则是从后往前绘制的。这意味着，我们可以尽可能地把物体的队列设置为不透明物体的渲染队列，而尽量避免使用半透明队列。而且，我们还可以充分利用Unity的渲染队列来控制绘制顺序。</p><p><strong>时刻警惕透明物体</strong></p><p><strong>减少实时光照和阴影</strong></p><h3 id="节省带宽">16.7 节省带宽</h3><p><strong>减少纹理大小</strong></p><p>多级渐远纹理技术（mipmapping）和纹理压缩</p><p><strong>利用分辨率缩放</strong></p><p>尤其是对于很多低端手机，除了分辨率高其他硬件条件并不尽如人意。</p><h3 id="减少计算复杂度">16.8 减少计算复杂度</h3><p><strong>Shader的LOD技术</strong></p><p>它的原理是，只有Shader的LOD值小于某个设定的值，这个Shader才会被使用，而使用了那些超过设定值的Shader的物体将不会被渲染。</p><p><strong>代码方面的优化</strong></p><p><strong>根据硬件条件进行缩放</strong></p><h1 id="第5篇-扩展篇">第5篇 扩展篇</h1><h2 id="第17章-unity的表面着色器探秘">第17章 Unity的表面着色器探秘</h2><h3 id="表面着色器的一个例子">17.1 表面着色器的一个例子</h3><p>和顶点/片元着色器需要包含到一个特定的Pass块中不同，表面着色器的CG代码是直接而且也必须写在SubShader块中，Unity会在背后为我们生成多个Pass。当然，可以在SubShader一开始处使用Tags来设置该表面着色器使用的标签。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Unity Shaders Book/Chapter 17/Bumped Diffuse&quot;</span> &#123;<br>Properties &#123;<br>_Color (<span class="hljs-string">&quot;Main Color&quot;</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>_MainTex (<span class="hljs-string">&quot;Base (RGB)&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>_BumpMap (<span class="hljs-string">&quot;Normalmap&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;bump&quot;</span> &#123;&#125;<br>&#125;<br>SubShader &#123;<br>Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br>LOD <span class="hljs-number">300</span><br><br>CGPROGRAM<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> surface surf Lambert</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> target 3.0</span><br><br>sampler2D _MainTex;<br>sampler2D _BumpMap;<br>fixed4 _Color;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Input</span> &#123;</span><br>float2 uv_MainTex;<br>float2 uv_BumpMap;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> &#123;<br>fixed4 tex = tex2D(_MainTex, IN.uv_MainTex);<br>o.Albedo = tex.rgb * _Color.rgb;<br>o.Alpha = tex.a * _Color.a;<br>o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));<br>&#125;<br><br>ENDCG<br>&#125; <br><br>FallBack <span class="hljs-string">&quot;Legacy Shaders/Diffuse&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译指令">17.2 编译指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span>  surface  surfaceFunction  lightModel  [optionalparams]</span><br></code></pre></td></tr></table></figure><p>#pragmasurface用于指明该编译指令是用于定义表面着色器的，在它的后面需要指明使用的表面函数（surfaceFunction）和光照模型（lightModel），同时，还可以使用一些可选参数来控制表面着色器的一些行为。</p><h3 id="两个结构体">17.3 两个结构体</h3><p>一个表面着色器需要使用两个结构体：表面函数的输入结构体Input，以及存储了表面属性的结构体SurfaceOutput（Unity5新引入了另外两个同种的结构体SurfaceOutputStandard和SurfaceOutputStandardSpecular）。</p><h3 id="unity背后做了什么">17.4 Unity背后做了什么</h3><p>Unity实际会在背后为表面着色器生成真正的顶点/片元着色器。在每个编译完成的表面着色器的面板上，都有一个“Showgenerated code”的按钮可供查看。</p><h3 id="surface-shader的缺点">17.6 Surface Shader的缺点</h3><h2 id="第18章-基于物理的渲染">第18章 基于物理的渲染</h2><p>基于物理的渲染技术（Physically Based Shading,PBS）已经应用于实时渲染中。Unity 5引入了一个名为StandardShader的可在不同材质之间通用的着色器，而该着色器就是使用了基于物理的光照模型。</p><h3 id="pbs的理论和数学基础">18.1 PBS的理论和数学基础</h3><p>本节主要参考了Naty Hoffman在SIGGRAPH 2013上做的名为Background:Physics and Math of Shading的演讲。</p><p><strong>菲涅耳等式</strong>（Fresnelequations）描述有多少百分比的光会被反射（另一部分就是被折射了）：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-菲涅耳等式.jfif"alt="菲涅耳等式" /><figcaption aria-hidden="true">菲涅耳等式</figcaption></figure><p>物体的表面和光照发生的各种行为，更像是一系列微小的光学平滑平面和光交互的结果，其中每个小平面会把光分割成不同的方向。光滑表面的微平面的法线变化较小，反射光线的方向变化也更小。粗糙表面的微平面的法线变化较大，反射光线的方向变化也更大</p><p>金属材质具有很高的吸收系数，因此，所有被折射的光往往会被立刻吸收，被金属内部的自由电子转化成其他形式的能量。而非金属材质则会同时表现出吸收和散射两种现象，这些被散射出去的光又被称为<strong>次表面散射光</strong>（subsurface-scatteredlight）。</p><p><strong>BRDF</strong>（Bidirectional Reflectance DistributionFunction，双向反射分布函数）：</p><p><span class="math inline">\(f(l, v)\)</span>（单位<spanclass="math inline">\(sr^{-1}\)</span>），即反射辐射率（单位<spanclass="math inline">\(W/m^2sr\)</span>）和入射辐照度（单位<spanclass="math inline">\(W/m^2\)</span>）之比。<spanclass="math inline">\(l\)</span>是入射光方向，<spanclass="math inline">\(v\)</span>是观察方向。</p><p><strong>反射方程</strong>（reflection equation）： <spanclass="math display">\[L_o(v)=\int_{\Omega}f(l,v)\times L_i(l)(n\cdot l)d\omega_i\]</span> 即给定观察方向<spanclass="math inline">\(v\)</span>，该方向上的反射辐射率<spanclass="math inline">\(L_o(v)\)</span>等于所有入射方向的辐照度乘以BRDF值的积分。推导过程可以看<ahref="https://zhuanlan.zhihu.com/p/21376124">这篇文章</a>。</p><p>对于方向确定、大小为无线小的精确光源（punctual lightsources），使用<spanclass="math inline">\(l_c\)</span>来表示它的方向，使用<spanclass="math inline">\(c_{light}\)</span>表示它的颜色，反射等式可以简化为：<span class="math display">\[L_o(v)=\pi f(l_c,v)\times c_{light} (n\cdot l_c)\]</span>如果场景中包含了多个精确光源，我们可以把它们分别代入上面的式子进行计算，然后把它们的结果相加即可。公式推导参考[1]。</p><p>BRDF满足交换律和能量守恒。交换率即交换<spanclass="math inline">\(l\)</span>和<spanclass="math inline">\(v\)</span>，BRDF值不变。能量守恒即表面反射的能量不能超过入射的光能。</p><p><strong>BRDF中用于描述表面反射的部分被称为高光反射项（specularterm），以及用于描述次表面散射的漫反射项（diffuse term）。</strong></p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-高光反射和漫反射.jfif"alt="高光反射和漫反射" /><figcaption aria-hidden="true">高光反射和漫反射</figcaption></figure><p><strong>漫反射项</strong></p><p>Lambert模型就是最简单、也是应用最广泛的漫反射BRDF。准确的LambertianBRDF的表示为： <span class="math display">\[f_{Lambsrt}(l,v)=\frac{c_{diff}}{\pi}\]</span> <spanclass="math inline">\(c_{diff}\)</span>表示漫反射光线所占的比例，它也通常被称为是漫反射颜色（diffusecolor）。与我们之前讲过的Lambert光照模型不太一样的是，上面的式子实际上是一个定值，我们常见到的余弦（即<spanclass="math inline">\(n\cdotl\)</span>）因子部分实际是反射等式的一部分，而不是BRDF的部分。上面的式子之所以要除以π，是因为我们假设漫反射在所有方向上的强度都是相同的，而BRDF要求在半球内的积分值为1(<ahref="https://zhuanlan.zhihu.com/p/342807202">为什么BRDF的漫反射项要除以π</a>)。</p><p>给定入射方向<spanclass="math inline">\(l\)</span>的光源在表面某点的漫反射辐射率为： <spanclass="math display">\[L_{diff}=\frac{c_{diff}}{\pi}\times L_i(l)(n\cdot l)\]</span> Disney使用的BRDF[2]更复杂。</p><p><strong>高光反射项</strong></p><p>基于Torrance-Sparrow microfacetmodel[5]，BRDF的高光反射项可以用下面的形式来表示： <spanclass="math display">\[f_{spec}(l,v)=\frac{F(l,h)G(l,v,h)D(h)}{4(n\cdot l)(n\cdot v)}\]</span> <span class="math inline">\(h\)</span>是<spanclass="math inline">\(l\)</span>和<spanclass="math inline">\(v\)</span>的半程向量。</p><p><spanclass="math inline">\(D(h)\)</span>是微面元的法线分布函数（normaldistribution function,NDF），它用于计算有多少比例的微面元的法线满足<spanclass="math inline">\(m=h\)</span>，只有这部分微面元才会把光线从<spanclass="math inline">\(l\)</span>方向反射到<spanclass="math inline">\(v\)</span>上。</p><p><span class="math inline">\(G(l, v,h)\)</span>是阴影——遮掩函数（shadowing-maskingfunction），它用于计算那些满足<spanclass="math inline">\(m=h\)</span>的微面元中有多少会由于遮挡而不会被人眼看到，因此它给出了活跃的微面元（activemicrofacets）所占的浓度，只有活跃的微面元才会成功地把光线反射到观察方向上。</p><p><span class="math inline">\(F(l,h)\)</span>则是这些活跃微面元的菲涅尔反射（Fresnelreflectance）函数，它可以告诉我们每个活跃的微面元会把多少入射光线反射到观察方向上，即表示了反射光线占入射光线的比率。</p><p>分母<span class="math inline">\(4(n\cdot l)(n\cdotv)\)</span>是用于校正从微面元的局部空间到整体宏观表面数量差异的校正因子。</p><p>Blinn-Phong模型[7]使用的法线分布函数<spanclass="math inline">\(D_{blinn}(h)=(n\cdot h)^{gloss}\)</span>。</p><p><strong>Unity中的PBS实现</strong></p><p>Unity5一共实现了两种PBS模型。一种是基于GGX模型的，另一种则是基于归一化的Blinn—Phong模型的。这两种模型使用了不同的公式来计算高光反射项中的法线分布函数<spanclass="math inline">\(D(h)\)</span>和阴影—遮掩函数<spanclass="math inline">\(G(l,v,h)\)</span>。在默认情况下，Unity5使用基于归一化后的Blinn-Phong模型来实现基于物理的渲染（尽管很多引擎选择使用GGX模型）。</p><p>我们可以在Unity内置的UnityStandardBRDF.cginc文件中找到它的实现。</p><h3 id="unity-5的standard-shader">18.2 Unity 5的Standard Shader</h3><p>Unity支持两种流行的基于物理的工作流程：<strong>金属工作流</strong>（Metallicworkflow）和<strong>高光反射工作流</strong>（Specular workflow）。</p><p>金属工作流是默认的工作流程，对应的Shader为StandardShader。而如果想要使用高光反射工作流，就需要在材质的Shader下拉框中选择Standard（Specularsetup）。需要注意的是，通常来讲，使用不同的工作流可以实现相同的效果，只是它们使用的参数不同而已。金属工作流也不意味着它只能模拟金属类型的材质，金属工作流的名字来源于它定义了材质表面的金属值（是金属类型的还是非金属类型的）。高光反射工作流的名字来源于它可以直接指定表面的高光反射颜色（有很强的高光反射还是很弱的高光反射）等，而在金属工作流中这个颜色需要由漫反射颜色和金属值衍生而来。在实际的游戏制作过程中，我们可以选择自己更偏好的工作流来制作场景，这更多的是个人喜好的问题。当然也可以同时混用两种工作流。</p><p>材质和光的交互可以分成<strong>漫反射和高光反射</strong>两个部分，其中漫反射对应了次表面散射的结果，而高光反射则对应了表面反射的结果。</p><p><strong>金属材质</strong></p><ul><li>几乎没有漫反射，因为所有被吸收的光都会被自由电子立刻转化为其他形式的能量；</li><li>有非常强烈的高光反射；</li><li>高光反射通常是有颜色的，例如金子的反光颜色为黄色。</li></ul><p><strong>非金属材质</strong></p><ul><li>大多数角度高光反射的强度比较弱，但在掠射角时高光反射强度反而会增强，即菲涅耳现象；</li><li>高光反射的颜色比较单一；</li><li>漫反射的颜色多种多样。</li></ul><p>读者需要在Edit →Project Setttings→Player→Other Settings→ColorSpace中选择Linear才可以得到和图18.9中相同的效果，这是因为基于物理的渲染需要使用<strong>线性空间</strong>（详见18.3.4节）来进行相关计算。</p><p><strong>使用Standard Shader</strong></p><p>金属工作流：</p><blockquote><p>Albedo：物体的整体颜色</p></blockquote><blockquote><p>Metallic：0-1 1金属</p></blockquote><blockquote><p>Smoothness：0-1 1光滑</p></blockquote><p>如果我们在设置Metallic属性时使用的是一张纹理，那么这张纹理的A通道就对应了表面的Smoothness值（此时纹理的GB通道则被忽略）。</p><p>高光反射工作流：</p><blockquote><p>Albedo：定义了表面的漫反射强度。对于非金属材质，它的值通常仍然是视觉上认为的物体颜色，但对于金属材质，Albedo的值通常非常接近黑色（金属材质几乎不存在次表面散射的现象）。</p></blockquote><blockquote><p>Specular：非金属材质通常使用一个灰度值范围在0～55的深灰色来作为Specular值，表明非金属材质的高光反射较弱。金属材质则通常会使用视觉上认为的该金属的颜色作为它的Specular值。</p></blockquote><blockquote><p>Smoothness：同上</p></blockquote><p>材质面板的Render Mode选项: StandardShader支持4种渲染模式，分别是Opaque、Cutout、Fade和Transparent。</p><ul><li>Opaque用于渲染最常见的不透明物体，这也是默认的渲染模式。</li><li>对于像玻璃这样的材质，我们可以选择Transparent模式，在这个渲染模式下，Albedo属性的A通道用于控制材质的透明度。</li><li>而在Cutout渲染模式下，Albedo属性中纹理的A通道会成为一个掩码纹理，而它的子属性AlphaCutoff将是透明度测试时使用的阈值。</li><li>Fade模式和Transparent模式是类似的，不同的是，在Transparent模式下，当材质的透明值不断降低时，它的反射仍然能被保留，而在Fade模式下，该材质的所有渲染效果都会逐渐从屏幕上淡出。</li></ul><p>想要让整个场景的渲染结果令人满意，尤其包含了复杂光照的场景，仅仅有这些使用了PBS的材质是不够的，我们需要使用Unity提供的其他一些重要的技术，例如HDR格式的Skybox、全局光照、反射探针、光照探针、HDR和屏幕后处理等。</p><h3 id="一个更加复杂的例子">18.3 一个更加复杂的例子</h3><p><strong>反射探针</strong></p><p>当关闭场景中的所有光源并把环境光照强度设为0后，使用了StandardShader的物体仍然具有光照效果，只有在Lighting-&gt;Environment-&gt;Environment Reflections把反射源设置为空，并关闭所有反射探针，才能使得物体不接受任何默认的反射信息。</p><p>反射探针（Reflection Probes）的工作原理和光照探针（LightProbes）类似，它允许我们在场景中的特定位置上对整个场景的环境反射进行采样，并把采样结果存储在每个探针上。当游戏中包含反射效果的物体从这些探针附近经过时，Unity会把从这些邻近探针存储的反射结果传递给物体使用的反射纹理。如果物体周围存在多个反射探针，Unity还会在这些反射结果之间进行插值，来得到平滑渐变的反射效果。实际上，Unity会在场景中放置一个默认的反射探针，这个反射探针存储了对场景使用的Skybox的反射结果，来作为场景的环境光照。如果我们需要让场景中的物体包含额外的反射效果，就需要放置更多的反射探针。</p><p>Baked，这种类型的反射探针是通过提前烘焙来得到该位置使用的Cubemap的，在游戏运行时反射探针中存储的Cubemap并不会发生变化。需要注意的是，这种类型的反射探针在烘焙时同样只会处理那些静态物体（即那些被标识为ReflectionProbe Static的物体）;</p><p>Realtime，这种类型则会实时更新当前的Cubemap，并且不受静态物体还是动态物体的影响。当然，这种类型的反射探针需要花费更多的处理时间，因此，在使用时应当非常小心它们的性能。幸运的是，Unity允许我们从脚本中通过触发来精确控制反射探针的更新；</p><p>Custom，这种类型的探针既可以让我们从编辑器中烘焙它，也可以让我们使用一个自定义的Cubemap来作为反射映射，但自定义的Cubemap不会被实时更新。</p><p><strong>全局光照</strong></p><p>除了StandardShader外，Unity还引入了一个重要的流水线——实时全局光照（GlobalIllumination,GI）流水线。使用GI，场景中的物体不仅可以受直接光照的影响，还可以接受间接光照的影响。</p><p><strong>线性空间</strong></p><p>基于物理的渲染需要使用线性空间来进行相关计算。</p><p>亮度上的线性变化对人眼感知来说是非均匀的，人眼更容易感知暗部区域的变换，而对较亮区域的变化比较不敏感。</p><p>摄影设备如果使用了8位空间来存储照片的话，会使用大约为0.45的编码伽马来对输入的亮度进行编码，得到一张编码后的图像。因此，图像中0.5像素值对应的亮度其实并不是0.5，而大约为0.22（<spanclass="math inline">\(0.5\approx 0.22^{0.45}\)</span>）。</p><p>当把图片放到显示器里显示时，我们应该对图像再进行一次解码操作，使得屏幕输出的亮度和捕捉到的亮度是符合线性的。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-27-编码伽马和显示伽马.jfif"alt="编码伽马和显示伽马" /><figcaption aria-hidden="true">编码伽马和显示伽马</figcaption></figure><p>微软联合爱普生、惠普提供了<strong>sRGB</strong>颜色空间标准，推荐显示器的显示伽马值为2.2，并配合0.45的编码伽马就可以保证最后伽马曲线之间可以相互抵消（因为<spanclass="math inline">\(2.2\times0.45\approx1\)</span>）。绝大多数的摄像机、PC和打印机都使用了上述的sRGB标准。</p><p>当我们选择<strong>伽马空间</strong>时，实际上就是“放任模式”，不会对Shader的输入进行任何处理，即使输入可能是非线性的；也不会对输出像素进行任何处理，这意味着输出的像素会经过显示器的显示伽马转换后得到非预期的亮度，通常表现为整个场景会比较昏暗。当选择<strong>线性空间</strong>时，Unity会把输入纹理设置为sRGB模式，在这种模式下，硬件在对纹理进行采样时会自动将其转换到线性空间中；并且，GPU会在Shader写入颜色缓冲前自动进行伽马校正或是保持线性在后面进行伽马校正，这取决于当前的渲染配置。</p><p>如果有一天我们对图像的存储空间能够大大提升，通用的格式不再是8位时，例如是32位时，伽马也许就会消失。因为，我们有足够多的颜色空间可以利用，<strong>不需要为了充分利用存储空间进行伽马编码</strong>。</p><p><strong>HDR ( High Dynamic Range )</strong></p><p>Nvidia曾总结过使用HDR进行渲染的动机：让亮的物体可以真地非常亮，暗的物体可以真地非常暗，同时又可以看到两者之间的细节。</p><p>HDR使用远远高于8位的精度（如32位）来记录亮度信息，使得我们可以表示超过0～1内的亮度值，从而可以更加精确地反映真实的光照环境。尽管最后我们仍然需要把它们转换到LDR进行显示，但我们可以使用<strong>色调映射</strong>（tonemapping）技术来控制这个转换的过程，从而允许我们最大限度地保留需要的亮度细节。</p><p><strong>PBS优点</strong></p><p>PBS并不意味着游戏画面需要追求和照片一样真实的效果。事实上，很多游戏都不需要刻意去追求与照片一样的真实感，玩家眼中的真实感大多也并不是如此。PBS的优点在于，我们只需要一个万能的shader就可以渲染相当一大部分类型的材质，而不是使用传统的做法为每种材质写一个特定的shader。同时，PBS可以保证在各种光照条件下，材质都可以自然地和光源进行交互，而不需要我们反复地调整材质参数。</p><h3 id="参考文献">18.6 参考文献</h3><p>[1] Hoffman N. Background: physics and math of shading[C]//FourthInternational Conference and Exhibition on Computer Graphics andInteractive Techniques, Anaheim, USA. 2013: 21-25。</p><p>[2] Burley B, Studios W D A. Physically-based shading atdisney[C]//ACM SIGGRAPH. 2012:1-7。</p><p>[3] Walter B, Marschner S R, Li H, et al. Microfacet models forrefraction through rough surfaces[C]//Proceedings of the 18thEurographics conference on Rendering Techniques. EurographicsAssociation, 2007: 195-206。</p><p>[4] Beckmann P, Spizzichino A. The scattering of electromagneticwaves from rough surfaces[J]. Norwood, MA, Artech House, Inc., 1987, 511p.,1987, 1。</p><p>[5] Torrance K E, Sparrow E M. Theory for off-specular reflectionfrom roughened surfaces[J]. JOSA, 1967, 57(9): 1105-1112。</p><p>[6] Smith B G. Geometrical shadowing of a random roughsurface[J].Antennas and Propagation, IEEE Transactions on, 1967, 15(5):668-671。</p><p>[7] Blinn J F. Models of light reflection for computer synthesizedpictures[C]//ACM SIGGRAPH Computer Graphics. ACM, 1977, 11(2):192-198。</p><p>[8] Schlick C. An inexpensive BRDF model for physically-basedrendering[C]//Computer graphics forum. 1994, 13(3): 233-246。</p><h2 id="第19章-unity-5更新了什么">第19章 Unity 5更新了什么</h2><h2 id="第20章-还有更多内容吗">第20章 还有更多内容吗</h2><h1 id="注意点">注意点</h1><p><code>mul()</code>函数一般使用内置矩阵左乘列向量，等价于内置矩阵的转置右乘行向量。</p><p>获取指向相机的方向：</p><p><code>fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</code></p><p>获取指向光源的方向：</p><p><code>fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</code></p><p><code>fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</code></p><p>计算时辐射率就是颜色。</p><p>使用<code>fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));</code>从法线图中解压得到法线向量，然后由xy反推z，因为xyz是模为1的方向向量。</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》笔记</title>
      <link href="//posts/Notebook/Effective-Modern-CPP-note/"/>
      <url>//posts/Notebook/Effective-Modern-CPP-note/</url>
      
        <content type="html"><![CDATA[<p>42 Specific Ways to Improve Your Use of C++11 AND C++14</p><span id="more"></span><p>Scott Meyers 著</p><p>高博 译</p><p class="note note-primary">摘录整理。</p><p><ahref="https://www.aristeia.com/BookErrata/emc++-errata.html">本书修订及更新网站</a></p><p><ahref="https://github.com/CnTransGroup/EffectiveModernCppChinese">另一种翻译</a></p><h1 id="第1章-型别推导">第1章 型别推导</h1><h2 id="条款1-理解型别推导">条款1 理解型别推导</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParamType param)</span></span>; <br><span class="hljs-built_in">f</span>(expr);<br></code></pre></td></tr></table></figure><p>T与ParamType两个型别推导往往不同。</p><p><strong>情况1: ParamType是指针或引用，但不是万能引用</strong></p><p>实参的引用会被忽略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = x;<br><br><span class="hljs-comment">// 向持有T&amp;型别的模板传入const对象是安全的，常量性会传给T</span><br><span class="hljs-comment">// T不会被推导成引用，引用性会被忽略</span><br><span class="hljs-built_in">f</span>(x);  <span class="hljs-comment">// T的型别是int, param的型别是int&amp;</span><br><span class="hljs-built_in">f</span>(cx); <span class="hljs-comment">// T的型别是const int，param的型别是const int&amp;</span><br><span class="hljs-built_in">f</span>(rx); <span class="hljs-comment">// T的型别是const int，param的型别是const int&amp;</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span></span>;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = X;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = X;<br><br><span class="hljs-comment">// 符合直觉</span><br><span class="hljs-built_in">f</span>(x);  <span class="hljs-comment">// T的型别是int，param的型别是const int&amp;</span><br><span class="hljs-built_in">f</span>(cx); <span class="hljs-comment">// T的型别是int，param的型别是const int&amp;</span><br><span class="hljs-built_in">f</span>(rx); <span class="hljs-comment">// T的型别是int，param的型别是const int&amp;</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T* param)</span></span>;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *px = &amp;x; <span class="hljs-comment">// px是指涉到x的指针，型别为const int</span><br><br><span class="hljs-comment">// 符合直觉</span><br><span class="hljs-built_in">f</span>(&amp;x); <span class="hljs-comment">// T的型别是int，param的型别是int*</span><br><span class="hljs-built_in">f</span>(px); <span class="hljs-comment">// T的型别是const int，param的型别是const int*</span><br></code></pre></td></tr></table></figure><p><strong>情况2: ParamType 是个万能引用</strong></p><p>采用右值来初始化万能引用会得到一个右值引用；采用左值来初始化万能引用，就会得到一个左值引用。</p><blockquote><p>这里涉及引用折叠，X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp;&amp;都折叠成类型X&amp;；类型X&amp;&amp;&amp;&amp;折叠成X&amp;&amp;。（参见C++ Primer 16.2或条款28）</p></blockquote><p>当遇到<strong>万能引用</strong>时，型别推导规则会<strong>区分实参是左值还是右值</strong>。而非万能引用是从来不会作这样的区分的。</p><p>向形参T&amp;&amp;传入实参左值，是T被推导为引用型别的<strong>唯一情形</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = X;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = X;<br><br><span class="hljs-built_in">f</span>(x); <span class="hljs-comment">// x是左值，所以T的型别是int&amp;， param的型别也是int&amp;</span><br><span class="hljs-built_in">f</span>(cx); <span class="hljs-comment">// cx是左值，所以T的型别是const int&amp;，param的型别也是const int&amp;</span><br><span class="hljs-built_in">f</span>(rx); <span class="hljs-comment">// rx是左值，所以T的型别是const int&amp;，param的型别也是const int&amp;</span><br><span class="hljs-built_in">f</span>(<span class="hljs-number">27</span>); <span class="hljs-comment">// 27是右值，所以T的型别是int，param的型别就成了int&amp;&amp;</span><br></code></pre></td></tr></table></figure><p><strong>情况3: ParamType既非指针也非引用</strong></p><p>因为是值传递，引用、顶层const、volatile均忽略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br><br><span class="hljs-type">int</span> x=<span class="hljs-number">27</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cx = x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rx = X;<br><br><span class="hljs-built_in">f</span>(x); <span class="hljs-comment">// T和param的型别都是int</span><br><span class="hljs-built_in">f</span>(cx); <span class="hljs-comment">// T和param的型别还都是int</span><br><span class="hljs-built_in">f</span>(rx); <span class="hljs-comment">// T和param的型别仍都是int</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> ptr = <span class="hljs-string">&quot;Fun with pointers&quot;</span>; <span class="hljs-comment">// ptr是个指涉到const对象的const指针</span><br><span class="hljs-built_in">f</span>(ptr); <span class="hljs-comment">//传递型别为const char * const 的实参，param的型别被推导为const char *</span><br><span class="hljs-comment">// 底层const得到保留，即一个可修改的，指向const字符串的指针</span><br></code></pre></td></tr></table></figure><p><strong>数组实参</strong></p><p>数组会<strong>退化</strong>为指向到其首元素的指针，除了引用方式传参的时候。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 两种声明等价</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> param[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(<span class="hljs-type">int</span>* param)</span></span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;J. P. Briggs&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptrToName = name;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br><span class="hljs-built_in">f</span>(name); <span class="hljs-comment">// name是数组，但T的型别被推导成const char *</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;<br><span class="hljs-built_in">f</span>(name); <span class="hljs-comment">// T的型别是const char [13]，param的型别是const char (&amp;)[13]</span><br></code></pre></td></tr></table></figure><p>推导数组尺寸的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">arraySize</span><span class="hljs-params">(T (&amp;)[N])</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> N;<br>&#125;<br><span class="hljs-type">int</span> keyVals[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">35</span>&#125;;<br><span class="hljs-type">int</span> mappedVals[<span class="hljs-built_in">arraySize</span>(keyVals)];<br>std::array&lt;<span class="hljs-type">int</span>, arraySize(keyVals)&gt; mappedVals;<br></code></pre></td></tr></table></figure><p><strong>函数实参</strong></p><p>函数型别会<strong>退化</strong>为函数指针，除了引用方式传参的时候。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(T param)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(T&amp; param)</span></span>;<br><br><span class="hljs-built_in">f1</span>(someFunc); <span class="hljs-comment">// param型别是void (*)(int, double)，函数指针</span><br><span class="hljs-built_in">f2</span>(someFunc); <span class="hljs-comment">// param型别是void (&amp;)(int, double)，函数引用</span><br></code></pre></td></tr></table></figure><h2 id="条款2-理解auto型别推导">条款2 理解auto型别推导</h2><p>在模板型别推导和auto型别推导可以建立起<strong>一一映射</strong>。映射仅指概念上等价，并不是编译器真的生成了该模板和语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_for_x</span><span class="hljs-params">(T param)</span></span>;<br><span class="hljs-built_in">func_for_x</span>(<span class="hljs-number">27</span>);<br><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> cx = x;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_for_cx</span><span class="hljs-params">(<span class="hljs-type">const</span> T param)</span></span>;<br><span class="hljs-built_in">func_for_cx</span>(x);<br><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; rx = x;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_for_rx</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span></span>;<br><span class="hljs-built_in">func_for_rx</span>(x);<br></code></pre></td></tr></table></figure><p>条款1的规则也适用于auto型别推导，只有<strong>一个例外</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 四种初始化语法</span><br><span class="hljs-comment">// C++98的两种</span><br><span class="hljs-type">int</span> x1 = <span class="hljs-number">27</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x2</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span></span>;<br><span class="hljs-comment">// C++11增加的两种</span><br><span class="hljs-type">int</span> x3 = &#123; <span class="hljs-number">27</span> &#125;;<br><span class="hljs-type">int</span> x4&#123; <span class="hljs-number">27</span> &#125;;<br><br><span class="hljs-comment">// 型别是int,值是27</span><br><span class="hljs-keyword">auto</span> x1 = <span class="hljs-number">27</span>;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">x2</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span></span>;<br><span class="hljs-comment">// 型别是std::initializer_list&lt;int&gt;,值是&#123; 27 &#125;</span><br><span class="hljs-keyword">auto</span> x3 = &#123; <span class="hljs-number">27</span> &#125;;<br><span class="hljs-keyword">auto</span> x4&#123; <span class="hljs-number">27</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br><span class="hljs-built_in">f</span>(&#123; <span class="hljs-number">27</span> &#125;); <span class="hljs-comment">// 错误</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(std::initializer_list&lt;T&gt; initList)</span></span>;<br><span class="hljs-built_in">f</span>(&#123; <span class="hljs-number">27</span> &#125;); <span class="hljs-comment">// 正确，T推导为int</span><br></code></pre></td></tr></table></figure><p>C++14允许使用auto来说明函数返回值需要推导、lambda表达式会在形参声明中用到auto，这些auto是在<strong>使用模板型别推导而非auto型别推导</strong>。因此以下用法是错误的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">createInitList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// 错误</span><br>&#125;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">auto</span> resetV = [&amp;v](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; newValue) &#123; v = newValue; &#125;; <br><span class="hljs-built_in">resetV</span>(&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><h2 id="条款3-理解decltype">条款3 理解decltype</h2><p>C++11的<strong>返回值型别尾序语法</strong> (trailing return typesyntax)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在指定返回值型别时可以使用函数形参</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(c[i])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">authenticateUser</span>();<br>    <span class="hljs-keyword">return</span> c[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>C++11允许单表达式的lambda式的<strong>返回值型别推导</strong>，而C++14则将这个允许范围扩张到了一切lambda式和一切函数，<strong>可以只保留auto</strong>，但不总是正确，因为auto推导会<strong>忽略引用</strong>。C++14使用decltype(auto)解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp; c, Index i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">authenticateUser</span>();<br>    <span class="hljs-keyword">return</span> c[i];<br>&#125;<br><br>Widget w;<br><span class="hljs-type">const</span> Widget&amp; cw = w;<br><span class="hljs-keyword">auto</span> myWidget1 = cw;<span class="hljs-comment">// auto型别推导，myWidget1的型别是Widget</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) myWidget2 = cw; <span class="hljs-comment">// decltype型别推导，myWidget2的型别是const Widget&amp;</span><br></code></pre></td></tr></table></figure><p>再考虑到传递右值的情况，<code>authAndAccess</code>函数应使用万能引用和<code>std::forward</code>（参见条款25）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> Index&gt;</span><br><span class="hljs-function"><span class="hljs-title">dectype</span><span class="hljs-params">(<span class="hljs-keyword">auto</span>)</span> <span class="hljs-title">authAndAccess</span><span class="hljs-params">(Container&amp;&amp; c, Index i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">authenticateUser</span>();<br>    <span class="hljs-keyword">return</span> std::forward&lt;Container&gt;(c)[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>decltype存在艰涩的例外情况，本书不完全展开。</p><p>对于型别为T的左值表达式，除非该表达式仅有一个名字，decltype总是得出型别T&amp;。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// decltype(x)是int，decltype((x))是int&amp;。因为C++定义表达式(x)也是一个左值。</span><br></code></pre></td></tr></table></figure><h2 id="条款4-掌握查看型别推导结果的方法">条款4掌握查看型别推导结果的方法</h2><ol type="1"><li><p>IDE的提示</p></li><li><p>编译器诊断信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TD</span>; <span class="hljs-comment">// Type Displayer</span><br>TD&lt;<span class="hljs-keyword">decltype</span>(x)&gt; xType; <span class="hljs-comment">// 因为模板未定义，所以编译器会输出包括x型别得诊断信息</span><br><span class="hljs-comment">// 如：error: aggregate &#x27;TD&lt;int&gt; xType&#x27; has incomplete type and cannot be defined</span><br></code></pre></td></tr></table></figure></li><li><p>运行时输出</p><p>不同编译器实现不同。<code>std::type_info::name</code>中处理型别的方式<strong>仿佛</strong>是向函数模板桉值传递形参那样，引用、顶层const、volatile会被忽略，因此并不可靠。</p><p><code>&lt;boost/type_index.hpp&gt;</code>库表现更好：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/type_index.hpp&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> boost::typeindex::type_id_with_cvr;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;T = &quot;</span> &lt;&lt; <span class="hljs-built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="hljs-built_in">pretty_name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;param = &quot;</span> &lt;&lt; <span class="hljs-built_in">type_id_with_cvr</span>&lt;<span class="hljs-keyword">decltype</span>(param)&gt;().<span class="hljs-built_in">pretty_name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="第2章-auto">第2章 auto</h1><h2 id="条款5-优先选用auto而非显式型别声明">条款5优先选用auto，而非显式型别声明</h2><p>std::function通常比起auto又大又慢，还可能导致内存耗尽异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::pair&lt;std::string, <span class="hljs-type">int</span>&gt;&amp; p : m) <span class="hljs-comment">// key应该是const std::string，写成这样会导致多余的复制开销</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-type">unsigned</span> sz = v.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// std::vector&lt;int&gt;::size_type和unsigned不一定位数相同</span><br></code></pre></td></tr></table></figure><h2id="条款6-当auto推导的型别不符合要求时使用带显式型别的初始化物习惯用法">条款6当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法</h2><p><strong>特例</strong>：<code>std::vector&lt;bool&gt;</code>的<code>operator[]</code>的返回值<strong>并不是容器中的一个元素的引用</strong>，而是<code>std::vector&lt;bool&gt;::reference</code>型别（嵌套在<code>std::vector&lt;bool&gt;</code>里的类，一个<strong>代理类</strong>）的对象。因为<code>std::vector&lt;bool&gt;</code>用一个比特表示一个bool元素，而<strong>C++禁止比特的引用</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">features</span><span class="hljs-params">(<span class="hljs-type">const</span> Widget&amp; w)</span></span>;<br>Widget w;<br><span class="hljs-type">bool</span> highPriority = <span class="hljs-built_in">features</span>(w)[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">auto</span> highPriority = <span class="hljs-built_in">features</span>(w)[<span class="hljs-number">5</span>]; <span class="hljs-comment">// highPriority型别不是bool，不符合预期</span><br><span class="hljs-built_in">processWidget</span>(w, highPriority);<br></code></pre></td></tr></table></figure><p>防止这样的代码：<code>auto someVar = ”隐形"代理型别表达式;</code></p><p>带显式型别的初始化物习惯用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> highPriority = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-built_in">features</span>(w)[<span class="hljs-number">5</span>]);<br></code></pre></td></tr></table></figure><h1 id="第3章-转向现代c">第3章 转向现代C++</h1><h2 id="条款7-在创建对象时注意区分和">条款7在创建对象时注意区分()和</h2><p>条款2中提到过，C++有<strong>四种初始化语法</strong>。（初始化与赋值是两码事）</p><p>C++11引入<strong>大括号初始化</strong>，适用于<strong>所有场合</strong>。小括号初始化不适用于为非静态成员指定默认初始化值，等号初始化不适用于不可复制的对象（如<code>std::atomic</code>型别的对象）。</p><p>大括号初始化<strong>禁止内置型别的隐式窄化型别转换</strong>，如double到int。</p><p><strong>C++最令人苦恼之解析语法</strong>（most vexingparse）：任何能够解析为声明的都要解析为声明。可以用大括号初始化解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Widget <span class="hljs-title">w1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 调用Widget的构造函数，传入形参10</span><br><span class="hljs-function">Widget <span class="hljs-title">w2</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 声明了一个名为w2，返回Widget型别对象的函数</span><br>Widget w3&#123;&#125;; <span class="hljs-comment">// 调用没有形参的Widget构造函数</span><br></code></pre></td></tr></table></figure><p>只要有可能，编译器就会优先把大括号初始化语法解读为带有<code>std::initializer_list</code>型别形参的构造函数。（类似的，条款2曾提到，使用<strong>大括号初始化物</strong>来初始化用auto声明的变量会使推导出的型别称为<code>std::initializer_list</code>）（空大括号优先表示没有实参而不是空的<code>std::initializer_list</code>）</p><p>对于vector，使用()还是{}有很大区别，例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomeWork</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 利用params创建局部对象T</span><br>    <span class="hljs-function">T <span class="hljs-title">localObject</span><span class="hljs-params">(std::forward&lt;Ts&gt;(params)...)</span></span>; <span class="hljs-comment">// 小括号</span><br>    T localObject&#123;std::forward&lt;Ts&gt;(params)...&#125;; <span class="hljs-comment">// 大括号</span><br>&#125;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>doSomeWork&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>); <br><span class="hljs-comment">// 如果doSomeWork在创建local0bject使用了小括号，结果会得到一个包含10个元素的std::vector。</span><br><span class="hljs-comment">// 如果doSomeWork使用了大括号，结果会得到一个包含2个元素的std::vector。</span><br><br><span class="hljs-comment">// std::make_unique和std::make_shared使用小括号</span><br></code></pre></td></tr></table></figure><h2 id="条款8-优先选用nullptr而非0或null">条款8优先选用nullptr，而非0或NULL</h2><p>C++11以前，不要在指针型别和整型之间做重载。C++11的nullptr不具备整型类型。</p><p>nullptr的实际型别是<code>std::nullptr_t</code>，循环定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>    <span class="hljs-keyword">namespace</span> std<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(__nullptr)</span> <span class="hljs-type">nullptr_t</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">using</span> ::std::<span class="hljs-type">nullptr_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="条款9-优先选用别名声明而非typedef">条款9优先选用别名声明，而非typedef</h2><p>C++11引入别名声明。</p><p>更易理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 别名声明</span><br><span class="hljs-keyword">using</span> FP = <span class="hljs-built_in">void</span> (*)(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> std::string&amp;);<br><br><span class="hljs-comment">// typedef</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*FP)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> std::string&amp;)</span></span>;<br></code></pre></td></tr></table></figure><p>可以模板化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 别名声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;<br>MyAllocList&lt;Widget&gt; lw;<br><br><span class="hljs-comment">// typedef</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyAllocList</span> &#123;<br>    <span class="hljs-keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;<br>&#125;;<br>MyAllocList&lt;Widget&gt;::type lw;<br><span class="hljs-comment">// 并且，依赖于模板型别形参的型别前面必须加typename</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typename</span> MyAlloclist&lt;T&gt;::type list;<br>&#125;;<br></code></pre></td></tr></table></figure><p>头文件<code>&lt;type_traits&gt;</code>有可以修改型别的工具：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++11中，仍使用typedef实现</span><br>std::remove_const&lt;T&gt;::type<br>std::remove_reference&lt;T&gt;::type<br>std::add_lvalue_reference&lt;T&gt;::type<br><span class="hljs-comment">// C++14中，使用别名声明</span><br>std::<span class="hljs-type">remove_const_t</span>&lt;T&gt;<br>std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;<br>std::<span class="hljs-type">add_lvalue_reference_t</span>&lt;T&gt;<br></code></pre></td></tr></table></figure><h2id="条款10-优先选用限定作用域的枚举型别而非不限作用域的枚举型别">条款10优先选用限定作用域的枚举型别，而非不限作用域的枚举型别</h2><p>C++11的限定作用域的枚举防止了枚举量的名字<strong>泄漏</strong>到枚举型别所在作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; black, white, red &#125;;<br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 错误，已声明</span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123; black, white, red &#125;;<br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p>此外，限定作用域的枚举型别无法<strong>隐式</strong>转换到其它型别。</p><p>C++98不限定作用域的枚举无法进行前置声明，因为无法确认其<strong>底层型别</strong>。若取值范围小会用char，更大则用更大的整数型别。这时，即使只有一个函数用到这个枚举量，修改枚举会导致整个系统重新编译。</p><p>C++11限定作用域的枚举可以前置声明，因为其底层型别默认是int，并且可以手动指定。不限定作用域枚举手动指定底层型别后也可以前置声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Status</span>: std::<span class="hljs-type">uint32_t</span>; <br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>: std::<span class="hljs-type">uint8_t</span>;<br></code></pre></td></tr></table></figure><p>不限作用域的枚举唯一的优点：用来取<code>std::tuple</code>型别的各个域更方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> UserInfo = std::tuple&lt;std::string, <span class="hljs-comment">// 名字</span><br>                std::string, <span class="hljs-comment">// 电子邮件</span><br>                std::<span class="hljs-type">size_t</span>&gt;; <span class="hljs-comment">// 声望值</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;<br>UserInfo uInfo;<br><span class="hljs-keyword">auto</span> val = std::<span class="hljs-built_in">get</span>&lt;uiEmail&gt;(uInfo); <br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;<br>UserInfo uInfo;<br><span class="hljs-keyword">auto</span> val = std::get&lt;<span class="hljs-built_in">static_cast</span>&lt;std::<span class="hljs-type">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;(uInfo);<br><span class="hljs-comment">// 可以写一个函数对其进行简化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">toUType</span><span class="hljs-params">(E enumerator)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;std::<span class="hljs-type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);<br>&#125;<br><span class="hljs-keyword">auto</span> val = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-built_in">toUType</span>(UserInfoFields::uiEmail)&gt;(uInfo);<br></code></pre></td></tr></table></figure><h2 id="条款11-优先选用删除函数而非private未定义函数">条款11优先选用删除函数，而非private未定义函数</h2><p>阻止C++自动生成的成员函数被调用，优先选用C++11的<code>=delete</code>。</p><p>删除函数习惯上声明为public，当被错误使用时报错信息更明确。</p><p><strong>非成员函数</strong>可以定义为删除函数，借此可以禁止非成员函数的指定重载版本。</p><p><strong>特化函数模板</strong>（包括特化成员函数模板）可以定义为删除函数。</p><h2 id="条款12-为意在改写的函数添加override声明">条款12为意在改写的函数添加override声明</h2><p>override的要求：</p><ol type="1"><li>基类中的函数必须是虚函数。</li><li>基类和派生类中的函数名字必须完全相同（析构函数例外）。</li><li>基类和派生类中的函数形参型别必须完全相同。</li><li>基类和派生类中的函数常量性（constness）必须完全相同。</li><li>基类和派生类中的函数返回值和异常规格必须兼容。</li><li>基类和派生类中的<strong>函数引用饰词</strong>（referencequalifier）必须完全相同。（C++11新增）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> &amp;</span>; <span class="hljs-comment">// 这个版本的doWork仅在*this是左值时调用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> &amp;&amp;</span>; <span class="hljs-comment">// 这个版本的doWork仅在*this是右值时调用</span><br>&#125;;<br><br><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 工厂函数（返回右值）</span><br>Widget w; <span class="hljs-comment">// 普通对象（左值）</span><br><br>W.<span class="hljs-built_in">doWork</span>(); <span class="hljs-comment">// 以左值调用Widget::doWork</span><br><span class="hljs-built_in">makeWidget</span>().<span class="hljs-built_in">doWork</span>(); <span class="hljs-comment">// 以右值调用Widget::doWork</span><br><br><span class="hljs-comment">// 最佳实践</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = std::vector&lt;<span class="hljs-type">double</span>&gt;;<br>    <span class="hljs-function">DataType&amp; <span class="hljs-title">data</span><span class="hljs-params">()</span> &amp;</span><br><span class="hljs-function">    </span>&#123;<br>         <span class="hljs-keyword">return</span> values; <span class="hljs-comment">// 对于左值Widgets型别，返回左值</span><br>    &#125;<br>    <span class="hljs-function">DataType <span class="hljs-title">data</span><span class="hljs-params">()</span> &amp;&amp;</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(values); <span class="hljs-comment">// 对于右值Widgets型别，返回右值</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    DataType values;<br>&#125;;<br></code></pre></td></tr></table></figure><p>C++新增了两个<strong>语境关键字</strong>（contextualkeyword）：override和final。语言保留这两个关键字，但仅在特定语境下保留，以下代码升级到C++11后依然合法。</p><h2 id="条款13-优先选用const_iterator-而非iterator">条款13优先选用const_iterator， 而非iterator</h2><p>从<code>const_ iterator</code>到<code>iterator</code><strong>不存在可移植的型别转换</strong>，连<code>static_cast</code>及<code>reinterpret_ cast</code>也不行。C++98和C++11皆然。</p><p>由于在标准化过程中的短视，C++11仅添加了<strong>非成员函数版本</strong>的begin和end，而没有添加cbegin、cend、rbegin、rend、crbegin和crend。C++14纠正了这种短视。</p><h2 id="条款14-只要函数不会发射异常就为其加上noexcept声明">条款14只要函数不会发射异常，就为其加上noexcept声明</h2><p>C++98异常规格已被废弃，C++11只关心<strong>是否</strong>发射异常。</p><p>noexcept声明使<strong>优化器</strong>可以更好地优化，不需要在异常传出函数的前提下，将执行期栈保持在可开解状态；也不需要在异常溢出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构。</p><p>C++98中<code>std::vector</code>的扩容做法是先把元素从旧内存复制到新内存，再析构旧内存中的对象。这个做法使<code>push_back</code>提供了<strong>强异常安全保证</strong>：若复制过程中抛出了异常，原对象保持原样不变。C++11引入了移动语义，仅在移动操作不会发射异常（带有noexcept声明）的前提下，<code>push_back</code>等函数会把C++98中的赋值操作替换为C++11中的移动操作。</p><p>默认地，<strong>内存释放函数</strong>和<strong>所有的析构函数</strong>（无论是用户定义的，还是编译器自动生成的）都隐式地具备noexcept性质。这么一来，它们就无须加上noexcept声明了。</p><blockquote><p>析构函数未隐式地具备noexcept性质的唯一场合：所在类中有数据成员（包括继承而来的成员，以及在其他数据成员中包含的数据成员）的型别显式地将其析构函数声明为可能发射异常的，为其加上<code>noexcept(false)</code>声明。这样的析构函数很少见，标准库里一个也没有，而如果标准库使用了某个对象（例如，被包含在容器内，或被传递给某个算法），而其析构函数发射了异常，则该程序行为是<strong>未定义</strong>的。</p></blockquote><p>有理由使得带有noexcept声明的函数依赖于缺乏noexcept保证的代码（调用不带noexcept声明的来此C或者C++98的函数），C++允许此类代码通过编译，并且编译器通常不会就此生成警告。</p><h2 id="条款15-只要有可能使用constexpr就使用它">条款15只要有可能使用constexpr，就使用它</h2><p><strong>对于对象</strong>，constexpr代表不仅是const而且<strong>在编译阶段已知</strong>，因此可以放置在只读内存以进行优化，可以用于数组尺寸、枚举量的值、对齐规格等。</p><p><strong>对于函数</strong>，constexpr代表函数在调用时若传入的所有参数均是编译期常量，则产出编译期常量；若传入的参数含有直至运行期才知晓的值，则产出运行期值，与普通函数无异。</p><p>C++11中，constexpr函数不得包含多于一个可执行语句，即一条return语句；constexpr函数被隐式声明为const，无法修改对象的非mutable数据成员；返回型别void不是字面型别。C++14放宽以上限制。</p><p><strong>字面型别</strong>即可以持有编译期可以决议的值的型别，<strong>用户自定义型别同样可能也是字面型别</strong>，因为它的构造函数和其他成员函数可能也是constexpr函数。</p><h2 id="条款16-保证const成员函数的线程安全性">条款16保证const成员函数的线程安全性</h2><p>对于单个要求同步的变量或内存区域，使用<code>std::atomic</code>足够且性能更好。</p><p>如果有两个或更多个变量或内存区域需要作为一整个单位进行操作时，应使用互斥量。</p><h2 id="条款17-理解特种成员函数的生成机制">条款17理解特种成员函数的生成机制</h2><p>特种成员函数即C++会自行生成的成员函数，包括<strong>默认构造函数、析构函数、复制构造函数，复制赋值运算符、移动构造函数、移动赋值运算符</strong>。</p><p>自动生成的C++移动构造函数和移动赋值运算符执行作用于非静态成员的<strong>按成员移动</strong>操作。按成员移动由两部分组成的，一部分是在支持移动操作的成员上执行的移动操作，另一部分是在不支持移动操作的成员上执行的复制操作。</p><p>两种复制操作是彼此独立的，声明了其中一个，并不会阻止编译器生成另一个。</p><p>两种移动操作并不彼此独立，声明了其中一个，就会阻止编译器生成另一个。</p><p>声明了复制操作，不再会生成移动操作了。</p><p>声明了移动操作，复制操作会废除（=delete）。</p><p>大三律（Rule ofThree）：如果声明了复制构造函数、复制赋值运算符、析构函数中的任何个，就得同时声明所有个。</p><p><strong>默认构造函数</strong>：仅当类中不包含声明的构造函数时才生成。</p><p><strong>析构函数</strong>：仅当类中不包含声明的析构函数时才生成。仅当基类的析构函数为虚，派生类的析构函数才为虚。默认为noexcept。</p><p><strong>复制构造函数</strong>：当该类未声明复制构造函数时生成。声明移动操作会导致其被废除。已声明复制赋值运算符或析构函数时，仍然生成复制构造函数已经成为了被废弃的行为。</p><p><strong>复制赋值运算符</strong>：当该类未声明复制赋值运算符时生成。声明移动操作会导致其被废除。已声明复制构造函数或析构函数时，仍然生成复制赋值运算符已经成为了被废弃的行为。</p><p><strong>移动构造函数和移动赋值运算符</strong>：当该类未声明析构函数、复制操作、移动操作时生成。</p><p><strong>成员函数模板</strong>在任何情况下都不会抑制特种成员函数的生成。（条款26与之相关）</p><h1 id="第4章-智能指针">第4章 智能指针</h1><h2 id="条款18-使用stdunique_ptr管理具备专属所有权的资源">条款18使用std::unique_ptr管理具备专属所有权的资源</h2><p><code>std::unique_ptr</code>不允许复制，是只移型别。</p><p><code>std::unique_ptr</code>可能不调用托管资源析构函数的情况：</p><ol type="1"><li>异常传播开影响到某个线程的主函数</li><li>违反了noexcept异常规格</li><li><code>std::abort</code>、<code>std::_Exit</code>、<code>std::exit</code>、<code>std::quick_exit</code>（必定不调用局部对象析构函数）</li></ol><h2 id="条款19-使用stdshared_ptr管理具备共享所有权的资源">条款19使用std::shared_ptr管理具备共享所有权的资源</h2><p><code>std::shared_ptr</code>可以通过访问某资源的<strong>引用计数</strong>来确定是否自己是最后一个指涉到该资源的。</p><p>引用计数带来的性能影响：</p><ol type="1"><li>尺寸是裸指针的两倍（具体看实现）</li><li>引用计数的内存必须动态分配</li><li>引用计数的递增和递减必须是原子操作</li></ol><p>与<code>std::unique_ptr</code>不同，<code>std::shared_ptr</code>的析构器型别不是智能指针型别的一部分，更灵活。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> loggingDel = [](Widget *pw) <span class="hljs-comment">// 自定义析构器</span><br>&#123;<br>    <span class="hljs-built_in">makeLogEntry</span>(pw);<br>    <span class="hljs-keyword">delete</span> pw;<br>&#125;;<br><br><span class="hljs-comment">// 析构器型别是智能指针型别的一部分</span><br><span class="hljs-function">std::unique_ptr&lt;Widget, <span class="hljs-title">dec1type</span><span class="hljs-params">(<span class="hljs-number">1</span>oggingDe1)</span>&gt; <span class="hljs-title">upw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, <span class="hljs-number">1</span>oggingDel)</span></span>;<br><br><span class="hljs-comment">// 析构器型别不是智能指针型别的一部分</span><br><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spW</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, loggingDe1)</span></span>;<br></code></pre></td></tr></table></figure><p>与<code>std::unique_ptr</code>不同，自定义析构器不会改变<code>std::shared_ptr</code>的尺寸，无论析构器是怎样的型别，<code>std::shared_ptr</code>对象的尺寸都相当于裸指针的两倍。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-09-22-shared_ptr.png" /></p><p>避免将<strong>裸指针</strong>传递给一个<code>std::shared_ptr</code>的构造函数，以免创建多个控制块、拥有多个引用计数。</p><p>创建多控制块情形一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pw = <span class="hljs-keyword">new</span> Widget; <br><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spw1</span><span class="hljs-params">(pW, loggingDe1)</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spw2</span><span class="hljs-params">(pw, loggingDel)</span></span>;<br></code></pre></td></tr></table></figure><p>创建多控制块情形二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-type">void</span> Widget::process<br>&#123;<br>    processedWidgets.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 新创建控制块</span><br>&#125;<br><br><span class="hljs-comment">// 解决办法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; &#123; <span class="hljs-comment">// 奇妙递归模板模式 (The Curiously Recurring Template Pattern, CRTP)</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-type">void</span> Widget::process<br>&#123;<br>    processedWidgets.<span class="hljs-built_in">emplace_back</span>((<span class="hljs-built_in">shared_from_this</span>()); <br>&#125;<br></code></pre></td></tr></table></figure><p>可以由<code>std::unique_ptr</code>构造<code>std::shared_ptr</code>，反之不成立。</p><p>有<code>std::unique_ptr&lt;T[]&gt;</code>，没有<code>std::shared_ptr&lt;T[]&gt;</code>。</p><h2id="条款20-对于类似stdshared_ptr但有可能空悬的指针使用stdweak_ptr">条款20对于类似std::shared_ptr但有可能空悬的指针使用std:weak_ptr</h2><p><code>std::weak_ptr</code>并不是一种独立的智能指针，而是<code>std::shared_ptr</code>的一种扩充，一般通过后者创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> spw = std::<span class="hljs-built_in">make_shared</span>&lt;Widget&gt;();<br><span class="hljs-function">std::weak_ptr&lt;Widget&gt; <span class="hljs-title">wpw</span><span class="hljs-params">(spw)</span></span>;<br><span class="hljs-comment">// 可用wpw.expired()检查指针是否空悬</span><br></code></pre></td></tr></table></figure><p><code>std::weak_ptr</code>可用于缓存、观察者模式、避免循环引用等情况。</p><h2id="条款21-优先选用stdmake_unique和stdmake_shared而非直接使用new">条款21优先选用std::make_unique和std::make_shared，而非直接使用new</h2><p><code>std::make_shared</code>在C++11加入，<code>std::make_unique</code>在C++14加入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function">std::unique_ptr&lt;T&gt; <span class="hljs-title">make_unique</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(std::forward&lt;Ts&gt;(params)...));<br>&#125;<br></code></pre></td></tr></table></figure><p>new可能导致内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">computePriority</span>()); <br><span class="hljs-comment">// 编译器未规定new Widget、shared_ptr构造函数、computePriority函数调用三个操作的顺序</span><br><span class="hljs-comment">// 若new Widget后直接进行computePriority函数调用并发生异常，将导致内存泄漏</span><br><span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">make_shared</span>&lt;Widget&gt;(), <span class="hljs-built_in">computePriority</span>());<br><span class="hljs-comment">// 可以通过make系列函数避免</span><br></code></pre></td></tr></table></figure><p>make系列函数的缺点：</p><ol type="1"><li>无法自定义析构器。</li><li>无法完美转发大括号初始化物（对形参进行完美转发时使用圆括号）。</li></ol><p>对于<code>std::shared_ptr</code>，make系列函数额外的缺点：</p><ol type="1"><li><p>不适用于有自身版本的opeator new和operatordelete的类。因为<code>std::allocate_shared</code>要求的内存数量并不等于动态分配对象的尺寸，而是该尺寸的基础上加上控制块的尺寸（参见条款19图）。</p></li><li><p><code>std::make_shared</code>使<code>std::shared_ptr</code>的<strong>控制块和托管对象在同一内存块上分配</strong>。此时，就算最后一个<code>std::shared_ptr</code>析构，只要还存在<code>std::weak_ptr</code>，托管对象内存也不会释放，因为与其关联的控制块内存没有释放（控制块有弱计数）。</p></li></ol><blockquote><p>弱计数（参见条款19图）对指涉到该控制块的<code>std::weak_ptr</code>进行计数。</p><p>实际上，弱计数的值并不始终等于指涉到控制块的<code>std::weak_ptr</code>的数量，因为库的实现者已经找到了某些方法向弱计数加入额外信息以促进更好的代码生成。</p></blockquote><h2id="条款22-使用pimpl习惯用法时将特殊成员函数的定义放到实现文件中">条款22使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h2><p>Pimpl即pointer to implementation。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br><span class="hljs-keyword">private</span>:<br>    std::string name;<br>    std::vector&lt;<span class="hljs-type">double</span>&gt; data;<br>    Gadget g1, g2, g3;<br>&#125;;<br><br><span class="hljs-comment">// Pimpl</span><br><span class="hljs-comment">// 减少了Wiget的客户需要包含的头文件</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    ~<span class="hljs-built_in">Widget</span>();<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Impl</span>;<br>    Imp1 *pImpl;<br>    <span class="hljs-comment">// Widget::Impl是一个已声明但未定义的不完整型别，可以声明指涉其的指针</span><br>    <span class="hljs-comment">// 因为Widget::Impl是不玩</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>现代C++中Pimpl通常使用<code>std::unique_ptr</code>实现，但是注意，应将析构函数和移动操作（引发析构）的定义放在<strong>实现文件中的不完整型别的定义之后</strong>，因为在实施delete运算符之前会使用C++11中的<code>static_assert</code>去确保裸指针未指涉到非完整型别。</p><blockquote><p>对于<code>std::unique_ptr</code>而言，析构器型别是智能指针型别的一部分，这使得编译器会产生更小尺寸的运行期数据结构以及更快速的运行期代码。如此高效带来的后果是，欲使用编译器生成的特种函数（例如，析构函数或移动操作），就要求其指涉到的型别必须是完整型别。</p><p>对于<code>std::shared_ptr</code>而言，析构器的型别并非智能指针型别的一部分，这就需要更大尺寸的运行时期数据结构以及更慢一些的目标代码，但在使用编译器生成的特种函数时，其指涉到的型别却并不要求是完整型别。</p></blockquote><h1 id="第5章-右值引用移动语义和完美转发">第5章右值引用、移动语义和完美转发</h1><p>移动语义使得创建<strong>只移型别</strong>对象成为可能，这些型别包括<code>std::unique_ ptr</code>、<code>std::future</code>、<code>std:: thread</code>等。</p><p><strong>形参总是左值</strong>，即使其型别是右值引用。</p><h2 id="条款23-理解stdmove和stdforward">条款23理解std::move和std::forward</h2><p>这两者在运行期无所作为，不会生成任何可执行代码，仅仅执行强制型别转换。</p><p><code>std::move</code>只做一件事，把实参强制转换成右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::move的示例实现（C++14）</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> ReturnType = <span class="hljs-type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;ReturnType&gt;(param);<br>&#125;<br><span class="hljs-comment">// std::forward的示例实现见条款28</span><br></code></pre></td></tr></table></figure><p><code>std::move</code><strong>不保证经过其强制型别转换后的对象具备可移动的能力</strong>。针对常量对象执行的移动操作将一声不响地变换成复制操作，例如左值<code>const std::string</code>转换为右值<code>const std::string</code>，仍调用复制构造函数。</p><p>因为形参总是左值，<code>std::forward</code><strong>只在传入形参的实参使用右值初始化时</strong>，把实参强制转化为右值。</p><h2 id="条款24-区分万能引用和右值引用">条款24区分万能引用和右值引用</h2><p>当&amp;&amp;涉及<strong>型别推导</strong>，如auto、函数模板形参（比如形如T&amp;&amp;）时，是万能引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 万能引用</span><br><span class="hljs-keyword">auto</span>&amp;&amp; var2 = var1;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;<br><br><span class="hljs-comment">//右值引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Widget&amp;&amp; param)</span></span>; <span class="hljs-comment">// 没有型别推导</span><br><br>Widget&amp;&amp; var1 = <span class="hljs-built_in">Widget</span>(); <span class="hljs-comment">// 没有型别推导</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="hljs-comment">// 不形如T&amp;&amp;</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;&amp; param)</span></span>; <span class="hljs-comment">// 有const饰词</span><br><br><span class="hljs-comment">// 注意！</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> = allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">push_back</span>(T&amp;&amp; x); <span class="hljs-comment">// 由std::vector模板具现化的实例决定，没有型别推导，是右值引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>.. Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>; <span class="hljs-comment">// 独立于std::vector模板的型别形参T，有型别推导，是万能引用</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="条款25-针对右值引用实施stdmove针对万能引用实施stdforward">条款25针对右值引用实施std::move，针对万能引用实施std::forward</h2><p>在按值返回的函数中，如果返回的是绑定到一个右值引用或一个万能引用的对象，则当你返回该引用时，应该对其实施<code>std::move</code>或者<code>std::forward</code>。</p><p><strong>返回值优化</strong> （return value optimization,RVO）：当局部对象型别和函数返回值型别相同<strong>且</strong>返回值就是局部对象本身（而不是引用），编译器<strong>可以选择</strong>在一个按值返回的函数里省略对局部对象的复制（或者移动），<strong>直接在为函数返回值分配的内存上创建局部变量</strong>。当编译器选择不执行RVO时，返回对象必须作为右值处理，相当于<code>std:: move</code>隐式地被实施于返回的局部对象上。所以若局部对象可能适用于RVO，请勿针对其实施<code>std::move</code>或<code>std:: forward</code>。</p><blockquote><p>有人对RVO实施在局部对象时，权据局部对象具名或不具名（亦即临时）的特性进行了区分，限制了RVO对不具名对象的使用，并将其对具名对象实施者，特别地称为<strong>具名返回值优化</strong>（namedreturn value optimization, NRVO）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Widget <span class="hljs-title">makeWidget</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Widget w;<br>    ...<br>    <span class="hljs-keyword">return</span> w;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条款26-避免依万能引用型别进行重载">条款26避免依万能引用型别进行重载</h2><p>形参为万能引用的函数和几乎任何型别都会产生精确匹配（条款30描述了几种不属于该情况的实参），<strong>不要把万能引用作为重载候选型别</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 重载版本1</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">&quot;logAndAdd&quot;</span>);<br>    names.<span class="hljs-built_in">emplace</span>(std::forward&lt;T&gt;(name));<br>&#125;<br><span class="hljs-function">std::string <span class="hljs-title">nameFromIdx</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span>;<br><br><span class="hljs-comment">// 重载版本2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">&quot;logAndAdd&quot;</span>);<br>    names.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">nameFromIdx</span>(idx));<br>&#125;<br><br><span class="hljs-type">short</span> nameIdx;<br><span class="hljs-built_in">logAndAdd</span>(nameIdx); <span class="hljs-comment">// 调用了重载版本1，因为精确匹配优先于型别提升匹配（short提升到int）</span><br></code></pre></td></tr></table></figure><p><strong>完美转发构造函数</strong>会造成严重问题，对于非常量的左值型别而言，它一般会形成相对于复制构造函数的更佳匹配，并且它们还会劫持派生类中对基类的复制和移动构造函数的调用（调用基类的完美转发构造函数）。</p><h2 id="条款27-熟悉依万能引用型别进行重载的替代方案">条款27熟悉依万能引用型别进行重载的替代方案</h2><ol type="1"><li><p>放弃重载</p></li><li><p>传递<code>const T&amp;</code>型别的形参代替万能引用</p></li><li><p>传值代替万能引用</p></li><li><p>标签分派</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对条款26中代码的改进</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAndAdd</span><span class="hljs-params">(T&amp;&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-number">1</span>ogAndAddImpl(std::forward&lt;T&gt;(name),<br>                  std::is_integral&lt;std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&gt;());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAndAddImp1</span><span class="hljs-params">(T&amp;&amp; name, std::false_type)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">log</span>(now, <span class="hljs-string">&quot;logAndAdd&quot;</span> );<br>    names.<span class="hljs-built_in">emplace</span>(std::forward&lt;T&gt;(name));<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">nameFromIdx</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAndAddImpl</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, std::true_type)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">logAndAdd</span>(<span class="hljs-built_in">nameFromIdx</span>(idx)); <span class="hljs-comment">// 委托给前一个重载版本</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对接受万能引用的模板施加限制</p><p><code>std::enable_if</code>可以强制编译器表现出来的行为如同特定的模板不存在一般。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<br>        <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>            !std::is_intergral_v&lt;std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&gt;<br>            &amp;&amp;<br>            !std::is_base_of_v&lt;Person, std::<span class="hljs-type">decay_t</span>&lt;T&gt;&gt;<br>        &gt;::type<br>    &gt;<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">Person</span>(T&amp;&amp; n) : <span class="hljs-built_in">name</span>(std::forward&lt;T&gt;(n))<br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> idx) : <span class="hljs-built_in">name</span>(<span class="hljs-built_in">nameFromIdx</span>(idx))<br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string name;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>SFINAE是使得<code>std::enable_if</code>得以运作的技术。</p></blockquote></li></ol><h2 id="条款28-理解引用折叠">条款28 理解引用折叠</h2><p>万能引用就是在型别推导的过程会区别左值和右值，以及会发生引用折叠的语境中的右值引用。</p><p>禁止声明引用的引用，但编译器却可以在<strong>特殊的语境</strong>中产生引用的引用，<strong>模板实例化</strong>就是这样的语境之一。当编译器生成引用的引用时，<strong>引用折叠</strong>机制便支配了接下来发生的事情。</p><blockquote><p>特殊的四个语境：</p><ol type="1"><li>模板实例化</li><li>auto变量的型别生成</li><li>生成和使用typedef和别名声明</li><li>decltype的运用</li></ol></blockquote><p>引用折叠规则：如果任一引用为左值引用，则结果为左值引用。否则（即两个皆为右值引用）结果为右值引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::forward的示例实现，并不完整</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);<br>&#125;<br><br><span class="hljs-comment">// 使用完美转发的函数f</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; fParam)</span> <span class="hljs-comment">// 万能引用</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 完成一些操作</span><br>    <span class="hljs-built_in">someFunc</span>(std::forward&lt;T&gt;(fParam)); <span class="hljs-comment">// 将fParam转发至someFunc</span><br>&#125;<br><br><span class="hljs-comment">// 若向函数f传入左值Widget，则T推导为Widget&amp;，则std::forward&lt;T&gt;实例化：</span><br><span class="hljs-function">Widget&amp; &amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;Widget&amp;&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);<br>&#125;<br><span class="hljs-comment">// 即，传入左值引用，返回左值引用</span><br><span class="hljs-function">Widget&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Widget&amp;&gt;(param);<br>&#125;<br><br><span class="hljs-comment">// 若向函数f传入右值Widget，则T为Widget，则std::forward&lt;T&gt;实例化：</span><br><span class="hljs-function">Widget&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> remove_reference&lt;Widget&gt;::type&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);<br>&#125;<br><span class="hljs-comment">// 即，传入左值引用，返回右值引用</span><br><span class="hljs-function">Widget&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(Widget&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条款29-假定移动操作不存在成本高未使用">条款29假定移动操作不存在、成本高、未使用</h2><p>对于已知型别或已知对于移动语义的支持情况的代码，无需作以上假定。</p><p>移动语义不会更好的场景：</p><ol type="1"><li>对象没有提供移动操作</li><li>移动不比复制快</li><li>要求不可发射异常，但移动操作未加上noexcept声明，不可用</li></ol><p>C++11引入带有STL接口的内建数组<code>std::array</code>，它和<code>std::vector</code>等其它容器不一样，内存不在堆上，而在对象内，移动无法通过移动指针实现。因此移动和复制都是线性复杂度。</p><p><code>std::string</code>采用了SSO(small stringoptimization)，小型字符串存储在对象的某个缓冲区内，不适用堆上分配的内存。移动不比复制快。</p><h2 id="条款30-熟悉完美转发的失败情形">条款30熟悉完美转发的失败情形</h2><p>完美转发的含义是不仅转发对象，还转发其显著特征：型别、是左值还是右值，以及是否带有const或volation饰词等。</p><p>给定目标函数<strong>f</strong>和转发函数<strong>fwd</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fwd</span><span class="hljs-params">(T&amp;&amp; param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(std::forward&lt;T&gt;(param));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fwd</span><span class="hljs-params">(Ts&amp;&amp;... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(std::forward&lt;Ts&gt; (params)...);<br>&#125;<br></code></pre></td></tr></table></figure><p>完美转发失败指当以某特定实参调用<strong>f</strong>会执行某操作，而用同实参调用<strong>fwd</strong>会执行不同的操作。<strong>不能实施完美转发的实参</strong>如下：</p><ol type="1"><li><p>大括号初始化物</p><p>由于<strong>fwd</strong>的形参未声明为<code>std::initializer_list</code>，编译器就会被禁止在<strong>fwd</strong>的调用过程中从表达式<code>&#123;1, 2, 3&#125;</code>出发来推导型别。</p><p>解决办法：auto可以完成上述推导，可以先用auto声明，再传递给<strong>fwd</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> il = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-built_in">fwd</span>(il);<br></code></pre></td></tr></table></figure></li><li><p>0和NULL用作空指针</p><p>推导为整型而非指针型别。</p><p>解决办法：用nullptr。</p></li><li><p>仅有声明的整型static const成员变量</p><p>不需要给出类中的整型staticconst成员变量的定义，<strong>仅需声明之</strong>。编译器会根据这些成员的值实施常数传播，从而就不必再为它们保留内存。因此<strong>不能对其取址</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> MinVals = <span class="hljs-number">28</span>;<br>&#125;;<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; widgetData;<br>widgetData.<span class="hljs-built_in">reserve</span>(Widget::MinVals); <span class="hljs-comment">// 编译器绕过缺少定义的事实，直接用28替换Widget::MinVals</span><br></code></pre></td></tr></table></figure><p>引用在编译器生成的机器码中当指针处理，所以也<strong>不能将其传给万能引用</strong>。（有的编译器和链接器可以，但这不可移植）</p><p>解决办法：对其提供定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> Widget::MinVals;<br><span class="hljs-comment">// 这里没有指定28，因为声明和定义只需有一个提供初始化物。</span><br><span class="hljs-comment">// ODR(one definition rule)</span><br></code></pre></td></tr></table></figure></li><li><p>重载的函数名字和模板名字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> (*pf)(<span class="hljs-type">int</span>))</span></span>;<br><span class="hljs-comment">// 或 void f(int pf(int));</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">processVal</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">processVal</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> priority)</span></span>;<br><br><span class="hljs-built_in">f</span>(processVal); <span class="hljs-comment">// 没问题</span><br><span class="hljs-built_in">fwd</span>(processVal); <span class="hljs-comment">// 错误，无法确定用哪个重载版本</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">workOnVal</span><span class="hljs-params">(T param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-built_in">fwd</span>(work0nVal); <span class="hljs-comment">//错误，无法确定用模板的哪个实例</span><br></code></pre></td></tr></table></figure><p>解决办法：手动指定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> ProcessFuncType = <span class="hljs-built_in">int</span> (*)(<span class="hljs-type">int</span>);<br>ProcessFuncType processValPtr = processVal;<br><span class="hljs-built_in">fwd</span>(processValPtr); <span class="hljs-comment">// 重载指定</span><br><br><span class="hljs-built_in">fwd</span>(<span class="hljs-built_in">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal)); <span class="hljs-comment">// 模板指定</span><br></code></pre></td></tr></table></figure></li><li><p>位域</p><p>C++标准禁止非const引用绑定到位域。</p><blockquote><p>位域是由机器字的若干任意部分组成的（例如32位int的第3到第5个比特），这样的实体是不可能有办法对其直接取址的。在硬件层次，引用和指针本是同一事物。</p><p>因此，常量引用也不可能绑定到位域，只是绑定到了复制了位域值的常规对象。</p></blockquote><p>解决办法：复制位域值再转发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IPv4Header</span> &#123;<br>    std::<span class="hljs-type">uint32_t</span> version:<span class="hljs-number">4</span>,<br>    IHL:<span class="hljs-number">4</span>,<br>    DSCP:<span class="hljs-number">6</span>,<br>    ECN:<span class="hljs-number">2</span>,<br>    totalLength:<span class="hljs-number">16</span>;<br>&#125;;<br><span class="hljs-keyword">auto</span> length = <span class="hljs-built_in">static_cast</span>&lt;std::<span class="hljs-type">uint16_t</span>&gt;(h.totalLength);<br><span class="hljs-built_in">fwd</span>(length);<br></code></pre></td></tr></table></figure></li></ol><h1 id="第6章-lambda表达式">第6章 lambda表达式</h1><p><strong>lambda表达式</strong>是表达式的一种，比如在下面这段代码中<code>std::find_if</code>的第三个实参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">find_if</span>(container.<span class="hljs-built_in">begin</span>(), container.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> val) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt; val &amp;&amp; val &lt; <span class="hljs-number">10</span>; &#125;);<br></code></pre></td></tr></table></figure><p><strong>闭包</strong>是lambda式创建的运行期对象，根据不同的捕获模式，闭包会持有数据的副本或引用。在上面的代码中，闭包就是作为第三个实参在运行期传递给<code>std::find_if</code>的对象。</p><p><strong>闭包类</strong>就是实例化闭包的类。每个lambda式都会触发编译器生成一个独无二的闭包类。而闭包中的语句会变成它的闭包类成员函数的可执行指令。</p><h2 id="条款31-避免默认捕获模式">条款31 避免默认捕获模式</h2><p>按引用的默认捕获模式可能导致<strong>空悬引用</strong>（当闭包越过了其包含的局部变量或形参的生命期）。</p><p>按值的默认捕获模式可能会使程序员误解情况（不可能直接捕获对象的成员变量，只可能捕获this指针，让对象被析构后持有空悬指针）。</p><h2 id="条款32-使用初始化捕获将对象移入闭包">条款32使用初始化捕获将对象移入闭包</h2><p>C++14为<strong>对象移动入闭包</strong>提供了直接支持。C++11中有近似达成移动捕获行为的做法。</p><p><strong>初始化捕获</strong> （initcapture）（也叫广义lambda捕获）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++14</span><br>std::vector&lt;<span class="hljs-type">double</span>&gt; data;<br><span class="hljs-keyword">auto</span> func = [data = std::<span class="hljs-built_in">move</span>(data)]&#123;&#125;;<br><br><span class="hljs-comment">// C++11模拟移动捕获</span><br>std::vector&lt;<span class="hljs-type">double</span>&gt; data;<br><span class="hljs-keyword">auto</span> func = std::<span class="hljs-built_in">bind</span>([](<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data)&#123;&#125;,<br>                      std::<span class="hljs-built_in">move</span>(data)<br>                     );<br></code></pre></td></tr></table></figure><h2 id="条款33-对auto型别的形参使用decltype以stdforward之">条款33对auto&amp;&amp;型别的形参使用decltype，以std::forward之</h2><p>C++14的<strong>泛型lambda式</strong>可以在形参规格中<strong>使用auto</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 完美转发lambda式，C++14</span><br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span>&amp;&amp; param)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(param)&gt;(param))); <br>&#125;;<br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span>&amp;&amp;... params)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(params)&gt;(params)...);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实例化<code>std::forward</code>时，使用一个右值引用型别和使用一个非引用型别，会产生相同结果。（<code>std::forward</code>实现参见条款28）</p></blockquote><h2 id="条款34-优先选用lambda式而非stdbind">条款34优先选用lambda式，而非std::bind</h2><p><code>std::bind</code>是C++98中<code>std::bind1st</code>和<code>std::bind2nd</code>的后继特性，在2005年TR1文档就包含了<code>std::tr1::bind</code>。</p><p>lambda式优点：</p><ol type="1"><li><p>lambda式可读性强于<code>std::bind</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> betweenL = [lowVal, highVal](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; val)<br>&#123;<br>    <span class="hljs-keyword">return</span> lowVal &lt;= val &amp;&amp; val &lt;= highVal;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;<br><span class="hljs-keyword">auto</span> betweenB = std::<span class="hljs-built_in">bind</span>(std::logical_ <span class="hljs-keyword">and</span>&lt;&gt;(),<br>                          std::<span class="hljs-built_in">bind</span>(std::less_ equal&lt;&gt;(),<br>                                    lowVal,<br>                                    _1),<br>                          std::<span class="hljs-built_in">bind</span>(std::less_equal&lt;&gt;(),<br>                                    _1, <br>                                    highVal));<br><span class="hljs-comment">// C++14中，标准运算符模板的模板型别实参大多数情况下可以省略不写，直接写&lt;&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>std::bind</code>调用时刻进行表达式评估求值，并将结果存储到绑定对象中，等待绑定对象调用时使用。lambda式统一在调用时刻求值，不容易造成误解。（使用计时函数时）</p></li><li><p><code>std::bind</code>无法进行重载决议，需要显式指定（使用函数指针类型<code>static_cast</code>）。编译器不太会内联通过函数指针发起的函数调用，因而更慢。</p></li><li><p><code>std::bind</code>默认传值，传引用需要使用<code>std::ref</code>；<code>std::bind</code>返回的绑定对象所有实参都是按引用传递的（利用完美转发）。lambda式可以直观地手动指定。</p></li></ol><p>在C++14中，<strong>完全没必要用<code>std::bind</code></strong>。C++11中还可以在<strong>移动捕获</strong>（C++14用初始化捕获）或<strong>绑定函数调用符模板对象</strong>（C++14的lambda式可以使用lambda形参）时使用。</p><h1 id="第7章-并发api">第7章 并发API</h1><p>C++11将<strong>并发</strong>融入了语言和库中。</p><p>熟悉其他线程API（例如，pthread或Windows线程库）的程序员有时会对C++提供的相对斯巴达式地简练的特性集感觉惊讶，但这是因为，<strong>C++对并发的支持中有一大部分是以对编译器厂商实施约束的形式提供的</strong>。在C++的历史上程序员首次可以跨越所有平台撰写具有标准行为的多线程程序。</p><p>标准库中为<strong>期值</strong>（future）准备了两个模板:<code>std::future</code>和<code>std::shared_future</code>。在很多情况下，它们之间的区别并不重要，书中仅谈论期值概念，意思是指可以对这两种都适用。</p><h2 id="条款35-优先选用基于任务而非基于线程的程序设计">条款35优先选用基于任务而非基于线程的程序设计</h2><p>异步方式运行函数<code>doAsyncWork</code>有两种选择：基于线程和基于任务。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doAsyncWork</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 基于线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(doAsyncWork)</span></span>; <br><span class="hljs-comment">// 无法直接获取返回值，doAsyncWork抛出异常时会调用std::terminate</span><br><span class="hljs-comment">// 即使doAsyncWork声明为noexcept，上述语句依然可能抛出异常（如创建线程数量已达上限），此时需要手工管理线程（在当前线程中运行doAsyncWork，或等待已存在线程完成工作）</span><br><br><span class="hljs-comment">// 基于任务</span><br><span class="hljs-keyword">auto</span> fut = std::<span class="hljs-built_in">async</span>(doAsyncWork); <br><span class="hljs-comment">// std::async返回的期值提供了返回函数get，可以获得返回值或异常</span><br><span class="hljs-comment">// 将线程管理交给标准库的实现者</span><br></code></pre></td></tr></table></figure><p>C++并发中线程的三种意义：</p><ol type="1"><li>硬件线程。实际执行计算的线程。现代计算机体系结构会为每个CPU内核提供一个或多个硬件线程。</li><li>软件线程。操作系统（无操作系统的嵌入式系统除外）用以实施跨进程管理以及进行硬件线程调度的线程。比硬件线程多，有上限。</li><li><code>std::thread</code>。C++进程里的对象，用作底层软件线程的句柄。</li></ol><blockquote><p><strong>超订</strong>（oversubscription）即就绪状态（非阻塞）的软件线程超过了硬件线程的数量，此时线程调度器会为软件线程在硬件线程上分配CPU时间片。当一个线程的时间片用完，另一个线程启动时，会执行语境切换，增加系统的总体线程管理开销。</p><p>超订难以避免。软件线程和硬件线程的比例取决于软件线程变成可运行状态的频繁程度，会<strong>动态改变</strong>（如一个线程如I/O密集型转换为计算密集型时）。因此使用std::async将管理交给标准库实现者更好。</p></blockquote><p>基于线程更合适的情况：</p><ol type="1"><li>需要访问底层线程实现的API。</li><li>需要自己根据硬件特性优化线程用法，手动管理线程耗尽、超订、负载均衡，以及新平台适配</li><li>实现超越C++并发API的线程技术（如在C++实现中未提供线程池的平台上实现线程池）</li></ol><h2 id="条款36-如果异步是必要的则指定stdlaunchasync">条款36如果异步是必要的，则指定std::launch::async</h2><p><code>std::async</code>的<strong>启动策略</strong>：</p><ol type="1"><li><code>std::launch::async</code>启动策略意味着函数必须以异步方式运行，即在另一线程之上执行。</li><li><code>std::launch::deferred</code>启动策略意味函数只会在<code>std::async</code>所返回的期值的get或wait得到调用时才运行。当调用get或wait时，函数会同步运行，调用方会阻塞至函数运行结束为止。如果get或wait都没有得到调用，函数是不会运行的。</li></ol><p><strong>默认启动策略是两者均可</strong>（便于标准库管理线程）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fut1 = std::<span class="hljs-built_in">async</span>(f); <span class="hljs-comment">// 同下</span><br><span class="hljs-keyword">auto</span> fut2 = std::<span class="hljs-built_in">async</span>(std::launch::async | std::launch::deferred, f);<br></code></pre></td></tr></table></figure><p>使用<code>std::launch::async</code>启动策略的<code>std::async</code>函数的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-keyword">auto</span></span><br><span class="hljs-function"><span class="hljs-title">reallyAsync</span><span class="hljs-params">(F&amp;&amp; f, Ts&amp;&amp;... params)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">async</span>(std::launch::async,<br>                      std::forward&lt;F&gt;(f),<br>                      std::forward&lt;Ts&gt;(params)...);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条款37-使stdthread型别对象在所有路径皆不可联结">条款37使std::thread型别对象在所有路径皆不可联结</h2><p>若<code>std::thread</code>型别对象对应的底层线程处于已运行、阻塞、等待调度、运行结束等状态，认为其处于<strong>可联结状态</strong>（joinable）。</p><p><strong>不可联结状态</strong>（unjoinable）的<code>std::thread</code>型别对象包括：</p><ol type="1"><li>默认构造对象。没有可以执行的函数，也就没有对应的底层执行线程。</li><li>已移动对象。对应的底层执行线程被对应到另外一个对象。</li><li>已join对象。join之后不再对应于已运行完的底层执行线程。</li><li>已detach对象。断开了对象和它对应的底层执行线程之间的连接。</li></ol><p><code>std::thread</code>型别对象的<strong>析构函数被调用时，若其还是可联结状态，会导致程序终止，而不是隐式join或者隐式detach</strong>。因为C++标准委员会规定可联结的线程的析构函数导致程序终止，避免产生性能问题或失去对线程的控制导致BUG。</p><p>覆盖所有路径是很复杂的（正常走完作用域，或由return、continue、break、goto或异常跳出作用域），为了确保覆盖，使用RAII机制（即智能指针的实现方法）。标准库没有，参考实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadRAII</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">DtorAction</span> &#123; join, detach &#125;;<br>    <span class="hljs-built_in">ThreadRAII</span>(std::thread&amp;&amp; t, DtorAction a) : <span class="hljs-built_in">action</span>(a), <span class="hljs-built_in">t</span>(std::<span class="hljs-built_in">move</span>(t)) &#123;&#125;<br>    ~<span class="hljs-built_in">ThreadRAII</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">joinable</span>()) <br>        &#123;<br>            <span class="hljs-keyword">if</span>(action == DtorAction::join) <br>            &#123;<br>                t.<span class="hljs-built_in">join</span>();<br>            &#125; <br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                t.<span class="hljs-built_in">detach</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">ThreadRAII</span>(ThreadRAII&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    ThreadRAII&amp; <span class="hljs-keyword">operator</span>=(ThreadRAII&amp;&amp;) = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function">std::thread&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> t; &#125;<br><span class="hljs-keyword">private</span>:<br>    DtorAction action;<br>    std::thread t;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="条款38-对变化多端的线程句柄析构函数行为保持关注">条款38对变化多端的线程句柄析构函数行为保持关注</h2><p>期值对象和<code>std::thread</code>对象的<strong>析构函数行为</strong>不同。</p><p>调用方、被调方和共享状态之间的关系：</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-09-24-future.png" /></p><p>条款36讲过<code>std::async</code>的启动策略，<strong>只有</strong>经由其启动的<strong>未推迟任务</strong>的共享状态的<strong>最后一个期值</strong>会<strong>保持阻塞直到该任务结束</strong>（析构函数对底层异步执行任务的线程实施了一次<strong>隐式join</strong>）；<strong>其它所有期值</strong>的析构函数仅进行常规析构行为就结束了（如果<strong>被推迟任务</strong>的所有期值被析构其就不可能运行）。（C++11和C++14中情况一致）</p><blockquote><p>常规析构行为即析构期值对象的成员，针对共享状态里的<strong>引用计数</strong>实施一次自减。共享状态由指涉到它的期值和被调方的<code>std::promise</code>共同操纵，引用计数使得库能够知道何时可以析构共享状态。</p></blockquote><h2id="条款39-考虑针对一次性事件通信使用以void为模板型别实参的期值">条款39考虑针对一次性事件通信使用以void为模板型别实参的期值</h2><p>如果仅限于一次性通信，不需要条件变量，互斥量和标志位，使用<code>std::promise</code>型别对象和期值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::promise&lt;<span class="hljs-type">void</span>&gt; p; <span class="hljs-comment">// 通信信道的promise</span><br><br> <span class="hljs-comment">// ...检测某个事件</span><br>p.<span class="hljs-built_in">set_value</span>(); <span class="hljs-comment">// 通知反应任务</span><br><br><span class="hljs-comment">// ...准备作出反应</span><br>p.<span class="hljs-built_in">get_future</span>().<span class="hljs-built_in">wait</span>(); <span class="hljs-comment">//等待对应于p的期值</span><br><span class="hljs-comment">// ...对事件作出反应</span><br></code></pre></td></tr></table></figure><h2 id="条款40-对并发使用stdatomic对特种内存使用volatile">条款40对并发使用std:atomic，对特种内存使用volatile</h2><p><code>std::atomic</code><strong>用于多线程访问的数据且不用互斥量</strong>，是撰写并发软件的工具。</p><p>volatile<strong>用于读写操作不可以被优化掉的内存</strong>，是在面对特种内存时使用的工具</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ai</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <br>ai = <span class="hljs-number">10</span>; <span class="hljs-comment">// 原子操作</span><br>std::cout &lt;&lt; ai; <span class="hljs-comment">// 只能保证读取是原子操作。在读取ai的值和调用operator &lt;&lt;将其写人标准输出之间，另一个线程可能已经修改了ai 的值。</span><br>++ai; <span class="hljs-comment">// 原子操作</span><br>--ai; <span class="hljs-comment">// 原子操作</span><br></code></pre></td></tr></table></figure><p><code>std::atomic</code>型别对象的特点：</p><ol type="1"><li>采用顺序一致性。有其它在代码重新排序方面更灵活的一致性模型，但难以维护。</li><li>所有成员函数都保证为原子的。不支持复制操作，硬件无法保证其为原子的。</li></ol><p><strong>常规内存</strong>：若多次写入之间没有读取操作，编译器可以消除多余的写入操作；若多次读取之间没有写入操作，编译器可以消除多余的读取操作。</p><p><strong>特种内存</strong>：用于内存映射I/O的内存，与显示器、打印机等外部设备通信。因为通信会有读取和写入，所以要求编译器不对在此内存上的操作做任何优化。</p><p><code>std::atomic</code>和volatile用于不同目的，所以它们可以一起使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">volatile</span> std::atomic&lt;<span class="hljs-type">int</span>&gt; vai;<br></code></pre></td></tr></table></figure><h1 id="第8章-微调">第8章 微调</h1><h2id="条款41-针对可复制的形参在移动成本低并且一定会被复制的前提下考虑将其按值传递">条款41针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1.本质上在做同一件事情的两个函数，增加程序足迹</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123; names.<span class="hljs-built_in">push_back</span>(newName); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(std::string&amp;&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123; names.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(newName)); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::string&gt; names;<br>&#125;;<br><br><span class="hljs-comment">// 2.万能引用会产生多个实例化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(T&amp;&amp; newName)</span></span><br><span class="hljs-function">    </span>&#123;<br>        names.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(newName));<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 3.直接传值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addName</span><span class="hljs-params">(std::string newName)</span></span><br><span class="hljs-function">    </span>&#123; names.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(newName)); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>程序足迹（programfootprint）通常是指目标代码经常性占用内存的尺寸（动态分配的内存，或是从外存加载到内存的部分往往不计在内）</p></blockquote><p>使用以上三种方法进行以下实验：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget W;<br><span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">&quot;Bart&quot;</span>)</span></span>;<br>W.<span class="hljs-built_in">addName</span>(name); <span class="hljs-comment">// 传入左值</span><br>W.<span class="hljs-built_in">addName</span>(name + <span class="hljs-string">&quot;Jenne&quot;</span>); <span class="hljs-comment">// 传入右值</span><br></code></pre></td></tr></table></figure><p>方法1：两个重载函数的实参均按引用传递，无成本，接收左值的重载函数内一次复制，接收右值的重载函数内一次移动。</p><p>方法2：实参按引用传递，无成本。函数内对于左值一次复制，对于右值一次移动。</p><p>方法3：实参按值传递，对于左值一次复制，对于右值一次移动。函数内一次移动。</p><p>综上，方法三总是多一次移动操作。当且仅当<strong>形参可复制</strong>、<strong>移动成本低</strong>、<strong>形参在函数内一定会被复制</strong>时考虑方法三。</p><blockquote><p>一定会被复制指，形参传到函数后一定有复制操作，且该操作不会因为条件语句的判定不执行。</p><p>一定有复制操作时，传入左值，三种方法均有一次复制（方法1、2的复制发生在函数内，方法3的复制发生在传参时），方法3以额外多一次移动的代价克服了方法1增加程序足迹和方法2多个实例化的缺点。当移动成本低，这个交易就是划算的。</p></blockquote><h2 id="条款42-考虑置入而非插入">条款42 考虑置入而非插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">vs.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;xyzzy&quot;</span>);<br><span class="hljs-comment">// 从字符串字面量（const char [6]）出发，复制构造std::string型别的临时对象，传递给push_back的右值重载版本，绑定到右值引用形参，然后在函数内移动构造一个std::string型别的对象</span><br>vs.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;xyzzy&quot;</span>);<br><span class="hljs-comment">// 完美转发，直接在函数内移动构造一个std::string型别的对象</span><br></code></pre></td></tr></table></figure><p>下列情况置入比插入更高效：</p><ol type="1"><li>欲添加的值是以构造而非赋值方式加入容器。</li><li>传递的实参型别与容器持有之物的型别不同。</li><li>容器不太可能由于出现重复情况而拒绝待添加的新值。</li></ol><p>置入存在的问题：</p><ol type="1"><li><p>直接完美转发构造所需的参数时，把对象创建推迟到在容器的内存中构造，若发生异常会导致资源泄漏。</p></li><li><p>越过了explicit对构造函数的限制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;std::regex&gt; regexes;<br><span class="hljs-comment">// 接收const char *指针的std::regex构造函数声明为explicit，杜绝隐式转换</span><br><br>std::regex r = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 不能编译</span><br>regexes.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 不能编译</span><br><br>regexes.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 能编译！使用直接初始化</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于AI的材质研究</title>
      <link href="//posts/Research/AI-based-Material-Research/"/>
      <url>//posts/Research/AI-based-Material-Research/</url>
      
        <content type="html"><![CDATA[<p>资料汇总</p><span id="more"></span><h1 id="论文">论文</h1><p>分类并按年份排序。</p><p>期刊会收录会议上的论文，比如TOG (SG), CGF(EG)。TOG每一年有六期，第四期收录SIGGRAPH，第六期收录SIGGRAPHAsia（仅Technical Papers，不包括Conference Proceedings）。</p><h2 id="svbrdf">SVBRDF</h2><p>估计SVBRDF相关的解析BRDF模型的参数（如Diffuse、Specular、Roughnesss、Normal四张贴图）。</p><h3 id="reflectance-modeling-by-neural-texture-synthesis">ReflectanceModeling by Neural Texture Synthesis</h3><p>【TOG2016】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;aittala2016reflectance,</span><br><span class="hljs-template-variable">  title=&#123;Reflectance modeling by neural texture synthesis&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Aittala, Miika and Aila, Timo and Lehtinen, Jaakko&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Transactions on Graphics (ToG)&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;35&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;4&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;1--13&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2016&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;ACM New York, NY, USA&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="modeling-surface-appearance-from-a-single-photograph-using-self-augmented-convolutional-neural-networks">ModelingSurface Appearance from a Single Photograph using Self-augmentedConvolutional Neural Networks</h3><p>【TOG2017】【<ahref="https://github.com/msraig/self-augmented-net">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;li2017modeling,</span><br><span class="hljs-template-variable">  title=&#123;Modeling surface appearance from a single photograph using self-augmented convolutional neural networks&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Li, Xiao and Dong, Yue and Peers, Pieter and Tong, Xin&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Transactions on Graphics (ToG)&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;36&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;4&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;1--11&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2017&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;ACM New York, NY, USA&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="single-image-svbrdf-capture-with-a-rendering-aware-deep-network">Single-ImageSVBRDF Capture with a Rendering-Aware Deep Network</h3><p>【TOG2018】【<ahref="https://github.com/valentin-deschaintre/Single-Image-SVBRDF-Capture-rendering-loss">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;deschaintre2018single,</span><br><span class="hljs-template-variable">  title=&#123;Single-image svbrdf capture with a rendering-aware deep network&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Deschaintre, Valentin and Aittala, Miika and Durand, Fredo and Drettakis, George and Bousseau, Adrien&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Transactions on Graphics (ToG)&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;37&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;4&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;1--15&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2018&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;ACM New York, NY, USA&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="efficient-reflectance-capture-using-an-autoencoder">EfficientReflectance Capture Using an Autoencoder</h3><p>【TOG2018】</p><p>OpenSVBRDF的前置工作之一。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;kang2018efficient,</span><br><span class="hljs-template-variable">  title=&#123;Efficient reflectance capture using an autoencoder.&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Kang, Kaizhang and Chen, Zimin and Wang, Jiaping and Zhou, Kun and Wu, Hongzhi&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Trans. Graph.&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;37&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;4&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;127--1&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2018&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="single-image-surface-appearance-modeling-with-self-augmented-cnns-and-inexact-supervision">SingleImage Surface Appearance Modeling with Self-augmented CNNs and InexactSupervision</h3><p>【CGF2018】【<ahref="https://github.com/msraig/InexactSA">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;ye2018single,</span><br><span class="hljs-template-variable">  title=&#123;Single image surface appearance modeling with self-augmented cnns and inexact supervision&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Ye, Wenjie and Li, Xiao and Dong, Yue and Peers, Pieter and Tong, Xin&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Computer Graphics Forum&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;37&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;7&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;201--211&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2018&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  organization=</span><span class="hljs-template-variable">&#123;Wiley Online Library&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="materials-for-masses-svbrdf-acquisition-with-a-single-mobile-phone-image">Materialsfor Masses: SVBRDF Acquisition with a Single Mobile Phone Image</h3><p>【ECCV2018】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;li2018materials,</span><br><span class="hljs-template-variable">  title=&#123;Materials for masses: SVBRDF acquisition with a single mobile phone image&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Li, Zhengqin and Sunkavalli, Kalyan and Chandraker, Manmohan&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Proceedings of the European conference on computer vision (ECCV)&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;72--87&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2018&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="flexible-svbrdf-capture-with-a-multi-image-deep-network">FlexibleSVBRDF Capture with a Multi-Image Deep Network</h3><p>【CGF2019】【<ahref="https://github.com/valentin-deschaintre/multi-image-deepNet-SVBRDF-acquisition">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;deschaintre2019flexible,</span><br><span class="hljs-template-variable">  title=&#123;Flexible svbrdf capture with a multi-image deep network&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Deschaintre, Valentin and Aittala, Miika and Durand, Fr&#123;\&#x27;e&#125;</span><span class="language-xml">do and Drettakis, George and Bousseau, Adrien&#125;,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Computer graphics forum&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;38&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;4&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;1--13&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2019&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  organization=</span><span class="hljs-template-variable">&#123;Wiley Online Library&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="deep-inverse-rendering-for-high-resolution-svbrdf-estimation-from-an-arbitrary-number-of-images">DeepInverse Rendering for High-resolution SVBRDF Estimation from anArbitrary Number of Images</h3><p>【TOG2019】【<ahref="https://github.com/msraig/DeepInverseRendering">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;gao2019deep,</span><br><span class="hljs-template-variable">  title=&#123;Deep inverse rendering for high-resolution SVBRDF estimation from an arbitrary number of images.&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Gao, Duan and Li, Xiao and Dong, Yue and Peers, Pieter and Xu, Kun and Tong, Xin&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Trans. Graph.&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;38&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;4&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;134--1&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2019&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="materialgan-reflectance-capture-using-a-generative-svbrdf-model">MaterialGAN:Reflectance Capture using a Generative SVBRDF Model</h3><p>【SGA2020】【<ahref="https://github.com/tflsguoyu/materialgan">Github</a>】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@article&#123;guo2020materialgan,<br>  title=&#123;Materialgan: reflectance capture using a generative svbrdf model&#125;,<br>  author=&#123;Guo, Yu <span class="hljs-keyword">and </span>Smith, Cameron <span class="hljs-keyword">and </span>Ha&#123;\v&#123;s&#125;&#125;an, Milo&#123;\v&#123;s&#125;&#125; <span class="hljs-keyword">and </span>Sunkavalli, Kalyan <span class="hljs-keyword">and </span>Zhao, <span class="hljs-keyword">Shuang&#125;,</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">journal=&#123;arXiv </span>preprint arXiv:<span class="hljs-number">2010</span>.<span class="hljs-number">00114</span>&#125;,<br>  year=&#123;<span class="hljs-number">2020</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="guided-fine-tuning-for-large-scale-material-transferm-flash-images">GuidedFine-Tuning for Large-Scale Material Transferm Flash Images</h3><p>【CGF2020】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;deschaintre2020guided,</span><br><span class="hljs-template-variable">  title=&#123;Guided fine-tuning for large-scale material transfer&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Deschaintre, Valentin and Drettakis, George and Bousseau, Adrien&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Computer Graphics Forum&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;39&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;4&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;91--105&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2020&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  organization=</span><span class="hljs-template-variable">&#123;Wiley Online Library&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="deep-svbrdf-estimation-on-real-materials">Deep SVBRDF Estimationon Real Materials</h3><p>【3DV2020】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;asselin2020deep,</span><br><span class="hljs-template-variable">  title=&#123;Deep SVBRDF estimation on real materials&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Asselin, Louis-Philippe and Laurendeau, Denis and Lalonde, Jean-Fran&#123;\c&#123;c&#125;</span><span class="language-xml">&#125;ois&#125;,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;2020 International Conference on 3D Vision (3DV)&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;1157--1166&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2020&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  organization=</span><span class="hljs-template-variable">&#123;IEEE&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="joint-svbrdf-recovery-and-synthesis-from-a-single-image-using-an-unsupervised-generative-adversarial-network">JointSVBRDF Recovery and Synthesis From a Single Image using an UnsupervisedGenerative Adversarial Network</h3><p>【EGSR2020】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@inproceedings&#123;zhao2020joint,<br>  title=&#123;<span class="hljs-keyword">Joint </span>SVBRDF Recovery <span class="hljs-keyword">and </span>Synthesis From a Single Image using an Unsupervised Generative Adversarial Network.&#125;,<br>  author=&#123;Zhao, Yezi <span class="hljs-keyword">and </span>Wang, <span class="hljs-keyword">Beibei </span><span class="hljs-keyword">and </span>Xu, Yanning <span class="hljs-keyword">and </span>Zeng, Zheng <span class="hljs-keyword">and </span>Wang, Lu <span class="hljs-keyword">and </span>Holzschuch, Nicolas&#125;,<br>  <span class="hljs-keyword">booktitle=&#123;EGSR </span>(DL)&#125;,<br>  pages=&#123;<span class="hljs-number">53</span>--<span class="hljs-number">66</span>&#125;,<br>  year=&#123;<span class="hljs-number">2020</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="surfacenet-adversarial-svbrdf-estimation-from-a-single-image">SurfaceNet:Adversarial SVBRDF Estimation from a Single Image</h3><p>【ICCV2021】【<ahref="https://github.com/perceivelab/surfacenet">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;vecchio2021surfacenet,</span><br><span class="hljs-template-variable">  title=&#123;Surfacenet: Adversarial svbrdf estimation from a single image&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Vecchio, Giuseppe and Palazzo, Simone and Spampinato, Concetto&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Proceedings of the IEEE/CVF International Conference on Computer Vision&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;12840--12848&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2021&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="generative-modelling-of-brdf-textures-from-flash-images">GenerativeModelling of BRDF Textures from Flash Images</h3><p>【arXiv2021】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@article&#123;henzler2021generative,<br>  title=&#123;Generative modelling of <span class="hljs-keyword">BRDF </span>textures from flash images&#125;,<br>  author=&#123;Henzler, Philipp <span class="hljs-keyword">and </span>Deschaintre, Valentin <span class="hljs-keyword">and </span>Mitra, Niloy <span class="hljs-keyword">J </span><span class="hljs-keyword">and </span>Ritschel, Tobias&#125;,<br>  <span class="hljs-keyword">journal=&#123;arXiv </span>preprint arXiv:<span class="hljs-number">2102</span>.<span class="hljs-number">11861</span>&#125;,<br>  year=&#123;<span class="hljs-number">2021</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="adversarial-single-image-svbrdf-estimation-with-hybrid-training">AdversarialSingle-Image SVBRDF Estimation with Hybrid Training</h3><p>【CGF2021】【<ahref="https://github.com/xilongzhou/Adversarial-Single-Image-SVBRDF-Estimation-with-Hybrid-Training">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;zhou2021adversarial,</span><br><span class="hljs-template-variable">  title=&#123;Adversarial Single-Image SVBRDF Estimation with Hybrid Training&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Zhou, Xilong and Kalantari, Nima Khademi&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Computer Graphics Forum&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;40&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;315--325&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2021&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  organization=</span><span class="hljs-template-variable">&#123;Wiley Online Library&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="highlight-aware-two-stream-network-for-single-image-svbrdf-acquisition">Highlight-AwareTwo-Stream Network for Single-Image SVBRDF Acquisition</h3><p>【TOG2021】【<ahref="https://github.com/leisuzz/Highlight-Aware-Two-Stream-Network-for-Single-Image-SVBRDF-Acquisition">Github</a>】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@article&#123;guo2021highlight,<br>  title=&#123;Highlight-aware two-stream network for single-image SVBRDF acquisition&#125;,<br>  author=&#123;Guo, <span class="hljs-keyword">Jie </span><span class="hljs-keyword">and </span>Lai, <span class="hljs-keyword">Shuichang </span><span class="hljs-keyword">and </span>Tao, Chengzhi <span class="hljs-keyword">and </span>Cai, Yuelong <span class="hljs-keyword">and </span>Wang, Lei <span class="hljs-keyword">and </span>Guo, Yanwen <span class="hljs-keyword">and </span>Yan, Ling-Qi&#125;,<br>  <span class="hljs-keyword">journal=&#123;ACM </span>Transactions on Graphics (TOG)&#125;,<br>  volume=&#123;<span class="hljs-number">40</span>&#125;,<br>  number=&#123;<span class="hljs-number">4</span>&#125;,<br>  pages=&#123;<span class="hljs-number">1</span>--<span class="hljs-number">14</span>&#125;,<br>  year=&#123;<span class="hljs-number">2021</span>&#125;,<br>  publisher=&#123;ACM New York, NY, USA&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="tilegen-tileable-controllable-material-generation-and-capture">TileGen:Tileable, Controllable Material Generation and Capture</h3><p>【SGA2022】【<ahref="https://github.com/xilongzhou/TileGen">Github</a>】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@inproceedings&#123;zhou2022tilegen,<br>  title=&#123;Tilegen: Tileable, controllable material generation <span class="hljs-keyword">and </span>capture&#125;,<br>  author=&#123;Zhou, Xilong <span class="hljs-keyword">and </span>Hasan, Milos <span class="hljs-keyword">and </span>Deschaintre, Valentin <span class="hljs-keyword">and </span>Guerrero, Paul <span class="hljs-keyword">and </span>Sunkavalli, Kalyan <span class="hljs-keyword">and </span>Kalantari, Nima Khademi&#125;,<br>  <span class="hljs-keyword">booktitle=&#123;SIGGRAPH </span>Asia <span class="hljs-number">2022</span> Conference Papers&#125;,<br>  pages=&#123;<span class="hljs-number">1</span>--<span class="hljs-number">9</span>&#125;,<br>  year=&#123;<span class="hljs-number">2022</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="look-ahead-training-with-learned-reflectance-loss-for-single-image-svbrdf-estimation">Look-AheadTraining with Learned Reflectance Loss for Single-Image SVBRDFEstimation</h3><p>【TOG2022】【<ahref="https://github.com/xilongzhou/lookahead_svbrdf">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;zhou2022look,</span><br><span class="hljs-template-variable">  title=&#123;Look-Ahead Training with Learned Reflectance Loss for Single-Image SVBRDF Estimation&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Zhou, Xilong and Kalantari, Nima Khademi&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Transactions on Graphics (TOG)&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;41&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;6&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;1--12&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2022&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;ACM New York, NY, USA&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="svbrdf-recovery-from-a-single-image-with-highlights-using-a-pretrained-generative-adversarial-network">SVBRDFRecovery From a Single Image with Highlights using a PretrainedGenerative Adversarial Network</h3><p>【CGF2022】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;wen2022svbrdf,</span><br><span class="hljs-template-variable">  title=&#123;SVBRDF Recovery from a Single Image with Highlights Using a Pre-trained Generative Adversarial Network&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Wen, Tao and Wang, Beibei and Zhang, Lei and Guo, Jie and Holzschuch, Nicolas&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Computer Graphics Forum&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;41&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;6&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;110--123&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2022&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  organization=</span><span class="hljs-template-variable">&#123;Wiley Online Library&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="materia-single-image-high-resolution-material-capture-in-the-wild">MaterIA:Single Image High-Resolution Material Capture in the Wild</h3><p>【CGF2022】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;martin2022materia,</span><br><span class="hljs-template-variable">  title=&#123;MaterIA: Single Image High-Resolution Material Capture in the Wild&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Martin, Rosalie and Roullier, Arthur and Rouffet, Romain and Kaiser, Adrien and Boubekeur, Tamy&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Computer Graphics Forum&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;41&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;163--177&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2022&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  organization=</span><span class="hljs-template-variable">&#123;Wiley Online Library&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="data-driven-svbrdf-estimation-using-deep-embedded-clustering">DataDriven SVBRDF Estimation Using Deep Embedded Clustering</h3><p>【Electronics2022】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;kim2022data,</span><br><span class="hljs-template-variable">  title=&#123;Data Driven SVBRDF Estimation Using Deep Embedded Clustering&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Kim, Yong Hwi and Lee, Kwan H&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;Electronics&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;11&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;19&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;3239&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2022&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;MDPI&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="deep-svbrdf-estimation-from-single-image-under-learned-planar-lighting">DeepSVBRDF Estimation from Single Image under Learned Planar Lighting</h3><p>【SG2023】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@inproceedings&#123;zhang2023deep,<br>  title=&#123;Deep SVBRDF Estimation from Single Image under Learned Planar Lighting&#125;,<br>  author=&#123;Zhang, Lianghao <span class="hljs-keyword">and </span>Gao, Fangzhou <span class="hljs-keyword">and </span>Wang, Li <span class="hljs-keyword">and </span>Yu, Minjing <span class="hljs-keyword">and </span>Cheng, <span class="hljs-keyword">Jiamin </span><span class="hljs-keyword">and </span>Zhang, <span class="hljs-keyword">Jiawan&#125;,</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">booktitle=&#123;ACM </span>SIGGRAPH <span class="hljs-number">2023</span> Conference Proceedings&#125;,<br>  pages=&#123;<span class="hljs-number">1</span>--<span class="hljs-number">11</span>&#125;,<br>  year=&#123;<span class="hljs-number">2023</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="deepbasis-hand-held-single-image-svbrdf-capture-via-two-level-basis-material-model">DeepBasis:Hand-Held Single-Image SVBRDF Capture via Two-Level Basis MaterialModel</h3><p>【SGA2023】【<ahref="https://github.com/CGLiWang/DeepBasis_SVBRDF">Github</a>】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@inproceedings&#123;wang2023deepbasis,<br>  title=&#123;DeepBasis: Hand-Held Single-Image SVBRDF Capture via Two-Level <span class="hljs-keyword">Basis </span>Material Model&#125;,<br>  author=&#123;Wang, Li <span class="hljs-keyword">and </span>Zhang, Lianghao <span class="hljs-keyword">and </span>Gao, Fangzhou <span class="hljs-keyword">and </span>Zhang, <span class="hljs-keyword">Jiawan&#125;,</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">booktitle=&#123;SIGGRAPH </span>Asia <span class="hljs-number">2023</span> Conference Papers&#125;,<br>  pages=&#123;<span class="hljs-number">1</span>--<span class="hljs-number">11</span>&#125;,<br>  year=&#123;<span class="hljs-number">2023</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="matfusion-a-generative-diffusion-model-for-svbrdf-capture">MatFusion:A Generative Diffusion Model for SVBRDF Capture</h3><p>【SGA2023】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;sartor2023matfusion,</span><br><span class="hljs-template-variable">  title=&#123;Matfusion: a generative diffusion model for svbrdf capture&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Sartor, Sam and Peers, Pieter&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;SIGGRAPH Asia 2023 Conference Papers&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;1--10&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2023&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="efficient-reflectance-capture-with-a-deep-gated-mixture-of-experts">EfficientReflectance Capture with a Deep Gated Mixture-of-Experts</h3><p>【TVCG2023】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;ma2023efficient,</span><br><span class="hljs-template-variable">  title=&#123;Efficient Reflectance Capture With a Deep Gated Mixture-of-Experts&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Ma, Xiaohe and Yu, Yaxin and Wu, Hongzhi and Zhou, Kun&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;IEEE Transactions on Visualization and Computer Graphics&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2023&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;IEEE&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="opensvbrdf-a-database-of-measured-spatially-varying-reflectance">OpenSVBRDF:A Database of Measured Spatially-Varying Reflectance</h3><p>【TOG2023】【<a href="https://opensvbrdf.github.io/">Page</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;ma2023opensvbrdf,</span><br><span class="hljs-template-variable">  title=&#123;OpenSVBRDF: A Database of Measured Spatially-Varying Reflectance&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Ma, Xiaohe and Xu, Xianmin and Zhang, Leyao and Zhou, Kun and Wu, Hongzhi&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Transactions on Graphics&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;42&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;6&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2023&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;ASSOC COMPUTING MACHINERY 1601 Broadway, 10th Floor, NEW YORK, NY USA&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="ultra-high-resolution-svbrdf-recovery-from-a-single-image">Ultra-HighResolution SVBRDF Recovery from a Single Image</h3><p>【TOG2023】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@article&#123;guo2023ultra,<br>  title=&#123;Ultra-High Resolution SVBRDF Recovery from a Single Image&#125;,<br>  author=&#123;Guo, <span class="hljs-keyword">Jie </span><span class="hljs-keyword">and </span>Lai, <span class="hljs-keyword">Shuichang </span><span class="hljs-keyword">and </span>Tu, Qinghao <span class="hljs-keyword">and </span>Tao, Chengzhi <span class="hljs-keyword">and </span>Zou, Changqing <span class="hljs-keyword">and </span>Guo, Yanwen&#125;,<br>  <span class="hljs-keyword">journal=&#123;ACM </span>Transactions on Graphics&#125;,<br>  year=&#123;<span class="hljs-number">2023</span>&#125;,<br>  publisher=&#123;ACM New York, NY&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="photomat-a-material-generator-learned-from-single-flash-photos">PhotoMat:A Material Generator Learned from Single Flash Photos</h3><p>【SG2023】【<ahref="https://github.com/xilongzhou/PhotoMat">Github</a>】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@inproceedings&#123;zhou2023photomat,<br>  title=&#123;Photomat: A material generator learned from single flash photos&#125;,<br>  author=&#123;Zhou, Xilong <span class="hljs-keyword">and </span>Hasan, Milos <span class="hljs-keyword">and </span>Deschaintre, Valentin <span class="hljs-keyword">and </span>Guerrero, Paul <span class="hljs-keyword">and </span>Hold-Geoffroy, Yannick <span class="hljs-keyword">and </span>Sunkavalli, Kalyan <span class="hljs-keyword">and </span>Kalantari, Nima Khademi&#125;,<br>  <span class="hljs-keyword">booktitle=&#123;ACM </span>SIGGRAPH <span class="hljs-number">2023</span> Conference Proceedings&#125;,<br>  pages=&#123;<span class="hljs-number">1</span>--<span class="hljs-number">11</span>&#125;,<br>  year=&#123;<span class="hljs-number">2023</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="brdf">BRDF</h2><p>AI压缩BRDF测量数据，基于AI的BRDF模型。</p><h3 id="unified-neural-encoding-of-btfs">Unified Neural Encoding ofBTFs</h3><p>【CGF2020】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;rainer2020unified,</span><br><span class="hljs-template-variable">  title=&#123;Unified neural encoding of BTFs&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Rainer, Gilles and Ghosh, Abhijeet and Jakob, Wenzel and Weyrich, Tim&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Computer Graphics Forum&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;39&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;167--178&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2020&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  organization=</span><span class="hljs-template-variable">&#123;Wiley Online Library&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="neural-btf-compression-and-interpolation">Neural BTF Compressionand Interpolation</h3><p>【CGF2020】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;rainer2019neural,</span><br><span class="hljs-template-variable">  title=&#123;Neural BTF compression and interpolation&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Rainer, Gilles and Jakob, Wenzel and Ghosh, Abhijeet and Weyrich, Tim&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Computer Graphics Forum&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;38&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;235--244&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2019&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  organization=</span><span class="hljs-template-variable">&#123;Wiley Online Library&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="deepbrdf-a-deep-representation-for-manipulating-measured-brdf">DeepBRDF:A Deep Representation for Manipulating Measured BRDF</h3><p>【CGF2020】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@inproceedings&#123;hu2020deepbrdf,<br>  title=&#123;DeepBRDF: A deep representation for manipulating measured <span class="hljs-keyword">BRDF&#125;,</span><br><span class="hljs-keyword"></span>  author=&#123;Hu, <span class="hljs-keyword">Bingyang </span><span class="hljs-keyword">and </span>Guo, <span class="hljs-keyword">Jie </span><span class="hljs-keyword">and </span>Chen, Yanjun <span class="hljs-keyword">and </span>Li, Mengtian <span class="hljs-keyword">and </span>Guo, Yanwen&#125;,<br>  <span class="hljs-keyword">booktitle=&#123;Computer </span>Graphics Forum&#125;,<br>  volume=&#123;<span class="hljs-number">39</span>&#125;,<br>  number=&#123;<span class="hljs-number">2</span>&#125;,<br>  pages=&#123;<span class="hljs-number">157</span>--<span class="hljs-number">166</span>&#125;,<br>  year=&#123;<span class="hljs-number">2020</span>&#125;,<br>  <span class="hljs-keyword">organization=&#123;Wiley </span>Online Library&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="neural-brdf-representation-and-importance-sampling">Neural BRDFRepresentation and Importance Sampling</h3><p>【CGF2021】【<ahref="https://github.com/asztr/Neural-BRDF">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@inproceedings</span><span class="hljs-template-variable">&#123;sztrajman2021neural,</span><br><span class="hljs-template-variable">  title=&#123;Neural BRDF representation and importance sampling&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Sztrajman, Alejandro and Rainer, Gilles and Ritschel, Tobias and Weyrich, Tim&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  booktitle=</span><span class="hljs-template-variable">&#123;Computer Graphics Forum&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;40&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;6&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;332--346&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2021&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  organization=</span><span class="hljs-template-variable">&#123;Wiley Online Library&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="invertible-neural-brdf-for-object-inverse-rendering">InvertibleNeural BRDF for Object Inverse Rendering</h3><p>【PAMI2021】【<ahref="https://github.com/chenzhekl/iBRDF">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;chen2021invertible,</span><br><span class="hljs-template-variable">  title=&#123;Invertible neural BRDF for object inverse rendering&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Chen, Zhe and Nobuhara, Shohei and Nishino, Ko&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;IEEE Transactions on Pattern Analysis and Machine Intelligence&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;44&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;12&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;9380--9395&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2021&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;IEEE&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="a-compact-representation-of-measured-brdfs-using-neural-processes">ACompact Representation of Measured BRDFs Using Neural Processes</h3><p>【TOG2021】【<ahref="https://github.com/Rendering-at-ZJU/NPs-BRDF">Github</a>】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;zheng2021compact,</span><br><span class="hljs-template-variable">  title=&#123;A compact representation of measured brdfs using neural processes&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Zheng, Chuankun and Zheng, Ruzhang and Wang, Rui and Zhao, Shuang and Bao, Hujun&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Transactions on Graphics (TOG)&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;41&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;1--15&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2021&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;ACM New York, NY&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="neural-layered-brdfs">Neural Layered BRDFs</h3><p>【SA2022】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@inproceedings&#123;fan2022neural,<br>  title=&#123;Neural Layered <span class="hljs-keyword">BRDFs&#125;,</span><br><span class="hljs-keyword"></span>  author=&#123;Fan, <span class="hljs-keyword">Jiahui </span><span class="hljs-keyword">and </span>Wang, <span class="hljs-keyword">Beibei </span><span class="hljs-keyword">and </span>Hasan, Milos <span class="hljs-keyword">and </span>Yang, <span class="hljs-keyword">Jian </span><span class="hljs-keyword">and </span>Yan, Ling-Qi&#125;,<br>  <span class="hljs-keyword">booktitle=&#123;ACM </span>SIGGRAPH <span class="hljs-number">2022</span> Conference Proceedings&#125;,<br>  pages=&#123;<span class="hljs-number">1</span>--<span class="hljs-number">8</span>&#125;,<br>  year=&#123;<span class="hljs-number">2022</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="a-sparse-non-parametric-brdf-model">A Sparse Non-parametric BRDFModel</h3><p>【TOG2022】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;tongbuasirilai2022sparse,</span><br><span class="hljs-template-variable">  title=&#123;A Sparse Non-parametric BRDF Model&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Tongbuasirilai, Tanaboon and Unger, Jonas and Guillemot, Christine and Miandji, Ehsan&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Transactions on Graphics&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;41&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;5&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;1--18&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2022&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;ACM New York, NY&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="material-shape">Material &amp; Shape</h2><p>同时估计材质和形状。</p><h3id="learning-to-reconstruct-shape-and-spatially-varying-reflectance-from-a-single-image">Learningto Reconstruct Shape and Spatially-Varying Reflectance from a SingleImage</h3><p>【TOG2018】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;li2018learning,</span><br><span class="hljs-template-variable">  title=&#123;Learning to reconstruct shape and spatially-varying reflectance from a single image&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Li, Zhengqin and Xu, Zexiang and Ramamoorthi, Ravi and Sunkavalli, Kalyan and Chandraker, Manmohan&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Transactions on Graphics (TOG)&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;37&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;6&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  pages=</span><span class="hljs-template-variable">&#123;1--11&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2018&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  publisher=</span><span class="hljs-template-variable">&#123;ACM New York, NY, USA&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3id="learning-efficient-illumination-multiplexing-for-joint-capture-of-reflectance-and-shape">LearningEfficient Illumination Multiplexing for Joint Capture of Reflectance andShape</h3><p>【TOG2019】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@article&#123;kang2019learning,<br>  title=&#123;Learning efficient illumination <span class="hljs-keyword">multiplexing </span>for <span class="hljs-keyword">joint </span>capture of reflectance <span class="hljs-keyword">and </span><span class="hljs-keyword">shape.&#125;,</span><br><span class="hljs-keyword"></span>  author=&#123;Kang, Kaizhang <span class="hljs-keyword">and </span>Xie, Cihui <span class="hljs-keyword">and </span>He, Chengan <span class="hljs-keyword">and </span>Yi, Mingqi <span class="hljs-keyword">and </span>Gu, Minyi <span class="hljs-keyword">and </span>Chen, Zimin <span class="hljs-keyword">and </span>Zhou, Kun <span class="hljs-keyword">and </span>Wu, Hongzhi&#125;,<br>  <span class="hljs-keyword">journal=&#123;ACM </span>Trans. Graph.&#125;,<br>  volume=&#123;<span class="hljs-number">38</span>&#125;,<br>  number=&#123;<span class="hljs-number">6</span>&#125;,<br>  pages=&#123;<span class="hljs-number">165</span>--<span class="hljs-number">1</span>&#125;,<br>  year=&#123;<span class="hljs-number">2019</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="two-shot-spatially-varying-brdf-and-shape-estimation">Two-shotSpatially-varying BRDF and Shape Estimation</h3><p>【CVPR2020】【<ahref="https://github.com/NVlabs/two-shot-brdf-shape">Github</a>】</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">@inproceedings&#123;boss2020two,</span><br>  title=&#123;Two-shot spatially-varying brdf <span class="hljs-keyword">and</span> shape estimation&#125;,<br>  author=&#123;Boss, Mark <span class="hljs-keyword">and</span> Jampani, Varun <span class="hljs-keyword">and</span> Kim, Kihwan <span class="hljs-keyword">and</span> Lensch, Hendrik <span class="hljs-keyword">and</span> Kautz, Jan&#125;,<br>  booktitle=&#123;Proceedings of the IEEE/CVF Conference on Computer Vision <span class="hljs-keyword">and</span> Pattern Recognition&#125;,<br>  pages=&#123;<span class="hljs-number">3982</span>--<span class="hljs-number">3991</span>&#125;,<br>  year=&#123;<span class="hljs-number">2020</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="inverse-rendering-for-complex-indoor-scenes-shape-spatially-varying-lighting-and-svbrdf-from-a-single-image">InverseRendering for Complex Indoor Scenes: Shape, Spatially-Varying Lightingand SVBRDF from a Single Image</h3><p>【CVPR2020】</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">@inproceedings&#123;li2020inverse,</span><br>  title=&#123;Inverse rendering for complex indoor scenes: Shape, spatially-varying lighting <span class="hljs-keyword">and</span> svbrdf from a single image&#125;,<br>  author=&#123;Li, Zhengqin <span class="hljs-keyword">and</span> Shafiei, Mohammad <span class="hljs-keyword">and</span> Ramamoorthi, Ravi <span class="hljs-keyword">and</span> Sunkavalli, Kalyan <span class="hljs-keyword">and</span> Chandraker, Manmohan&#125;,<br>  booktitle=&#123;Proceedings of the IEEE/CVF Conference on Computer Vision <span class="hljs-keyword">and</span> Pattern Recognition&#125;,<br>  pages=&#123;<span class="hljs-number">2475</span>--<span class="hljs-number">2484</span>&#125;,<br>  year=&#123;<span class="hljs-number">2020</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="a-unified-spatial-angular-structured-light-for-single-view-acquisition-of-shape-and-reflectance">AUnified Spatial-Angular Structured Light for Single-View Acquisition ofShape and Reflectance</h3><p>【CVPR2023】</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">@inproceedings&#123;xu2023unified,</span><br>  title=&#123;A unified spatial-angular structured light for single-view acquisition of shape <span class="hljs-keyword">and</span> reflectance&#125;,<br>  author=&#123;Xu, Xianmin <span class="hljs-keyword">and</span> Lin, Yuxin <span class="hljs-keyword">and</span> Zhou, Haoyang <span class="hljs-keyword">and</span> Zeng, Chong <span class="hljs-keyword">and</span> Yu, Yaxin <span class="hljs-keyword">and</span> Zhou, Kun <span class="hljs-keyword">and</span> Wu, Hongzhi&#125;,<br>  booktitle=&#123;Proceedings of the IEEE/CVF Conference on Computer Vision <span class="hljs-keyword">and</span> Pattern Recognition&#125;,<br>  pages=&#123;<span class="hljs-number">206</span>--<span class="hljs-number">215</span>&#125;,<br>  year=&#123;<span class="hljs-number">2023</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="material-cont.">Material Cont.</h2><p>其它材质相关。</p><h3 id="neumip-multi-resolution-neural-materials">NeuMIP:Multi-Resolution Neural Materials</h3><p>【TOG2021】</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">@article</span><span class="hljs-template-variable">&#123;kuznetsov2021neumip,</span><br><span class="hljs-template-variable">  title=&#123;NeuMIP: Multi-resolution neural materials&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  author=</span><span class="hljs-template-variable">&#123;Kuznetsov, Alexandr&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  journal=</span><span class="hljs-template-variable">&#123;ACM Transactions on Graphics (TOG)&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  volume=</span><span class="hljs-template-variable">&#123;40&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  number=</span><span class="hljs-template-variable">&#123;4&#125;</span><span class="language-xml">,</span><br><span class="language-xml">  year=</span><span class="hljs-template-variable">&#123;2021&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="woven-fabric-capture-from-a-single-photo">Woven Fabric Capturefrom a Single Photo</h3><p>【SGA2022】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@inproceedings&#123;<span class="hljs-keyword">jin2022woven,</span><br><span class="hljs-keyword"></span>  title=&#123;Woven fabric capture from a single photo&#125;,<br>  author=&#123;<span class="hljs-keyword">Jin, </span>Wenhua <span class="hljs-keyword">and </span>Wang, <span class="hljs-keyword">Beibei </span><span class="hljs-keyword">and </span>Hasan, Milos <span class="hljs-keyword">and </span>Guo, Yu <span class="hljs-keyword">and </span>Marschner, Steve <span class="hljs-keyword">and </span>Yan, Ling-Qi&#125;,<br>  <span class="hljs-keyword">booktitle=&#123;SIGGRAPH </span>Asia <span class="hljs-number">2022</span> Conference Papers&#125;,<br>  pages=&#123;<span class="hljs-number">1</span>--<span class="hljs-number">8</span>&#125;,<br>  year=&#123;<span class="hljs-number">2022</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="a-semi-procedural-convolutional-material-prior">ASemi-procedural Convolutional Material Prior</h3><p>【CGF2023】【<ahref="https://github.com/xilongzhou/Material_prior">Github</a>】</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">@inproceedings&#123;zhou2023semi,<br>  title=&#123;A Semi-Procedural Convolutional Material Prior&#125;,<br>  author=&#123;Zhou, Xilong <span class="hljs-keyword">and </span>Ha&#123;\v&#123;s&#125;&#125;an, Milo&#123;\v&#123;s&#125;&#125; <span class="hljs-keyword">and </span>Deschaintre, Valentin <span class="hljs-keyword">and </span>Guerrero, Paul <span class="hljs-keyword">and </span>Sunkavalli, Kalyan <span class="hljs-keyword">and </span>Kalantari, Nima Khademi&#125;,<br>  <span class="hljs-keyword">booktitle=&#123;Computer </span>Graphics Forum&#125;,<br>  year=&#123;<span class="hljs-number">2023</span>&#125;,<br>  <span class="hljs-keyword">organization=&#123;Wiley </span>Online Library&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="工具">工具</h1><h2 id="软件">软件</h2><p><ahref="https://www.adobe.com/hk_en/products/substance3d-sampler.html">Photogrammetrysoftware for 3D capture - Adobe Substance 3D</a></p><ul><li>支持从照片生成材质。</li><li>算法来自论文：MaterIA: Single Image High‐Resolution Material Capturein the Wild。</li></ul><p><a href="https://boundingboxsoftware.com/materialize/">Bounding BoxSoftware - Materialize</a></p><ul><li>支持从照片生成材质，编辑自由度很高。</li></ul><p><a href="https://armorlab.org/">ArmorLab | PBR TextureCreation</a></p><ul><li>基于节点，支持从照片生成材质、超分、修复、平铺转化、文生图、文字辅助变种生成。最高16k。</li></ul><h2 id="在线">在线</h2><p><a href="https://toggle3d.com/ai">Generate PBR Material with AI(toggle3d.com)</a></p><ul><li>支持从照片生成材质、文生材质、材质属性调整。</li></ul><p><a href="https://poly.cam/tools/ai-texture-generator">AI TextureGenerator for Blender, Unreal, Unity | Polycam</a></p><ul><li>支持文生材质，可以附加参考图片。</li></ul><p><a href="https://textures.digimans.ai/">Online AI PBR MaterialGenerator - Digimans.ai</a></p><ul><li>支持从照片生成材质。</li></ul><h1 id="文章">文章</h1><p><ahref="https://zhuanlan.zhihu.com/p/620852185">AI生成游戏中基于物理的渲染（PBR）贴图探索- 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《More Effective C++》笔记</title>
      <link href="//posts/Notebook/More-Effective-CPP-note/"/>
      <url>//posts/Notebook/More-Effective-CPP-note/</url>
      
        <content type="html"><![CDATA[<p>35 New Ways to Improve Your Programs and Designs</p><span id="more"></span><p>Scott Meyers 著</p><p>候捷 译</p><p class="note note-primary">摘录整理。</p><p><ahref="https://www.aristeia.com/BookErrata/mec++-errata.html">本书修订及更新网站</a></p><p>条款1指本书条款1，条款E1指另一本书Effective C++的条款1。</p><h1 id="基础议题">1 基础议题</h1><h2 id="指针与引用的区别">1 指针与引用的区别</h2><p>任何情况下都不能使用<strong>指向空值的引用</strong>！如需指向空值，使用指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> *pc = <span class="hljs-number">0</span>; <span class="hljs-comment">// 设置指针为空值 </span><br><span class="hljs-type">char</span> &amp;rc = *pc; <span class="hljs-comment">//  让引用指向空值，结果不确定</span><br></code></pre></td></tr></table></figure><p>引用必须初始化，指针可以不初始化。</p><p>引用初始化后不能改变， 指针可以被重新赋值以指向另一个不同的对象。</p><h2 id="尽量使用c风格的类型转换">2 尽量使用C++风格的类型转换</h2><p>使用static_cast，const_cast，dynamic_cast，reinterpret_cast等四个类型转换操作符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> firstNumber, secondNumber; <br><span class="hljs-type">double</span> result = ((<span class="hljs-type">double</span>)firstNumber)/secondNumber;<br><span class="hljs-comment">// 应该这样写</span><br><span class="hljs-type">double</span> result = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(firstNumber)/secondNumber;<br></code></pre></td></tr></table></figure><h2 id="不要对数组使用多态">3 不要对数组使用多态</h2><p>因为编译器无法正确判断数组中各元素内存地址与数组的起始地址的间隔。</p><p>从具体类（concreteclasses）派生的具体类容易犯对数组使用多态的错误。（参见条款33）</p><h2 id="避免无用的缺省构造函数">4 避免无用的缺省构造函数</h2><p>如果类没有缺省构造函数，且仅定义了有参构造函数，建立其对象数组有以下办法：</p><ol type="1"><li><p>直接初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">A a[] = &#123;<span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>), <span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>)&#125;;<br></code></pre></td></tr></table></figure><p>只能用于非堆数组，不能用于堆数组。</p></li><li><p>创建指针数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> A* PA;<br>PA pa[<span class="hljs-number">10</span>];<br>PA *pb = <span class="hljs-keyword">new</span> PA[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>浪费内存。</p></li><li><p>用 placement new 方法。(参见条款8)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> *rawMemory = <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-number">10</span>*<span class="hljs-built_in">sizeof</span>(A)); <br>A *a = <span class="hljs-built_in">static_cast</span>&lt;A*&gt;(rawMemory); <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) <br>    <span class="hljs-keyword">new</span> (&amp;a[i])<span class="hljs-built_in">A</span>(i); <br></code></pre></td></tr></table></figure></li></ol><p><strong>通过仔细设计模板可以杜绝对缺省构造函数的需求，如vector。</strong></p><h1 id="运算符">2 运算符</h1><h2 id="谨慎定义类型转换函数">5 谨慎定义类型转换函数</h2><p>允许类型转换的两种函数：</p><ul><li>单参构造函数（该函数可以是只定义了一个参数，也可以是虽定义了多个参数但第一个参数以后的所有参数都有缺省值）</li><li>隐式类型转换运算符</li></ul><p>一般来说，越有经验的C++程序员就越喜欢<strong>避开</strong>类型转换运算符。例如，库函数中的string类型没有包括隐式地从string转换成C风格的<code>char*</code>的功能，而是定义了一个成员函数c_str用来完成这个转换。</p><p>使用explicit声明避免单参构造函数造成的无意义的类型转换。</p><p>编译器<strong>不会连续调用两个用户定义（user-defined）的类型转换进行隐式转换</strong>。因此可以考虑使用公有<strong>内部类</strong>的对象作为单参构造函数的入参。（这里的内部类在功能上被称为代理类，参见条款30）</p><h2 id="自增increment自减decrement操作符前缀形式与后缀形式的区别">6自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别</h2><p>C++规定<strong>后缀形式</strong>有一个int类型参数，当函数被调用时，编译器传递一个0做为int参数的值给该函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// unlimited precision int</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UPInt</span> &#123; <br><span class="hljs-keyword">public</span>: <br>    UPInt&amp; <span class="hljs-keyword">operator</span>++(); <span class="hljs-comment">// ++前缀 </span><br>    <span class="hljs-type">const</span> UPInt <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">// ++后缀 </span><br>    UPInt&amp; <span class="hljs-keyword">operator</span>--(); <span class="hljs-comment">// --前缀 </span><br>    <span class="hljs-type">const</span> UPInt <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>); <span class="hljs-comment">// --后缀 </span><br>    UPInt&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">int</span>); <span class="hljs-comment">// +=操作符，UPInts与ints相运算</span><br>&#125;; <br><br>UPInt&amp; UPInt::<span class="hljs-keyword">operator</span>++() <br>&#123; <br>    *<span class="hljs-keyword">this</span> += <span class="hljs-number">1</span>; <span class="hljs-comment">// 增加 </span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 取回值 </span><br>&#125;<br><br><span class="hljs-comment">// 返回const避免++++</span><br><span class="hljs-type">const</span> UPInt UPInt::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) <br>&#123; <br>    UPInt oldValue = *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 取回值 </span><br>    ++(*<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 增加 </span><br>    <span class="hljs-keyword">return</span> oldValue; <span class="hljs-comment">// 返回被取回的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>后缀increment和decrement应该根据它们的前缀形式来实现，便于维护。</p><h2 id="不要重载">7 不要重载<code>&amp;&amp; || ,</code></h2><p>对于<code>&amp;&amp; ||</code>，重载会打破大家熟悉的<strong>短路求值</strong>原则。因为重载引发函数调用，而C++规范<strong>没有定义</strong>函数参数的计算顺序。</p><p>对于<code>,</code>，一个包含逗号的表达式首先计算逗号左边的表达式，然后计算逗号右边的表达式；整个表达式的结果是逗号右边表达式的值。重载会打破上述规则。</p><p>以上是建议不要重载，不是不能重载。</p><p>不能重载的操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">.   .*   ::   ?:   <br><span class="hljs-keyword">new</span>   <span class="hljs-keyword">delete</span>   <span class="hljs-keyword">sizeof</span>   <span class="hljs-keyword">typeid</span><br><span class="hljs-keyword">static_cast</span>   <span class="hljs-keyword">dynamic_cast</span>   <span class="hljs-keyword">const_cast</span>   <span class="hljs-keyword">reinterpret_cast</span><br></code></pre></td></tr></table></figure><p>能重载的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>   <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>   <br><span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[]   <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[] <br>+   -   *   /  %   ^   &amp;   |   ~ <br>!   =   &lt;   &gt;   +=   -=   *=   /=   %=<br>^=   &amp;=   |=   &lt;&lt;   &gt;&gt;   &gt;&gt;=   &lt;&lt;=   ==   != <br>&lt;=   &gt;=   &amp;&amp;   ||   ++   --   ,   -&gt;*   -&gt; <br>() [] <br></code></pre></td></tr></table></figure><h2 id="理解各种不同含义的new和delete">8理解各种不同含义的new和delete</h2><p>new操作符为分配内存调用operator new函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-comment">// 你能增加额外的参数重载函数operator new，但是第一个参数类型必须是size_t，决定分配多少内存。</span><br></code></pre></td></tr></table></figure><p>特殊的operator new函数被称为placement new。（条款4有例子）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 它看上去像这样,仅仅返回指向内存的指针</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, <span class="hljs-type">void</span>* location)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> location; <br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>在堆上建立一个对象，分配内存且调用构造函数：使用new操作符。</p></li><li><p>仅分配内存：使用operator new函数。</p></li><li><p>定制在堆对象被建立时的内存分配过程：重载operatornew函数，然后使用new操作符。（new操作符会调用你定制的operatornew）</p></li><li><p>在一块已经获得指针的内存里建立一个对象：使用placementnew。</p></li></ol><p>如果用placementnew在内存中建立对象，应该避免在该内存中用delete操作符。指针来源无法确定。</p><h1 id="异常">3 异常</h1><p>C程序员能够仅通过setjmp和longjmp来完成与异常处理相似的功能。但是longjmp在C++中使用时，当它调整堆栈不能对局部对象调用析构函数。大多数C++程序员依赖于这些析构函数的调用，所以setjmp和longjmp不能够替换异常处理。</p><h2 id="使用析构函数防止资源泄漏">9 使用析构函数防止资源泄漏</h2><p>即RAII，用智能指针代替普通指针。</p><h2 id="在构造函数中防止资源泄漏">10 在构造函数中防止资源泄漏</h2><p>C++仅仅能删除被<strong>完全构造</strong>的对象（fully contructedobjects）。</p><blockquote><p>如果为没有完成构造操作的对象调用析构函数，析构函数如何去做呢？仅有的办法是在每个对象里加入一些字节来指示构造函数执行了多少步？然后让析构函数检测这些字节并判断该执行哪些操作。这样的记录会减慢析构函数的运行速度，并使得对象的尺寸变大。C++避免了这种开销，代价是不能自动地删除被部分构造的对象。</p></blockquote><p>若构造函数中抛出异常，捕获所有的异常，然后执行一些清除代码，最后再重新抛出异常让它继续传递。</p><h2 id="禁止异常信息exceptions传递到析构函数外">11禁止异常信息（exceptions）传递到析构函数外</h2><p>两种情况下会调用析构函数:</p><ol type="1"><li>正常情况下删除一个对象，例如对象超出了作用域或被显式地delete。</li><li>异常传递的堆栈辗转开解（stack-unwinding）过程中，由异常处理系统删除一个对象。</li></ol><p>如果在一个异常被激活的同时，析构函数也抛出异常，并导致程序控制权转移到析构函数外，C++将调用terminate函数。这个函数<strong>立即终止</strong>程序的运行，连局部对象都没有被释放。</p><h2 id="理解抛出一个异常与传递一个参数或调用一个虚函数间的差异">12理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异</h2><p>差异：</p><ol type="1"><li><p>调用函数时，程序的控制权最终还会返回到函数的调用处；但是当抛出一个异常时，控制权永远不会回到抛出异常的地方。</p></li><li><p>C++规范要求被做为异常抛出的对象<strong>必须被拷贝</strong>（不论通过传值捕获异常还是通过引用捕获），然后再传入catch语句。拷贝使用对象的<strong>静态类型</strong>所对应的拷贝构造函数。</p><p>因此当抛出一个异常时，系统构造的（以后会析构掉）被抛出对象的拷贝数<strong>比以相同对象做为参数传递给函数时</strong>构造的拷贝数要多一个。例如通过传值方式捕获异常时，异常会被拷贝两次。</p><blockquote><p>应该用throw来重新抛出当前的异常，因为这样不会改变被传递出去的异常类型（变为catch语句参数的静态类型），而且不用生成一个新拷贝。</p></blockquote></li><li><p>函数调用中不允许转递一个临时对象到一个非const引用类型的参数里（参见条款19），但是在异常中却允许。</p></li><li><p>catch语句匹配异常类型时不会进行基本类型的隐式类型转换（int到double），但可以进行派生类到基类、类型化指针（typedpointer）到无类型指针（untyped pointer）的转换。</p></li><li><p>catch语句匹配顺序总是取决于它们在程序中出现的顺序。</p><blockquote><p>虚拟函数采用最优适合法， 而异常处理采用的是最先适合法。</p></blockquote></li></ol><p>书中总结仅提了2、4、5。</p><h2 id="通过引用reference捕获异常">13 通过引用（reference）捕获异常</h2><p>通过指针捕获异常的缺点：</p><ol type="1"><li><p>需要指针是全局与静态对象，否则抛出异常后指针指向的异常对象将被释放。</p></li><li><p>也可以建立一个堆对象抛出，但catch语句无法判断指针指向的是不是堆对象、是否要删除。</p></li></ol><p>通过值捕获异常的缺点：</p><ol type="1"><li>异常将被拷贝两次。</li><li>派生类的异常对象被做为基类异常对象捕获时，派生类行为会被<strong>切掉</strong>（slicedoff）。</li></ol><h2 id="审慎使用异常规格exception-specifications">14审慎使用异常规格(exception specifications)</h2><p>如果一个函数抛出一个<strong>不在异常规格范围</strong>里的异常，系统在运行时能够检测出这个错误，然后一个特殊函数unexpected将被自动地调用。函数unexpected缺省的行为是调用函数terminate，而terminate缺省的行为是调用函数abort，所以一个违反异常规格的程序其缺省的行为就是halt（停止运行）。</p><blockquote><p>动态异常规范（<code>throw(optional_type_list)</code> 规范）在 C++11中<strong>已弃用</strong>，并已在 C++17 中<strong>删除</strong>，但<code>throw()</code> 除外，它是 <code>noexcept(true)</code> 的别名。</p></blockquote><h2 id="了解异常处理的系统开销">15 了解异常处理的系统开销</h2><p>只要可能就尽量采用不支持异常的方法编译程序，把使用try块和异常规格限制在你确实需要它们的地方，并且只有在确为异常的情况下（exceptional）才抛出异常。</p><h1 id="效率">4 效率</h1><p>从两个角度阐述效率问题：语言独立和语言本身。</p><h2 id="牢记80-20准测">16 牢记80-20准测</h2><p>大约20％的代码使用了80％的程序资源；大约20%的代码耗用了大约80％的运行时间；大约20％的代码使用了80％的内存；大约20％的代码执行80％的磁盘访问；80％的维护投入于大约20％的代码上。</p><h2 id="考虑使用lazy-evaluation懒惰计算法">17 考虑使用lazyevaluation（懒惰计算法）</h2><p>与之相对的是eager evaluation。</p><ol type="1"><li><p>引用计数</p><p>只要可能就共享使用其它值而不是拷贝。如String。</p></li><li><p>区别对待读取和写入</p><p>推迟做出是读操作还是写操作的决定，直到能判断出正确的答案。如opertaor[]操作符。</p></li><li><p>Lazy Fetching（懒惰提取）</p><p>对于大型对象，仅提取需要的字段。</p></li></ol><p>mutalbe关键字声明的字段在const成员函数里也能被修改。如果编译器不支持mutalbe，建立一个non-const指针，其指向的对象与this指针一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">LargeObject* <span class="hljs-type">const</span> fakeThis = <span class="hljs-built_in">const_cast</span>&lt;LargeObject* <span class="hljs-type">const</span>&gt;(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><p>Lazy Expression Evaluation（懒惰表达式计算）</p><p>对于大型矩阵运算，仅计算需要的值。</p></li></ol><h2 id="分期摊还期望的计算">18 分期摊还期望的计算</h2><p>这个条款的核心就是over-eagerevaluation（过度热情计算法）：在要求你做某些事情<strong>以前</strong>就完成它们。</p><p>集合每次更新时同步更新其最大最小值，用户可以随时使用最大最小值。</p><p>缓存那些已经被计算出来而以后还有可能需要的值。</p><blockquote><p>iterator是一个对象，不是指针，所以不能保证”-&gt;”被正确应用到它上面。不过STL要求”.”和”*”在iterator上是合法的，所以(*it).second在语法上虽然比较繁琐，但是保证能运行。</p></blockquote><h2 id="理解临时对象的来源">19 理解临时对象的来源</h2><p>在任何时候只要见到常量引用（reference-to-const）参数，就存在建立<strong>临时对象</strong>而绑定在参数上的可能性。在任何时候只要见到函数返回对象，就会有一个<strong>临时对象</strong>被建立（以后被释放）。</p><p>禁止为<strong>非常量引用</strong>（reference-to-non-const）参数产生临时对象。</p><h2 id="协助完成返回值优化">20 协助完成返回值优化</h2><p>返回对象是必要的，应该优化开销而不是避免它。</p><blockquote><p>摘录本章末尾一段的原文：</p><p>Programmers looking for a C++ compiler can ask vendors whether the<strong>return value optimization</strong> is implemented. If one vendorsays yes and another says "The what?," the first vendor has a notablecompetitive advantage. Ah, capitalism. Sometimes you just gotta loveit.</p><p>上文提到的return valueoptimization详细解释可见《深度探索C++对象模型》的2.3节，其被称为NamedReturn Value（NRV）优化。</p><p>笔记：<ahref="https://reddish.fun/posts/Notebook/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2CPP%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E7%AC%94%E8%AE%B0/#%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8C%96%E8%AF%AD%E6%84%8F%E5%AD%A6">《深度探索C++对象模型》笔记- Homeland</a></p></blockquote><h2 id="通过重载避免隐式类型转换">21 通过重载避免隐式类型转换</h2><p>大多数C++程序员希望进行没有临时对象开销的隐式类型转换。可以使用重载避免。</p><p>为避免程序混乱，每一个重载的operator必须带有一个<strong>用户定义类型</strong>（user-defined type）的参数。</p><h2 id="考虑用运算符的赋值形式op取代其单独形式op">22考虑用运算符的赋值形式（op=）取代其单独形式（op）</h2><p>从零开始实现operator+=和-=，而operator+和operator-则是通过<strong>调用前述的函数来提供自己的功能</strong>。使用这种设计方法，只用维护operator的赋值形式就行了。而且如果假设operator赋值形式在类的public接口里，这就不用让operator的单独形式成为类的友元。（参见条款E19）</p><p>总的来说operator的赋值形式比其单独形式效率更高，因为单独形式要返回一个新对象，从而在临时对象的构造和释放上有一些开销。</p><h2 id="考虑变更程序库">23 考虑变更程序库</h2><p>程序库的设计就是一个<strong>折衷</strong>的过程。理想的程序库应该是短小的、快速的、强大的、灵活的、可扩展的、直观的、普遍适用的、具有良好的支持、没有使用约束、没有错误的。这也是不存在的。为尺寸和速度而进行优化的程序库一般不能被移植。具有大量功能的的程序库不会具有直观性。没有错误的程序库在使用范围上会有限制。</p><p>因为不同的程序库在效率、可扩展性、移植性、类型安全和其他一些领域上蕴含着不同的设计理念，通过变换使用给予性能更多考虑的程序库，你有时可以大幅度地提高软件的效率。</p><h2 id="理解虚拟函数多继承虚基类和rtti所需的代价">24理解虚拟函数、多继承、虚基类和RTTI所需的代价</h2><p>virtual table和virtual table pointers通常被分别地称为vtbl和vptr。</p><p>一个 vtbl通常是一个函数指针数组。vtbl的大小与类中声明的虚函数的数量成正比（包括从基类继承的虚函数）。</p><p>vtbl应该放在哪里？</p><ol type="1"><li>每一个可能需要vtbl的object文件生成一个vtbl拷贝。连接程序然后去除重复的拷贝，在最后的可执行文件或程序库里就为每个vtbl保留一个实例。</li><li>要在一个object文件中生成一个类的vtbl，要求该object文件包含该类的第一个非内联、非纯虚拟函数（non-inlinenon-pure virual function）定义（也就是类的实现体）。（这种启发式算法在类中的所有虚函数都内声明为内联函数时会失败）</li></ol><p>在每个包含虚函数的类的对象里，你必须为额外的指针（vptr）付出代价。</p><p><strong>RTTI被设计为在类的vtbl基础上实现。</strong>（typeid得到的type_info会放在vtbl的slot里）</p><blockquote><p>使用嵌套的switch语句或层叠的if-then-else语句模拟虚函数的调用，其产生的代码比虚函数的调用还要多，而且代码运行速度也更慢。你自己编写代码不可能做得比编译器生成的代码更好</p></blockquote><h1 id="技巧">5 技巧</h1><h2 id="将构造函数和非成员函数虚拟化">25将构造函数和非成员函数虚拟化</h2><p><strong>虚拟构造函数</strong>是指能够根据输入给它的数据的不同而建立不同类型的对象。虚拟构造函数在很多场合下都有用处，从磁盘（或者通过网络连接，或者从磁带机上）读取对象信息只是其中的一个应用。</p><p>被派生类重定义的虚拟函数不用必须与基类的虚拟函数具有一样的<strong>返回类型</strong>。如果函数的返回类型是一个指向基类的指针（或一个引用），那么派生类的函数可以返回一个指向基类的派生类的指针（或引用）。这不是C++的类型检查上的漏洞，它使得有可能声明像虚拟构造函数这样的函数。</p><p><strong>具有虚拟行为的非成员函数</strong>很简单。编写一个虚拟函数来完成工作，然后再写一个非虚拟函数，它什么也不做只是调用这个虚拟函数。可以内联这个非虚拟函数来避免这个句法花招引起函数调用开销。</p><h2 id="限制某个类所能产生的对象数量">26限制某个类所能产生的对象数量</h2><p>在类中的静态对象实际上总是被构造（和释放），即使不使用该对象。与此相反，只有第一次执行函数时，才会建立<strong>函数中的静态对象</strong>，所以如果没有调用函数，就不会建立对象。</p><p>类中的静态成员初始化时间不确定。C++为一个translationunit（也就是生成一个 object文件的源代码的集合）内的静态成员的初始化顺序提供某种保证，但是对于在不同translationunit中的静态成员的初始化顺序则没有这种保证（参见条款E47）。</p><p>不要建立<strong>包含局部静态数据的非成员函数</strong>，可能会使程序的静态对象的拷贝超过一个。</p><p><strong>对象所处的三种不同的环境</strong>：</p><ol type="1"><li>只有它们本身</li><li>作为其它派生类的基类</li><li>被嵌入在更大的对象里</li></ol><p>这些不同环境极大地混淆了<strong>跟踪存在对象的数目</strong>的含义，因为人心目中的对象的存在的含义与编译器不一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 具有实例计数功能的基类</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BeingCounted</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counted</span> &#123; <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TooManyObjects</span>&#123;&#125;; <span class="hljs-comment">// 用来抛出异常 </span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">objectCount</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> numObjects; &#125; <br><span class="hljs-keyword">protected</span>: <br>    <span class="hljs-built_in">Counted</span>(); <br>    <span class="hljs-built_in">Counted</span>(<span class="hljs-type">const</span> Counted&amp; rhs); <br>    ~<span class="hljs-built_in">Counted</span>() &#123; --numObjects; &#125; <br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> numObjects; <br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> maxObjects; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 避免构造函数的代码重复</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BeingCounted</span>&gt; <br>Counted&lt;BeingCounted&gt;::<span class="hljs-built_in">Counted</span>() &#123; <span class="hljs-built_in">init</span>(); &#125; <br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BeingCounted</span>&gt; <br>Counted&lt;BeingCounted&gt;::<span class="hljs-built_in">Counted</span>(<span class="hljs-type">const</span> Counted&lt;BeingCounted&gt;&amp;) &#123; <span class="hljs-built_in">init</span>(); &#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BeingCounted</span>&gt; <br><span class="hljs-type">void</span> Counted&lt;BeingCounted&gt;::<span class="hljs-built_in">init</span>() <br>&#123; <br>    <span class="hljs-keyword">if</span> (numObjects &gt;= maxObjects) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TooManyObjects</span>(); <br>    ++numObjects; <br>&#125; <br></code></pre></td></tr></table></figure><p>若private继承Counted类，可以使用<code>using Counted::objectCount;</code>恢复访问权至public。</p><p><strong>必须定义Counted内的静态成员。</strong>对于numObjects来说，我们只需要在Counted的实现文件里定义它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BeingCounted</span>&gt; <br><span class="hljs-type">int</span> Counted&lt;BeingCounted&gt;::numObjects; <span class="hljs-comment">// 自动把它初始化为0</span><br></code></pre></td></tr></table></figure><p>对于maxObjects，留给此类的客户端类X初始化，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> Counted&lt;X&gt;::maxObjects = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>若客户端类X不初始化，连接时会发生错误，因为maxObjects没有被定义。</p><h2 id="要求或禁止在堆中产生对象">27 要求或禁止在堆中产生对象</h2><p>要求类的对象<strong>仅分配在堆中</strong>：</p><p>将此类的析构函数声明为private，使析构函数不能被隐式调用，因此也就不能在栈中创建对象。客户端只能用伪析构函数释放他们建立的对象。（异常处理体系要求所有在栈中的对象的析构函数必须申明为公有）</p><p>如果要继承此类，应将析构函数声明为protected；若要包含此类的对象作为成员，应包含指向其的指针而不是本身。</p><p>没有一种可移植的方法来判断对象<strong>是否在堆上</strong>：</p><p>设置静态标志位的方法不行。即使重载operator new和operatornew[]，在new对象数组时也只能设置一次标志位。在<code>UPNumber *pn = new UPNumber(*new UPNumber);</code>情况下，C++不保证两次operatornew和两次UPNumber构造函数的调用顺序，标志位可能被提前清除。</p><p>利用栈在结构上趋向低地址、堆在在结构上趋向高地址的内存布局，堆中的变量或对象肯定比任何栈中的变量或对象<strong>地址小</strong>。首先，并不是所有系统都是这样；其次，这种方法无法辨别堆对象与<strong>静态对象</strong>。（在很多栈和堆<strong>相向扩展</strong>的系统里，静态对象位于堆的底端）</p><p>判断<strong>是否能够删除一个指针</strong>是可行的：</p><p>构建一个operatornew返回的地址集合。通过继承抽象基类的方式实现，避免污染全局命名空间。</p><p>带有多继承或虚基类的对象会有几个地址（参见条款24和31），需要把this指针dynamic_cast成<code>const void*</code>，变成一个指向当前对象起始地址的指针。</p><p><strong>禁止堆对象</strong>是可行的：</p><p>把operator new、operatordelete声明为private。但作为派生类的对象和被嵌入在更大的对象里时，无法禁止。</p><blockquote><p>参见条款26中对象所处的三种不同的环境。</p></blockquote><h2 id="灵巧smart指针">28 灵巧（smart）指针</h2><blockquote><p>auto_ptr已经废除了。C++11新标准增添了unique_ptr、shared_ptr以及weak_ptr这3个智能指针。</p></blockquote><p>使用<strong>成员模板</strong>重载类型转换运算符实现基类和派生类之间的智能指针的隐式转换。</p><p><code>const T*</code>对应<code>shared_ptr&lt;const T&gt;</code>，<code>T* const</code>对应<code>const shared_ptr&lt;T&gt;</code>。</p><h2 id="引用计数">29 引用计数</h2><p>写时拷贝：与其它对象共享一个值<strong>直到写操作时</strong>才拥有自己的拷贝。</p><blockquote><p>除非使用proxy，否则无法区别当前是读操作还是写操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 利用引用计数使相同值的string指向同一个对象</span><br><span class="hljs-comment">// 此时，需要对string进行写时拷贝，避免对单个string的修改影响其它string</span><br><span class="hljs-type">char</span>&amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <br>&#123; <br>    <span class="hljs-keyword">if</span> (value-&gt;refCount &gt; <span class="hljs-number">1</span>) <br>    &#123; <br>        --value-&gt;refCount; <br>        value = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringValue</span>(value-&gt;data); <br>    &#125; <br>    <span class="hljs-keyword">return</span> value-&gt;data[index]; <br>&#125;<br></code></pre></td></tr></table></figure><p>上述方法无法解决以下指针（或引用）造成的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">String s1 = <span class="hljs-string">&quot;Hello&quot;</span>; <br><span class="hljs-type">char</span> *p = &amp;s1[<span class="hljs-number">1</span>];<br>String s2 = s1;<br>*p = <span class="hljs-string">&#x27;x&#x27;</span>; <span class="hljs-comment">//s1,s2都改了</span><br></code></pre></td></tr></table></figure><p>解决方法是增加一个标志位指出它是否为可共享的。在最初（对象可共享时）将标志打开，在非const的operator[]被调用时将它关闭。一旦标志位被设为false，就将<strong>永远</strong>保持在这个状态。</p><h2 id="代理类">30 代理类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharProxy</span> &#123; <br>    <span class="hljs-keyword">public</span>: <br>        <span class="hljs-built_in">CharProxy</span>(String&amp; str, <span class="hljs-type">int</span> index); <br>        CharProxy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> CharProxy&amp; rhs); <br>        CharProxy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">char</span> c); <br>        <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">char</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <br>    <span class="hljs-keyword">private</span>: <br>        String&amp; theString; <br>        <span class="hljs-type">int</span> charIndex; <br>    &#125;;<br>    <span class="hljs-type">const</span> CharProxy <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span>; <span class="hljs-comment">// for const Strings </span><br>    CharProxy <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index); <span class="hljs-comment">// for non-const Strings </span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharProxy</span>; <br><span class="hljs-keyword">private</span>: <br>    RCPtr&lt;StringValue&gt; value; <br>&#125;;<br><span class="hljs-comment">// 创建和返回一个proxy对象来代替字符</span><br><span class="hljs-type">const</span> String::CharProxy String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> <br>&#123; <br>    <span class="hljs-comment">// 虽然有const转型，不用担心String内部的字符可能通过proxy类被修改，因为返回的CharProxy对象自己是const的.</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">CharProxy</span>(<span class="hljs-built_in">const_cast</span>&lt;String&amp;&gt;(*<span class="hljs-keyword">this</span>), index); <br>&#125; <br>String::CharProxy String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <br>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">CharProxy</span>(*<span class="hljs-keyword">this</span>, index); <br>&#125; <br><br>String::CharProxy::<span class="hljs-built_in">CharProxy</span>(String&amp; str, <span class="hljs-type">int</span> index):<span class="hljs-built_in">theString</span>(str),<span class="hljs-built_in">charIndex</span>(index) &#123;&#125; <br><br><span class="hljs-comment">// 将proxy对象作右值使用时,只需返回它所扮演的字符</span><br>String::<span class="hljs-function">CharProxy::<span class="hljs-keyword">operator</span> <span class="hljs-title">char</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> theString.value-&gt;data[charIndex]; <br>&#125; <br><br><span class="hljs-comment">// 将proxy对象作左值使用并赋给其另一个proxy对象时</span><br>String::CharProxy&amp; String::CharProxy::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> CharProxy&amp; rhs) <br>&#123; <br>    <span class="hljs-comment">// 如果该string和其它string对象共享一个值，中断共享</span><br>    <span class="hljs-keyword">if</span> (theString.value-&gt;<span class="hljs-built_in">isShared</span>()) <br>    &#123; <br>        theString.value = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringValue</span>(theString.value-&gt;data); <br>    &#125; <br>    <span class="hljs-comment">// 赋值</span><br>    theString.value-&gt;data[charIndex] = rhs.theString.value-&gt;data[rhs.charIndex]; <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br><br><span class="hljs-comment">// 将proxy对象作左值使用并赋给其一个char时</span><br>String::CharProxy&amp; String::CharProxy::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">char</span> c) <br>&#123; <br>    <span class="hljs-keyword">if</span> (theString.value-&gt;<span class="hljs-built_in">isShared</span>()) <br>    &#123; <br>        theString.value = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringValue</span>(theString.value-&gt;data); <br>    &#125; <br>    theString.value-&gt;data[charIndex] = c; <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125; <br><br><span class="hljs-comment">// 使用proxy将读或写的判断推迟到operator[]返回之后</span><br>String s1, s2; <span class="hljs-comment">// reference-counted strings </span><br>cout &lt;&lt; s1[<span class="hljs-number">5</span>];<br>s2[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;<br>s1[<span class="hljs-number">3</span>] = s2[<span class="hljs-number">8</span>]; <br></code></pre></td></tr></table></figure><p>除了以上提到的，要使proxy对象的行为和它们所扮演的对象一致，你必须重载可作用于实际对象的每一个函数。 例如取地址运算符。</p><p>编译器在调用函数而将参数转换为此函数所要的类型时，只调用一个用户自定义的转换函数（参见条款5），因此很可能在函数调用时，传实际对象是成功的而传proxy对象是失败的。</p><h2 id="让函数根据一个以上的对象来决定怎么虚拟">31让函数根据一个以上的对象来决定怎么虚拟</h2><p>虚函数体系只能作用在一个对象身上，C++没有提供<strong>作用在多个对象上</strong>的虚函数。</p><blockquote><p>这个问题被称为二重调度 （double dispatch），名字来自于object-oriented programming community， 在那里虚函数调用的术语是messagedispatch，而基两个参数的虚调用是通过doubledispatch实现的，推而广之，在多个参数上的虚函数叫multiple dispatch。</p></blockquote><p>以游戏中的碰撞处理为例，当两个GameObject的派生类的对象碰撞时，碰撞处理函数如何处理？</p><p>方法1：虚函数+手动RTTI（typeid）</p><p>增加新类型时需要更新if-else，难以维护。</p><p>方法2：虚函数+虚函数</p><p>增加新类型时需要，每个类都需要增加一个新的虚函数，都需要重新编译。（方法1不需要重新编译）</p><p>方法3：虚函数+手动虚函数表（构造一个类似vtbl的映射表以实现二重调度的第二部分）</p><p>也需要重新编译。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameObject</span> <br>&#123; <br><span class="hljs-keyword">public</span>: <br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">collide</span><span class="hljs-params">(GameObject&amp; otherObject)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;; <br><br><span class="hljs-comment">// SpaceStation、Asteroid亦继承自GameObject</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpaceShip</span>: <span class="hljs-keyword">public</span> GameObject <br>&#123; <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 成员函数指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(SpaceShip::*HitFunctionPtr)</span><span class="hljs-params">(GameObject&amp;)</span></span>; <br>    <span class="hljs-function"><span class="hljs-type">static</span> HitFunctionPtr <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> GameObject&amp; whatWeHit)</span></span>; <br>    <span class="hljs-keyword">typedef</span> map&lt;string, HitFunctionPtr&gt; HitMap;<br>     <span class="hljs-function"><span class="hljs-type">static</span> HitMap* <span class="hljs-title">initializeCollisionMap</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">collide</span><span class="hljs-params">(GameObject&amp; otherObject)</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">hitSpaceShip</span><span class="hljs-params">(SpaceShip&amp; otherObject)</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">hitSpaceStation</span><span class="hljs-params">(SpaceStation&amp; otherObject)</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">hitAsteroid</span><span class="hljs-params">(Asteroid&amp; otherobject)</span></span>; <br>&#125;; <br><br><span class="hljs-function">SpaceShip::HitFunctionPtr <span class="hljs-title">SpaceShip::lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> GameObject&amp; whatWeHit)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-comment">// 使用智能指针</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> auto_ptr&lt;HitMap&gt; <span class="hljs-title">collisionMap</span><span class="hljs-params">(initializeCollisionMap())</span></span>; <br>    HitMap::iterator mapEntry= collisionMap.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">typeid</span>(whatWeHit).<span class="hljs-built_in">name</span>()); <br>    <span class="hljs-keyword">if</span> (mapEntry == collisionMap.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">return</span> (*mapEntry).second;<br>    <span class="hljs-comment">// 不用习惯上的mapEntry-&gt;second的原因参见条款18</span><br>&#125; <br><br><span class="hljs-function">SpaceShip::HitMap* <span class="hljs-title">SpaceShip::initializeCollisionMap</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    HitMap *phm = <span class="hljs-keyword">new</span> HitMap; <br>    (*phm)[<span class="hljs-string">&quot;SpaceShip&quot;</span>] = &amp;hitSpaceShip; <br>    (*phm)[<span class="hljs-string">&quot;SpaceStation&quot;</span>] = &amp;hitSpaceStation; <br>    (*phm)[<span class="hljs-string">&quot;Asteroid&quot;</span>] = &amp;hitAsteroid; <br>    <span class="hljs-keyword">return</span> phm; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpaceShip::collide</span><span class="hljs-params">(GameObject&amp; otherObject)</span> </span><br><span class="hljs-function"></span>&#123; <br>    HitFunctionPtr hfp = <span class="hljs-built_in">lookup</span>(otherObject);<br>    <span class="hljs-keyword">if</span> (hfp)<br>    &#123;  <br>        (<span class="hljs-keyword">this</span>-&gt;*hfp)(otherObject); <br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123; <br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">CollisionWithUnknownObject</span>(otherObject); <br>    &#125; <br>&#125; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpaceShip::hitSpaceShip</span><span class="hljs-params">(GameObject&amp; spaceShip)</span> </span><br><span class="hljs-function"></span>&#123; <br>    SpaceShip&amp; theSpaceShip = <span class="hljs-built_in">dynamic_cast</span>&lt;SpaceShip&amp;&gt;(spaceShip); <br><span class="hljs-comment">// process a SpaceShip-SpaceShip collision; </span><br>&#125; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpaceShip::hitSpaceStation</span><span class="hljs-params">(GameObject&amp; spaceStation)</span> </span><br><span class="hljs-function"></span>&#123; <br>     spaceStation&amp; thespaceStation = <span class="hljs-built_in">dynamic_cast</span>&lt;SpaceStation&amp;&gt;(spaceStation); <br><span class="hljs-comment">// process a SpaceShip-SpaceStation collision; </span><br>&#125; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpaceShip::hitAsteroid</span><span class="hljs-params">(GameObject&amp; asteroid)</span> </span><br><span class="hljs-function"></span>&#123; <br>    Asteroid&amp; theAsteroid = <span class="hljs-keyword">dynamic_cast</span>&lt;Asteroid&amp;&gt;*(asteroid);<br><span class="hljs-comment">// process a SpaceShip-Asteroid collision; </span><br>&#125; <br></code></pre></td></tr></table></figure><p>方法4：使用非成员的碰撞处理函数</p><p>不需要重新编译。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SpaceShip.h&quot;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SpaceStation.h&quot;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Asteroid.h&quot;</span> </span><br><span class="hljs-comment">// 无名命名空间中的东西是当前编译单元（其实就是当前文件）私有的，和被申明为文件范围内static的函数一样。</span><br><span class="hljs-comment">// 有了命名空间后，文件范围内的static已经不赞成使用了，你应该尽快让自己习惯使用无名的命名空间（只要编译器支持）。</span><br><span class="hljs-keyword">namespace</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shipAsteroid</span><span class="hljs-params">(GameObject&amp; spaceShip, GameObject&amp; asteroid)</span></span>; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shipStation</span><span class="hljs-params">(GameObject&amp; spaceShip, GameObject&amp; spaceStation)</span></span>; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">asteroidStation</span><span class="hljs-params">(GameObject&amp; asteroid, GameObject&amp; spaceStation)</span></span>; <br>    <span class="hljs-comment">// 镜像函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">asteroidShip</span><span class="hljs-params">(GameObject&amp; asteroid, GameObject&amp; spaceShip)</span> </span>&#123; <span class="hljs-built_in">shipAsteroid</span>(spaceShip, asteroid); &#125; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stationShip</span><span class="hljs-params">(GameObject&amp; spaceStation, GameObject&amp; spaceShip)</span> </span>&#123; <span class="hljs-built_in">shipStation</span>(spaceShip, spaceStation); &#125; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stationAsteroid</span><span class="hljs-params">(GameObject&amp; spaceStation, GameObject&amp; asteroid)</span> </span>&#123; <span class="hljs-built_in">asteroidStation</span>(asteroid, spaceStation);&#125; <br>    <span class="hljs-comment">// 与方法三类似</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*HitFunctionPtr)</span><span class="hljs-params">(GameObject&amp;, GameObject&amp;)</span></span>; <br>    <span class="hljs-keyword">typedef</span> map&lt; pair&lt;string,string&gt;, HitFunctionPtr &gt; HitMap; <br>    <span class="hljs-function">pair&lt;string,string&gt; <span class="hljs-title">makeStringPair</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2)</span></span>;<br>    <span class="hljs-function">HitMap* <span class="hljs-title">initializeCollisionMap</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-function">HitFunctionPtr <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; class1, <span class="hljs-type">const</span> string&amp; class2)</span></span>; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processCollision</span><span class="hljs-params">(GameObject&amp; object1, GameObject&amp; object2)</span> </span><br><span class="hljs-function"></span>&#123; <br>    HitFunctionPtr phf = <span class="hljs-built_in">lookup</span>(<span class="hljs-built_in">typeid</span>(object1).<span class="hljs-built_in">name</span>(), <span class="hljs-built_in">typeid</span>(object2).<span class="hljs-built_in">name</span>()); <br>    <span class="hljs-keyword">if</span> (phf) <span class="hljs-built_in">phf</span>(object1, object2); <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-built_in">UnknownCollision</span>(object1, object2); <br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br>     <span class="hljs-function">pair&lt;string,string&gt; <span class="hljs-title">makeStringPair</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2)</span> </span><br><span class="hljs-function">     </span>&#123; <br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">pair</span>&lt;string,string&gt;(s1, s2); <br>     &#125; <br>&#125; <br><br><span class="hljs-keyword">namespace</span><br>&#123; <br>     <span class="hljs-function">HitMap* <span class="hljs-title">initializeCollisionMap</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">     </span>&#123; <br>         HitMap *phm = <span class="hljs-keyword">new</span> HitMap; <br>         (*phm)[<span class="hljs-built_in">makeStringPair</span>(<span class="hljs-string">&quot;SpaceShip&quot;</span>,<span class="hljs-string">&quot;Asteroid&quot;</span>)] = &amp;shipAsteroid; <br>         (*phm)[<span class="hljs-built_in">makeStringPair</span>(<span class="hljs-string">&quot;SpaceShip&quot;</span>, <span class="hljs-string">&quot;SpaceStation&quot;</span>)] = &amp;shipStation; <br>         <span class="hljs-keyword">return</span> phm; <br>     &#125; <br>&#125;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br>    <span class="hljs-function">HitFunctionPtr <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; class1, <span class="hljs-type">const</span> string&amp; class2)</span> </span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-function"><span class="hljs-type">static</span> auto_ptr&lt;HitMap&gt; <span class="hljs-title">collisionMap</span><span class="hljs-params">(initializeCollisionMap())</span></span>; <br>        HitMap::iterator mapEntry= collisionMap-&gt;<span class="hljs-built_in">find</span>(<span class="hljs-built_in">make_pair</span>(class1, class2)); <br>        <span class="hljs-keyword">if</span> (mapEntry == collisionMap-&gt;<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">return</span> (*mapEntry).second; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以将映射表HitMap放入一个类，并由它提供动态修改映射关系的成员函数。</p><h1 id="杂项">6 杂项</h1><h2 id="在未来时态下开发程序">32 在未来时态下开发程序</h2><p>用C++语言自己来表达设计上的约束条件，而不是用注释或文档。例如，如果一个类被设计得不会被继承，不要只是在其头文件中加个注释，用C++的方法来阻止继承。</p><p>提供完备的类，即使某些部分现在还没有被使用。如果有了新的需求，不用回过头去改它们。</p><p>如果没有限制你不能通用化你的代码，那么通用化它。例如，如果在写树的遍历算法，考虑将它通用得可以处理任何有向不循环图。</p><h2 id="将非尾端类设计为抽象类">33 将非尾端类设计为抽象类</h2><p>对于以下的OO体系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123; <br><span class="hljs-keyword">public</span>: <br>    Animal&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Animal&amp; rhs); <br>&#125;; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lizard</span>: <span class="hljs-keyword">public</span> Animal &#123; <br><span class="hljs-keyword">public</span>: <br>    Lizard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Lizard&amp; rhs); <br>&#125;; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chicken</span>: <span class="hljs-keyword">public</span> Animal &#123; <br><span class="hljs-keyword">public</span>: <br>    Chicken&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Chicken&amp; rhs); <br>&#125;; <br></code></pre></td></tr></table></figure><p>应该允许通过指针进行同类型赋值，而禁止通过同样的指针进行混合类型赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 允许</span><br>Animal *pAnimal1 = &amp;liz1;<br>Animal *pAnimal2 = &amp;liz2;<br>*pAnimal1 = *pAnimal2; <br><span class="hljs-comment">// 禁止</span><br>Animal *pAnimal1 = &amp;liz; <br>Animal *pAnimal2 = &amp;chick; <br>*pAnimal1 = *pAnimal2; <br></code></pre></td></tr></table></figure><p>在赋值函数内加入dynamic_cast成本高，且可能抛出异常。</p><p>在Animal中将operator=置为private，会同时禁止时Animal对象间的赋值。</p><p>最容易的实现方法是抽象出AbstractAnimal抽象类作为基类。</p><blockquote><p>实现纯虚函数一般不常见，但对纯虚析构函数，它不只是常见，它是必须。</p></blockquote><h2 id="如何在同一程序中混合使用c和c">34如何在同一程序中混合使用C++和C</h2><p>确保C++编译器和C编译器兼容，然后考虑4个问题：</p><ol type="1"><li><p>名变换</p><p>名变换，即C++编译器给程序的每个函数换一个独一无二的名字。因为C++有函数重载，C没有。</p><p>因此需要使用C++的<code>extern "C"</code>指示<strong>禁止名变换</strong>。</p><p>不要将<code>extern "C"</code>看作是申明这个函数是用C语言写的，应该看作是申明在个函数应该被当作好象C写的一样而进行调用。可以对FORTRAN、Pascal、汇编等其它语言使用<code>extern "C"</code>，也可以对C++本身使用<code>extern "C"</code>（当要用C++写一个库给使用其它语言的客户使用时，需要禁止名变换）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus </span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br>&#123; <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span></span>; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">twiddleBits</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> bits)</span></span>; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simulate</span><span class="hljs-params">(<span class="hljs-type">int</span> iterations)</span></span>; <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus </span><br>&#125; <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>不同编译器名变换方式不同，如果混合链接来自于不同编译器的obj文件，极可能得到<strong>链接错误</strong>，因为变换后的名字不匹配。</p></li><li><p>静态初始化</p><p>静态初始化：<strong>静态的</strong>类对象和<strong>定义在全局的、命名空间中的或文件体中的</strong>类对象的构造函数通常在main被执行前就被调用。</p><p>静态析构：在main结束后析构。</p><p>编译器main的最开始插入静态初始化函数，在main结束时插入静态析构函数。</p><p><strong>混编时应该用C++写main</strong>。将C写的main改名为realMain，然后用C++版本的main调用realMain。</p><p>如果不能用C++写main，处理起来就麻烦了。编译器生产商们几乎全都提供了一个额外的体系来启动静态初始化和静态析构的过程，请查阅编译器文档或联系生产商来知道如何实现。</p></li><li><p>动态内存分配</p><p>C++部分使用new和delete，C部分使用malloc和free。只要<strong>new分配的内存使用delete释放，malloc分配的内存用free释放</strong>，那么就没问题。</p></li><li><p>数据结构的兼容性</p><p>C++中的struct的规则兼容了C中的规则，可以安全传递。如果在C++版本中增加了<strong>非虚函数</strong>，其内存结构也没有改变。增加虚函数的结构和有基类的结构无法安全传递，内存结构不同。</p></li></ol><h2 id="让自己习惯使用标准c语言">35 让自己习惯使用标准C++语言</h2><p>此节描述了1996年C++的变化。</p><blockquote><p>STL是标准运行库的一部分。</p></blockquote><h1 id="附录">附录</h1><h2 id="objects-counting-in-c">Objects Counting in C++</h2><p>"Do It For Me" pattern（curiously recurring template pattern）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">public</span> Counter&lt;Widget&gt; <br>&#123; <br>    <span class="hljs-comment">// ...</span><br>&#125;; <br></code></pre></td></tr></table></figure><p>private继承更紧密，不会扩张对象大小，比复合更好。</p><p>使用operator new及对应的operator delete，避免内存泄漏。</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective C++》第三版笔记</title>
      <link href="//posts/Notebook/Effective-CPP-3th-note/"/>
      <url>//posts/Notebook/Effective-CPP-3th-note/</url>
      
        <content type="html"><![CDATA[<p>55 Specific Ways to Improve Your Programs and Designs</p><span id="more"></span><p>Scott Meyers 著</p><p>候捷 译</p><p class="note note-primary">摘录整理。</p><p><ahref="https://aristeia.com/BookErrata/ec++3e-errata.html">本书修订及更新网站</a></p><h1 id="让自己习惯c">1 让自己习惯C++</h1><h2 id="视c为一个语言联邦">1 视C++为一个语言联邦</h2><p>C++是多范式（multiparadigm）编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。</p><p>C++主要的4个<strong>次语言</strong>：C、Object-Oriented C++、TemplateC++、STL。</p><p>不同次语言的高效编程守则不相同。</p><h2 id="尽量以const-enum-inline替换-define">2 尽量以const, enum,inline替换 #define</h2><p>宁可以编译器替换预处理器。</p><p>使用#define定义的名称并未进入符号表，难以追踪，并且可能会导致目标码出现多份常量。</p><p><strong>class专属常量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NumTurns = <span class="hljs-number">5</span>; <span class="hljs-comment">// 常量声明式</span><br>    <span class="hljs-type">int</span> scores[NumTurns]; <span class="hljs-comment">// 使用该常量</span><br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> GamePlayer::NumTurns; <span class="hljs-comment">// 常量定义式（声明时获得初值，不可再设初值）</span><br></code></pre></td></tr></table></figure><p>通常C++要求对使用的任何东西提供定义式，如果它是<strong>static整数类型class专属常量</strong>（integraltype，例如int、char、bool），则需要特殊处理。只要不取地址，就可以声明并使用，无须提供定义式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// enum hack, 一种代替做法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123; NumTurns = <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> scores[NumTurns];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>以templateinline函数代替宏</strong>，可以避免很多潜在的问题。</p><h2 id="尽可能使用const">3 尽可能使用const</h2><p>const出现在星号<strong>左边</strong>，表示被指示物是常量；出现在星号<strong>右边</strong>，指示指针本身是常量。</p><p>声明STL迭代器为const就像声明<code>T* const</code>一样，表示迭代器本身是常量，不得指向不同的东西，但所指的东西的值可以改动。<code>const_iterator</code>则像<code>const T*</code>，表示迭代器指向的东西的值不可改动。</p><p>const可以重载。</p><p><strong>bitwise constness</strong>:成员函数只有在不更改对象之任何成员变量（static除外）时才可以说是const。<strong>编译器保证这种常量性</strong>，但是仍有漏洞，如返回一个引用可能导致内部成员在外部被更改。</p><p><strong>logical constness</strong>:一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才得以如此。使用<strong>mutable</strong>关键字可以释放掉non-static成员变量的bitwiseconstness约束。</p><p>如果要避免重复代码，可以用non-const版本调用const版本，只是要<strong>两次转型</strong>。不能用const版本调用non-const版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span><br>    &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> text[position];<br>    &#125;<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position)<br>    &#123;<br>        <span class="hljs-keyword">return</span><br>            <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;( <span class="hljs-comment">// 将op[]返回值的const转除</span><br>              <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock&amp;&gt;(*<span class="hljs-keyword">this</span>) <span class="hljs-comment">// 为*this加上const</span><br>                [position] <span class="hljs-comment">// 调用const op[]</span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="确实对象被使用前已先被初始化">4确实对象被使用前已先被初始化</h2><p>别混淆赋值（assignment）与初始化（initialization）。</p><p>C++规定对象的成员变量的初始化发生在进入构造函数本体之前。memberinitializationlist才是初始化。const和references必须初始化，不能赋值。</p><p>成员变量初始化顺序<strong>只与类中声明顺序有关</strong>，与memberinitialization list中出现次序无关。</p><p><strong>编译单元</strong>（translationunit）是指产出单一目标文件的那些源码。基本上它是单一源码文件加上其所含入的头文件。</p><p>在函数内的static对象称为localstatic对象，其他static对象称为non-static对象。</p><p><strong>C++对定义于不同编译单元内的non-localstatic对象的初始化顺序无明确定义。</strong>为了保证初始化顺序正确，应该以“函数调用”（返回一个reference指向localstatic对象）替换“直接访问non-local static对象”。</p><p>任何一种non-conststatic对象在多线程环境下“等待某事发生”都会有麻烦。处理这种麻烦的一种做法是：在程序的单线程启动阶段手工调用所有reference-returning，这可消除与初始化有关的“竞速形势（raceconditions）”。</p><h1 id="构造析构赋值运算">2 构造/析构/赋值运算</h1><h2 id="了解c默默编写并调用哪些函数">5了解C++默默编写并调用哪些函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 写下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123; &#125;;<br><span class="hljs-comment">// 就好像写下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Empty</span>() &#123; ... &#125;<br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-type">const</span> Empty&amp; rhs) &#123; ... &#125;<br>    ~<span class="hljs-built_in">Empty</span>() &#123; ... &#125;<br>    Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Empty&amp; rhs) &#123; ... &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="若不想使用编译器自动生成的函数就该明确拒绝">6若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>声明为private并不予实现，或继承一个uncopyable class。</p><blockquote><p>现代C++做法是=delete</p></blockquote><h2 id="为多态基类声明virtual析构函数">7为多态基类声明virtual析构函数</h2><p>并不是所有类的设计目的都是作为基类使用。为了具备多态性应该声明rtual析构函数；否则不应该。</p><blockquote><p>现代C++可以用final禁止继承</p></blockquote><h2 id="别让异常逃离析构函数">8 别让异常逃离析构函数</h2><p>如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，吞下它们或结束程序。</p><p>如果客户需要对某个操作函数运行期间抛出的异常做出反应，class应该提供一个普通函数（而非在析构函数中）执行该操作。</p><h2 id="绝不在构造和析构过程中调用virtual函数">9绝不在构造和析构过程中调用virtual函数</h2><p>在构造/析构期间，virtual函数不是virtual函数。</p><h2 id="令operator返回一个reference-to-this">10令operator=返回一个reference to *this</h2><p>这是一个被大家默认遵守的协议，便于<strong>连锁赋值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">x = y = z = <span class="hljs-number">15</span>;<br><span class="hljs-comment">// 赋值采用左结合律</span><br>x = (y = (z = <span class="hljs-number">15</span>));<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    Widget&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>    &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">int</span> rhs)<br>    &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在operator中处理自我赋值">11 在operator=中处理自我赋值</h2><p>在赋值前进行证同测试，避免自我赋值；在赋值完成前确保传入对象不被删除；copyand swap。</p><h2 id="复制对象时勿忘其每一个成分">12 复制对象时勿忘其每一个成分</h2><p>拷贝应确保复制对象内的所有成员和继承来的所有成员。</p><p>不要试图令拷贝构造函数和拷贝赋值操作符相互调用。</p><h1 id="资源管理">3 资源管理</h1><h2 id="以对象管理资源">13 以对象管理资源</h2><p>把资源放进对象内，依赖C++的析构函数自动调用机制确保资源被释放。</p><blockquote><p>C++11之前常被使用的RAII classes是tr1::shared_ptr和auto_ptr。</p></blockquote><h2 id="在资源管理类中小心copying行为">14在资源管理类中小心copying行为</h2><p>复制RAII对象必须一并复制它所管理的资源，资源的copying行为决定RAII对象的copying行为。常见的行为有：拒绝copying、引用计数。</p><h2 id="在资源管理类中提供对原始资源的访问">15在资源管理类中提供对原始资源的访问</h2><p>每一个RAII类都应该提供访问其管理的原始资源的方法。显式转换比较安全，隐式转换比较方便。</p><h2 id="成对使用new和delete时要采用相同的形式">16成对使用new和delete时要采用相同的形式</h2><p>即同时带[]或同时不带[]。</p><h2 id="以独立语句将newed对象置入智能指针">17以独立语句将newed对象置入智能指针</h2><blockquote><p>C/C++语言函数参数入栈顺序为从右至左。</p><p>参数计算顺序则与编译器有关，例如VS的计算顺序是从右至左，Clang的计算顺序是从左至右。</p><p>Java、C#总是以特定次序完成函数参数的计算。</p></blockquote><p>由于C++函数参数计算顺序<strong>不确定</strong>，不要在函数参数中用new出来的普通指针构造智能指针，否则有可能new出来的普通指针在放入智能指针之前就因为其它参数计算异常而丢失，造成资源泄露。</p><p>用独立语句做这件事。</p><h1 id="设计与声明">4 设计与声明</h1><h2 id="让接口容易被正确使用不易被误用">18让接口容易被正确使用，不易被误用</h2><p>利用类型系统限制函数参数，即为特定参数创建特定的类。</p><p>保持接口一致性。如C++ STL容器都有名为size的成员函数，Java则不然。</p><p>使用shared_ptr返回参数消除用户的资源管理责任。</p><p>shared_ptr支持定制删除器，可防范<strong>跨DLL问题</strong>。</p><blockquote><p>跨DLL问题指如果两个DLL（或者EXE调用DLL）的CRT链接不同（如一个是MT一个是MD），跨DLL的new/delete成对运用会导致运行期错误。</p><p>这个问题的根本原因是同一个内存地址在不同的CRT里面指向的地方是不一样的。</p><p>如果都是用的MD就没有问题，那就是用的同一个CRT。</p><p>利用虚函数的动态绑定技术可以解决这个问题，因为虚表里面已经指向了创建这个对象的模块里面的CRT的new和delete，那么当我们在DLL里面调用虚函数来释放的时候，系统会为我们找到构造对象时候的释放函数。</p></blockquote><h2 id="设计class犹如设计type">19 设计class犹如设计type</h2><p>新type的对象应该如何被创建和销毁?</p><p>对象的初始化和对象的赋值该有什么样的差别?</p><p>新type的对象如果被passed by value (以值传递)，意味什么?</p><p>什么是新type的“合法值" ?</p><p>你的新type需要配合某个继承图系(inheritance graph)吗?</p><p>你的新type需要什么样的转换?</p><p>什么样的操作符和函数对此新type而言是合理的?</p><p>什么样的标准函数应该驳回?</p><p>谁该取用新type的成员?</p><p>什么是新type的“未声明接口”( undeclared interface) ?</p><p>你的新type有多么一般化?</p><p>你真的需要- - -个新type吗?</p><h2 id="宁以pass-by-reference-to-const替换pass-by-value">20宁以pass-by-reference-to-const替换pass-by-value</h2><p>此替换高效且可避免传参切割问题。也有例外：</p><p>如果窥视C++编译器的底层，你会发现，<strong>references往往以指针实现出来</strong>。因此passby reference通常意味真正传递的是指针。</p><p>如果你有个对象属于内置类型(例如int)，pass by value往往比pass byreference的效率高些。对内置类型而言，当你有机会选择采用pass by value或pass by reference to const 时，选择pass by value并非没有道理。这个忠告也适用于STL的迭代器和函数对象，因为习惯上它们都被设计为passby value。</p><h2 id="必须返回对象时别妄想返回其reference">21必须返回对象时，别妄想返回其reference</h2><p>绝不要：</p><ul><li><p>返回pointer或reference指向一一个 local stack对象。返回前就已经销毁了。</p></li><li><p>返回reference指向一个heap-allocated对象。可能内存泄露。</p></li><li><p>返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。作比较时产生错误。</p></li></ul><h2 id="将成员变量声明为private">22 将成员变量声明为private</h2><p>将成员变量声明为private可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</p><p>protected 并不比public更具封装性。</p><h2 id="宁以non-membernon-friend-替换member函数">23宁以non-member、non-friend 替换member函数</h2><p>这样做可以增加封装性、包裹弹性(packagingflexibility)和机能扩充性。</p><h2 id="若所有参数皆需类型转换请为此采用non-member函数">24若所有参数皆需类型转换，请为此采用non-member函数</h2><p>比如重载+。</p><p>另外，可以避免friend函数就应该避免。</p><h2 id="考虑写出一个不抛异常的swap函数">25考虑写出一个不抛异常的swap函数</h2><blockquote><p>C++只允许对class template偏特化，function template不行。</p><p>客户可以全特化std内的templates，但不可以添加新的templates(或classes或functions或其他任何东西)到std里头。</p></blockquote><p>如果你提供一个member swap，也该提供一个non-memberswap用来调用前者。对 于classes (而非templates)，也请特化std: :swap。</p><blockquote><p>所有STL容器也都提供有publicswap)成员函数和std::swap特化版本(用以调用前者)。</p></blockquote><h1 id="实现">5 实现</h1><h2 id="尽可能延后变量定义式的出现时间">26尽可能延后变量定义式的出现时间</h2><p>避免初始化后再赋值，最好等待实参出现，直接构造。</p><h2 id="尽量少做转型动作">27 尽量少做转型动作</h2><p>通常应该避免做出“对象在C++中如何布局”的假设。</p><p>尽量避免转型、注重效率避免dynamic_cast、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型，少用旧式转型。</p><h2 id="避免返回handles指向对象内部成分">28避免返回handles指向对象内部成分</h2><p>这样可以避免悬空指针。</p><h2 id="为-异常安全而努力是值得的">29 为“ 异常安全”而努力是值得的</h2><p>带有异常安全性的函数满足两个条件：</p><ol type="1"><li>不泄露任何资源。（RAII解决）</li><li>不允许数据败坏。（copy and swap解决）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 改进前</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span>;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Mutex mutex;<br>    Image* bgImage;<br>    <span class="hljs-type">int</span> imageChanges;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMeun::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">lock</span>(&amp;mutex);<br>    <span class="hljs-keyword">delete</span> bgImage;<br>    ++imageChanges;<br>    bgImage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc);<br>    <span class="hljs-built_in">unlock</span>(&amp;mutex);<br>&#125;<br><span class="hljs-comment">// 改进后</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PMImpl</span> &#123;<br>    std::tr1::shared_ptr&lt;Image&gt; bgImage;<br>    <span class="hljs-type">int</span> imageChanges;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Mutex mutex;<br>    std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMeun::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>    <span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;mutex)</span></span>;<br>    std::<span class="hljs-function">tr1::shared_ptr&lt;PMImpl&gt; <span class="hljs-title">pNew</span><span class="hljs-params">(<span class="hljs-keyword">new</span> PMImpl(*pImpl))</span></span>;<br>    pNew-&gt;bgImage.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc));<br>    ++pNew-&gt;imageChanges;<br>    <span class="hljs-built_in">swap</span>(pImpl,pNew);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="透彻了解inlining的里里外外">30 透彻了解inlining的里里外外</h2><p>inlining可以免除函数调用成本，代价是更大的目标码和程序体积（导致额外的换页行为，降低高速缓存装置的命中率）。</p><p>inline只是一个<strong>申请</strong>，不是强制命令。定义于class内的函数隐式提出该申请。</p><p>编译器通常不对“通过函数指针而进行的调用”实施inlining（因为要取地址），这意味对inline函数的调用有可能被inlined也可能不被inlined，取决于该调用的实施方式。</p><p>inline函数的修改导致整个程序需要重新编译。</p><h2 id="将文件间的编译依存关系降至最低">31将文件间的编译依存关系降至最低</h2><p>C++并没有把“将接口从实现中分离”这事做得很好。C++坚持将class的实现细目置于class 定义式中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Date theBirthDate;<br>&#125;<br></code></pre></td></tr></table></figure><p>这导致<strong>编译依存关系</strong>，若date.h改变，每一个含入Personclass的文件就得重新编译。因为当定义一个Person对象时，编译器需要知道该分配多少空间。</p><blockquote><p>Java不存在这个问题是因为Java定义对象时编译器只是分配一个指针指向该对象。</p></blockquote><p>设计策略：</p><ol type="1"><li><p>如果使用object references 或objectpointers可以完成任务，就不要使用objects。你可以只靠一个类型声明式就定义出指向该类型的references和pointers；但如果定义某类型的objects，就需要用到该类型的定义式。</p></li><li><p>如果能够,尽量<strong>以class声明式替换class定义式</strong>。注意，当你声明一个函数而它用到某个class时，你并不需要该class 的定义;纵使函数以byvalue方式传递该类型的参数(或返回值)亦然。</p></li><li><p>为声明式和定义式提供不同的头文件。</p></li></ol><p>基于此构想的两个手段是Handle classes和Interface classes。</p><p>程序库头文件应该以“完全且仅有声明式”(full and declaration-onlyforms)的形式存在。这种做法不论是否涉及templates都适用。</p><h1 id="继承与面向对象程序设计">6 继承与面向对象程序设计</h1><h2 id="确定你的public继承塑模出is-a关系">32确定你的public继承塑模出is-a关系</h2><p>以C++进行面向对象编程，最重要的一个规则是: public inheritance(公开继承)意味"is-a" (是一种)的关系。</p><p>这个关系的含义：适用于base classes身上的每一件事情一定也适用于derivedclasses身上，因为每一个derived class对象也都是一个base class对象。</p><h2 id="避免遮掩继承而来的名称">33 避免遮掩继承而来的名称</h2><p>derived classes内的名称会遮掩baseclasses内的名称。在public继承下从来没有人希望如此。</p><p>为了让被遮掩的名称再见天日，可使用using 声明式或转交函数( forwardingfunctions)。</p><h2 id="区分接口继承和实现继承">34 区分接口继承和实现继承</h2><p><strong>可以为纯虚函数提供定义</strong>，调用它的唯一途径是调用时明确指出其class名称（<code>对象指针-&gt;类名::函数名</code>）。</p><h2 id="考虑virtual函数以外的其他选择">35考虑virtual函数以外的其他选择</h2><p>NVI（non-virtual interface）手法：令客户通过publicnon-virtual成员函数间接调用private virtual函数。</p><p>将virtual函数替换为<strong>函数指针/function模板类</strong>成员变量。</p><p>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。</p><h2 id="绝不重新定义继承而来的non-virtual函数">36绝不重新定义继承而来的non-virtual函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br>D x;<br>B* pB = &amp;x;<br>D* pD = &amp;x;<br>pB-&gt;<span class="hljs-built_in">mf</span>(); <span class="hljs-comment">// 调用B::mf</span><br>pD-&gt;<span class="hljs-built_in">mf</span>(); <span class="hljs-comment">// 调用D::mf</span><br><span class="hljs-comment">// 不合理的行为</span><br></code></pre></td></tr></table></figure><h2 id="绝不重新定义继承而来的缺省参数值">37绝不重新定义继承而来的缺省参数值</h2><p>virtual函数是<strong>动态绑定</strong>(dynamicallybound)，而缺省参数值是<strong>静态绑定</strong>(statically bound)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span> <span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 不合理的行为</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span> <span class="hljs-params">(ShapeColor color = Green)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br>Shape* pr = <span class="hljs-keyword">new</span> Rectangle;<br><br>pr-&gt;<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// 调用Rectangle::draw(Shape::Red)!诡异吧。</span><br><span class="hljs-comment">// 因为pr动态类型是Rectangle*，静态类型是Shape*。</span><br><span class="hljs-comment">// 调用哪个虚函数由动态类型决定，使用什么缺省参数值有静态类型决定。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span> <span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">请注意，以上这么写则当客户以对象调用此函数，一定要指定参数值。因为静态绑定下这个函数并不从其base继承缺省参数值。</span><br><span class="hljs-comment">但若以指针(或reference)调用此函数，可以不指定参数值，因为动态绑定下这个函数会从其base继承缺省参数值。</span><br><span class="hljs-comment">*/</span><br>&#125;;                                                                                                 <br></code></pre></td></tr></table></figure><h2 id="通过复合塑模出has-a或根据某物实现出">38通过复合塑模出has-a或"根据某物实现出"</h2><p>复合(composition)关系指某种类型的对象内含它种类型的对象。</p><p>如果两个classes之间并非is-a的关系，复合比继承更好。</p><h2 id="明智而审慎地使用private继承">39 明智而审慎地使用private继承</h2><p>以下情况采用private继承更好：</p><ul><li>出于条款18，隐藏父类的接口。</li><li>相比复合，需要重定义virtual函数或访问类成员。</li></ul><blockquote><p>C++官方要求空对象大小不为零，但派生类的基类成分除外，可以为0，称为EBO(emptybase optimization)。这例外也只对单继承有效，对多重继承无效。</p></blockquote><h2 id="明智而审慎地使用多重继承">40 明智而审慎地使用多重继承</h2><p>看到是否有个函数可取用之前，C++首先确认这个函数对此调用之言是最佳匹配。<strong>找出最佳匹配函数后才检验其可取用性。</strong></p><p>若多重继承中存在不同继承路径指向相同基类，缺省的做法是执行复制；当使用<strong>virtual继承</strong>时，基类成为virtual基类，只有一个。</p><p>virtual base的初始化责任是由继承体系中的<strong>最低层</strong>(mostderived) class负责：</p><ol type="1"><li>classes若派生自virtual bases而需要初始化，必须认知其virtualbases——不论那些bases距离多远。</li><li>当一个新的derived class加入继承体系中，它必须承担其virtual bases(不论直接或间接)的初始化责任。</li></ol><p>非必要不使用virtual继承，且<strong>不要放置数据</strong>（避免对其初始化和赋值带来的诡异的事）。（Java、.NET语言的Interfaces不允许含有任何数据）</p><p>多重继承的确有正当用途。其中一个情节涉及“public继承某个Interfaceclass”和“private继承某个协助实现的class"的两相组合。</p><h1 id="模板与泛型编程">7 模板与泛型编程</h1><h2 id="了解隐式接口和编译期多态">41 了解隐式接口和编译期多态</h2><p>classes 和templates都支持接口(interfaces)和多态(polymorphism)。</p><p>对classes而言接口是<strong>显式</strong>的(explicit)，以函数签名为中心。多态则是通过virtual函数发生于<strong>运行期</strong>。</p><p>对template参数而言，接口是<strong>隐式</strong>的(implicit)，奠基于有效表达式。多态则是通过template具现化和函数重载解析(functionoverloading resolution)发生于<strong>编译期</strong>。</p><h2 id="了解typename的双重意义">42 了解typename的双重意义</h2><p>意义一：声明template参数时，前缀关键字class和typename可互换。</p><p>意义二：C++有个规则可以解析(resolve)下述歧义状态:如果解析器在template中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你用<strong>前导typename</strong>告诉它是。所以<strong>缺省情况下嵌套从属名称不是类型</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span> <span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span></span><br><span class="hljs-function"></span>&#123;<br>    C::const_iterator* X;   <br>    <span class="hljs-comment">// 歧义</span><br>    <span class="hljs-comment">// 若C::const_iterator是类型，X是指针。</span><br>    <span class="hljs-comment">// 若C::const_iterator是静态成员变量，x是全局变量名称，则*代表相乘。</span><br>    <span class="hljs-comment">// 用typename告诉它是类型。前导typename当且仅当这种场合下使用。</span><br>    <span class="hljs-function"><span class="hljs-keyword">typename</span> C::const_iterator <span class="hljs-title">iter</span><span class="hljs-params">(container.begin())</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述规则有个<strong>例外</strong>。typename不可以出现在base classeslist内的嵌套从属类型名称之前，也不可在member initialization list(成员初值列)中作为base class修饰符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base&lt;T&gt;::Nested &#123; <span class="hljs-comment">// base class list中不允许&quot;typename&quot;。</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Derived</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>: Base&lt;T&gt;::Nested (x) //member initialization list中不允许<span class="hljs-string">&quot;typename&quot;</span>。</span><br><span class="hljs-function">    &#123;</span><br>    <span class="hljs-keyword">typename</span> Base&lt;T&gt;::Nested temp; <span class="hljs-comment">// 嵌套从属类型名称既不在base class list中也不在member initialization list中，作为一个base class修饰符需加上typename。</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="学习处理模板化基类内的名称">43 学习处理模板化基类内的名称</h2><p>C++知道<strong>模板化基类</strong>(templatized baseclasses)有可能被特化，而那个特化版本可能不提供和一般性template相同的接口。因此它往往拒绝在模板化基类内寻找继承而来的名称（拒绝调用）。</p><p>就某种意义而言，当我们从Object Oriented C++跨进Template C++（条款1）继承就不像以前那般畅行无阻了。</p><p>三种方法使继承函数有效：</p><ol type="1"><li>函数调用动作前加上<code>this-&gt;</code>。</li><li>使用using声明式让编译器进入baseclass作用域查找该名称。（条款33中用其查找被派生类遮掩的名称）</li><li>使用<code>::</code>显式声明被调用的函数位于baseclass内。（此举会关闭virtual绑定行为）</li></ol><h2 id="将与参数无关的代码抽离templates">44将与参数无关的代码抽离templates</h2><p>任何template代码都不该与某个造成膨胀的template参数产生相依关系。</p><p>因<strong>非类型模板参数</strong>(non-type template parameters)而造成的代码膨胀，解决办法是以函数参数或class成员变量替换template参数。</p><p>因<strong>类型参数</strong>(typeparameters)而造成的代码膨胀，解决办法是让带有完全相同二进制表述(binaryrepresentations)的具现类型(instantiationtypes)共享实现码。例1，许多平台上int和long二进制表述相同，某些连接器会合并完全相同的函数实现码。例2，许多平台上所有指针类型二进制描述相同，使用void*更好。</p><h2 id="运用成员函数模板接受所有兼容类型">45运用成员函数模板接受所有兼容类型</h2><p>模板和其派生模板的实例化类不是派生关系。</p><p>利用<strong>成员函数模板</strong>可以让函数接受所有<strong>兼容的类型</strong>，可以用于类的构造函数和赋值函数。</p><p>成员函数模板并不改变语言规则，在类内声明<strong>泛化</strong>拷贝构造函数并不会阻止编译器生成它们自己的拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_</span> ptr &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">shared_ptr</span>(shared_ptr <span class="hljs-type">const</span>&amp; r); <span class="hljs-comment">// copy构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt; </span><br><span class="hljs-function">    <span class="hljs-title">shared_ptr</span><span class="hljs-params">(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r)</span></span>; <span class="hljs-comment">// 泛化copy构造函数</span><br>    shared_ptr&amp; <span class="hljs-keyword">operator</span>=(shared_ptr <span class="hljs-type">const</span>&amp; r); <span class="hljs-comment">// copy assignment</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>&gt;<br>    shared_ptr&amp; <span class="hljs-keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r); <span class="hljs-comment">// 泛化copy assignment</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="需要类型转换时请为模板定义非成员函数">46需要类型转换时请为模板定义非成员函数</h2><p>为了让类型转换可能发生于所有实参身上，我们需要一个non-member函数（条款24）；<strong>对于模板</strong>，为了令这个函数被自动具现化，我们需要将它声明在class内部；而在class内部声明non-member函数的唯一办法就是令它成为一个friend。（与friend的传统用途“访问class 的non-public成分”毫不相干）</p><h2 id="请使用traits-classes表现类型信息">47 请使用traitsclasses表现类型信息</h2><p>traits是一个C++程序员共同遵守的协议。这个技术的要求之一是，它对<strong>内置(built-in)类型</strong>和<strong>用户自定义(user-defined)类型</strong>的表现必须一样好。traits必须能够施行于内置类型意味类型内的嵌套信息(nestinginformation)这种东西出局了，因为我们无法将信息嵌套于原始指针内。因此<strong>类型的traits信息必须位于类型自身之外</strong>。</p><p>（习惯上traits 总是被实现为structs，但它们却又往往被称为traitsclasses。）</p><p>标准技术是把它放进一个template及其一或多个特化版本中。这样的templates在标准程序库中有若干个。</p><p><strong>以迭代器为例</strong>。 六种迭代器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">input_iterator_tag</span> &#123; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">output_iterator_tag</span> &#123; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">forward_iterator_tag</span> : <span class="hljs-keyword">public</span> input_iterator_tag &#123; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bidirectional_iterator_tag</span> : <span class="hljs-keyword">public</span> forward_iterator_tag &#123; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">random_access_iterator_tag</span> : <span class="hljs-keyword">public</span> bidirectional_iterator_tag &#123; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">contiguous_iterator_tag</span> : <span class="hljs-keyword">public</span> random_access_iterator_tag &#123; &#125;; <span class="hljs-comment">// (since C++20)</span><br></code></pre></td></tr></table></figure><p>针对迭代器者的traits classes被命名为iterator_ traits:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iterator_traits</span>;<br></code></pre></td></tr></table></figure><p>对于用户自定义类型的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt; ... &gt; <span class="hljs-comment">// template参数略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">deque</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category;<br>    &#125;;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt; ... &gt; <span class="hljs-comment">// template参数略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> bidirectional_iterator_tag iterator_category;<br>    &#125;;<br>&#125;;<br><span class="hljs-comment">// 用来表现“IterT说它自己是什么”</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iterator</span> traits &#123;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> IterT::iterator_category iterator_category;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对内置类型（这里是指针）的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt; <span class="hljs-comment">// template偏特化</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iterator</span> traits&lt;IterT*&gt;<br>&#123;<br><span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="hljs-comment">// 针对内置指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>利用函数重载在<strong>编译期</strong>决议使用的函数：（若采用if...else语句和typeid运算符则是在<strong>运行期</strong>决议，且会导致编译问题，因为编译器必须确保所有源码都有效，纵使是不会执行起来的代码。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt; <span class="hljs-comment">// 用于random access迭代器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span> <span class="hljs-params">(IterT&amp; iter, DistT d, std::random_access_iterator_tag)</span></span><br><span class="hljs-function"></span>&#123;<br>    iter += d;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt; <span class="hljs-comment">// 用于bidirectional迭代器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span> <span class="hljs-params">(IterT&amp; iter, DistT d, std::bidirectional_iterator_tag)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(d &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">while</span> (d--) ++iter; &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">while</span> (d++) -- iter; &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt; <span class="hljs-comment">// 用于input迭代器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span> <span class="hljs-params">(IterT&amp; iter, DistT d, std::input_iterator_tag)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(d &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span> (<span class="hljs-string">&quot;Negative distance&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">while</span>(d--) ++iter;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span> <span class="hljs-params">(IterT&amp; iter, DistT d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">doAdvance</span>(<br>        iter, <br>        d,<br>        <span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="hljs-built_in">iterator_category</span>()<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="认识template元编程">48 认识template元编程</h2><p>Template metaprogramming (TMP，模板元编程)是编写template-basedC++程序并执行于<strong>编译期</strong>的过程。</p><p>TMP已被证明是个“图灵完全”(Turing-complete)机器，意思是它的威力大到足以计算任何事物。使用TMP你可以声明变量、执行循环、编写及调用函数....</p><p>例如条款47展示的TMP if..else条件句是藉由templates和其特化体表现出来。不过那毕竟是汇编语言层级的TMP。针对TMP而设计的程序库（例如Boost'sMPL，见条款55）提供更高层级的语法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// TMP的阶乘运算示范如何通过“递归模板具现化”(recursive template instantiation) 实现循环，以及如何在TMP中创建和使用变量</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt; <span class="hljs-comment">//一般情况: Factorial&lt;n&gt;的值是n乘以Factorial&lt;n-1&gt;的值。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br><span class="hljs-keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="hljs-number">-1</span>&gt;::value &#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-comment">// 特殊情况: Factoria1&lt;0&gt;的值是1</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br><span class="hljs-keyword">enum</span> &#123; value = <span class="hljs-number">1</span> &#125;;<br>&#125;<br><span class="hljs-comment">//使用Factorial&lt;n&gt;::value就可以得到n阶乘值。</span><br></code></pre></td></tr></table></figure><h1 id="定制new和delete">8 定制new和delete</h1><p>STL容器所使用的heap内存是由容器所拥有的分配器对象(allocator objects)管理，不是被new和delete直接管理。本章并不讨论STL分配器。</p><h2 id="了解new-handler的行为">49 了解new-handler的行为</h2><p>当operatornew抛出异常以反映一个未获满足的内存需求之前，它会先调用一个客户指定的错误处理函数，一个所谓的new-handler。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以下是当operator new 无法分配足够内存时，该被调用的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outOfMem</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to satisfy request for memory\n&quot;</span>;<br>    std::<span class="hljs-built_in">abort</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-built_in">set_new_handler</span>(outOfMem);<br>    <span class="hljs-type">int</span>* pBigDataArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100000000L</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>Nothrownew是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。</p><h2 id="了解new和delete的台理替换时机">50了解new和delete的台理替换时机</h2><p>怎么会有人想要替换编译器提供的operator new或operator delete？</p><ol type="1"><li><p>用来检测运用上的错误。</p><p>overruns（写入点在分配区块尾端之后）或underruns（写入点在分配区块起点之前）。</p><p>超额分配内存，以额外空间放置签名以供检查。</p></li><li><p>为了强化效能。</p></li><li><p>为了收集使用上的统计数据。</p></li></ol><h2 id="编写new和delete时需固守常规">51 编写new和delete时需固守常规</h2><p>C++裁定所有非附属(独立式)对象必须有非零大小（条款39）。</p><p>C++保证“删除null指针永远安全”，所以你必须兑现这项保证。</p><h2 id="写了placement-new也要写placement-delete">52 写了placementnew也要写placement delete</h2><p>当写一个placement operator new ,请确定也写出了对应的placementoperatordelete。如果没有这样做，程序可能会发生隐微而时断时续的内存泄漏。</p><p>当你声明placement new和placementdelete,请确定不要无意识（非故意）地遮掩了它们的正常版本（条款33）。</p><h1 id="杂项讨论">9 杂项讨论</h1><h2 id="不要轻忽编译器的警告">53 不要轻忽编译器的警告</h2><p>字面意义。</p><h2 id="让自己熟悉包括tr1在内的标准程序库">54让自己熟悉包括TR1在内的标准程序库</h2><p>TR1代表"Technical Report 1"，是C++11之前的过渡期产物。</p><h2 id="让自己熟悉boost">55 让自己熟悉Boost</h2><p>Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深具影响力的角色。</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语学习笔记</title>
      <link href="//posts/Notebook/Japanese-note/"/>
      <url>//posts/Notebook/Japanese-note/</url>
      
        <content type="html"><![CDATA[<p>个人总结</p><span id="more"></span><h1 id="引言">1 引言</h1><p>日语受多种文化影响，是世界上文字系统最为复杂的语言之一。我认为日语的复杂体现在以下几点：</p><ol type="1"><li><p>汉字、假名和罗马字共存。如例句：</p><p>このデパートは，いろいろなPRの方法を工夫している。</p><p>这家超市正在酝酿各种促销战略。</p></li><li><p>词汇来源广阔，如传入的汉字词、自创的汉字词（如“哲学”、“手续”等词，现代反传入中国）、由英法荷葡德意俄等国语言音译的词。</p></li><li><p>有男性用语与女性用语之分。</p></li><li><p>有敬语与普通语之分。</p></li><li><p>动词、形容词时态变化伴随的音变繁多。</p><p>汉语的音变较少，如“恶”字做名词时读作/è/，做动词时音变成/wù/。</p><p>汉语中“去”的否定是“不去”，前面加上不字就好，而日语中“行く”的否定是“行かない”，需要词尾音变。</p></li></ol><p>我认为日语对于中国人来说比对于其它外国人更简单，因为日语书写用的汉字和假名源于中国人的母语。</p><h1 id="读写">2 读写</h1><h2 id="打字">打字</h2><p>打字有两种主流输入法，微软拼音输入法和日本键盘输入法，感觉对于中国人而言前者更易学。</p><p>在windows下，alt+shift切换输入法语种。</p><p>切换到日语后，ctrl+caps切换平假名，alt+caps切换片假名，shift+caps切换字母数字。</p><p>输入罗马音拼写对应假名（清音（五十音），浊音，半浊音，拗音）。</p><p>部分假名有多种打字法：</p><p>し (si) (shi) (ci) ち (ti) (chi) つ(tu) (tsu)</p><p>ふ (hu) (fu) じ (ji) (zi)</p><p>为了区分，部分假名打字所用的罗马音与读音所用的罗马音并不相同：</p><p>ぢ读作ji打用di</p><p>づ读作zu打用du</p><p>促音：将促音后的第一个罗马字母打两遍。</p><p>拨音：打两个n。</p><p>片假名的长音：0旁的破折号。（至今没搞懂按破折号出来的那一堆横线里哪个才是长音）</p><p>小写假名：前面加一个x。</p><p>特殊拗音打字法：</p><p>ふぁ(fa)　ふぃ(fi)　ふぇ(fe)　ふぉ(fo)　ぢぃ(dyi)</p><p>にぃ(nyi)　みぃ(myi)　くぃ(qi)　ちぇ(cye)　ぎぃ(gyi)</p><p>ファ(fa)　フィ(fi)　フェ(fe)　フォ(fo)</p><p>ウィ(uxi)　ウェ(uxe)　ウォ(uxo)</p><p>ヴァ(va)　ヴィ(vi)　ヴェ(ve)　ヴォ(vo)</p><p>ティ(texi)　テュ(texyu)　ディ(dexi)　デュ(dexyu)</p><p>ツァ(tuxa)　ツェ(tuxe)</p><p>クァ(kuxa)　クィ(kuxi)　クォ(kuxo)</p><p>シェ(sixe)　ジェ(zixe)</p><p>チェ(che)</p><h2 id="手写">手写</h2><p>假名<strong>手写体</strong>与<strong>印刷体</strong>不同，体现在平假名，主要是<strong>き、さ、り</strong>这三个假名。</p><h2 id="标点符号">标点符号</h2><p>。句号</p><p>，、逗号。均对应中文输入时键盘上的“《，”键。注意，日语输入时键盘上的“|\”键对应的是“｜￥”而不是“|、”。横写时两者均可用，竖写时只用后者。日语书写中没有汉语逗号和顿号的区别。</p><p>・中黑点。对应中文输入时键盘上的“？、”。相当于汉语中连接名词时的顿号。</p><p>「」单引号。相当于汉语的引号。</p><p>『』双引号。相当于汉语的书名号。</p><p>（）括弧。相当于汉语的小括号。</p><p>？！正式文件中不使用，一般文章和个人通信使用。</p><p>：；列条目或特别形式的文章中使用，一般文章不使用。</p><h2 id="读音">读音</h2><p>日语汉字的读音中有将古代传来的汉语读音日语化了的“音読（音读）”，也有将固化的日语发音与汉字含义相结合后的“訓読（训读）”。有的汉字有十个以上读音。</p><p>日语<strong>声调</strong>：汉语将音的高低称为声调，依音节中的高低变化表示不同的意思。日语在一个音节内没有高低变化，通过音节之间的高低变化表示不同含义。发音分为高低，由此构成日语的声调。日语声调的主要功能为标识词和词的界线。</p><p>日语<strong>语调</strong>：句子的抑扬顿挫。</p><p>特殊情况：は作助词时读wa，へ作助词时读e，を在现代日语中只作助词使用，总是读作o。</p><h1 id="语法">3 语法</h1><h2 id="词性">词性</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-04-12-品词.webp"alt="品词" /><figcaption aria-hidden="true">品词</figcaption></figure><p>首先可分为<strong>独立词</strong>和<strong>附属词</strong>，独立词有明确的词汇含义，附属词只有语法功能，依附于前者才有意义。</p><p><strong>活用</strong>可简单理解为有词尾变化。只有动词、形容词、形容动词、助动词存在活用。活用中保持形态不变的部分叫做<strong>词干</strong>，而变化的部分叫做<strong>词尾</strong>。</p><p>有活用的独立词称为<strong>用言</strong>，可以当谓语，包括动词、形容词、形容动词。</p><p>没有活用且可以当主语的独立词成为<strong>体言</strong>，包括名词、代词、数词。数词又可分为基数词、序数词、助数词。</p><p>在用言之前，修饰用言的称为<strong>副词</strong>。</p><p>在体言之前，修饰体言的称为<strong>连体词</strong>。</p><p>在词与词、句与句之间起连接作用的称为<strong>接续词</strong>。</p><p>用于感叹、呼唤、答应的称为<strong>感叹词</strong>。</p><p><strong>助词</strong>和<strong>助动词</strong>都起一定的语法作用，后者主要接在用言后面。</p><h2 id="两套语法">两套语法</h2><p>日语有<strong>教育语法</strong>和<strong>学校语法</strong>两套语法，教育语法后出现，是普通语言学的角度提出的面向外国人的新语法系统。</p><table><thead><tr class="header"><th>教育语法</th><th>学校语法</th></tr></thead><tbody><tr class="odd"><td>一类动词</td><td>五段活用动词</td></tr><tr class="even"><td>二类动词</td><td>上一段活用动词，下一段活用动词</td></tr><tr class="odd"><td>三类动词</td><td>サ变动词，カ变动词</td></tr><tr class="even"><td>一类形容词</td><td>形容词</td></tr><tr class="odd"><td>二类形容词</td><td>形容动词</td></tr><tr class="even"><td>连词</td><td>接续词</td></tr><tr class="odd"><td>ます形</td><td>连用形+助动词“ます”</td></tr><tr class="even"><td>て形</td><td>连用形+接续助词“て”</td></tr><tr class="odd"><td>ない形</td><td>未然形+助动词“ない”</td></tr><tr class="even"><td>基本形</td><td>终止形，连体形</td></tr><tr class="odd"><td>た形</td><td>连用形+助动词“た”</td></tr><tr class="even"><td>命令形</td><td><strong>命令形</strong></td></tr><tr class="odd"><td>意志形</td><td>未然形+助动词“う／よう”</td></tr><tr class="even"><td>ば形</td><td>假定形+接续助词“ば”</td></tr><tr class="odd"><td>可能形式</td><td>可能动词，未然形+助动词“れる／られる”</td></tr><tr class="even"><td>被动形式</td><td>未然形+助动词“れる／られる”</td></tr><tr class="odd"><td>使役形式</td><td>未然形+助动词“せる／させる”</td></tr><tr class="even"><td>小句</td><td>节</td></tr><tr class="odd"><td>复句</td><td>复文</td></tr><tr class="even"><td>短语</td><td>句</td></tr></tbody></table><h2 id="动词分类">动词分类</h2><p>以ます形为准：</p><p>一类动词：去掉ます后的最后一个音位于い段的绝大多数动词。</p><p>二类动词：去掉ます后的最后一个音位于え段的动词以及位于い段的一小部分动词。</p><p>三类动词：来ます、します、~します</p><p>以基本形为准：</p><p>一类动词：以う段假名结尾</p><p>二类动词：以い段+る或者え段+る结尾。</p><p>三类动词：来る、する、~する。</p><p>记忆方法：</p><p>一类动词：以う、つ、ぬ、ぶ、む、く、ぐ、す作为词尾的<strong>所有</strong>动词；以る作为词尾，る前的假名在あ、お段的<strong>所有</strong>动词。</p><p>二类动词：以る作为词尾，る前的假名在い、え段的<strong>所有</strong>动词。</p><p>【例外】按以上规则应是二类动词但其实是一类动词的<strong>26</strong>个动词：</p><ol type="1"><li>帰（かえ）る（回来、回去）　</li><li>切（き）る（切）　</li><li>減（へ）る（减少）</li><li>要（い）る（需要）　　</li><li>知（し）る（知道、认识）</li><li>走（はし）る（跑、行驶）</li><li>入（はい）る（进入）</li><li>返（かえ）る（返还）</li><li>滑（すべ）る（滑）</li><li>参（まい）る（”来、去“的自谦语）</li><li>混（ま）じる（夹杂）</li><li>握（にぎ）る（握）</li><li>煎（い）る（煎、炒）　</li><li>練（ね）る（推敲）　</li><li>散（ち）る（凋谢）　　</li><li>照（て）る（照耀）　</li><li>蹴（け）る（踢）</li><li>焦（あせ）る（着急）</li><li>限（かぎ）る（限于）</li><li>湿（しめ）る（潮湿）</li><li>茂（しげ）る（茂盛）</li><li>遮（さえぎ）る（遮住）　</li><li>罵（ののし）る（骂）　</li><li>嘲（あざけ）る（嘲笑）　　</li><li>漲（みなぎ）る（充满）　</li><li>覆（くつがえ）る（被推翻）</li></ol><h2 id="动词活用">动词活用</h2><p>以《中日交流标准日本语》初级为准，一共<strong>12种</strong>活用，ます形、て形、ない形、基本形、た形、命令形、意志形、ば形、可能形式、被动形式、使役形式、使役被动形式。</p><p><strong>记忆方法</strong></p><p>表中以基本形（う段）为基础变形，更容易记忆（标日教材以ます形为基础变形，规则见表后）。</p><table><thead><tr class="header"><th></th><th>一类动词</th><th>二类动词</th><th>三类动词</th></tr></thead><tbody><tr class="odd"><td>ます形</td><td>う段→い段+ます</td><td>る→ます</td><td>来（く）る→来（き）ます<br>する→します</td></tr><tr class="even"><td>て形、た形</td><td>う、つ、る→って/た<br>ぬ、ぶ、む→んで/だ<br>く→いて/た<br>ぐ→いで/だ<br>す→して/た<br>（例外：行く→行って）</td><td>る→て/た</td><td>来（く）る→来（き）て/た<br>する→して/た</td></tr><tr class="odd"><td>ない形</td><td>う段→あ段+ない</td><td>る→ない</td><td>来（く）る→来（こ）ない<br>する→しない</td></tr><tr class="even"><td>命令形</td><td>う段→え段</td><td>る→ろ</td><td>来（く）る→来（こ）い<br>する→しろ</td></tr><tr class="odd"><td>意志形</td><td>う段→お段长音</td><td>る→よう</td><td>来（く）る→来（き）よう<br>する→しよう</td></tr><tr class="even"><td>ば形</td><td>う段→え段+ば</td><td>る→れば</td><td>来（く）る→来（く）れば<br>する→すれば</td></tr><tr class="odd"><td>可能形式</td><td>う段→え段+る</td><td>る→られる</td><td>来（く）る→来（こ）られる<br>する→できる</td></tr><tr class="even"><td>被动形式</td><td>う段→あ段+れる</td><td>る→られる</td><td>来（く）る→来（こ）られる<br>する→される</td></tr><tr class="odd"><td>使役形式</td><td>う段→あ段+せる</td><td>る→させる</td><td>来（く）る→来（こ）させる<br>する→させる</td></tr><tr class="even"><td>使役被动形式</td><td>う段→あ段+される</td><td>る→させられる</td><td>来（く）る→来（こ）させられる<br>する→させられる</td></tr></tbody></table><p><strong>て形</strong>（14课）：</p><p>一类动词：ます形去掉ます后加て，并做如下发音变化，き→いて，ぎ→いで，び、み、に→んで，ち、り、い→って，し→して。行きます属于例外，て形是行って。</p><p>二类动词：ます形去掉ます加て。</p><p>三类动词：ます形去掉ます加て。</p><p><strong>ない形</strong>（19课）：</p><p>一类动词：ます形去掉ます后最后一个音变成相应的あ段音，后加ない。如果最后音为い时，把い变成わ后加ない。</p><p>二类动词：ます形去掉ます加ない。</p><p>三类动词：来（き）ます→来（こ）ない、します→しない。</p><p><strong>基本形</strong>（20课）：</p><p>一类动词：基本形最后一个音为う段，ます形去掉ます最后一个音为い段。</p><p>二类动词：基本形为ます形去掉ます加る。</p><p>三类动词：来（き）ます→来（く）る、します→する。</p><p><strong>た形</strong>（21课）：</p><p>て形的て→た、で→だ。</p><p><strong>命令形</strong>（29课）：</p><p>一类动词：基本形最后一个音变成相应的え段上的音。</p><p>二类动词：基本形的る变成ろ。</p><p>三类动词：来（く）る→来（こ）い、する→しろ。</p><p><strong>意志形</strong>（30课）：</p><p>一类动词：基本形最后一个音变成相应的お段上的音的长音。</p><p>二类动词：基本形的る变成よう。</p><p>三类动词：来（く）る→来（こ）よう、する→しよう。</p><p><strong>ば形</strong>（37课）：</p><p>一类动词：基本形最后一个音变成相应的え段上的音，再加ば。</p><p>二类动词：基本形的る变成れば。</p><p>三类动词：来（く）る→来（く）れば、する→すれば。</p><p><strong>可能形式</strong>（38课）：</p><p>一类动词：基本形最后一个音变成相应的え段上的音，再加る。</p><p>二类动词：基本形的る变成られる。</p><p>三类动词：来（く）る→来（こ）られる、する→できる。</p><p><strong>被动形式</strong>（41课）：</p><p>一类动词：ない形的ない变成れる。</p><p>二类动词：ない形的ない变成られる。</p><p>三类动词：来（く）る→来（こ）られる、する→される。</p><p><strong>使役形式</strong>（43课）：</p><p>一类动词：ない形的ない变成せる。</p><p>二类动词：ない形的ない变成させる。</p><p>三类动词：来（く）る→来（こ）させる、する→させる。</p><p><strong>使役被动形式</strong>（43课）：</p><p>一类动词：ない形的ない变成される。</p><p>二类动词：ない形的ない变成させられる。</p><p>三类动词：来（く）る→来（こ）させられる、する→させられる。</p><p><strong>补充说明</strong></p><p>标日课本的12种活用，可以看作八形四态，四态即可能态、被动态、使役态、使役被动态。</p><p>还有一种<strong>禁止形</strong>，就是在基本形的基础上加上な。</p><p>还有一种<strong>自发态</strong>，自发态和被动态的形态是一模一样的，自发态表示某种自发的心情，有点中文里不由自主的感觉。自发态动词大多是和情感有关的动词。</p><p>基本形也称辞书形，对应学校语法里的终止形和连体形，它们形态都是一样的。</p><p>以“行く→行ける→行けます”为例，先变为可能形式再变为ます形，也就是说可以<strong>复合活用</strong>。</p><p>一段动词和来る的可能形式和被动形式是一样的，需要通过语境区分。</p><p><strong>标日变形结构</strong> <span class="math display">\[ます形\left\{\begin{matrix}て形,た形\\基本形\left\{\begin{matrix}意志形 \\命令形 \\ば形 \\可能形式 \\\end{matrix}\right.\\ない形\left\{\begin{matrix}被动形式 \\使役形式 \\使役被动形式 \\\end{matrix}\right.\\\end{matrix}\right.\]</span></p><h2 id="敬体形和简体形">敬体形和简体形</h2><p>はい→うん</p><p>いいえ→ううん</p><p><strong>动词</strong></p><table><thead><tr class="header"><th></th><th></th><th>敬体形</th><th>简体形</th></tr></thead><tbody><tr class="odd"><td>现在将来形式</td><td>肯定</td><td>買います</td><td>買う（基本形）</td></tr><tr class="even"><td></td><td>否定</td><td>買いません</td><td>買わない（ない形）</td></tr><tr class="odd"><td>过去形式</td><td>肯定</td><td>買いました</td><td>買った（た形）</td></tr><tr class="even"><td></td><td>否定</td><td>買いませんでした</td><td>買わなかった（なかった形）</td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th>敬体形</th><th>简体形</th></tr></thead><tbody><tr class="odd"><td>现在将来形式</td><td>肯定</td><td>あります</td><td>ある</td></tr><tr class="even"><td></td><td>否定</td><td>ありません</td><td>ない</td></tr><tr class="odd"><td>过去形式</td><td>肯定</td><td>ありました</td><td>あった</td></tr><tr class="even"><td></td><td>否定</td><td>ありませんでした</td><td>なかった</td></tr></tbody></table><table><thead><tr class="header"><th></th><th></th><th>敬体形</th><th>简体形</th></tr></thead><tbody><tr class="odd"><td>现在将来形式</td><td>肯定</td><td>います</td><td>いる</td></tr><tr class="even"><td></td><td>否定</td><td>いません</td><td>いない</td></tr><tr class="odd"><td>过去形式</td><td>肯定</td><td>いました</td><td>いた</td></tr><tr class="even"><td></td><td>否定</td><td>いませんでした</td><td>いなかった</td></tr></tbody></table><p><strong>一类形容词</strong></p><table><thead><tr class="header"><th></th><th></th><th>敬体形</th><th>简体形</th></tr></thead><tbody><tr class="odd"><td>现在将来形式</td><td>肯定</td><td>忙しいです</td><td>忙しい</td></tr><tr class="even"><td></td><td>否定</td><td>忙しくないです</td><td>忙しくない</td></tr><tr class="odd"><td>过去形式</td><td>肯定</td><td>忙しかったです</td><td>忙しかった</td></tr><tr class="even"><td></td><td>否定</td><td>忙しくなかったです</td><td>忙しくなかった</td></tr></tbody></table><p><strong>二类形容词</strong></p><table><thead><tr class="header"><th></th><th></th><th>敬体形</th><th>简体形</th></tr></thead><tbody><tr class="odd"><td>现在将来形式</td><td>肯定</td><td>簡単です</td><td>簡単だ</td></tr><tr class="even"><td></td><td>否定</td><td>簡単ではありません</td><td>簡単ではない</td></tr><tr class="odd"><td>过去形式</td><td>肯定</td><td>簡単でした</td><td>簡単だった</td></tr><tr class="even"><td></td><td>否定</td><td>簡単ではありませんでした</td><td>簡単ではなかった</td></tr></tbody></table><p><strong>名词</strong></p><table><thead><tr class="header"><th></th><th></th><th>敬体形</th><th>简体形</th></tr></thead><tbody><tr class="odd"><td>现在将来形式</td><td>肯定</td><td>晴れです</td><td>晴れだ</td></tr><tr class="even"><td></td><td>否定</td><td>晴れではありません</td><td>晴れではない</td></tr><tr class="odd"><td>过去形式</td><td>肯定</td><td>晴れでした</td><td>晴れだった</td></tr><tr class="even"><td></td><td>否定</td><td>晴れではありませんでした</td><td>晴れではなかった</td></tr></tbody></table><h2 id="自动词与他动词">自动词与他动词</h2><p>自动词后续ています时，如该自动词是表示<strong>动作</strong>的，表示<strong>正在进行</strong>；如该自动词是表示<strong>变化</strong>的，表示<strong>结果存续</strong>。</p><p><strong>在词形上有对应关系</strong>的自动词后续ています时均表示<strong>结果存续</strong>。</p><p>自动词て形+います和自动词た形都可以表示结果存续，但后者偏重表示变化的完成，前者偏重表示变化完成后形成的结果状态。</p><p>他动词后续ています一般表示现在进行，也有例外，如：森さんは車を持っています。</p><h2 id="时体态式">时体态式</h2><p>拿熟悉的英语举例：</p><p>时（tense）表示时间区别的动词形式。时分为现在时、过去时、将来时、过去将来时。</p><p>体（aspect）表示动作或过程在一定时间内处于何种状态的动词形式。体分为进行体和完成体。</p><p>态（voice）表示主语与谓语动词之间的主动或被动关系的动词形式。英语动词有两种语态：主动态（activevoice）和被动态(passive voice)。</p><p>式（mood）区别说话人以何种语气说话的动词形式。英语中有陈述式（IndicativeMood）、祈使式(Imperative Mood)、虚拟式(Subjunctive Mood)。</p><blockquote><p>上外张月祥教授著有《英语动词的时体态式》一书。</p></blockquote><p>关于传统的英语16种时态，<ahref="https://www.zhihu.com/people/shi-xiao-nan-64-50">楠木英语</a>回答如下：</p><blockquote><p>16种时态分法是18世纪模仿拉丁语的框架搭建起来的，并不符合英语的实际情况，况且英语语言学内部对时态的数量也不一致。有8种，12种，14种多种说法。</p><p>所以借用英国夸克等人的理论和国内章振邦的说法，应该是英语有两时tense，现在时和过去时，表示动作发生的时间。两体aspect，进行体和完成体，表示动作存在的状态。没有独立的将来时专有的动词形式。没有将来时，但是可以用多种词汇手段表示将来。</p></blockquote><h2 id="语气词">语气词</h2><p>语气词可以根据其独立性与否分为两大类：独立语气词和粘着语气词。</p><p>粘着语气词的存在是包括汉语、日语、越南语在内的大多数东方语言<strong>区别于</strong>英语、法语等西方语言的重要特征之一。</p><p>日语的粘着性语气词多数位于句末，粘附在形容词性句节上以强化句子的疑问、祈使、感叹等功能。常用的语气词包括表示疑问的～か、～かい、～かね、～かしら等，强调自己的主张、判断或表示命令、请求的～よ、～わよ等，表示佩服、惊讶、感叹、认可、遗憾等心情的～ね、～わ、～わね等，表示轻松、轻率、反对语气的さ等。</p><h2 id="细节">细节</h2><h3 id="が与は">が与は</h3><p>が与は的并存是日语的特点之一，其用法的细微区别是日语的难点之一。根据捷克斯洛伐克语言学家所提出的“功能性句展示成分（FunctionalSentencePerspective）”这一概念，由“が”参与构成的副词性句节所蕴涵的“交际性动力（CommunicativeDynamism）值”要高于由“は”参与构成的副词性句节。换言之，“が”参与构成的副词性句节所蕴涵的<strong>新的信息量</strong>比由“は”参与构成的副词性句节要多，这就是“は”所引导的副词性句节在日语中常常被省略的原因。</p><h3 id="たら">たら</h3><p>二类形容词和名词的过去否定形式<code>~ではなかった</code>后续たら时，要去掉其中的は变成<code>~でなかったら</code>。</p><h1 id="考级">4 考级</h1><p>认可度最高的日语等级考试是JLPT（Japanese Language ProficiencyTest），官网：<ahref="http://jlpt.jp/cn/guideline/testsections.html">JLPT</a></p><p>JLPT级别由高到低为N1~N5，考试时间亦由长到短。考试科目都是一样分3部分，每部分60分，总分180分。合格需要同时满足两个条件：每部分分数大于等于19分且总分大于等于合格分。不同级别合格分不一样，比如N2是90分。</p><blockquote><p>语言知识（文字、词汇、语法）、阅读、听力</p><p>げんごちしき（もじ・ごい・ぶんぽう）・どっかい・ちょうかい</p><p>言語知識（文字・語彙・文法）・読解・聴解</p><p>Language Knowledge(Vocabulary/Grammar)・Reading・Listening</p></blockquote><p>考试需要带身份证、准考证，文具带2B铅笔和橡皮擦就行了。答题卡在左下角写生日和姓名，试卷在封面写准考证号和姓名。（答案选项填涂区域为<strong>椭圆形</strong>，而不是中国高考的矩形）（姓名写中文就可）（准考证号写准考证上的，不用像考场标记的准考证号一样带中间的横杠）</p><p>以<strong>N2</strong>为例，考试流程如下：</p><ol type="1"><li>13:00前入场</li><li>13:15发答题卡（两张，需要自己撕开）</li><li>13:20发试卷</li><li>13:30 开始答题（语言知识、阅读）（共105分钟）</li><li>15:15 结束答题（可以上厕所）</li><li>15:25 开始答题（听力）</li><li>16:15 收卷（听力时间应该是50分钟，根据录音长短有波动）</li></ol><p>以<strong>N2</strong>为例，分数组成如下（题目数X分数）：</p><p>文字词汇一共6个题型，37分</p><ol type="1"><li>汉字读法 5X1</li><li>汉字书写 5X1</li><li>词语构成（接头接尾词） 7X1</li><li>前后关系（选词填空） 5X1</li><li>近义替换 5X1</li><li>用法 5X2</li></ol><p>语法一共3个题型，22分</p><ol start="7" type="1"><li>选择合适语法 12X1</li><li>排列组合句子 5X1</li><li>文章中的语法 5X1</li></ol><p>阅读一共5个题型，61分</p><ol start="10" type="1"><li>内容理解短篇 5X2</li><li>内容理解中篇 9X3</li><li>综合理解 2X3</li><li>论点理解长篇 3X4</li><li>信息检索 2X3</li></ol><p>听力一共5个题型，56分</p><ol type="1"><li>问题理解 5X2</li><li>重点理解 6X2</li><li>概要理解 5X2</li><li>即时应答 12X1</li><li>综合理解 3X4</li></ol><p>分数计算方法：</p><p>语言知识（文字、词汇、语法）÷59X60</p><p>阅读 ÷61X60</p><p>听力 ÷56X60</p><p>另外，JLPT采用<strong>尺度得点</strong>的计分方式，根据试题整体正确率、每个考生的整体正确率、全体考生的答题正误情况，以及连续做对的题的难度区间确定考生最终的标准分。所以自己估分不会太准。</p><h1 id="参考资料">参考资料</h1><p>中日交流标准日本语 / 人民教育出版社</p><p><a href="https://www.academia.edu/8092939/Japanese">Japanese ChongXin - Academia.edu</a></p><p><ahref="https://www.cpsenglish.com/question/4925">英语中的“时体态式”的理解</a></p><h1 id="附录">附录</h1><h2 id="五十音图">五十音图</h2><table><thead><tr class="header"><th></th><th>あ段</th><th>い段</th><th>う段</th><th>え段</th><th>お段</th></tr></thead><tbody><tr class="odd"><td>あ行</td><td>あ　ア a</td><td>い　イ i</td><td>う　ウ u</td><td>え　エ e</td><td>お　オ o</td></tr><tr class="even"><td>か行</td><td>か　カ ka</td><td>き　キ ki</td><td>く　ク ku</td><td>け　ケ ke</td><td>こ　コ ko</td></tr><tr class="odd"><td>さ行</td><td>さ　サ sa</td><td>し　シ shi</td><td>す　ス su</td><td>せ　セ se</td><td>そ　ソ so</td></tr><tr class="even"><td>た行</td><td>た　タ ta</td><td>ち　チ chi</td><td>つ　ツ tsu</td><td>て　テ te</td><td>と　ト to</td></tr><tr class="odd"><td>な行</td><td>な　ナ na</td><td>に　ニ ni</td><td>ぬ　ヌ nu</td><td>ね　ネ ne</td><td>の　ノ no</td></tr><tr class="even"><td>は行</td><td>は　ハ ha</td><td>ひ　ヒ hi</td><td>ふ　フ fu</td><td>へ　ヘ he</td><td>ほ　ホ ho</td></tr><tr class="odd"><td>ま行</td><td>ま　マ ma</td><td>み　ミ mi</td><td>む　ム mu</td><td>め　メ me</td><td>も　モ mo</td></tr><tr class="even"><td>や行</td><td>や　ヤ ya</td><td></td><td>ゆ　ユ yu</td><td></td><td>よ　ヨ yo</td></tr><tr class="odd"><td>ら行</td><td>ら　ラ ra</td><td>り　リ ri</td><td>る　ル ru</td><td>れ　レ re</td><td>ろ　ロ ro</td></tr><tr class="even"><td>わ行</td><td>わ　ワ wa</td><td></td><td></td><td></td><td>を　ヲ wo</td></tr><tr class="odd"><td></td><td>ん　ン n</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>此外，かさたは四行可变化为浊音が ga、ざ za、だ da、ば ba和半浊音ぱpa。</p><p>此外，い段的きしちにひみりぎじびぴ这十一个假名可以与やゆよ组成拗音。有两对拗音的罗马音相同，じ和ぢji，ず和づ zu。</p><p>同一个假名打字所用的罗马音可能有多个，或者与读音所用的罗马音并不相同，还有一些用来表示外来语的特殊拗音，见“必要常识-打字”部分。</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度探索C++对象模型》笔记</title>
      <link href="//posts/Notebook/Inside-the-CPP-Object-Model-note/"/>
      <url>//posts/Notebook/Inside-the-CPP-Object-Model-note/</url>
      
        <content type="html"><![CDATA[<p>Inside the C++ Object Model</p><span id="more"></span><p>Stanley B. Lippman 著</p><p>候捷 译</p><p class="note note-primary">摘录整理。</p><h1 id="前言">前言</h1><p>这本书是由一位编译器设计者针对中高级C++程序员所写的。</p><p>有两个概念可以解释C++对象模型：</p><ol type="1"><li><p>语言中直接支持面向对象程序设计的部分。</p></li><li><p>对于各种支持的<strong>底层实现机制</strong>。</p></li></ol><p>本书主要专注于第二个概念。</p><p>目前所有编译器对于virtualfunction的实现法都是使用各个class专属的virtualtable，大小固定，并且在程序执行前就构造好了。</p><h1 id="第0章-导读">第0章 导读</h1><p>对象模型是深层结构的知识，关系到“与语言无关、与平台无关、跨网络可执行”软件组件（softwarecomponent）的基础原理。也因此，了解C++对象模型，是学习目前软件组件三大规格（COM、CORBA、SOM）的技术基础。</p><p>如果你对COM有兴趣，我也要同时推荐你看另一本书：Essential COM，DonBox著，AddisonWesley公司1998年出版（《COM本质论》，侯捷译，碁峰1998）。</p><h1 id="第1章-关于对象">第1章 关于对象</h1><h2 id="c对象模式">1.1 C++对象模式</h2><p>在C++中，有两种class datamembers：<strong>static和nonstatic</strong>，以及三种class memberfunctions：<strong>static、nonstatic和virtual</strong>。</p><p>指向虚表的指针称为<strong>vptr</strong>，设定（setting）和重置（resetting）都由每一个class的 constructor、destructor和 copy assignment运算符自动完成。</p><p>每一个 class所关联的 type_info object（用以支持 runtime typeidentification，RTTI）也经由 virtual table被指出来，通常放在表格的第一个slot。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-04-23-CPPObjectModel.jpg"alt="C++对象模型" /><figcaption aria-hidden="true">C++对象模型</figcaption></figure><h2 id="关键词所带来的差异">1.2 关键词所带来的差异</h2><p>如果不是为了努力维护与C之间的兼容性，C++远可以比现在更简单些。</p><p>C struct在C++中的一个合理用途，是当你要传递“一个复杂的classobject的全部或部分”到某个C函数去时，struct声明可以将数据封装起来，并<strong>保证拥有与C兼容的空间布局</strong>。然而这项保证只在组合（composition）的情况下才存在。如果是“继承”而不是“组合”，编译器会决定是否应该有额外的datame mbers被安插到base structsubobject之中（再一次请你参考3.4节的讨论以及图3.2a和图3.2b）。</p><h2 id="对象的差异">1.3 对象的差异</h2><p>C++程序设计模型直接支持三种programmingparadigms（程序设计范式）：</p><ol type="1"><li>程序模型（procedural model）。就像 C一样，C++当然也支持它。</li><li>抽象数据类型模型（abstract data type model，ADT）。</li><li>面向对象模型（object-oriented model）。</li></ol><p>在OOparadigm之中，程序员需要处理一个未知实例，它的类型虽然有所界定，却有无穷可能。相反地，在ADTparadigm中，程序员处理的是一个拥有固定而单一类型的实例，它在编译时期就已经完全定义好了。</p><p>C++以下列方法支持<strong>多态</strong>：</p><ol type="1"><li>经由一组隐式的转化操作。例如把一个 derived class指针转化为一个指向其 public base type的指针。</li><li>经由 virtual function机制。</li><li>经由 dynamic_cast和 typeid运算符。</li></ol><p>一个class object的内存包括：</p><ul><li><p>其 nonstatic data members的总和大小。</p></li><li><p>加上任何由于alignment的需求而填补（padding）上去的空间（可能存在于members之间，也可能存在于集合体边界）。</p><blockquote><p>alignment就是将数值调整到某数的倍数。在32位计算机上，通常alignment为4bytes（32位），以使bus的“运输量”达到最高效率。</p></blockquote></li><li><p>加上为了支持virtual而由内部产生的任何额外负担（overhead）。</p></li></ul><p>“指针类型”会教导编译器如何<strong>解释</strong>某个特定地址中的内存内容及其大小。</p><p>一个pointer或一个reference之所以支持多态，是因为它们并不引发内存中任何“与类型有关的内存委托操作（type-dependentcommitment）”；会受到改变的，只有它们所指向的内存的“大小和内容解释方式”而已。</p><p>C++通过class的pointers和references来支持多态，这种程序设计风格就称为“面向对象”。</p><p>C++也支持具体的ADT程序风格，如今被称为object-based（OB）。例如Stringclass，一种非多态的数据类型。</p><blockquote><p>之前一直不解《C++Primer（第5版）》中推荐序2里“基于对象”和“面向对象”风格的区别，这里算是明白了。</p></blockquote><h1 id="第2章-构造函数语意学">第2章 构造函数语意学</h1><h2 id="default-constructor的构造操作">2.1 DefaultConstructor的构造操作</h2><p>被合成的defaultconstructor<strong>只满足编译器的需要</strong>，而不是程序的需要。因此除了base class subobjects 和 member clas s objects之外的nonstatic datamember（如整数、整数指针、整数数组等等）都不会被初始化。</p><p>编译器合成nontrivial default constructor的4种情况：</p><ol type="1"><li><p>“带有 Default Constructor”的 Member Class Object</p></li><li><p>“带有 Default Constructor”的 Base Class</p><p>调用顺序优先于1</p></li><li><p>“带有一个 Virtual Function”的 Class</p><p>两种情况：class声明（或继承）一个 virtualfunction。class派生自一个继承串链，其中有一个或更多的 virtual baseclasses。</p><p>产生vtbl和vptr</p></li><li><p>“带有一个 Virtual Base Class”的 Class</p><p>对于 class 所定义的每一个constructor，编译器会安插那些“允许每一个virtual baseclass的执行期存取操作”的代码。如果class没有声明任何constructors，编译器必须为它合成一个defaultconstructor。</p></li></ol><h2 id="copy-constructor的构造操作">2.2 Copy Constructor的构造操作</h2><p>拷贝构造函数可以是多参数形式，其第二参数及后继参数以一个默认值供应之。</p><p>一个class不展现出“bitwise copy semantics”时，编译器合成nontrivialcopy constructor的4种情况：</p><ol type="1"><li>当class内含一个member object 而后者的class声明有一个copyconstructor时。</li><li>当 class继承自一个 base class而后者存在一个 copyconstructor时（再次强调，不论是被显式声明或是被合成而得）。</li><li>当 class声明了一个或多个 virtual functions时。</li><li>当 class派生自一个继承串链，其中有一个或多个 virtual baseclasses时。</li></ol><h2 id="程序转化语意学">2.3 程序转化语意学</h2><p><strong>Named Return Value</strong>（NRV）优化以result参数取代namedreturnvalue。NRV优化由编译器完成，如下伪码所示。如果用了NRV优化，那就不必调用拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    X xx;<br>    <span class="hljs-comment">// ...处理xx</span><br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(X &amp;__result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// default constructor被调用</span><br>    <span class="hljs-comment">// C++伪码</span><br>    __result.X::<span class="hljs-built_in">X</span>();<br>    <span class="hljs-comment">// ...处理__result</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般而言，面对“以一个class object作为另一个classobject的初值”的情形，语言允许编译器有大量的自由发挥空间。其利益当然是导致机器码产生时有明显的效率提升。缺点则是你不能够安全地规划你的copyconstructor 的<strong>副作用</strong>，必须视其执行而定。</p><p>如果class声明一个或一个以上的virtual functions，或内含一个virtualbaseclass，不能在构造函数中使用<code>memcpy()</code>或<code>memset()</code>，否则会导致那些“被编译器产生的内部members”的初值被改写（如vptr）。</p><h2 id="成员们的初始化队伍">2.4 成员们的初始化队伍</h2><p>在下列情况下，为了让你的程序能够被顺利编译，你必须使用memberinitialization list：</p><ol type="1"><li>当初始化一个 reference member时；</li><li>当初始化一个 const member时；</li><li>当调用一个 base class的 constructor，而它拥有一组参数时；</li><li>当调用一个 member class的 constructor，而它拥有一组参数时。</li></ol><p>编译器会一一操作initializationlist，以<strong>适当顺序</strong>在constructor之内安插初始化操作，并且在任何explicitusercode之前。（list中的项目顺序<strong>是由class中的members声明顺序决定的</strong>，不是由initializationlist中的排列顺序决定的。）</p><h1 id="第3章-data语意学">第3章 Data语意学</h1><p>C++Standard并不强制规定如“base classsubobjects的排列顺序”或“不同存取层级的datamembers的排列顺序”这种琐碎细节。它也不规定virtual functions或virtualbase classes的实现细节。C++Standard只说：那些细节由各家厂商自定。</p><p>class object的大小可能比想象的大，因为：</p><ol type="1"><li>由编译器自动加上的额外 data members，用以支持某些语言特性（主要是各种 virtual特性）。</li><li>因为 alignment（边界调整）的需要。</li></ol><h2 id="data-member的绑定">3.1 Data Member的绑定</h2><p>无。讲了一点原来C++编译器在数据绑定上的缺陷。</p><h2 id="data-member的布局">3.2 Data Member的布局</h2><p>C++Standard要求，在同一个accesssection（也就是private、public、protected等区段）中，members的排列只需符合“较晚出现的members在classobject 中有较高的地址”这一条件即可。</p><h2 id="data-member的存取">3.3 Data Member的存取</h2><p><strong>static member</strong>并不内含在一个classobject之中，对其存取效率不受对象影响。</p><p>欲对一个<strong>nonstatic datamember</strong>进行存取操作，编译器需要把class object的起始地址加上datamember的偏移位置（offset）。</p><p>当类是派生类并且继承结构中有虚基类，存取从虚基类继承而来的member时，用指针要慢于用对象本身。</p><h2 id="继承与data-member">3.4 “继承”与Data Member</h2><p><strong>只要继承不要多态</strong></p><p>在没有虚函数的继承中，继承关系可能会导致空间膨胀，因为每个类有自己的padding。</p><p><strong>加上多态</strong></p><p>引入空间和存取时间上的额外负担，vtbl和vptr。</p><blockquote><p>目前在 C++编译器那个领域里有一个主要的讨论题目：把 vptr 放置在 classobject的哪里会最好？</p></blockquote><p><strong>多重继承</strong></p><p>多重继承体系中子类的数据布局并没有被C++ Standard要求。</p><p><strong>虚拟继承</strong></p><p>虚拟继承体系中，子类只有共有父类的一个对象。</p><blockquote><p>Class 如果内含一个或多个 virtual base classsubobjects，像istream那样，将被分割为两部分：一个不变区域和一个共享区域。不变区域中的数据，不管后继如何衍化，总是拥有固定的offset（从object的开头算起），所以这一部分数据可以被直接存取。至于共享区域，所表现的就是virtualbase classsubobject。这一部分的数据，其位置会因为每次的派生操作而有变化，所以它们只可以被间接存取。各家编译器实现技术之间的差异就在于<strong>间接存取的方法不同</strong>。</p></blockquote><h2 id="对象成员的效率">3.5 对象成员的效率</h2><p>用实验测试效率。</p><h2 id="指向data-members的指针">3.6 指向Data Members的指针</h2><p>对应C++Primer 19.4 类数据成员指针的底层解释。</p><h1 id="第4章-function语意学">第4章 Function语意学</h1><h2 id="member的各种调用方式">4.1 Member的各种调用方式</h2><p><strong>非静态成员函数</strong></p><p>C++的设计准则之一就是：nonstatic member function至少必须和一般的nonmemberfunction有相同的效率。前者也是通过隐藏的this指针访问对象成员，所以实际效率应该是一样的。</p><blockquote><p>C++编译器对namemangling的做法目前还没有统一，但我们知道它迟早会统一。</p></blockquote><p><strong>虚拟成员函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">ptr-&gt;<span class="hljs-built_in">normalize</span>();<br><span class="hljs-comment">// 调用虚函数，（可能）发生以下转化：</span><br>(*ptr-&gt;vptr[<span class="hljs-number">1</span>])(ptr);<br></code></pre></td></tr></table></figure><p><strong>静态成员函数</strong></p><p>静态成员函数没有this指针，因此其：</p><ul><li>它不能够直接存取其 class中的 nonstatic members。</li><li>它不能够被声明为 const、volatile或 virtual。</li><li>它不需要（但可以）经由 class object 才被调用。</li></ul><h2 id="virtual-member-functions">4.2 Virtual Member Functions</h2><p>作者探讨了虚函数调用的实现细节。</p><p>在C++中，<strong>多态</strong>（polymorphism）表示“以一个public baseclass 的指针（或reference），寻址出一个derived class object”的意思。</p><p><strong>thunk</strong>只有以assembly代码完成才有效率可言。由于cfront使用C作为其程序代码产生语言，所以无法提供一个有效率的thunk编译器。</p><blockquote><p>我的建议是，不要在一个 virtual base class 中声明 nonstatic datamembers。如果这么做，你会距离复杂的深渊愈来愈近，终不可拔。</p></blockquote><h2 id="函数的效能">4.3 函数的效能</h2><p>测试了不同情况下函数调用的效率。</p><h2 id="指向member-function的指针pointer-to-member-functions">4.4指向Member Function的指针Pointer-to-Member Functions</h2><p>对应C++Primer 19.4 类函数成员指针的底层解释。</p><h2 id="inline-functions">4.5 Inline Functions</h2><p>处理一个inline函数有两个阶段：</p><ol type="1"><li>分析函数定义，以决定函数的“intrinsic inline ability”（本质的inline能力）。“intrinsic”（本质的、固有的）一词在这里意指“与编译器相关”。</li><li>真正的inline函数扩展操作是在调用的那一点上。这会带来参数的求值操作（evaluation）以及临时性对象的管理。</li></ol><h1 id="第5章-构造析构拷贝语意学">第5章 构造、析构、拷贝语意学</h1><h2 id="无继承情况下的对象构造">5.1 “无继承”情况下的对象构造</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">float</span> x,y,z;<br>&#125;Point;<br></code></pre></td></tr></table></figure><p>观念上，编译器会为Point声明一个 trivial defaultconstructor、一个trivial destructor、一个 trivial copyconstructor，以及一个trivial copy assignmentoperator。但<strong>实际上，编译器会分析这个声明，并为它贴上PlainOl'Data标签</strong>。</p><h2 id="继承体系下的对象构造">5.2 继承体系下的对象构造</h2><p>Constructors的调用顺序是：由根源而末端（bottom up）、由内而外（insideout）。</p><p>在构造函数中调用虚函数无法正确实现多态。</p><h2 id="对象复制语意学">5.3 对象复制语意学</h2><p>一个class对于默认的copy assignmentoperator，在以下情况，不会表现出<strong>bitwise copy语意</strong>：</p><ol type="1"><li>当class内含一个member object，而其class有一个copy assignmentoperator时。</li><li>当一个class的 base class有一个 copy assignment operator时。</li><li>当一个class声明了任何 virtual functions （我们一定不要拷贝右端 classobject的 vptr地址，因为它可能是一个 derived class object）时。</li><li>当 class 继承自一个 virtual base class （不论此 base clas s 有没有copy operator）时。</li></ol><p>（和2.2节所述相同）</p><p>copy assignmentoperator在虚拟继承情况下行为不佳，需要小心地设计和说明。许多编译器甚至并不尝试取得正确的语意，它们在每一个中间（调停用）的copyassignment operator中调用每一个base class instance，于是造成virtual baseclass copy assignment operator 的多个实例被调用。</p><blockquote><p>我建议尽可能不要允许一个virtual base class的拷贝操作。我甚至提供一个比较奇怪的建议：不要在任何virtual baseclass中声明数据。</p></blockquote><h2 id="对象的效能">5.4 对象的效能</h2><p>测试了不同情况下对象拷贝的效率。</p><h2 id="析构语意学">5.5 析构语意学</h2><p>如果class没有定义destructor，那么只有在class内含的member object（抑或class自己的baseclass）拥有destructor的情况下，编译器才会自动合成出一个来。否则，destructor被视为不需要，也就不需被合成（当然更不需要被调用）。</p><h1 id="第6章-执行期语意学">第6章 执行期语意学</h1><h2 id="对象的构造和析构">6.1 对象的构造和析构</h2><p><strong>全局对象</strong></p><p>C++程序中所有的global objects都被放置在程序的datasegment中。如果显式指定给它一个值，此object将以该值为初值。否则object所配置到的内存内容为0（C并不自动设定初值）。</p><blockquote><p>我建议你根本就不要用那些需要静态初始化的globalobjects（虽然这项建议几乎普遍地不为C程序员所接受）。</p></blockquote><p><strong>局部静态对象</strong></p><p>局部静态对象被要求在所在函数调用时才被构造。</p><p><strong>对象数组</strong></p><h2 id="new和delete运算符">6.2 new和delete运算符</h2><p>new运算符实际上总是以标准的Cmalloc（）完成，虽然并没有规定一定得这么做不可。相同情况，delete运算符也总是以标准的Cfree（）完成。</p><p>有一个预先定义好的重载的（overloaded）new运算符，称为placementoperator new。它需要第二个参数，类型为void*。（即C++ Primer12.1.2提到的<strong>定位new</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// arena指向内存中的一个区块，用以放置新产生出来的Point2w object。</span><br>Point2s *ptw = <span class="hljs-built_in">new</span> (arena) Point2w;<br><span class="hljs-comment">// 实际操作，看起来很多余，但定位new的真正威力是将构造函数自动实施于arena所指的地址上</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, <span class="hljs-type">void</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">//C++Standard说arena必须指向相同类型的class，要不就是一块“新鲜”内存，足够容纳该类型的object。并未定义多态行为。</span><br></code></pre></td></tr></table></figure><h2 id="临时性对象">6.3 临时性对象</h2><p>copy constructor、destructor以及copy assignmentoperator都可以由使用者供应，所以不能够保证上述两个操作会导致相同的语意。因此以一连串的destruction和copy construction来取代assignment一般而言是不安全的，而且会产生临时对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 不会产生临时对象</span><br>T c = a + b;<br><span class="hljs-comment">// 会产生临时对象</span><br>c = a + b;<br>a + b;<br></code></pre></td></tr></table></figure><p><code>malloc(0)</code>在不同C标准库实现上表现不同，有的会得到分配了<code>MINSIZE</code>内存的指针，有的会返回空指针：<ahref="https://zhuanlan.zhihu.com/p/40490357">当你 malloc(0)时会发生什么</a></p><p>作者最后探讨了临时性对象的生命周期。</p><blockquote><p>本章最后的注解里提到了定位delete（与定位new对应）</p></blockquote><h1 id="第7章-站在对象模型的尖端">第7章 站在对象模型的尖端</h1><p>❓书中用方括号括起来的参考文献在哪里找？例如P279页“我的讨论，是以[CHASE94]、[LAJOIE94a]、[LAJOIE94b]、[LENKOV92]以及[SUN94a]为基础的。”</p><h2 id="template">7.1 Template</h2><p>有关template的三个主要讨论方向：</p><p>1.template的声明。基本来说就是当你声明一个template class、templateclass member function等等时，会发生什么事情。</p><p>2.如何“实例化（instantiates）”class object、inlinenonmember以及member templatefunctions。这些是“每一个编译单位都会拥有一份实例”的东西。</p><p>3.如何“实例化（instantiates）”nonmember、member templatefunctions以及 static template classmembers。这些都是“每一个可执行文件中只需要一份实例”的东西。这也就是一般而言template所带来的问题。</p><p>目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，<strong>只能施行以有限的错误检查</strong>。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让它通过了，只有在特定实例被定义之后，才会发出抱怨。这是目前实现技术上的一个大问题。</p><p><strong>Template中的名称决议法</strong>（Resolution）</p><p>两个划分：scope of the template <strong>definition</strong> / scopeof the template <strong>instantiation</strong></p><p>Template之中，对于一个nonmember name的决议结果，是根据这个name的使用是否与“用以实例化该template的参数类型”有关而决定的。</p><ul><li>如果其使用互不相关，那么就以“scope of the templatedeclaration”来决定name。</li><li>如果其使用互有关联，那么就以“scope of the templateinstantiation”来决定name。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// scope of the template definition </span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeRules</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invariant</span><span class="hljs-params">()</span> </span>&#123;<br>        _member = <span class="hljs-built_in">foo</span>(_val);<br>    &#125;<br>    <span class="hljs-function">type <span class="hljs-title">type_dependent</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">foo</span>(_member);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _val;<br>    type _member;<br>&#125;<br><span class="hljs-comment">// scope of the template instantiation</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><br>ScopeRules&lt;<span class="hljs-type">int</span>&gt; sr0;<br><span class="hljs-comment">// 调用extern double foo(double);</span><br>sr0.<span class="hljs-built_in">invariant</span>();<br><span class="hljs-comment">// 调用extern int foo(int);</span><br>sr0.<span class="hljs-built_in">type_dependent</span>();<br></code></pre></td></tr></table></figure><p><strong>Member Function的实例化行为</strong></p><p>作者探讨了成员函数的实例化行为，如何保证只产生一个vtbl实例。</p><h2 id="异常处理">7.2 异常处理</h2><p>当一个exception被抛出去时，控制权会从函数调用中被释放出来，并寻找一个吻合的catch子句。如果都没有吻合者，那么默认的处理例程terminate（）会被调用。当控制权被放弃后，堆栈中的每一个函数调用也就被<strong>推离</strong>（poppedup）。这个程序称为unwinding thestack。在每一个函数被推离堆栈之前，函数的local classobjects的destructor会被调用。</p><p>与其他语言特性进行比较，<strong>C++编译器支持EH机制所付出的代价最大</strong>。某种程度上是由于其执行期的天性以及对底层硬件的依赖，以及UNIX和PC两种平台对于执行速度和程序大小有着不同的取舍优先状态之故。</p><h2 id="执行期类型识别">7.3 执行期类型识别</h2><p>（Runtime Type Identification，RTTI）</p><p>❓开头没有看懂，String类引入operator char*() const重载operatorchar*() ，为什么会导致示例类向下转换错误？</p><p><strong>dynamic_cast</strong>运算符可以在执行期决定真正的类型。</p><p>对于指针，如果downcast是安全的（也就是说，如果base typepointer指向一个derived classobject），这个运算符会传回被适当转换过的指针；如果downcast不是安全的，这个运算符会传回0。</p><p>对于引用，如果 reference真正参考到适当的 derivedclass（包括下一层或下下一层，或下下下一层或……），downcast会被执行而程序可以继续进行；如果reference并不真正是某一种 derived class，那么，由于不能够传回0，因此抛出一个 bad_cast exception。</p><p><strong>Typeid运算符</strong></p><p>typeid运算符传回一个const reference，类型为type_info。</p><p>type_infoobjects 也适用于内建类型，以及非多态的使用者自定类型。</p><h2 id="效率有了弹性呢">7.4 效率有了，弹性呢？</h2><p><strong>动态共享函数库</strong></p><p>class的大小及其每一个直接（或继承而来）的members的偏移位置（offset）都<strong>在编译时期就已经固定</strong>（虚拟继承的members除外）。这虽然带来了效率，却在二进制层面（binarylevel）阻碍了弹性。如果 object 布局改变，应用程序就必须重新编译。</p><p><strong>共享内存</strong></p><p>每一个virtual function在virtualtable中的位置已经被写死了。目前的解决方法属于程序层面，程序员必须保证让跨越进程的sharedlibraries有相同的坐落地址（在SGI中，使用者可以根据所谓的so-location文件，指定每一个sharedlibrary的精确位置）。</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式与架构</title>
      <link href="//posts/Article/software-design-patterns-and-architecture/"/>
      <url>//posts/Article/software-design-patterns-and-architecture/</url>
      
        <content type="html"><![CDATA[<p>学习总结</p><span id="more"></span><h1 id="设计模式">1 设计模式</h1><h2 id="概述">1.1 概述</h2><p><strong>23种</strong>设计模式：</p><p><strong>创建型</strong></p><p>Prototype:用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</p><p>Factory Method:定义一个用于创建对象的接口，让子类决定将哪一个类实例化。其使一个类的实例化延迟到其子类。</p><p>Abstract Factory:提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。</p><p>Builder:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>Singleton: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>结构型</strong></p><p>Adapter:将一个类的接口转换成客户希望的另一个接口。其使得原本接口不兼容的类一起工作。</p><p>Bridge: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><p>Composite:将对象组合成树形结构以表示“部分-整体”的层次结构。使客户对单个对象和复合对象的使用具有一致性。</p><p>Decorator:动态地给一个对象添加一些额外的职责。就扩展功能而言，其比生成子类方式更为灵活。</p><p>Facade:为子系统中的一组接口提供一个一致的界面，其定义了一个高层接口，使得这一子系统更加容易使用。</p><p>Flyweight: 运用共享技术有效地支持大量细粒度的对象。</p><p>Proxy: 为其他对象提供一个代理以控制对这个对象的访问。</p><p><strong>行为型</strong></p><p>Chain of Responsibility:为解除请求的发送者和接收者之间耦合，而使得多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</p><p>Command:将一个请求封装为一个对象，从而使得你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</p><p>Interpreter:给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p><p>Iterator:提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</p><p>Mediator:用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>Memento:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p><p>Observer:定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</p><p>State:允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</p><p>Strategy:定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</p><p>Template Method:定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。其使得子类可以不改变一个算法结构即可重定义该算法的某些特定步骤。</p><p>Vistor:表示一个作用于某对象结构中的各元素的操作。其使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><h2 id="模式分类与联系">1.2 模式分类与联系</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-26-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%A9%BA%E9%97%B4.png"alt="设计模式空间" /><figcaption aria-hidden="true">设计模式空间</figcaption></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-26-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png"alt="设计模式之间的联系" /><figcaption aria-hidden="true">设计模式之间的联系</figcaption></figure><p>此外，还有一种<strong>16种</strong>设计模式的说法，创建型模式中原型模式被简单工厂模式替代，结构型模式中去掉组合模式，行为型模式中去掉责任链模式、解释器模式、迭代器模式、备忘录模式、模板方法模式、访问者模式。</p><h2 id="类之间的关系">1.3类之间的关系</h2><p>泛化：表现为继承非抽象类。实线空心三角箭头。</p><p>实现：表现为继承抽象类或接口。虚线空心三角箭头。</p><p>关联：表现为成员变量。实线箭头。</p><p>依赖：表现为成员函数参数。虚线箭头。</p><p>聚合与组合：也表现为成员变量。实线空心菱形箭头。菱形所在方为被组件组成方。组合表示的依赖关系比聚合更强。</p><h2 id="模式比较">1.4 模式比较</h2><p><strong>适配器模式</strong>：可分为类适配器和对象适配器，<strong>类适配器</strong>采用<strong>多继承</strong>的方式，适配器类同时继承被适配类和目标类，供客户类使用；<strong>对象适配器</strong>采用<strong>关联</strong>的方式，适配器类继承目标类，持有被适配类成员变量，供客户类使用。</p><p><strong>装饰器模式</strong>：装饰类继承被装饰类并持有被装饰类成员变量，由装饰类来决定是否调用被装饰类的行为以扩展自己的行为。</p><p><strong>代理模式</strong>：代理类和被代理类继承同一个父类，代理类持有被代理类成员变量，客户类通过调用代理类使用被代理类。</p><h2 id="solid设计原则">1.5 SOLID设计原则</h2><p>单一职责原则（Single ResponsibilityPrinciple）：一个类或者一个模块只做一件事。</p><p>开闭原则（Open Closed Principle）：对扩展开放，对修改关闭。</p><p>里氏替换原则（Liskov SubstitutionPrinciple）：派生类可以扩展基类的功能，但不能改变基类原有的功能。</p><p>接口隔离原则（Interface SegregationPrinciple）：一个接口应该拥有尽可能少的行为，对于不同的功能的模块分别使用不同接口，而不是使用同一个通用的接口。</p><p>依赖倒置原则（Dependence InversionPrinciple）：高级模块不应该依赖低级模块，而是依赖抽象接口，通过抽象接口使用对应的低级模块。</p><h1 id="架构">2 架构</h1><p>架构比设计模式更加宏观，关注软件整体结构而不是具体的类之间的关系。</p><h2 id="常见架构">2.1 常见架构</h2><p>分层架构</p><p>MVC架构</p><p>管道过滤器架构</p><p>C/S架构</p><p>事件驱动架构</p><p>微服务架构</p><h2 id="领域驱动设计">2.2 领域驱动设计</h2><p>领域驱动设计（Domain-DrivenDesign，简称DDD）用于应对复杂业务逻辑。</p><p>在传统的CURD开发里，业务逻辑都在service层，对象只是数据的载体，没有行为。DDD可以简单理解为引入了领域对象用于领域服务，在数据库持久化对象上又封装了一层，避免业务逻辑更改影响数据持久化操作。</p><h1 id="参考资料">3 参考资料</h1><p>《Design Patterns Elements of Reusable Object-Oriented Software》作者 Erich Gamma Richard Helm Ralph Johnson John Vissides</p><p><ahref="https://design-patterns.readthedocs.io/zh_CN/latest/index.html">图说设计模式— Graphic Design Patterns</a></p><p><ahref="https://tech.meituan.com/2017/12/22/ddd-in-practice.html">领域驱动设计在互联网业务开发中的实践- 美团技术团队</a></p><p><ahref="https://www.zhihu.com/question/475877331/answer/2035922184">为什么很多程序员不用switch，而是大量的if……elseif？</a>（关于过度设计的很生动的回答）</p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型视角下的编程语言</title>
      <link href="//posts/Article/programming-languages-%E2%80%8B%E2%80%8Bfrom-a-type-perspective/"/>
      <url>//posts/Article/programming-languages-%E2%80%8B%E2%80%8Bfrom-a-type-perspective/</url>
      
        <content type="html"><![CDATA[<p>关于强/弱/静态/动态类型语言的说法</p><span id="more"></span><p>关于编程语言中<strong>强/弱/静态/动态</strong>类型语言的划分，网络上存在很多互相矛盾的信息，这里做一个梳理。</p><p><strong>数据类型</strong>的意义是指定变量中数据的长度和处理方式。</p><p>简洁说法：强/弱类型指的是语言类型系统的类型检查的严格程度；静态/动态类型区分的是变量与类型的绑定方法。</p><p>网上可以找到两张分类图，左边来自<ahref="https://dustyprogrammer-blog.tumblr.com/post/16746798643/should-your-start-up-go-static-or-dynamic">MahdiYusuf</a>，右边来自<ahref="http://c.biancheng.net/view/8803.html">biancheng.net</a>。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-04-10-type.png" /></p><p>我个人认为C应该是弱类型，因为有<code>void*</code>这种万能指针做转换（不会有警告），并且允许弱类型写法通过编译（不同类型指针转换只有警告而已）。</p><p>C++从某种意义上说类型应该比C更强，因为禁止了不同类型指针之间的相互赋值（赋值给<code>void*</code>例外，反之不行），但是<strong>类型转换运算符</strong>使C++类型转换更自由了，说它更弱也可以。</p><p>侯捷老师的《STL源码解析》第60页（2.2.6节）说这种技巧（见如下代码）在强类型语言如Java中行不通，在非强类型语言如C++中十分普遍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">obj</span><br>&#123;<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">obj</span> *free_list_link;<br>    <span class="hljs-type">char</span> client_data[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种说法是面临与类型不匹配的运算时，弱类型尝试提供帮助，临时转换值让其符合当前运算。以JS为例。强类型遇到这种情况会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;5&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a+b);<br><span class="hljs-comment">// 输出是10</span><br></code></pre></td></tr></table></figure><p><ahref="https://www.zhihu.com/people/bu-rui">哥舒夜带刀</a>的说法是，类型的划分省略了太多信息，区分以下三对概念更重要：</p><ol type="1"><li><p>弱类型检查与强类型检查</p><p>类型检查的目标是捕获与类型有关的错误，能保证不存在与类型有关的不可捕获错误的编程语言，称为具有强类型检查；反之称为具有弱类型检查。</p></li><li><p>动态类型检查与静态类型检查</p><p>静态类型检查是指在编译阶段进行的类型检查，动态类型检查是在执行阶段进行的类型检查。</p><blockquote><p>解释型语言自己没有静态类型检查，但可以借助外部工具做到。</p><p>用编译型、解释型来分类编程语言已经过时了。就拿Java来说，先编译为字节码再由JVM解释执行，看上去是半解释半编译，JIT技术还会把热点代码直接编译为机器码。</p></blockquote></li><li><p>标识符的动态类型绑定与静态类型绑定</p><p>按标识符与特定类型的数据绑定后，重新绑定的约束条件划分。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI调参经验</title>
      <link href="//posts/Article/AI-training/"/>
      <url>//posts/Article/AI-training/</url>
      
        <content type="html"><![CDATA[<p>训练AI的调参经验总结</p><span id="more"></span><h1 id="环境配置">环境配置</h1><blockquote><p>2023/10/09更新</p></blockquote><h2 id="conda安装">conda安装</h2><p>用miniconda，没必要用anaconda。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前源： </span><br>conda config --show-sources<br><span class="hljs-comment"># 配置源的文件.condarc一般位于系统用户目录之下</span><br><span class="hljs-comment"># 清理环境无用包</span><br>conda clean -p<br></code></pre></td></tr></table></figure><p>重装miniconda的时候，提前备份安装目录下的envs文件夹以保留环境。</p><h2 id="cuda安装">CUDA安装</h2><p>下载<ahref="https://developer.nvidia.com/cuda-11-7-0-download-archive">CUDA11.7</a>。</p><p>双击exe安装即可，安装选项选择<strong>自定义</strong>，如果已有nvidia驱动（使用<code>nvidia-smi</code>命令判断）可以只勾选CUDA，否则全部勾选。一直下一步。</p><p>安装完成后使用<code>nvcc -V</code>确定自己的CUDA版本。</p><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvcc: NVIDIA (R) Cuda compiler driver<br>Copyright (c) 2005-2022 NVIDIA Corporation<br>Built on Tue_May__3_19:00:59_Pacific_Daylight_Time_2022<br>Cuda compilation tools, release 11.7, V11.7.64<br>Build cuda_11.7.r11.7/compiler.31294372_0<br></code></pre></td></tr></table></figure><h2 id="cudnn安装">cuDNN安装</h2><p>下载<ahref="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN</a>，选择DownloadcuDNN v8.5.0 (August 8th, 2022), for CUDA 11.x。</p><p>解压压缩包，将里面的 bin / include / lib三个文件夹直接复制到CUDA安装目录下（如果安装CUDA时默认安装路径，应该是<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7</code>），即合并到同名文件夹下。</p><p>在include文件夹下的cudnn.h中可以看到cudnn版本。</p><h2 id="备注">备注</h2><p>CUDA有driver api和runtime api。<code>nvidia-smi</code>命令显示的 CUDAVersion是driver api版本，<code>nvcc -V</code>显示是runtimeapi版本。runtime api的版本要低于或者等于driver api。</p><p>driver api是显卡驱动自带的，安装CUDA一般指安装CUDAToolkit以支持runtime api。</p><p>如果安装有pytorch，可以使用pytorch查看 ptorch、CUDA 、 cuDNN版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-built_in">print</span>(torch.__version__)<br><span class="hljs-comment"># 2.0.0</span><br><span class="hljs-built_in">print</span>(torch.version.cuda)<br><span class="hljs-comment"># 11.7</span><br><span class="hljs-built_in">print</span>(torch.backends.cudnn.version())<br><span class="hljs-comment"># 8500</span><br></code></pre></td></tr></table></figure><p>本地开发pytorch程序并不是必须在电脑上安装CUDA和cuDNN。可以在conda环境下安装pytorch时顺便安装pytorch-cuda，这样就自带了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install pytorch torchvision torchaudio pytorch-cuda=11.7 -c pytorch -c nvidia<br></code></pre></td></tr></table></figure><h1 id="pytorch">pytorch</h1><h2 id="训练">训练</h2><p>训练时使用<code>model.train()</code>，测试时使用<code>model.eval()</code>。BatchNormalization在测试时参数固定，Dropout在测试时不再生效。</p><p>测试时使用<code>model.eval()</code>虽然梯度不再传播，但仍然计算。<code>with torch.no_grad():</code>，防止计算梯度，节省资源。</p><p>学习率大时收敛快，但收敛到一定程度后不再收敛，需要降低学习率。使用<code>torch.optim.lr_scheduler.ExponentialLR()</code>之类的API。</p><p>标准训练流程为（代码选自<ahref="https://reddish.fun/posts/Notebook/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B0/#%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC%E5%B9%B6%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0">《pytorch深度学习实战》笔记- Homeworld</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">t_p = model(t_u, *params) <br>loss = loss_fn(t_p, t_c)<br><span class="hljs-comment"># 清空累积梯度</span><br>optimizer.zero_grad()<br><span class="hljs-comment"># 计算梯度</span><br>loss.backward()<br><span class="hljs-comment"># 查看params.grad并更新params，从中减去学习率乘梯度，就像手动求导并更新参数</span><br>optimizer.step()<br></code></pre></td></tr></table></figure><p><code>optimizer.zero_grad()</code>也可以放在训练之前，只要不出现在<code>loss.backward()</code>和<code>optimizer.step()</code>之间即可。参考<ahref="https://discuss.pytorch.org/t/where-should-i-place-zero-grad/101886">Whereshould I place .zero_grad()? - PyTorch Forums</a>。</p><h2 id="模型存取">模型存取</h2><ol type="1"><li><p>保存整个模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存</span><br>model = Model()<br>torch.save(model, <span class="hljs-string">&#x27;model_name.pth&#x27;</span>)<br><br><span class="hljs-comment"># 读取</span><br>model = torch.load(<span class="hljs-string">&#x27;model_name.pth&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>保存模型参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存</span><br>model = Model()<br><span class="hljs-comment"># 可以保存字典，用于同时保存多个模型等情况</span><br>torch.save(&#123;<span class="hljs-string">&#x27;model&#x27;</span>: model.state_dict()&#125;, <span class="hljs-string">&#x27;model_name.pth&#x27;</span>)、<br><br><span class="hljs-comment"># 读取</span><br>model = Model() <span class="hljs-comment"># 先定义</span><br>state_dict = torch.load(<span class="hljs-string">&#x27;model_name.pth&#x27;</span>)<br>model.load_state_dict(state_dict[<span class="hljs-string">&#x27;model&#x27;</span>])<br></code></pre></td></tr></table></figure><p>第一种方法可以直接保存模型，加载模型的时候直接把读取的模型给一个参数就行。它包含四个键，分别是model,optimizer,scheduler,iteration。</p><p>第二种方法在读取模型参数前<strong>要先定义一个模型</strong>（模型必须与原模型相同的构造），然后对这个模型导入参数。</p></li></ol><h2 id="权重初始化">权重初始化</h2><p>使用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>(torch.nn.Module):<br>    ...<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_weight</span>(<span class="hljs-params">layer</span>):<br>    <span class="hljs-comment"># or if isinstance(layer, nn.Conv2d):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(layer)==nn.Conv2d:<br>        nn.init.normal_(layer.weight,mean=<span class="hljs-number">0</span>,std=<span class="hljs-number">0.5</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">type</span>(layer)==nn.Linear:<br>        nn.init.uniform_(layer.weight,a=-<span class="hljs-number">1</span>,b=<span class="hljs-number">0.1</span>)<br>        nn.init.constant_(layer.bias,<span class="hljs-number">0.1</span>)<br><br>model=Model()<br><span class="hljs-comment"># 此方法会自下而上递归调用model中所有层,初始化其权重</span><br>model.apply(init_weight)<br></code></pre></td></tr></table></figure><p>不同的初始化API:<ahref="https://pytorch.org/docs/stable/nn.init.html?highlight=nn%20init">torch.nn.init— PyTorch 1.12 documentation</a></p><p>Pytorch线性层采取的默认初始化方式是kaiming_uniform_初始化。</p><h2 id="bn">BN</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.BatchNorm1d(num_features, eps=<span class="hljs-number">1e-05</span>, momentum=<span class="hljs-number">0.1</span>, affine=<span class="hljs-literal">True</span>, track_running_stats=<span class="hljs-literal">True</span>, device=<span class="hljs-literal">None</span>, dtype=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p><a href="https://arxiv.org/abs/1502.03167">Paper</a> <spanclass="math display">\[y=\frac {x-E[x]} {\sqrt{Var[x]+\epsilon} } *\gamma+\beta\]</span> 在最小批的每个维度上计算均值和标准差，<spanclass="math inline">\(\gamma\)</span> 和<spanclass="math inline">\(\beta\)</span>则是可学习参数向量，大小为输入的特征数或通道数。<spanclass="math inline">\(\gamma\)</span> 默认为1，<spanclass="math inline">\(\beta\)</span>默认为0。</p><p>为了将输入调整到激活函数的敏感区，BatchNorm层要加在激活函数前面。</p><h2 id="dropout">Dropout</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.Dropout(p=<span class="hljs-number">0.5</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>在训练过程中，按伯努利分布采样概率p随机将输入张量的元素置零。在每次调用中每个通道将被独立地置零。这已经被证明是正则化的有效手段。</p><p>注意，训练时输出会乘以<spanclass="math inline">\(\frac{1}{1-p}\)</span>。测试时模块简单计算一个恒等函数。</p><p>BN层的加入可以起到抑制过拟合的作用，在训练过程对每个单个样本的forward均引入多个样本（Batch个）的统计信息，相当于自带一定噪音，起到正则效果，无需添加Dropout。BN和Dropout同时使用会使精度下降，参考论文：</p><blockquote><p>Li X, Chen S, Hu X, et al. Understanding the disharmony betweendropout and batch normalization by variance shift[C]//Proceedings of theIEEE/CVF conference on computer vision and pattern recognition. 2019:2682-2690.</p></blockquote><p>Dropout层一般放在激活函数层之后。</p><h2 id="tensor操作">tensor操作</h2><p>可以认为，对于tensor a：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a.reshape() = a.view() + a.contiguous().view()<br></code></pre></td></tr></table></figure><p>tensor与numpy之间的转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 若未使用with torch.no_grad()，需要额外使用.detach()</span><br><span class="hljs-comment"># .cpu()与.to(&quot;cpu&quot;)等价</span><br><span class="hljs-comment"># .cuda()与.to(&quot;cuda:0&quot;)等价，数字0代表第一张gpu</span><br><span class="hljs-comment"># 示例，将torch.Tensor a转换为numpy.ndarray b</span><br>a.detach().cpu().numpy()<br></code></pre></td></tr></table></figure><h2 id="并行化">并行化</h2><p>训练AI模型有两类并行化，数据并行化和模型并行化。数据并行化指一张GPU处理一个数据切片（如一个batch的一部分），模型并行化指一张GPU处理一个模型切片（如模型的一层）。</p><p>对于数据并行化，pytorch有两种接口，<code>torch.nn.DataParallel</code>和<code>torch.nn.parallel.DistributedDataParallel</code>，前者为单机多线程，后者为单机/多机多进程且和模型并行化兼容。</p><p>对于模型并行化，有Pipleline并行化、Tensor并行化、Sequential并行化等方法，没有直接的接口。Pipleline并行化对模型按层划分到不同GPU上加速执行（类似CPUPipeline），实现可以参考<ahref="https://pytorch.org/tutorials/intermediate/model_parallel_tutorial.html">Single-MachineModel Parallel Best Practices — PyTorch Tutorials 2.1.0+cu121documentation</a>。</p><h1 id="loss-nan">loss nan</h1><p>出现loss nan可能有以下原因</p><ul><li><p>训练数据中含有nan</p></li><li><p>计算过程中溢出</p><ul><li>上溢出，进行譬如<spanclass="math inline">\(exp(x)\)</span>之类的运算。</li><li>下溢出，进行譬如<spanclass="math inline">\(\log(0)\)</span>之类的运算。</li></ul></li><li><p>梯度爆炸</p><ul><li>每个batch前梯度没有零，<code>optimizer.zero_grad()</code>(pytorch)</li><li>学习率过大</li><li>batchsize过大</li><li>可以用<code>torch.nn.utils.clip_grad_norm_</code>(pytorch)避免</li></ul></li></ul><h1 id="参数配置">参数配置</h1><p>常用的参数配置库有argparse和configparse。</p><p>argparse从命令行读取参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><br>parser = argparse.ArgumentParser(description=<span class="hljs-string">&#x27;test&#x27;</span>)<br><span class="hljs-comment"># 加--为无序可选参数，不加是顺序必选参数。</span><br><span class="hljs-comment"># 可用required参数设置是否可选。</span><br><span class="hljs-comment"># 可用nargs设置传入参数的个数，&#x27;+&#x27; 表示传入至少一个参数。</span><br>parser.add_argument(<span class="hljs-string">&#x27;--i&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">1</span>， <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;数字&#x27;</span>) <br>args = parser.parse_args()<br><span class="hljs-built_in">print</span>(args.i)<br><span class="hljs-comment"># 运行命令：python -u &quot;d:\code\TEST_PYTHON\main.py&quot; --i 5</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Namespace(i=5)</span><br><span class="hljs-string">5</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>如果希望将argparse读取的参数写入文件，直接从文件读取，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 写入</span><br>parser = argparse.ArgumentParser(description=<span class="hljs-string">&#x27;test&#x27;</span>)<br><span class="hljs-comment"># 参数略</span><br>args = parser.parse_args()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;config.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>json.dump(args.__dict__, f, indent=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 读取，不再需要从命令行传参</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;config.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    config = json.load(f)<br>args = argparse.Namespace(**config)<br></code></pre></td></tr></table></figure><p>configparse从文件读取参数。</p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++学习笔记</title>
      <link href="//posts/Notebook/C-CPP-note/"/>
      <url>//posts/Notebook/C-CPP-note/</url>
      
        <content type="html"><![CDATA[<p>个人整理</p><span id="more"></span><h1 id="c">C</h1><h2 id="基础">1 基础</h2><h3 id="char的具体实现是什么">char的具体实现是什么❔</h3><p>有些C编译器把char实现为有符号类型，即char可表示的范围是-128-127。有些C编译器把char实现为无符号类型，即char可表示的范围是0-255。</p><p>如不想由编译器决定，根据C90标准，C语言允许在关键字char前面使用signed或unsigned。</p><h3 id="何时刷新缓冲区">何时刷新缓冲区❔</h3><p>当缓冲区满、遇到换行字符或需要输入的时候（从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区）。</p><h3 id="sizeof后面是否要加圆括号">sizeof后面是否要加圆括号❔</h3><p>运算对象是类型时，圆括号必不可少；但是对于特定量，可有可无。</p><h3id="sizeof返回值与实现有关如何打印">sizeof返回值与实现有关，如何打印❔</h3><p>为了可移植性，stddef.h头文件（在包含stdio.h头文件时已包含其中）把<code>size_t</code>定义成系统使用sizeof返回的类型，这被称为底层类型（underlyingtype），printf()可使用z修饰符打印相应的类型。C还定义了<code>ptrdiff_t</code>类型和t修饰符来表示系统使用的两个地址差值的底层有符号整数类型。</p><h3 id="负数的整数除法的规则是什么">负数的整数除法的规则是什么❔</h3><p>C99以前不同的实现采用不同的方法，C99规定使用趋零截断。如-3.8截断为-3。</p><h3id="为什么有的c代码用and代替">为什么有的C代码用<code>and</code>代替<code>&amp;&amp;</code>❔</h3><p>并非所有的键盘都有和美式键盘一样的符号。因此C99标准新增了可代替逻辑运算符的拼写，它们被定义在ios646.h头文件中。如果在程序中包含该头文件，便可用<code>and</code>代替<code>&amp;&amp;</code>、<code>or</code>代替<code>||</code>。</p><p>注意：在C++中，备选拼写是<strong>关键字</strong>；已弃用iso646.h或C++等效的ciso646头文件。有<code>and</code>、<code>or</code>、<code>and_eq</code>、<code>or_eq</code>、<code>xor</code>、<code>xor_eq</code>、<code>not</code>、<code>not_eq</code>、<code>bitand</code>、<code>bitor</code>。</p><h3 id="指针之间可以相互赋值吗">指针之间可以相互赋值吗❔</h3><p>不可以，指针之间的赋值比数值类型之间的赋值要严格。不用类型转换就可以把int 类型的值赋给double类型的变量，但是两个类型的指针不能这样做。</p><h3 id="什么是复合字面量">什么是复合字面量❔</h3><p>C99新增了复合字面量（compound literal）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> diva[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;<br><span class="hljs-type">int</span> *pt1;<br>pt1 = (<span class="hljs-type">int</span> [<span class="hljs-number">2</span>])&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;; <span class="hljs-comment">// 复合字面量，[]内数字可省略</span><br></code></pre></td></tr></table></figure><h3id="空白字符分隔的字符串字面量会自动串联吗">空白字符分隔的字符串字面量会自动串联吗❔</h3><p>会。</p><h3 id="数组名是指针常量吗">数组名是指针常量吗❔</h3><p>数组名和指针很像，并且不能进行赋值或自增，但它不是指针常量。</p><p>数组名的类型是<code>type[size]</code>，不是<code>type* const</code>。对数组取值，得到的是<code>type(*)[size]</code>。</p><p>数组名会隐式转换为首元素指针右值，除了以下情况：</p><ol type="1"><li><code>sizeof</code></li><li><code>&amp;</code></li><li>用字符串字面量初始化字符数组</li><li><code>_Alignof</code>或<code>alignof</code></li></ol><h3 id="什么是翻译单元">什么是翻译单元❔</h3><p>通常在源代码（.c扩展名）中包含一个或多个头文件（.h扩展名）。头文件会依次包含其他头文件，所以会包含多个单独的物理文件。但是，C预处理实际上是用包含的头文件内容替换#include指令。所以源代码文件和所有的头文件都看成是一个包含信息的单独文件，这个文件被称为<strong>翻译单元</strong>（translationunit）。描述一个具有<strong>文件作用域</strong>的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。</p><h3 id="c语言有哪些存储类别说明符">C语言有哪些存储类别说明符❔</h3><p>C语言有6个关键字作为存储类别说明符：auto、register、static、extern、_Thread_local和typedef。typedef关键字与任何内存存储无关，把它归于此类有一些语法上的原因。尤其是，在绝大多数情况下，不能在声明中使用多个存储类别说明符，所以这意味着不能使用多个存储类别说明符作为typedef的一部分。唯一例外的是_Thread_local，它可以和static或extern一起使用。</p><h3id="为什么可以在一条声明中多次使用同一个限定符">为什么可以在一条声明中多次使用同一个限定符❔</h3><p>C99为类型限定符增加了一个新属性：幂等（idempotent）。</p><h3id="在文件间共享const变量有什么方法">在文件间共享const变量有什么方法❔</h3><p>可以采用两个策略。</p><ol type="1"><li><p>遵循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使用引用式声明（用extern关键字）。</p><blockquote><p>注意，extern用于普通变量时，只需要在声明处加extern；用于const变量时，声明和定义处都需要加extern。</p><p><ahref="https://learn.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170">extern(C++) | Microsoft Learn</a></p></blockquote></li><li><p>把const变量放在一个头文件中，用关键字static声明，然后在其他文件中包含该头文件。相当于给每个文件提供了一个单独的数据副本。</p></li></ol><h3 id="volatile用法">volatile用法❔</h3><p>volatile限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。例如：</p><ol type="1"><li>一个地址上可能储存着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变。</li><li>一个地址用于接受另一台计算机传入的信息。</li></ol><h3 id="restrict用法">restrict用法❔</h3><p>restrict关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。</p><h3 id="的优先级"><code>*</code> <code>()</code><code>[]</code>的优先级❔</h3><ol type="1"><li><p>数组名后面的<code>[]</code>和函数名后面的<code>()</code>具有相同的优先级。它们比<code>*</code>（解引用运算符）的优先级高。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *risks[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 是一个指针数组，不是指向数组的指针</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>[]</code>和<code>()</code>的优先级相同，都是从左往右结合。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*rusks)[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 是一个指向数组的指针，该数组内含10个int类型的元素</span><br><span class="hljs-type">int</span> *foo[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]; <span class="hljs-comment">// foo是一个内含3个元素的数组，其中每个元素是由4个指向int的指针组成的数组</span><br></code></pre></td></tr></table></figure></p></li></ol><h3id="函数指针和函数名可以互换使用吗">函数指针和函数名可以互换使用吗❔</h3><p>可以。</p><h3 id="c可以使用泛型吗">C可以使用泛型吗❔</h3><p>可以。利用C11新增的泛型选择表达式定义一个泛型宏，根据参数类型选择最合适的数学函数版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQRT(X) _Generic((X), long double: sqrtl,  default: sqrt, float: sqrtf)(X)</span><br></code></pre></td></tr></table></figure><h2 id="标准库">2 标准库</h2><h3 id="为什么不建议使用gets">为什么不建议使用<code>gets()</code>❔</h3><p><code>gets()</code>唯一的参数是words，它无法检查数组是否装得下输入行，若输入的字符串过长，会导致缓冲区溢出（bufferoverflow），可能引发段错误（Segmentationfault，表明程序试图访问未分配的内存）。有些人通过系统编程利用<code>gets()</code>插入和运行一些破坏系统安全的代码。</p><p>C11标准委员会直接从标准中废除了gets()函数。</p><h3 id="如何进行字符串与数字的转换">如何进行字符串与数字的转换❔</h3><p><code>atoi()</code>、<code>atol()</code>和<code>atof()</code>函数把字符串形式的数字分别转换成int、long和double类型的数字。<code>strtol()</code>、<code>strtoul()</code>和<code>strtod()</code>函数把字符串形式的数字分别转换成long、unsignedlong和double类型的数字。</p><h3 id="c语言是否允许变长数组">C语言是否允许变长数组❔</h3><p>C99标准允许声明变长数组（variable-length array，简称VLA），C11放弃了这一创新的举措，把VLA设定为可选，而不是语言必备的特性。</p><h3 id="文本文件与二进制文件区别">文本文件与二进制文件区别❔</h3><p>所有文件的内容都以二进制形式（0或1）储存。</p><p>如果文件最初使用二进制编码的字符（例如，ASCII或Unicode）表示文本（就像C字符串那样），该文件就是<strong>文本文件</strong>，其中包含文本内容。</p><p>如果文件中的二进制值代表机器语言代码或数值数据（使用相同的内部表示，假设，用于long或double类型的值）或图片或音乐编码，该文件就是<strong>二进制文件</strong>，其中包含二进制内容。</p><p>C提供两种访问文件的途径：二进制模式和文本模式。在二进制模式中，程序可以访问文件的每个字节。而在文本模式中，程序所见的内容和文件的实际内容不同。程序以文本模式读取文件时，把本地环境表示的行末尾或文件结尾映射为C模式。例如，C文本模式程序在MS-DOS平台读取文件时，把<code>\r\n</code>转换成<code>\n</code>；写入文件时，把<code>\n</code>转换成<code>\r\n</code>。在其他环境中编写的文本模式程序也会做类似的转换。</p><p>虽然C提供了二进制模式和文本模式，但是这两种模式的实现可以相同。前面提到过，因为UNIX使用一种文件格式，这两种模式<strong>对于UNIX实现而言</strong>完全相同。Linux也是如此。</p><h2 id="内存管理">3 内存管理</h2><h3 id="什么是存储类别">什么是存储类别❔</h3><p>不同的存储类别（storage class）具有不同的存储期（storageduration）、作用域（scope）和链接（linkage）。</p><p><strong>作用域</strong></p><p>描述程序中可访问标识符的区域。</p><p>一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域或文件作用域。</p><p>定义在块中的变量具有<strong>块作用域</strong>（blockscope），块作用域变量的可见范围是从定义处到包含该定义的块的末尾。块是用一对花括号括起来的代码区域。例如，整个函数体是一个块，函数中的任意复合语句也是一个块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A C99 feature: i = %d&quot;</span>, i);<br><span class="hljs-comment">// C99把块的概念扩展到包括for循环、while循环、do while循环和if语句所控制的代码，即使这些代码没有用花括号括起来，也算是块的一部分。所以，上面for循环中的变量i被视为for循环块的一部分，它的作用域仅限于for循环。一旦程序离开for循环，就不能再访问i。</span><br></code></pre></td></tr></table></figure><p><strong>函数作用域</strong>（functionscope）仅用于goto语句的标签。这意味着即使一个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数。如果在两个块中使用相同的标签会很混乱，标签的函数作用域防止了这样的事情发生。</p><p><strong>函数原型作用域</strong>（function prototypescope）用于函数原型中的形参名（变量名），它范围是从形参定义处到原型声明结束，这意味着而形参名（如果有的话）通常无关紧要（除了变长数组）。</p><p>变量的定义在函数的外面，具有<strong>文件作用域</strong>（filescope）。具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见。</p><p><strong>链接</strong></p><p>C变量有 3 种链接属性：外部链接、内部链接或无链接。</p><p>具有块作用域、函数作用域或函数原型作用域的变量都是<strong>无链接变量</strong>。这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作用域的变量可以是外部链接或内部链接。<strong>外部链接变量</strong>可以在多文件程序中使用，<strong>内部链接变量</strong>只能在一个翻译单元中使用。</p><blockquote><p>一些程序员把<strong>内部链接的文件作用域</strong>简称为<strong>文件作用域</strong>，把<strong>外部链接的文件作用域</strong>简称为<strong>全局作用域</strong>或<strong>程序作用域</strong>。</p></blockquote><p><strong>存储期</strong></p><p>作用域和链接描述了标识符的可见性，存储期则描述了通过这些标识符访问的对象的生存期。</p><p>C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。</p><p>所有的文件作用域变量都具有<strong>静态存储期</strong>。</p><blockquote><p>对于文件作用域变量，<strong>关键字static表明了其链接属性，而非存储期</strong>。以static声明的文件作用域变量具有内部链接。</p></blockquote><p>具有<strong>线程存储期</strong>的对象，从被声明时到线程结束一直存在。以关键字<code>_Thread_local</code>声明一个对象时，每个线程都获得该变量的私有备份。</p><p>块作用域的变量通常都具有<strong>自动存储期</strong>（当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。），也能具有静态存储期（加上关键字static）。</p><table><thead><tr class="header"><th>存储类别</th><th>存储期</th><th>作用域</th><th>链接</th><th>声明方式</th></tr></thead><tbody><tr class="odd"><td>自动</td><td>自动</td><td>块</td><td>无</td><td>块内</td></tr><tr class="even"><td>寄存器</td><td>自动</td><td>块</td><td>无</td><td>块内，使用关键字register</td></tr><tr class="odd"><td>静态外部链接</td><td>静态</td><td>文件</td><td>外部</td><td>所有函数外</td></tr><tr class="even"><td>静态内部链接</td><td>静态</td><td>文件</td><td>内部</td><td>所有函数外，使用关键字static</td></tr><tr class="odd"><td>静态无链接</td><td>静态</td><td>块</td><td>无</td><td>块内，使用关键字static</td></tr></tbody></table><blockquote><p>可声明为register的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存double类型的值。</p><p>如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变量。</p><p>与自动变量不同的是，如果未初始化外部变量，它们会被<strong>自动初始化</strong>为0。这一原则也适用于外部定义的数组元素。与自动变量的情况不同，只能使用常量表达式初始化文件作用域变量。</p><p>除了以上存储类别，还可以使用malloc和free进行动态内存分配，即<strong>动态分配存储期</strong>。</p></blockquote><h2 id="和c区别">4 和C++区别</h2><p>准确来说C++和C只有交集关系，C89之后诞生C++98和C99，然后是C++1x和C11，后续渐行渐远（C++<strong>不是</strong>C的超集）。</p><p>C++中有许多规则与C不同，这些不同使得C程序作为C++程序编译时可能以不同的方式运行或根本不能运行。</p><h3 id="auto关键字用法">auto关键字用法❔</h3><p>auto在C中是存储类别说明符（storage-classspecifier），在C++中是类型说明符。</p><h3 id="标识符处理">标识符处理❔</h3><p>在C中，下面的代码不会产生冲突：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rect</span> &#123;</span> <br>    <span class="hljs-type">double</span> x; <br>    <span class="hljs-type">double</span> y; <br>&#125;;<br><span class="hljs-type">int</span> rect; <br></code></pre></td></tr></table></figure><p>C++不允许这样做，因为它<strong>把标记名和变量名放在相同的名称空间中</strong>。</p><p>声明一个有标记的结构、联合、枚举后，就可以在C++中使用这个标记作为类型名，而C必须带上struct、union、enum。</p><p>C++中使用嵌套结构时要使用<code>::</code>，C不需要。</p><h3 id="void"><code>void*</code>❔</h3><p>C++要求在把<code>void*</code>指针赋给任何类型的指针时必须进行强制类型转换。C没有这样的要求。</p><p>另外，C++可以把派生类对象的地址赋给基类指针。</p><h3 id="函数原型">函数原型❔</h3><p>C可以没有<strong>函数原型</strong>，以下的代码在C中是正确的，在C++中是错误的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">slice</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">slice</span>(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">slice</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，C++允许重载。</p><h3 id="char常量">char常量❔</h3><p>C把char常量视为int类型，而C++将其视为char类型。</p><p>所以，C提供了一种方法可单独设置int类型中的每个字节。（C的早期版本不提供十六进制记法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-string">&#x27;ABCD&#x27;</span>;<br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;ABCD&#x27;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %c %c\n&quot;</span>, x, <span class="hljs-string">&#x27;ABCD&#x27;</span>, c, <span class="hljs-string">&#x27;ABCD&#x27;</span>);<br><span class="hljs-comment">// 输出 1094861636 1094861636 D D</span><br><span class="hljs-comment">// 如果把&#x27;ABCD&#x27;视为int类型，它是一个4字节的整数值。如果将其视为char类型，程序只使用最后一个字节。</span><br></code></pre></td></tr></table></figure><h3 id="const限定符">const限定符❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 都在函数外部</span><br><span class="hljs-comment">// C++的声明</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159</span>;<br><span class="hljs-comment">// 相当于下面C中的声明</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159</span>;<br></code></pre></td></tr></table></figure><p>C中全局的const具有外部链接，C++中则具有内部链接。</p><p>C++可以使用关键字extern使一个const值具有外部链接。所以两种语言都可以创建内部链接和外部链接的const变量。它们的区别在于<strong>默认使用哪种链接</strong>。</p><p>C++中可以使用const值来初始化其他const变量，在C中不能。</p><h3 id="枚举">枚举❔</h3><p>C++使用枚举比C严格。特别是，只能把enum常量赋给enum变量，然后把变量与其他值作比较。不经过显式强制类型转换，不能把int类型值赋给enum变量，而且也不能递增一个enum变量。</p><p>C++还有限定作用域的枚举和不限定作用域的枚举（enum后加上class）。</p><h3 id="布尔类型">布尔类型❔</h3><p>在C++中，布尔类型是bool，而且ture和false都是关键字。在C中，布尔类型是_Bool，但是要包含stdbool.h头文件才可以使用bool、true和false。</p><h3 id="c11中没有的c99c11特性">C++11中没有的C99/C11特性❔</h3><p>指定初始化器；</p><p>复合初始化器（Compound initializer）；</p><p>受限指针（Restricted pointer）（即，restric指针）；</p><p>变长数组；</p><p>伸缩型数组成员；</p><p>带可变数量参数的宏。</p><h1 id="c-1">C++</h1><h2 id="基础-1">1 基础</h2><h3id="对于类的特殊成员函数用户显式声明和编译器隐式声明的关系">对于类的特殊成员函数，用户显式声明和编译器隐式声明的关系❔</h3><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-12-30-cpp-compiler-implictly-declares.png" /></p><p>来源：</p><p><a href="https://www.youtube.com/watch?v=vLinb2fgkHk">EngineeringDistinguished Speaker Series: Howard Hinnant - YouTube</a></p><p><a href="https://howardhinnant.github.io/classdecl.html">C++ classdeclarations</a></p><h3id="在头文件里实现函数的注意事项">在头文件里实现函数的注意事项❔</h3><p>除了<strong>inline函数</strong>、<strong>在类的定义中实现的成员函数</strong>、<strong>模板函数</strong>外，若直接在头文件中定义函数，当头文件被多个实现文件包含时，函数会被生成的多个obj包含，导致重定义错误，无法链接。</p><h3id="如何查询当前默认使用的c标准">如何查询当前默认使用的C++标准❔</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -E -dM - &lt;/dev/null | grep <span class="hljs-string">&quot;STDC_VERSION&quot;</span><br><span class="hljs-comment"># 输出 #define __STDC_VERSION__ 201710L</span><br></code></pre></td></tr></table></figure><p><code>-E</code>意思是只做预处理。</p><p><code>-dM</code>搭配<code>-E</code>表示展示所有预定义宏。</p><blockquote><p>gcc相关命令参考<ahref="https://gcc.gnu.org/onlinedocs/gcc-9.4.0/gcc/Option-Summary.html#Option-Summary">OptionSummary (Using the GNU Compiler Collection (GCC))</a>。</p></blockquote><p><code>-</code>意思是从标准输入中读取，而不是从该命令行上提供的文件名中读取。这是一个常见的Unix 约定。</p><p><code>&lt; /dev/null</code>从 <code>/dev/null</code>重定向标准输入，其长度为0。因此将从标准输入读取并立即到达输入的末尾，使其仅打印预定义的宏(而不是输入中的任何宏，因为没有任何输入)。这是标准的shell语法，不特定于g++的调用。</p><h3 id="简单编译流程">简单编译流程❔</h3><p>preprocess，compile，assembly，link</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">g++ <span class="hljs-literal">-E</span> test.cpp <span class="hljs-literal">-o</span> test.i<br>g++ <span class="hljs-literal">-S</span> test.i <span class="hljs-literal">-o</span> test.s<br>g++ <span class="hljs-literal">-c</span> test.s <span class="hljs-literal">-o</span> test.o<br>g++  test.o <span class="hljs-literal">-o</span> test<br></code></pre></td></tr></table></figure><p>也可以直接对源文件执行每一命令。链接时是否写<code>.exe</code>均可。</p><h3 id="静态成员变量的类内初始化">静态成员变量的类内初始化❔</h3><p>使用const修饰的静态整型变量，比如<code>static const int | char | long</code>等<strong>可以</strong>类内初始化。</p><p>使用constexpr修饰的所有静态变量,比如<code>static constexpr int | float | double</code>等<strong>必须</strong>类内初始化。</p><p>非静态成员变量不能用constexpr修饰。</p><h3 id="初始化有哪几种顺序如何">初始化有哪几种，顺序如何❔</h3><p>声明初始化 -&gt; 初始化列表 -&gt; 构造函数初始化</p><h3id="dynamic_cast和static_cast的区别"><code>dynamic_cast</code>和<code>static_cast</code>的区别❔</h3><p>1）在类层次间进行上行转换时，两者一样。</p><p>2）在类层次间进行下行转换时，<code>dynamic_cast</code>具有类型检查的功能，比<code>static_cast</code>更安全。转换失败<code>dynamic_cast</code>会返回空指针，而<code>static_cast</code>只会转换，难以发现错误。</p><h3 id="constexpr和const区别">constexpr和const区别❔</h3><p>constexpr是C++11引入的关键字，指示值或返回值（<strong>如果可能</strong>）将在编译时进行计算。</p><p>const并未区分出编译期常量和运行期常量，constexpr限定在了编译期常量。因此可以用函数返回值给const变量赋值，但不能用其给constexpr变量赋值。</p><p>constexpr可以置于类构造函数前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 修饰变量时constexpr包含了const的含义，完全相同</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 此时必须同时使用const、constexpr，constexpr表示NP指针本身是常量表达式，而const表示指向的值是一个常量</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> *NP = &amp;N;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// C++11中对成员函数constexpr包含了const的含义</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 以后可能必须写成</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><h3 id="前置和后置的区别">前置++和后置++的区别❔</h3><p>前置++先赋值后返回，后置++先返回后赋值。</p><p>在对内置类型使用的时候，经过编译器优化，两者效率没有区别。</p><p>对于自定义类，通常的实现方式是：前置++自增后返回引用；后置++先用临时对象保存原来的对象，然后对原对象调用前置++，再返回临时对象。所以自定义类的客户使用前置++效率更高。</p><h3 id="纯虚函数可以有函数体吗">纯虚函数可以有函数体吗❔</h3><p>实现纯虚函数一般不常见，但纯虚析构函数必须实现。</p><p>如有函数体必须定义在类的外部。</p><h3 id="cfront是什么">cfront是什么❔</h3><p>最初Stroustrup实现C++时，使用了一个C++到C的编译器程序，而不是开发直接的C++到目标代码的编译器。前者叫做cfront(表示C前端，C frontend)，它<strong>将C++源代码翻译成C源代码</strong>，然后使用一个标准C编译器对其进行编译。这种方法简化了向C的领域引入C++的过程。其他实现也采用这种方法将C++引入到其他平台。</p><p>随着C++的日渐普及，越来越多的实现转向创建C++编译器，直接将C++源代码生成目标代码。这种直接方法加速了编译过程，并强调C++是一种独立（虽然有些相似）的语言。</p><h3 id="各种继承方式的作用">各种继承方式的作用❔</h3><table><thead><tr class="header"><th>特征</th><th>公有继承</th><th>保护继承</th><th>私有继承</th></tr></thead><tbody><tr class="odd"><td>公有成员变成</td><td>派生类的公有成员</td><td>派生类的保护成员</td><td>派生类的私有成员</td></tr><tr class="even"><td>保护成员变成</td><td>派生类的保护成员</td><td>派生类的保护成员</td><td>派生类的私有成员</td></tr><tr class="odd"><td>私有成员变成</td><td>只能通过基类接口访问</td><td>只能通过基类接口访问</td><td>只能通过基类接口访问</td></tr><tr class="even"><td>能否隐式向上转换</td><td>是</td><td>是（但只能在派生类中）</td><td>否</td></tr></tbody></table><p><strong>隐式向上转换</strong>指无需进行显式类型转换，就可以将基类指针或引用指向派生类对象。</p><p>可以使用<strong>using声明</strong>使派生类可以使用私有基类中的方法。</p><h3 id="虚基类是什么">虚基类是什么❔</h3><p>当派生类使用关键字virtual来指示派生时，基类就成为<strong>虚基类</strong>。从虚基类派生而来的类将只继承一个基类对象。</p><p>当类通过多条<strong>虚途径</strong>和<strong>非虚途径</strong>继承某个特定的基类时，该类将包含<strong>一个</strong>表示所有的虚途径的基类子对象和<strong>多个</strong>分别表示各条非虚途径的基类子对象。</p><blockquote><p>例如，假设类B被用作类C和D的虚基类，同时被用作类X和Y的非虚基类。类M从C、D、X、Y派生而来。在这种情况下，类M从虚派生祖先（即类C和D）那里共继承了一个B类子对象，并从每一个非虚派生祖先（即类X和Y）分别继承了一个B类子对象。因此，它包含三个B类子对象。</p></blockquote><p>有<strong>间接虚基类</strong>的派生类包含直接调用间接基类构造函数的构造函数。这对于间接非虚基类是非法的。</p><h3 id="嵌套类是什么">嵌套类是什么❔</h3><p>在另一个类中声明的类被称为<strong>嵌套类</strong>（nestedclass）。</p><p>嵌套类、结构和枚举的作用域特征：</p><table><thead><tr class="header"><th>声明位置</th><th>包含它的类是否可以使用它</th><th>从包含它的类派生而来的类是否可以使用它</th><th>在外部是否可以使用</th></tr></thead><tbody><tr class="odd"><td>私有部分</td><td>是</td><td>否</td><td>否</td></tr><tr class="even"><td>保护部分</td><td>是</td><td>是</td><td>否</td></tr><tr class="odd"><td>公有部分</td><td>是</td><td>是</td><td>是，通过类限定符来使用</td></tr></tbody></table><h3id="c为什么从语法上禁止函数模板的偏特化">C++为什么从语法上禁止函数模板的偏特化❔</h3><p>函数模板偏特化和函数重载同时存在的话，编译器决定调用哪个函数？语义存在模糊性。</p><p>函数调用顺序：</p><ol type="1"><li>普通函数及其重载函数，若无匹配进入2，有匹配返回</li><li>函数模板中最匹配的，若无匹配报错，有匹配进入3</li><li>该函数模板的全特化版本中最匹配的，若无匹配直接调用函数模板，有匹配返回</li></ol><p>有以下三种办法实现函数模板偏特化的行为：</p><ol type="1"><li>对类进行偏特化，重载类的函数调用运算符，利用函数对象实现。</li><li>利用标签分发进行函数重载。（可参考Effective C++条款47）</li><li>利用C++20的concept特性。</li></ol><h3id="c是否尽可能地解释为函数声明">C++是否尽可能地解释为函数声明❔</h3><p>是。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>()<br>    &#123;<br>    &#125;<br>    <span class="hljs-built_in">Widget</span>(<span class="hljs-type">int</span> i)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;i = i;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Widget w1;<br>    <span class="hljs-function">Widget <span class="hljs-title">w2</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 它没有声明名为w的Widget，而是声明了一个名为w的函数，该函数不带任何参数，并返回一个Widget。</span><br>    <span class="hljs-function">Widget <span class="hljs-title">w3</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(w1).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(w2).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(w3).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">6Widget</span><br><span class="hljs-comment">F6WidgetvE</span><br><span class="hljs-comment">6Widget</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3id="c模板的定义是否只能放在头文件中">C++模板的定义是否只能放在头文件中❔</h3><p>不是。但若将定义放在单独的源文件中，当模板被客户端代码使用时，必须在定义所在的源文件声明对应的实例化版本，否则会链接失败。</p><h3 id="如何利用c判断字节序">如何利用C++判断字节序❔</h3><p>Little Endian即低位字节排放在内存的低地址端；BigEndian即高位字节排放在内存的低地址端。以0x1234为例，LittleEndian下0x34放在低地址端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_little_endian_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-type">char</span> b = *(<span class="hljs-type">char</span> *)&amp;a; <span class="hljs-comment">// 取b等于a的低地址部分</span><br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0x34</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_little_endian_2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">NUM</span><br>    &#123;<br>        <span class="hljs-type">int</span> a;<br>        <span class="hljs-type">char</span> b;<br>    &#125; num;<br>    num.a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-keyword">return</span> num.b == <span class="hljs-number">0x34</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; boolalpha &lt;&lt; <span class="hljs-built_in">is_little_endian_1</span>() &lt;&lt; endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">is_little_endian_2</span>() &lt;&lt; noboolalpha &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="标准库-1">2 标准库</h2><h3id="为什么stdstring没有emplace或emplace_back操作">为什么std::string没有emplace或emplace_back操作❔</h3><p><code>std::vector&lt;T&gt;::emplace_back</code>的好处在于它直接在向量里构造类型为T的对象，而不是构造临时对象并拷贝。</p><p><code>char</code>是基本类型，不需要上述操作。</p><h3id="stdvector的增长因子k是如何设计的">std::vector的增长因子k是如何设计的❔</h3><p>有的实现里k=2，有的实现里k=1.5。</p><p>使用k=1.5更好，因为这样才有机会在分配时复用之前释放的内存。</p><p>考虑k=2的情况：</p><ol type="1"><li>分配16字节。</li><li>分配32字节，释放16字节。16字节内存空洞。</li><li>分配64字节，释放32字节。48字节内存空洞（假设这次释放的32字节和上次释放的16字节相邻）。</li><li>分配128字节，释放64字节。112字节内存空洞。</li><li>设初始为x，第n次分配时，<span class="math inline">\(2^{n}\timesx&gt;(2^{n-1}-1)\timesx\)</span>。下次分配的内存一定比之前释放的总和大。</li></ol><p>k=1.5则不会有以上情况。</p><h3id="容器的迭代器指针和引用无效的特殊情况">容器的迭代器、指针和引用无效的特殊情况❔</h3><p>string是STL中在swap过程中会导致迭代器、指针和引用变为无效的<strong>唯一</strong>容器。</p><p>deque只要没有删除操作发生，且插入操作只发生在容器的末尾，则指向数据的指针和引用就不会变为无效（迭代器有可能会变为无效）。deque是<strong>唯一</strong>的迭代器可能会变为无效而指针和引用不会变为无效的STL标准容器。</p><h3 id="什么是stl中的分配子">什么是STL中的分配子❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">tempalte &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">allocator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebind</span>&#123;<br>        <span class="hljs-keyword">typedef</span> allocator&lt;U&gt; other;<br>    &#125;;<br>&#125;;<br><span class="hljs-comment">// 每个分配子模板A（如std::allocator、SpecialAllocator等）都要有一个被称为rebind的嵌套结构模板。rebind带有唯一的类型参数U，并且只定义了一个类型定义other。other仅仅是A&lt;U&gt;的名字。结果，通过引用Allocator::rebind&lt;ListNode&gt;::other，list&lt;T&gt;就能从T对象的分配子（称为Allocator）得到相应的ListNode对象的分配子。</span><br></code></pre></td></tr></table></figure><h3id="什么情况下vectorchar优于string">什么情况下vector&lt;char&gt;优于string❔</h3><p>在多线程环境中使用引用计数，由避免内存分配和字符拷贝所节省下来的时间还比不上花在背后同步控制上的时间。</p><p>许多string实现在背后使用了引用计数技术。vector的实现不允许使用引用计数，所以不会发生隐藏的多线程性能问题。</p><p>可以检查basic_string模板的拷贝构造函数是否添加了引用计数。</p><h3id="如何把vector和string数据传给旧的api">如何把vector和string数据传给旧的API❔</h3><p>对于vectorv，需要得到一个指向v中数据的指针把v中的数据作为数组来对待，只需使用&amp;v[0]。</p><p>对于strings，对应的形式是s.c_str()。string中的数据不一定存储在连续的内存中。而且string的内部表示不一定以空字符结尾。</p><h3id="为什么说vectorbool是假容器">为什么说vector&lt;bool&gt;是假容器❔</h3><p>它并不真的储存bool，相反，为了节省空间，它储存的是bool的紧凑表示，使用与位域（bitfield）一样的思想。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">bool</span>&gt; v;<br><span class="hljs-type">bool</span> *pb = &amp;v[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 错！表达式的右边是vector&lt;bool&gt;::reference*类型，而不是bool*类型</span><br></code></pre></td></tr></table></figure><p>标准C++库的bitset同样使用紧凑表示，但bitset不支持插入和删除，不支持迭代器，不被视为STL容器。</p><p>deque&lt;bool&gt;确实存bool。</p><h3 id="相等和等价的区别">相等和等价的区别❔</h3><p>相等（equality）的概念基于operator==，等价（equivalence）的概念基于operator&lt;。如果两个值中的任何一个（按照一定的<strong>排序准则</strong>）都不在另一个的前面，那么这两个值（按照这一准则）就是等价的。</p><p><strong>关联容器</strong>是基于等价而不是相等的，set的find成员函数使用等价概念，而非成员的find函数使用相等概念。</p><h3id="为什么总是要包含所有需要的头文件">为什么总是要包含所有需要的头文件❔</h3><p>C++标准与C的标准有所不同，它<strong>没有规定</strong>标准库中的头文件之间的相互包含关系。</p><p>不同的C++实现选择了不同的实现方式。可能一种实现里&lt;vector&gt;包含了&lt;string&gt;，虽然同时用到&lt;vector&gt;和&lt;string&gt;，但只需要包含&lt;vector&gt;。但其它实现不一定是这样。所以只要用到&lt;string&gt;就包含&lt;string&gt;，有助于代码移植。</p><h3 id="实现一个自旋锁">实现一个自旋锁❔</h3><p>注意，自旋锁互斥忙等会占用大量CPU时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">spinlock</span><br>&#123;<br>std::atomic_flag flag;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">spinlock_mutex</span>() : <span class="hljs-built_in">flag</span>(ATOMIC_FLAG_INIT)<br>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (flag.<span class="hljs-built_in">test_and_set</span>(std::memory_order_acquire))<br>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>flag.<span class="hljs-built_in">clear</span>(std::memory_order_release);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3id="为什么说浮点值的算术原子运算并不存在">为什么说浮点值的算术原子运算并不存在❔</h3><p>根据IEEE754浮点数标准，容许采用多种形式表示同一数值。如80.0可以表示成5*(2<sup>4)，也可以表示成20*(2</sup>2)。但<code>compare_exchange_weak</code>、<code>compare_exchange_strong</code>操作所采用的是bitwisecomparison，效果等同于直接使用<code>memcmp()</code>函数。</p><h3 id="原子操作的内存次序">原子操作的内存次序❔</h3><p>先后一致次序：<code>memory_order_seq_cst</code>。要求在所有线程间进行全局同步。常见的x86和x86-64提供了开销相对低的方式以维持先后一致，但weakly-orderedmachine（Alpha、ARM、PowerPC等）上开销较大。</p><p>获取-释放次序：<code>memory_order_consume</code>（C++17建议不用）、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code>。</p><p>宽松次序：<code>memory_order_relaxed</code>。无须任何额外的同步操作，线程间仅存的共有信息是每个变量的改动序列。</p><h2 id="内存管理-1">3 内存管理</h2><h3 id="内存分区">内存分区❔</h3><p>栈区：由编译器自动分配和释放，存放函数的参数值、局部变量的值等，大小受限于操作系统和硬件。</p><p>堆区：由程序员手动分配和释放，通常用于动态内存分配，其大小受限于系统可用的虚拟内存大小。</p><p>全局/静态区：存放全局变量、静态变量等，包括初始化和未初始化的数据，其大小由编译器决定。</p><p>常量区：存储常量，一般不允许修改。</p><p>代码区：存放程序的二进制码。</p><h3 id="结构体成员变量如何存放">结构体成员变量如何存放❔</h3><p>在不使用<code>#pragma pack(N)</code>宏的情况下：</p><ol type="1"><li><p>结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从<strong>自己</strong>大小的整数倍开始（比如int在32位机为4字节，则要从4的整数倍地址开始存储）。</p></li><li><p>结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。</p></li><li><p>结构体作为成员时，结构体成员要从其内部最大元素大小的整数倍地址开始存储。（structa里存有structb，b里有char、int、double等元素时，那么b应该从8的整数倍地址处开始存储，因为sizeof(double)= 8 bytes）</p></li></ol><p>若使用<code>#pragma pack(N)</code>宏，编译器按N值和上述对齐值中的<strong>较小值</strong>进行对齐。当N值大于等于所有数据成员长度的时候，宏不产生任何效果。</p><h3id="c03的auto_ptr为什么在c11被废弃">C++03的auto_ptr为什么在C++11被废弃❔</h3><p>C++03中并不支持移动语义，而<code>std::auto_ptr</code>却试图用复制构造函数来实现移动构造函数的功能，结果导致其无法与<code>vector</code>等容器兼容，论为失败品。</p><h3 id="宽度位域有何作用">0宽度位域有何作用❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stuff</span> <br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> field1: <span class="hljs-number">30</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>       : <span class="hljs-number">2</span>; <span class="hljs-comment">// 使用未命名位域显式填充（一个位域成员不允许跨越两个unsigned int的边界）。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> field2: <span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>       : <span class="hljs-number">0</span>; <span class="hljs-comment">// 0宽度位域，使下一个位域field3存在下一个unsigned int中。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> field3: <span class="hljs-number">3</span>; <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="c11">4 C++11</h2><h3 id="新类型">新类型❔</h3><p>支持64位（或更宽）的整型：<code>long long</code><code>unsigned long long</code></p><p>支持16位和32位的字符表示：<code>char_16t</code><code>char32_t</code></p><p>原始字符串：<code>cout &lt;&lt; R"(King)" &lt;&lt; endl;</code></p><h3 id="初始化列表">初始化列表❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = &#123;<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">double</span> y&#123;<span class="hljs-number">2.75</span>&#125;;<br><span class="hljs-type">short</span> quar[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">76</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stump</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> roots;<br>    <span class="hljs-type">double</span> weight;<br><span class="hljs-keyword">public</span>:<br>    Stump&#123;<span class="hljs-type">int</span> r, <span class="hljs-type">double</span> w) : <span class="hljs-built_in">roots</span>(r), <span class="hljs-built_in">weight</span>(w) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function">Stump <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">15.6</span>)</span></span>;<br>stump s2&#123;<span class="hljs-number">5</span>,<span class="hljs-number">43.4</span>&#125;;<br>Stump s3 = &#123;<span class="hljs-number">4</span>，<span class="hljs-number">32.1</span>&#125;;<br><span class="hljs-comment">// 如果类有将模板std::initializer_list作为参数的构造函数，则只有该构造函数可以使用列表初始化形式。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span> </span>;<br><span class="hljs-comment">// uninitialized vector with 10 elements</span><br>vector&lt;<span class="hljs-type">int</span>&gt; a2&#123;<span class="hljs-number">10</span>&#125;;<br><span class="hljs-comment">// initializer list, a2 has 1 element set to 10</span><br>vector&lt;<span class="hljs-type">int</span>&gt; a3&#123;<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>&#125;; <br><span class="hljs-comment">// 3 elements set to 4,6,1</span><br></code></pre></td></tr></table></figure><h3 id="声明">声明❔</h3><p>auto、decltype、返回类型后置、using别名、nullptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// auto</span><br><span class="hljs-keyword">for</span> (std::initializer_list&lt;<span class="hljs-type">double</span>&gt;::iterator p = i1.<span class="hljs-built_in">begin</span>(); p != i1.<span class="hljs-built_in">end</span>(); p++)<br><span class="hljs-comment">// 替换</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = i1.<span class="hljs-built_in">begin</span>(); p != i1.<span class="hljs-built_in">end</span>(); p++&#125;<br><br><span class="hljs-comment">// decltype</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> &amp;k = j;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;n = j;<br><span class="hljs-keyword">decltype</span>(n) i1; <span class="hljs-comment">// i1 type const int &amp;</span><br><span class="hljs-keyword">decltype</span>(j) i2; <span class="hljs-comment">// i2 type int</span><br><span class="hljs-keyword">decltype</span>((j)) i3; <span class="hljs-comment">// i3 type int &amp;</span><br><span class="hljs-keyword">decltype</span>(k + <span class="hljs-number">1</span>) i4; <span class="hljs-comment">// i4 type int</span><br><br><span class="hljs-comment">// 返回类型后置</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U)<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">eff</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(T*U)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 模板别名</span><br><span class="hljs-comment">// using可用于模板部分具体化，但typedef不能</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> arr12 = std::array&lt;T, <span class="hljs-number">12</span>&gt;; <span class="hljs-comment">// template for multiple aliases</span><br>arr12&lt;<span class="hljs-type">double</span>&gt; a1;<br><br><span class="hljs-comment">// nullptr</span><br><span class="hljs-comment">// 用于表示空指针，它是指针类型，不能转换为整型类型。不能将nullptr传给接受int参数的函数。</span><br><span class="hljs-comment">// 为向后兼容，C++11仍允许使用0来表示空指针，因此表达式nulptr==0为true。</span><br></code></pre></td></tr></table></figure><h3 id="智能指针">智能指针❔</h3><p>抛弃<code>auto_prt</code>，新增<code>shared_prt</code>、<code>unique_ptr</code>、<code>weak_ptr</code>。</p><p>所有新增的智能指针都能与STL容器和移动语义协同工作。</p><h3 id="异常规范">异常规范❔</h3><p>抛弃异常规范，新增<code>noexcept</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 抛弃</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f501</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(bad_dog)</span></span>; <span class="hljs-comment">// 可能抛出bad_dog类型的异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f733</span><span class="hljs-params">(<span class="hljs-number">1</span>ong <span class="hljs-type">long</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 不抛出异常</span><br><span class="hljs-comment">// 新增</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f875</span><span class="hljs-params">(<span class="hljs-type">short</span>, <span class="hljs-type">short</span>)</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// 不抛出异常</span><br></code></pre></td></tr></table></figure><h3 id="作用域内枚举">作用域内枚举❔</h3><p>旧形式的枚举，同一个作用域内两个枚举的枚举成员不能同名。</p><p>新形式的枚举，需要显式限定。<code>New1::never</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 旧形式</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">01d1</span> &#123;yes, no, maybe&#125;;<br><span class="hljs-comment">// 新形式</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Class</span> Newl &#123;never, sometimes, often, always&#125;;<br><span class="hljs-keyword">enum struct</span> <span class="hljs-title class_">New2</span> &#123;never, lever, sever&#125;;<br></code></pre></td></tr></table></figure><h3 id="类的变化">类的变化❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// explicit禁止单参数构造函数导致的自动转换（即隐式调用）</span><br><span class="hljs-comment">// C++11拓展了explicit的这种用法，使得可对转换函数做类似的处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Plebe</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span></span>; <span class="hljs-type">const</span>;<br>&#125;;<br>Plebe a, b;<br><span class="hljs-type">int</span> n = a;<br><span class="hljs-type">double</span> x = b; <span class="hljs-comment">// 不合法</span><br>x = <span class="hljs-built_in">double</span>(b) ;<br><br><span class="hljs-comment">// 类内成员初始化 (如有成员初始化列表，会被成员初始化列表覆盖)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span><br>&#123;<br>    <span class="hljs-type">int</span> mem1 = <span class="hljs-number">10</span>; <br>    <span class="hljs-type">double</span> mem2 &#123;<span class="hljs-number">1966.54</span>&#125;; <br>    <span class="hljs-type">short</span> mem3;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>()&#123;&#125;<br>    <span class="hljs-comment">// Session() : mem1(10), mem2(1966.54) &#123;&#125;</span><br>    <span class="hljs-built_in">Session</span>(<span class="hljs-type">short</span> s) : <span class="hljs-built_in">mem3</span>(s) &#123;&#125;<br>    <span class="hljs-built_in">Session</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">double</span> d, <span class="hljs-type">short</span> s) : <span class="hljs-built_in">mem1</span>(n), <span class="hljs-built_in">mem2</span>(d), <span class="hljs-built_in">mem3</span>(s) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 如果提供了析构函数、复制构造函数或复制赋值运算符，编译器将不会自动提供移动构造函数和移动赋值运算符；如果提供了移动构造函数或移动赋值运算符，编译器将不会自动提供复制构造函数和复制赋值运算符。</span><br><br><span class="hljs-comment">// 用关键字default显式声明6个特殊成员函数（构造，析构，复制构造，复制赋值，移动构造，移动赋值）的默认版本。</span><br><span class="hljs-comment">// 用关键字delete禁止编译器使用任何成员函数。</span><br><br><span class="hljs-comment">// 在一个构造函数的定义中使用另一个构造函数称为委托。可以利用成员初始化列表进行委托。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Notes</span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-type">double</span> x;<br>    std::string st;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Notes</span>();<br>    <span class="hljs-built_in">Notes</span>(<span class="hljs-type">int</span>) ;<br>    <span class="hljs-built_in">Notes</span>(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>);<br>    <span class="hljs-built_in">Notes</span>(<span class="hljs-type">int</span>，<span class="hljs-type">double</span>, std::string);<br>&#125;;<br>Notes::<span class="hljs-built_in">Notes</span>(<span class="hljs-type">int</span> kk, <span class="hljs-type">double</span> xx，std: :string stt) : <span class="hljs-built_in">k</span>(kk),<span class="hljs-built_in">x</span>(xx),<span class="hljs-built_in">st</span>(stt) &#123;<span class="hljs-comment">/* do stuff */</span>&#125;<br>Notes::<span class="hljs-built_in">Notes</span>() : <span class="hljs-built_in">Notes</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, <span class="hljs-string">&quot;Oh&quot;</span>) &#123;<span class="hljs-comment">/* do other stuff */</span>&#125;<br>Notes::<span class="hljs-built_in">Notes</span>(<span class="hljs-type">int</span> kk) : <span class="hljs-built_in">Notes</span>(kk, <span class="hljs-number">0.01</span>, <span class="hljs-string">&quot;Ah&quot;</span>) &#123;<span class="hljs-comment">/* do yet other stuff */</span>&#125;<br>Notes::<span class="hljs-built_in">Notes</span>(<span class="hljs-type">int</span> kk, <span class="hljs-type">double</span> xx ) : <span class="hljs-built_in">Notes</span>(kk, xx，<span class="hljs-string">&quot;Uh&quot;</span>&#125; &#123;<span class="hljs-comment">/* ditto */</span>&#125;<br>                                         <br><span class="hljs-comment">// C++98提供了一种让名称空间中函数可用的语法，C++11将这种方法用于构造函数。</span><br><span class="hljs-keyword">class</span> BS <br>&#123;<br>    <span class="hljs-type">int</span> q;<br>    <span class="hljs-type">double</span> w;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BS</span>() : <span class="hljs-built_in">q</span>(<span class="hljs-number">0</span>)， <span class="hljs-built_in">w</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">BS</span>(<span class="hljs-type">int</span> k) : <span class="hljs-built_in">q</span>(k), <span class="hljs-built_in">W</span>(<span class="hljs-number">100</span>) &#123;&#125;<br>    <span class="hljs-built_in">BS</span>(<span class="hljs-type">double</span> x) : <span class="hljs-built_in">q</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">w</span>(x) &#123;&#125;<br>    <span class="hljs-built_in">BS</span>(<span class="hljs-type">int</span> k，<span class="hljs-type">double</span> x) : <span class="hljs-built_in">q</span>(k)，<span class="hljs-built_in">W</span>(x) &#123;&#125;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">Show</span>() <span class="hljs-type">const</span> &#123;std::cout &lt;&lt; q &lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt; w &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> DR : <span class="hljs-keyword">public</span> BS<br>&#123;<br><span class="hljs-type">short</span> j;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> BS::BS; <br>    <span class="hljs-built_in">DR</span>() : <span class="hljs-built_in">j</span>(<span class="hljs-number">-100</span>) &#123;&#125;   <span class="hljs-comment">// DR needs its own default constructor</span><br>    <span class="hljs-built_in">DR</span>(<span class="hljs-type">double</span> x) : <span class="hljs-built_in">BS</span>(<span class="hljs-number">2</span>*x), <span class="hljs-built_in">j</span>(<span class="hljs-built_in">int</span>(x)) &#123;&#125;<br>    <span class="hljs-built_in">DR</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">j</span>(<span class="hljs-number">-2</span>), <span class="hljs-built_in">BS</span>(i,<span class="hljs-number">0.5</span>*i) &#123;&#125;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">Show</span>() <span class="hljs-type">const</span> &#123;std::cout &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>; BS::<span class="hljs-built_in">Show</span>();&#125;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-built_in">main</span>()<br>&#123;<br>    DR o1; <span class="hljs-comment">// use DR()</span><br>    DR <span class="hljs-built_in">o2</span>(<span class="hljs-number">18.81</span>); <span class="hljs-comment">// use DR(double) instead of BS(double)</span><br>    DR <span class="hljs-built_in">o3</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1.8</span>); <span class="hljs-comment">// use BS(int, double)</span><br>&#125;<br>                                         <br><span class="hljs-comment">// 参数列表后加上说明符override指出要覆盖一个虚函数</span><br><span class="hljs-comment">// 参数列表后加上说明符final指出禁止派生类覆盖特定的虚函数</span><br><span class="hljs-comment">// 说明符override和final并非关键字，而是具有特殊含义的标识符。这意味着编译器根据上下文确定它们是否有特殊含义：在其他上下文中，可将它们用作常规标识符，如变量名或枚举。</span><br></code></pre></td></tr></table></figure><h3 id="模板及stl">模板及STL❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 范围for</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">6</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x : v)<br>    x = std::<span class="hljs-built_in">rand</span>();<br><br><span class="hljs-comment">// 新STL容器</span><br><span class="hljs-comment">// forward list, unordered map, unordered multimap, unordered set, unordered multiset, array</span><br><br><span class="hljs-comment">// 新STL方法</span><br><span class="hljs-comment">// cbegin(), cend(), crbegin(), crend()</span><br><br><span class="hljs-comment">// valarray</span><br><span class="hljs-comment">// C++11添加了两个函数(begin()和end(),它们都接受valarray作为参数,返回迭代器,以应用基于范围的STL算法</span><br><br><span class="hljs-comment">// 废弃export</span><br><br><span class="hljs-comment">// C++11以前声明嵌套模板要求将&gt;&gt;用空格分开,C++11不再有该要求</span><br></code></pre></td></tr></table></figure><h3 id="移动语义">移动语义❔</h3><p><strong>右值引用</strong>使用<code>&amp;&amp;</code>表示，可关联到右值（即可出现在赋值表达式右边，但不能对其应用<strong>地址运算符</strong>的值）。</p><p><strong>右值</strong>包括字面常量（C风格字符串除外，它表示地址）、诸如x+y等表达式以及返回值的函数（条件是该函数返回的不是引用）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> y = <span class="hljs-number">23</span>;<br><span class="hljs-type">int</span> &amp;&amp; r1 = <span class="hljs-number">13</span>;<br><span class="hljs-type">int</span> &amp;&amp; r2 = x + y;<br><span class="hljs-type">double</span> &amp;&amp; r3 = std::<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2.0</span>);<br><span class="hljs-comment">// 将右值关联到右值引用导致该右值被存储到特定的位置，且可以获取该位置的地址。虽然不能将运算符&amp;用于13，但可将其用于r1。通过将数据与特定的地址关联，使得可以通过右值引用来访问该数据。</span><br></code></pre></td></tr></table></figure><p>引入右值引用后，值类别分为左值、纯右值、亡值。<ahref="https://zh.cppreference.com/w/cpp/language/value_category">值类别</a>。</p><p><code>std:move</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt; &amp;&amp;<span class="hljs-title">move</span><span class="hljs-params">(T &amp;&amp;t)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt; &amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std:forward</code>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T &amp;&amp;<span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt; &amp;t)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T &amp;&amp;&gt;(t);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T &amp;&amp;<span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt; &amp;&amp;t)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">static_assert</span>(!std::is_lvalue_reference_v&lt;T&gt;,<br>  <span class="hljs-string">&quot;std::forward must not be used to convert an rvalue to an lvalue&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T &amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lambda">Lambda❔</h3><p>在C++中引入lambda的主要目的是，能够将类似于函数的表达式用作接受函数指针或函数对象的函数的参数。</p><h3 id="包装器">包装器❔</h3><p>C++11提供了<code>bind</code>、<code>men_fn</code>、<code>reference_wrapper</code>、<code>function</code>。<code>bind</code>可替代<code>bind1st</code>和<code>bind2nd</code>，但更灵活；<code>mem_fn</code>能够将成员函数作为常规函数进行传递；<code>reference_wrapper</code>能够创建行为像引用但可被复制的对象；<code>function</code>能够以统一的方式处理多种类似于函数（函数指针、函数对象、lambda）的形式（减少以函数为参数的模板的实例化次数）。</p><h3 id="可变参数模板">可变参数模板❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// definition for 0 parameters</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_list</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// definition for 1 parameter</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_list</span> <span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span></span><br><span class="hljs-function"></span>&#123;<br>    std: :cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> ;<br>&#125;<br><br><span class="hljs-comment">// definition for 2 or more parameters</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_list</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value, <span class="hljs-type">const</span> Args&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    <span class="hljs-built_in">show_list</span>(args...);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，当多个可变参数模板重载时，优先选择更特化的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 优先</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;firstArg, <span class="hljs-type">const</span> Args &amp;...args)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; firstArg &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>...(args) &lt;&lt; std::endl; <span class="hljs-comment">// sizeof ... args代表获取参数个数</span><br><span class="hljs-built_in">print</span>(args...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> Types &amp;...args)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;never&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">A 2</span><br><span class="hljs-comment">B 1</span><br><span class="hljs-comment">C 0</span><br><span class="hljs-comment">end</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="并发编程">并发编程❔</h3><p>原子操作库提供了头文件<code>atomic</code>，线程支持库提供了头文件<code>thread</code>、<code>mutex</code>、<code>condition_variable</code>和<code>future</code>。</p><p>《C++并发编程实战》第二版中各并发程序库的简要对比：</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2024-01-19-comparison-of-concurrent-libraries.jpg" /></p><h2 id="c14">5 C++14</h2><h3 id="变量模板">变量模板❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">constexpr</span> T kPI = <span class="hljs-built_in">T</span>(<span class="hljs-number">3.1415926535897932385</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; kPI&lt;<span class="hljs-type">int</span>&gt; &lt;&lt; std::endl;<br>std::cout &lt;&lt; kPI&lt;<span class="hljs-type">double</span>&gt; &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="decltypeauto">decltype(auto)❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// C++11</span><br><span class="hljs-comment">// template &lt;typename T, typename U&gt;</span><br><span class="hljs-comment">// auto func(T &amp;&amp;t, U &amp;&amp;u) -&gt; decltype(std::forward&lt;T&gt;(t) + std::forward&lt;U&gt;(u))</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// return std::forward&lt;T&gt;(t) + std::forward&lt;U&gt;(u);</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-comment">// C++14</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">func</span><span class="hljs-params">(T &amp;&amp;t, U &amp;&amp;u)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> std::forward&lt;T&gt;(t) + std::forward&lt;U&gt;(u);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.</span>) &lt;&lt; std::endl;<br>std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.</span>)), <span class="hljs-type">double</span>&gt; &lt;&lt; std::endl; <span class="hljs-comment">// true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="智能指针-1">智能指针❔</h3><p>补充了<code>make_unique</code>。</p><h2 id="c17">6 C++17</h2><h3 id="折叠表达式">折叠表达式❔</h3><p>不使用显式递归的情况下使用可变参数模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(Args... args)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (... + args);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译期if">编译期if❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N, <span class="hljs-type">int</span>... Ns&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-number">0</span> == <span class="hljs-keyword">sizeof</span>...(Ns))</span></span><br><span class="hljs-function"><span class="hljs-keyword">return</span> N</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> N + <span class="hljs-built_in">sum</span>&lt;Ns...&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-built_in">sum</span>&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&gt;() &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pmr">PMR❔</h3><p>PMR即polymorphic memoryresource，使用<code>std::pmr</code>命名空间下的<code>polymorphic_allocator</code>和<code>memory_resource</code>等类型，可以逐对象而不是逐类型指定内存分配器类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory_resource&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::array&lt;std::byte, 200000&gt; buf;<br>    std::pmr::monotonic_buffer_resource pool&#123;buf.<span class="hljs-built_in">data</span>(), buf.<span class="hljs-built_in">size</span>()&#125;;<br><br>    <span class="hljs-keyword">using</span> basic_string = std::basic_string&lt;<span class="hljs-type">char</span>, std::char_traits&lt;<span class="hljs-type">char</span>&gt;, std::pmr::polymorphic_allocator&lt;<span class="hljs-type">char</span>&gt;&gt;;<br><br>    std::vector&lt;std::basic_string&lt;<span class="hljs-type">char</span>, std::char_traits&lt;<span class="hljs-type">char</span>&gt;, std::pmr::polymorphic_allocator&lt;<span class="hljs-type">char</span>&gt;&gt;,<br>                std::pmr::polymorphic_allocator&lt;std::basic_string&lt;<span class="hljs-type">char</span>, std::char_traits&lt;<span class="hljs-type">char</span>&gt;, std::pmr::polymorphic_allocator&lt;<span class="hljs-type">char</span>&gt;&gt;&gt;&gt;<br>        <span class="hljs-built_in">coll</span>(&amp;pool);<br>    <span class="hljs-comment">// 简写为 std::pmr::vector&lt;std::pmr::string&gt; coll(&amp;pool);</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i)<br>    &#123;<br>        coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;just a non-SSO string&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何利用缓存行大小">如何利用缓存行大小❔</h3><p><code>std::hardware_destructive_interference_size</code>：作为两个对象之间的偏移量，以避免由于不同线程的不同运行时访问模式而导致的破坏性干扰（假共享）。</p><p><code>std::hardware_constructive_interference_size</code>：作为两个对象的组合内存占用大小和基本对齐的限制，以促进它们之间的构造性干扰（真共享）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">keep_apart</span><br>&#123;<br><span class="hljs-built_in">alignas</span>(std::hardware_destructive_interference_size) std::atomic&lt;<span class="hljs-type">int</span>&gt; a;<br><span class="hljs-built_in">alignas</span>(std::hardware_destructive_interference_size) std::atomic&lt;<span class="hljs-type">int</span>&gt; b;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">together</span><br>&#123;<br>std::atomic&lt;<span class="hljs-type">int</span>&gt; a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kennel</span><br>&#123;<br><span class="hljs-comment">// 其它数据成员</span><br><span class="hljs-built_in">alignas</span>(<span class="hljs-built_in">sizeof</span>(together)) together pack;<br>&#125;;<br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(together) &lt;= std::hardware_constructive_interference_size);<br></code></pre></td></tr></table></figure><p><ahref="https://en.cppreference.com/w/cpp/thread/hardware_destructive_interference_size">std::hardware_destructive_interference_size,std::hardware_constructive_interference_size - cppreference.com</a></p><p><ahref="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0154r1.html">P0154R1constexpr std::hardware_{constructive,destructive}_interference_size(open-std.org)</a></p><h2 id="c20">7 C++20</h2><h3 id="协程">协程❔</h3><p>参见笔记：<ahref="https://reddish.fun/posts/Article/CPP-Coroutine/">C++协程 -Homeworld</a></p><h3 id="consteval和constinit">consteval和constinit❔</h3><p>当函数声明为constexpr时，只有当其所有参数都是编译期常量时，返回值才是编译期常量。</p><p>consteval仅用于函数的声明，且调用该函数使用的参数<strong>必须</strong>是编译期常量，以保证该函数一定在编译期计算。</p><p>constinit声明拥有静态或线程存储期的变量，不能和constexpr或consteval一同使用。声明引用时，constinit等价于constexpr；声明对象时，constexpr强制对象为const，而constinit不要求。</p><h3 id="三路比较运算符">三路比较运算符❔</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;compare&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">auto</span> <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Point &amp;) <span class="hljs-type">const</span> = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Point pt1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, pt2&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>std::set&lt;Point&gt; s;<br>s.<span class="hljs-built_in">insert</span>(pt1);<br><br>std::cout &lt;&lt; std::boolalpha<br>  &lt;&lt; (pt1 == pt2) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>  <span class="hljs-comment">// false，operator==被隐式预置</span><br>  &lt;&lt; (pt1 != pt2) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>  <span class="hljs-comment">// true</span><br>  &lt;&lt; (pt1 &lt;  pt2) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>  <span class="hljs-comment">// true</span><br>  &lt;&lt; (pt1 &lt;= pt2) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>  <span class="hljs-comment">// true</span><br>  &lt;&lt; (pt1 &gt;  pt2) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>  <span class="hljs-comment">// false</span><br>  &lt;&lt; (pt1 &gt;= pt2) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://en.cppreference.com/w/cpp/language/default_comparisons">Defaultcomparisons (since C++20) - cppreference.com</a></p><h3 id="约束模板类型">约束模板类型❔</h3><p>利用concept约束模板类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// C++11</span><br><span class="hljs-comment">// template &lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, T&gt; = 0&gt;</span><br><span class="hljs-comment">// T add(T a, T b)</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// return a + b;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// C++20</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> integral = std::is_integral_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;integral T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ Primer》第五版笔记</title>
      <link href="//posts/Notebook/CPPPrimer-5th-note/"/>
      <url>//posts/Notebook/CPPPrimer-5th-note/</url>
      
        <content type="html"><![CDATA[<p>Stanley B. Lippman，Josée Lajoie，Barbara E. Moo 著</p><span id="more"></span><p>王刚，杨巨峰 译</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-C%2B%2BPrimer_s.jpg"alt="封面" /><figcaption aria-hidden="true">封面</figcaption></figure><p class="note note-primary">摘录整理。</p><h2 id="推荐序1">推荐序1</h2><p>第5版之于2011版标准，如同第3版之于1998版标准，必将成为经典的学习读本。</p><p>第5版则更加像一本学习教程，由浅入深，并结合大量代码实例来讲述C++语法和标准库。</p><p>学习语言的一个境界是把自己想象成编译器。</p><p>本书的另一个特色是将C++的语法和标准库融为一体来介绍。C++标准库本身就是C++语法的最佳样例，其中包含不少C++高级特性的指导性用法。在我的程序设计经历中，<strong>有些C++语言特性（比如虚拟继承），我只在标准库中看到过实用做法</strong>。</p><p>在实践中，不必全面地使用C++语言的各种特性，而应根据工程项目的实际情况，适当取舍（譬如动态类型信息、虚拟继承、异常等特性的使用很值得商榷）。通常只鼓励使用C++语言的一个子集就够了，<strong>一个值得学习和参考的例子是Google发布的GoogleC++ Style Guide</strong>。</p><h2 id="推荐序2">推荐序2</h2><p>编译器实现的速度也令人惊喜。短短两年时间，从开源的GCC、LLVM到专有的VisualC++和IntelC++，对于新标准的追踪之快，覆盖之全，与当年C++98标准颁布之后迟迟不能落地的窘境相比，可谓对比强烈。</p><p>一种优秀的编程语言，一定要对于计算这件事情实现一个完整和自洽的抽象。</p><p>而C语言之所以四十年长盛不衰，根本在于它对于现代计算机提供了一个<strong>底层的高级抽象</strong>：凡是比它低的抽象都过于简陋，凡是比它高的抽象都可以用C语言构造出来。</p><p>每当你需要走下去直接与硬件对话时，C++成为C之外唯一有效率的选择。</p><p>C++同时支持4种不同的编程风格：<strong>C风格、基于对象、面向对象和泛型</strong>。事实上，把微软的COM也算进来的话，还可以加上一种“基于组件”的风格。</p><p>每一个具体的技术领域，只需要读四五本书就够了。以前的C++是个例外，因为语言设计有缺陷，所以要读很多书才知道如何绕过缺陷。现在的C++11完全可以了，大家读四五本书就可以达到合格的水平，这恰恰是语言进步的体现。</p><p>本书是这四五本中的一本，而且是“教程+参考书”，扛梁之作，初学者的不二法门。另一本是《C++标准程序库》，对于C++熟手来说更为快捷。ScottMeyers的EffectiveC++永远是学习C++者必读的，只不过这本书的第4版不知道什么时候出来。AnthonyWilliams的C++ Concurrency inAction是学习用标准C++开发并发程序的最佳选择。国内的作品，我则高度推荐陈硕的《Linux多线程服务端编程》。这本书的名字赶跑了不少潜在的读者，所以我要特别说明一下。这本书是C++开发的高水平作品，与其说是教你怎么用C++写服务端开发，不如说是教你如何以服务端开发为例子提升C++开发水平。前面几本书都是谈标准C++自己的事情，碰到像iostream这样失败的标准组件也不得不硬着头皮介绍。而这本书是接地气的实践结晶，告诉你面对具体问题时应怎样权衡，C++里什么好用，什么不好用，为什么，等等。</p><h2 id="前言">前言</h2><p>2011年，C++标准委员会发布了ISOC++标准的一个重要修订版。此修订版是C++进化过程中的最新一步，延续了前几个版本对编程效率的强调。新标准的主要目标是：</p><ul><li>使语言更为统一，更易于教学。</li><li>使标准库更简单、安全、使用更高效。</li><li>使编写高效率的抽象和库变得更简单。</li></ul><p>现代C++语言可以看作是<strong>三部分</strong>组成的：</p><ul><li>低级语言，大部分继承自C语言。</li><li>现代高级语言特性，允许我们定义自己的类型以及组织大规模程序和系统。</li><li>标准库，它利用高级特性来提供有用的数据结构和算法。</li></ul><p><ahref="http://www.informit.com/title/0321714113">扩展示例的源码</a>，在书本下方的download选项卡里下载。</p><h2 id="第1章-开始">第1章 开始</h2><h3 id="编写一个简单的c程序">1.1 编写一个简单的C++程序</h3><p>一个<strong>函数的定义</strong>包含四部分：返回类型（returntype）、函数名（function name）、一个括号包围的形参列表（parameterlist，允许为空）以及函数体（function body）。</p><p>在大多数系统中，main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。</p><p><strong>命令行运行编译器</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ CC prog1.cc<br></code></pre></td></tr></table></figure><p>CC是编译器程序的名字，$是系统提示符。编译器生成一个可执行文件。Windows系统会将这个可执行文件命名为prog1.exe。UNIX系统中的编译器通常将可执行文件命名为a.out。在Windows下执行可以忽略其扩展名.exe，在一些系统中需要用<spanclass="math inline">\(./\)</span>显式指出其位于当前目录。</p><p>访问main的返回值的方法依赖于系统。在UNIX和Windows系统中，执行完一个程序后，都可以通过echo命令获得其返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在UNIX系统中，通过如下命令获得状态：</span><br>$ <span class="hljs-built_in">echo</span> $?<br><span class="hljs-comment"># 在Windows系统中查看状态可键入：</span><br>$ <span class="hljs-built_in">echo</span> %ERRORLEVEL%<br></code></pre></td></tr></table></figure><p>默认情况下，运行GNU编译器的命令是g++：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ g++ -o prog1 prog1.cc<br></code></pre></td></tr></table></figure><p>-oprog1是编译器参数，指定了可执行文件的文件名。在不同的操作系统中，此命令生成一个名为prog1或prog1.exe的可执行文件。在UNIX系统中，可执行文件没有后缀；在Windows系统中，后缀为.exe。如果省略了-oprog1参数，在UNIX系统中编译器会生成一个名为a.out的可执行文件，在Windows系统中则会生成一个名为a.exe的可执行文件。</p><p>根据使用的GNU编译器的版本，你可能需要指定-std=c++0x参数来打开对C++11的支持。</p><h3 id="初识输入输出">1.2 初识输入输出</h3><p>cin、cout、cerr、clog</p><p>写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 等价</span><br>std::cout &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; std::flush;<br>std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; std::<span class="hljs-built_in">fflush</span>(stdout);<br></code></pre></td></tr></table></figure><h3 id="注释简介">1.3 注释简介</h3><p>C++中有两种注释：单行注释和界定符对注释。</p><ul><li>单行注释以双斜线（//）开始，以换行符结束。当前行双斜线右侧的所有内容都会被编译器忽略，这种注释可以包含任何文本，包括额外的双斜线。</li><li>另一种注释使用继承自C语言的两个界定符（/＊和＊/）。这种注释以/＊开始，以＊/结束，可以包含除＊/外的任意内容，包括换行符。编译器将落在/＊和＊/之间的所有内容都当作注释。</li></ul><p>注释风格：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This file contains code from &quot;C++ Primer, Fifth Edition&quot;, by Stanley B.</span><br><span class="hljs-comment"> * Lippman, Josee Lajoie, and Barbara E. Moo, and is covered under the</span><br><span class="hljs-comment"> * copyright and warranty notices given in that book:</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * &quot;Copyright (c) 2013 by Objectwrite, Inc., Josee Lajoie, and Barbara E. Moo.&quot;</span><br><span class="hljs-comment">*/</span> <br></code></pre></td></tr></table></figure><p>注释界定符不能嵌套！单行注释会忽略一切。</p><h3 id="控制流">1.4 控制流</h3><p>while、for、if</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 遇到文件结束符结束。在Windows系统中，输入文件结束符的方法是敲Ctrl+Z（按住Ctrl键的同时按Z键），然后按Enter或Return键。在UNIX系统中，包括Mac OS X系统中，文件结束符输入是用Ctrl+D。</span><br><span class="hljs-keyword">while</span> (std::cin &gt;&gt; value) <br>    ...<br></code></pre></td></tr></table></figure><h3 id="类简介">1.5 类简介</h3><p>成员函数是定义为类的一部分的函数，有时也被称为方法（method）。</p><h3 id="书店程序">1.6 书店程序</h3><p>无。</p><h1 id="第ⅰ部分-c基础">第Ⅰ部分 C++基础</h1><h2 id="第2章-变量和基本类型">第2章 变量和基本类型</h2><h3 id="基本内置类型">2.1 基本内置类型</h3><p>C++定义了一套包括<strong>算术类型</strong>（arithmetictype）和<strong>空类型</strong>（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。</p><p>大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。在C++语言中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。</p><p>如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为<strong>带符号数会自动地转换成无符号数</strong>。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-28-literal.png" /></p><h3 id="变量">2.2 变量</h3><p>在C++语言中，<strong>初始化</strong>是一个异常复杂的问题，我们也将反复讨论这个问题。很多程序员对于用等号=来初始化变量的方式倍感困惑，这种方式容易让人认为初始化是赋值的一种。事实上在C++语言中，初始化和赋值是两个完全不同的操作。然而在很多编程语言中二者的区别几乎可以忽略不计，即使在C++语言中有时这种区别也无关紧要，所以人们特别容易把二者混为一谈。</p><p><strong>初始化不是赋值</strong>，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 4种初始化方式</span><br><span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> a&#123;pi&#125;, b = &#123;pi&#125;; <span class="hljs-comment">// 会因为存在信息丢失的危险导致报错</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(pi)</span>, d </span>= pi;  <span class="hljs-comment">// 不报错，正常执行</span><br></code></pre></td></tr></table></figure><p>使用{}初始化被称为<strong>列表初始化</strong>（listinitialization）。在 C++11中，初始化列表的适用性被大大增加了。它可以用于任何类型对象的初始化。</p><p>定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的（参见2.1.2节，第33页），如果试图拷贝或以其他形式访问此类值将引发错误。</p><p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持<strong>分离式编译</strong>（separatecompilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p><p>为了支持分离式编译，C++语言将声明和定义区分开来。<strong>声明</strong>（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<strong>定义</strong>（definition）负责创建与名字关联的实体。变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;  <span class="hljs-comment">// 声明i而非定义i</span><br><span class="hljs-type">int</span> j;  <span class="hljs-comment">// 声明并定义j</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 定义</span><br></code></pre></td></tr></table></figure><p>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p><p>变量能且只能被定义一次，但是可以被多次声明。</p><p>如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p><p>C++是一种<strong>静态类型</strong>（staticallytyped）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（typechecking）。</p><p><strong>作用域</strong>（scope）是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p><p>因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。</p><h3 id="复合类型">2.3 复合类型</h3><p>复合类型（compoundtype）是指基于其他类型定义的类型。C++语言有几种复合类型，本章将介绍其中的两种：<strong>引用和指针</strong>。</p><p><strong>引用</strong></p><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。因为引用本身不是一个对象，所以不能定义引用的引用。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。</p><p>除了2.4.1节（第55页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象<strong>严格匹配</strong>。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p><blockquote><p>第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。这是因为编译器创建了一个<strong>临时变量</strong>作为绑定的中间值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = i; <span class="hljs-comment">// 正确</span><br><span class="hljs-comment">// 相当于 const int temp = i; cosnt int &amp;r1 = temp; 因此i和r1的类型可以不一致</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span> &amp;r4 = r1 * <span class="hljs-number">2</span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>第二种例外情况是，我们可以将基类的指针或引用绑定到派生类对象上。</p></blockquote><p><strong>指针</strong></p><p>其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p><p>除了2.4.2节（第56页）和15.2.3节（第534页）将要介绍的两种例外情况，其他所有指针的类型都要和它所指向的对象<strong>严格匹配</strong>。</p><blockquote><p>第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> *cptr = &amp;pi;<br></code></pre></td></tr></table></figure><p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。<strong>所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</strong></p><p>第二种例外情况是，我们可以将基类的指针或引用绑定到派生类对象上。</p></blockquote><p><strong>空指针</strong></p><p>得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。过去的程序还会用到一个名为NULL的预处理变量（preprocessorvariable）来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。</p><p><strong>预处理变量</strong>不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须在前面加上std::。</p><p>以void＊的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象，关于这点将在19.1.1节（第726页）有更详细的介绍，4.11.3节（第144页）将讲述获取void＊指针所存地址的方法。</p><blockquote><p>当我们把指针存放在void＊中，并且使用static_cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，因此我们必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。</span><br><span class="hljs-comment">// 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> *p;<br><span class="hljs-type">int</span> *&amp;r = p; <span class="hljs-comment">// r是一个对指针p的引用</span><br>r = &amp;i; <span class="hljs-comment">// 令p指向i</span><br>*r = <span class="hljs-number">0</span>; <span class="hljs-comment">// 将i改为0</span><br></code></pre></td></tr></table></figure><h3 id="const限定符">2.4 const限定符</h3><p>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</p><p>默认状态下，const对象仅在文件内有效。</p><p>如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p><p><strong>const的引用</strong></p><p>可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为<strong>对常量的引用</strong>（referencetoconst）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</p><p>对const的引用可能引用一个并非const的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;r1 = i; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = i;<br>r1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 正确，r2代表的值也已为0</span><br>r2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><blockquote><p>（自己补充的例子）</p><p>由于前面2.3中提到的引用绑定的例外情况，对常量的引用会存在以下情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = i;<br>i = <span class="hljs-number">0</span>;<br>cout &lt;&lt; r1 &lt;&lt; endl;<br><span class="hljs-comment">// 42</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = j;<br>j = <span class="hljs-number">0</span>;<br>cout &lt;&lt; r2 &lt;&lt; endl;<br><span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>指针和const</strong></p><p>用名词<strong>顶层const</strong>（top-levelconst）表示指针本身是个常量，而用名词<strong>底层const</strong>（low-levelconst）表示指针所指的对象是一个常量。</p><p><strong>更一般的</strong>，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p1 = &amp;i;  <span class="hljs-comment">// 顶层const,p1不能改变</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">42</span>; <span class="hljs-comment">// 顶层const,ci不能改变</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;ci; <span class="hljs-comment">// 底层const,p2可以改变</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = p2; <span class="hljs-comment">// 右边是顶层const,左边是底层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r = ci;  <span class="hljs-comment">// 用于声明引用的const都是底层const</span><br><span class="hljs-comment">// 当执行对象的拷贝操作时,顶层const不受什么影响</span><br>i = ci;  <span class="hljs-comment">// 正确</span><br>p2 = p3; <span class="hljs-comment">// 正确</span><br><span class="hljs-comment">// 拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行</span><br><span class="hljs-type">int</span> *p = p3;  <span class="hljs-comment">// 错误，p3包含底层const，p没有</span><br>p2 = p3; <span class="hljs-comment">// 正确，p2、p3都是底层const</span><br>p2 = &amp;i;  <span class="hljs-comment">// 正确，int * 可以转化为 const int *</span><br><span class="hljs-type">int</span> &amp;r = ci;  <span class="hljs-comment">// 普通的int&amp;不能绑定到int常量上</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = i; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p><strong>constexpr和常量表达式</strong></p><p>常量表达式（constexpression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> m = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 是</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 是</span><br><span class="hljs-type">int</span> s = <span class="hljs-number">24</span>; <span class="hljs-comment">// 不是</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> p = <span class="hljs-built_in">cal_p</span>(); <span class="hljs-comment">// 不是</span><br></code></pre></td></tr></table></figure><p>在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿。</p><p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。</p><p>常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“<strong>字面值类型</strong>”（literaltype）。其他一些字面值类型将在7.5.6节（第267页）和19.3节（第736页）介绍。</p><blockquote><p>除了算术类型、引用和指针外，某些类也是字面值类型。和其他类不同，字面值类型的类可能含有constexpr函数成员。这样的成员必须符合constexpr函数的所有要求，它们是隐式const的（参见7.1.2节，第231页）。</p><p>枚举属于字面值常量类型（参见7.5.6节，第267页）。</p></blockquote><p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。</p><p>（constexpr只能写在指针左边。）</p><h3 id="处理类型">2.5 处理类型</h3><p>有两种方法可用于定义类型别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 传统的方法是使用关键字typedef</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> wages;  <span class="hljs-comment">// wages是double的同义词</span><br><span class="hljs-keyword">typedef</span> wages base, *p; <span class="hljs-comment">// base是double的同义词，p是double*的同义词</span><br><span class="hljs-comment">// 别名声明（alias declaration）</span><br><span class="hljs-keyword">using</span> SI = Sales_item;<br></code></pre></td></tr></table></figure><p>不能用简单的代换来理解别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *pstring;<br><span class="hljs-type">const</span> pstring cstr = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 指向char的常量指针</span><br><span class="hljs-comment">// 不应该理解为const char *cstr  = 0;</span><br><span class="hljs-comment">// 声明语句中用到pstring时，其基本数据类型是指针。可是用char＊重写了声明语句后，数据类型就变成了char，＊成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。</span><br><span class="hljs-type">const</span> pstring *ps; <span class="hljs-comment">// 该指针的对象是指向char的常量指针</span><br></code></pre></td></tr></table></figure><p><strong>auto</strong></p><p>编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p><p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的<strong>初始基本数据类型</strong>都必须一样<strong>（符号&amp;和＊只从属于某个声明符，而非基本数据类型的一部分）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i; <span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><ul><li><p>对引用对象，编译器以它引用的类型作为auto的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, &amp;r = i;<br><span class="hljs-keyword">auto</span> a = r; <span class="hljs-comment">// a是整数</span><br></code></pre></td></tr></table></figure></li><li><p><strong>auto一般会忽略掉顶层const，同时底层const则会保留下来。</strong>如果希望推断出的auto类型是一个顶层const，需要明确指出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i, &amp;cr = ci;<br><span class="hljs-keyword">auto</span> b = ci; <span class="hljs-comment">// b是整数（顶层const，忽略）</span><br><span class="hljs-keyword">auto</span> c = cr; <span class="hljs-comment">// c是整数</span><br><span class="hljs-keyword">auto</span> d = &amp;i; <span class="hljs-comment">// d是整数指针</span><br><span class="hljs-keyword">auto</span> e = &amp;ci; <span class="hljs-comment">// e是指向整数常量的指针（对常量对象取地址是底层const）</span><br><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> f = ci; <span class="hljs-comment">// f是const int</span><br><br><span class="hljs-comment">// 设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留。</span><br><span class="hljs-keyword">auto</span> &amp;g = ci; <span class="hljs-comment">// g是整数常量引用</span><br><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>; <span class="hljs-comment">// 错误，不能为非常量引用绑定字面值</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span>; <span class="hljs-comment">// 正确</span><br><br><span class="hljs-comment">// 续初始基本数据类型一致原则</span><br><span class="hljs-keyword">auto</span> k = ci, &amp;l = i; <span class="hljs-comment">//k是整数,l是整型引用</span><br><span class="hljs-keyword">auto</span> &amp;m = ci, *p = &amp;ci; <span class="hljs-comment">//m是整型常量引用,p是指向整型常量的指针</span><br><span class="hljs-keyword">auto</span> &amp;n = i, *p2 = &amp;ci; <span class="hljs-comment">//错误，不一致</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>decltype</strong></p><p>希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。</p><p>decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<br><span class="hljs-keyword">decltype</span>(r+<span class="hljs-number">0</span>) b;  <span class="hljs-comment">// 正确，b是一个未初始化的int。decltype(r)是引用，decltype(r+0)不是。</span><br><span class="hljs-keyword">decltype</span>(*p) c;  <span class="hljs-comment">// 错误，c是int&amp;,必须初始化。如果表达式的内容是解引用操作，则decltype将得到引用类型。</span><br><br><span class="hljs-keyword">decltype</span>((i)) d; <span class="hljs-comment">// 错误，d是int&amp;,必须初始化。decltype((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</span><br><span class="hljs-keyword">decltype</span>(i) e;  <span class="hljs-comment">// 正确，e是一个未初始化的int。</span><br></code></pre></td></tr></table></figure><h3 id="自定义数据结构">2.6 自定义数据结构</h3><p>C++11新标准规定，可以为数据成员提供一个<strong>类内初始值</strong>（in-classinitializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。</p><p>头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。</p><p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p><p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>（preprocessor），它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。</p><ul><li>#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。</li><li>头文件保护符（headerguard），头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。</li></ul><p>头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。</p><h2 id="第3章-字符串向量和数组">第3章 字符串、向量和数组</h2><h3 id="命名空间的using声明">3.1 命名空间的using声明</h3><p><strong>位于头文件的代码一般来说不应该使用using声明。</strong>这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。</p><h3 id="标准库类型string">3.2 标准库类型string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化</span><br>string s1; <span class="hljs-comment">// 默认初始化，空串</span><br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>; <span class="hljs-comment">// 直接初始化，s2是s1的副本</span><br>string s2 = s1; <span class="hljs-comment">// 拷贝初始化，s2是s1的副本</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>; <span class="hljs-comment">// 直接初始化，s3是字面值&quot;value&quot;的副本，除了字面值最后那个空字符外</span><br><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;c&#x27;</span>)</span></span>; <span class="hljs-comment">// 直接初始化，s4是cccc</span><br><span class="hljs-comment">//操作</span><br>os&lt;&lt;s; <br>is&gt;&gt;s;<br><span class="hljs-built_in">getline</span>(is,s);<br>s.<span class="hljs-built_in">empty</span>();<br>s.<span class="hljs-built_in">size</span>();<br>s[n];<br>s1+s1;<br>s1=s2;<br>s1==s2;<br>s1!=s2;<br>&lt;,&lt;=,&gt;,&gt;= <span class="hljs-comment">//字典序比较，大小写敏感</span><br></code></pre></td></tr></table></figure><p>在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。</p><p>getline从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。</p><p><strong>string::size_type</strong>类型</p><p>string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。无符号整型数，勿要与带符号数混用，例如比大小。</p><p>因为某些历史原因，也为了与C兼容，所以<strong>C++语言中的字符串字面值并不是标准库类型string的对象</strong>。切记，字符串字面值与string是不同的类型。当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。</p><p>一般来说，<strong>C++程序应该使用名为cname的头文件而不使用name.h的形式</strong>，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。</p><h3 id="标准库类型vector">3.3 标准库类型vector</h3><p>因为vector“容纳着”其他对象，所以它也常被称作容器（container）。</p><p>vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector&lt;int&gt;。</p><p>早期版本的C++标准中如果vector的元素还是vector（或者其他模板类型），则其定义的形式与现在的C++11新标准略有不同。过去，必须在外层vector对象的右尖括号和其元素类型之间添加一个空格，如应该写成vector&lt;vector&lt;int&gt;&gt;而非vector&lt;vector&lt;int&gt;&gt;。</p><p>C++语言提供了几种不同的初始化方式，在大多数情况下这些初始化方式可以相互等价地使用，<strong>三个例外</strong>：</p><ol type="1"><li>使用拷贝初始化时（即使用=时），只能提供一个初始值；</li><li>如果提供的是一个<strong>类内初始值</strong>，则只能使用拷贝初始化或使用花括号的形式初始化；</li><li>如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 10个0</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v2&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">// 10</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 10个1</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v4&#123;<span class="hljs-number">10</span>,<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 10，1</span><br><span class="hljs-comment">// 只有在无法执行列表初始化时才会考虑其他初始化方式。</span><br>vector&lt;string&gt; v5&#123;<span class="hljs-string">&quot;hi&quot;</span>&#125;; <span class="hljs-comment">// &quot;hi&quot;</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v6</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>)</span></span>; <span class="hljs-comment">// 错误</span><br>vector&lt;string&gt; v7&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//  10个&quot;&quot;</span><br>vector&lt;string&gt; v8&#123;<span class="hljs-number">10</span>,<span class="hljs-string">&quot;hi&quot;</span>&#125;; <span class="hljs-comment">// 10个&quot;hi&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;::size_type <span class="hljs-comment">// 正确</span><br>vector::size_type <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><h3 id="迭代器介绍">3.4 迭代器介绍</h3><p>原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！=而非&lt;进行判断有点儿奇怪。C++程序员习惯性地使用!=，是因为因为这种编程风格在标准库提供的所有容器上都有效。所有标准库容器的迭代器都定义了==和!=，但是它们中的大多数都没有定义&lt;运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; cv;<br><span class="hljs-keyword">auto</span> it1 = v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// vector&lt;int&gt;::iterator</span><br><span class="hljs-keyword">auto</span> it2 = cv.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// vector&lt;int&gt;::const_iterator</span><br><span class="hljs-keyword">auto</span> it3 = v.<span class="hljs-built_in">cbegin</span>(); <span class="hljs-comment">// vector&lt;int&gt;::const_iterator</span><br></code></pre></td></tr></table></figure><p>箭头运算符 -&gt; 把解引用和成员访问两个操作结合在一起：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 等价</span><br>it-&gt;mem;<br>(*it).mem;<br></code></pre></td></tr></table></figure><p>谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</p><p>迭代器相减得到类型名为<strong>difference_type</strong>的带符号整型数。</p><h3 id="数组">3.5 数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</span><br><span class="hljs-type">int</span> *ptr[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 含有10个整型指针的数组</span><br><span class="hljs-type">int</span> &amp;refs[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 错误，不存在引用的数组</span><br><span class="hljs-built_in">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-comment">// Parray指向一个含有10个整数的数组</span><br><span class="hljs-built_in">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr; <span class="hljs-comment">// arrRef引用一个含有10个整数的数组</span><br><span class="hljs-type">int</span> *(&amp;array)[<span class="hljs-number">10</span>] = ptrs; <span class="hljs-comment">// array是数组的引用，该数组含有10个指针</span><br></code></pre></td></tr></table></figure><p>在使用数组下标的时候，通常将其定义为<strong>size_t</strong>类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。两个指针相减的结果的类型是一种名为<strong>ptrdiff_t</strong>的标准库类型，带符号类型。</p><p>使用数组的时候编译器一般会把它转换成指针。在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">// ia2是一个整型指针，指向ia首元素</span><br><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// ia3是一个含有10个整数的数组</span><br>ia3 = p; <span class="hljs-comment">// 错误，不能用整型指针给数组赋值</span><br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia); <span class="hljs-comment">// 指向ia首元素的指针</span><br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia); <span class="hljs-comment">// 指向arr尾元素下一位置的指针</span><br><span class="hljs-comment">// 这两个函数定义在iterator头文件中。</span><br></code></pre></td></tr></table></figure><p>内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。</p><p><strong>C风格字符串</strong></p><p>字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的C风格字符串（C-stylecharacterstring）。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束（nullterminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（'\0'）。一般利用指针来操作这些字符串。</p><p>尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用。</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = s.<span class="hljs-built_in">c_str</span>();<br><span class="hljs-comment">// 如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</span><br><br><span class="hljs-comment">// 使用数组初始化vector对象</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(begin(int_arr),end(int_arr))</span></span>;<br></code></pre></td></tr></table></figure><h3 id="多维数组">3.6 多维数组</h3><p>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用range for遍历二维数组，需要将外层循环的控制变量声明成引用类型，避免数组被自动转成指针</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> rowCnt = <span class="hljs-number">3</span>, colCnt = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> ia[rowCnt][colCnt];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;row : ia)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> col : row)<br>        cout &lt;&lt; col &lt;&lt; endl;<br><br><span class="hljs-comment">// 使用别名的两种方式</span><br><span class="hljs-keyword">using</span> int_array = <span class="hljs-type">int</span>[<span class="hljs-number">4</span>]; <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> int_array[<span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">for</span> (int_array *p = ia; p != ia + <span class="hljs-number">3</span>; ++p)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> *q = *p; q != *p + <span class="hljs-number">4</span>; ++q)<br>        cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第4章-表达式">第4章 表达式</h2><h3 id="基础">4.1 基础</h3><p>作用于一个运算对象的运算符是一元运算符，如取地址符(&amp;)和解引用符(*)；作用于两个运算对象的运算符是二元运算符，如相等运算符(==)和乘法运算符(*)。除此之外，还有一个作用于三个运算对象的三元运算符(?:)。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p><p>使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。</p><p>C++的表达式要不然是<strong>右值</strong>（rvalue，读作“are-value”），要不然就是<strong>左值</strong>（lvalue，读作“ell-value”）。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</p><p>假定p的类型是int*，因为解引用运算符生成左值，所以decltype(*p)的结果是int&amp;。另一方面，因为取地址运算符生成右值，所以decltype(&amp;p)的结果是int**，也就是说，结果是一个指向整型指针的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// &lt;&lt;运算符没有明确规定何时以及如何对运算对象求值，因此下面的输出表达式是未定义的</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; endl; <span class="hljs-comment">//未定义</span><br></code></pre></td></tr></table></figure><p>有4种运算符明确规定了运算对象的求值顺序。<code>?: &amp;&amp; || ,</code>。</p><h3 id="算术运算符">4.2 算术运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bool值不应参与运算</span><br><span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>;<br><span class="hljs-type">bool</span> b2 = -b; <span class="hljs-comment">//b2是true</span><br></code></pre></td></tr></table></figure><p>C++11新标准则规定商一律向0取整（即直接切除小数部分）。</p><p>除了-m导致溢出的特殊情况，其他时候 (-m)/n 和 m/(-n) 都等于-(m/n)，m%(-n) 等于 m%n，(-m)%n 等于 -(m%n)。</p><h3 id="逻辑和关系运算符">4.3 逻辑和关系运算符</h3><p>逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为<strong>短路求值</strong>（short-circuitevaluation）。</p><h3 id="赋值运算符">4.4 赋值运算符</h3><p>无。</p><h3 id="递增和递减运算符">4.5 递增和递减运算符</h3><p><strong>除非必须，否则不用递增递减运算符的后置版本。</strong></p><p>前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。</p><p><strong>简洁可以成为一种美德</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; *iter++ &lt;&lt; endl;<br><span class="hljs-comment">// 等价于</span><br>cout &lt;&lt; *iter &lt;&lt; endl;<br>++iter;<br></code></pre></td></tr></table></figure><h3 id="成员访问运算符">4.6 成员访问运算符</h3><p><a href="https://www.kancloud.cn/z1481281370/cpplearn/1616089">1.5.2值的类别</a></p><p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。</p><h3 id="条件运算符">4.7 条件运算符</h3><p><code>?:</code>具有右结合性。</p><h3 id="位运算符">4.8 位运算符</h3><p>无。</p><h3 id="sizeof运算符">4.9 sizeof运算符</h3><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。</p><p>sizeof运算符满足<strong>右结合律</strong>，其所得的值是一个size_t类型的常量表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//等价</span><br><span class="hljs-keyword">sizeof</span> *p;<br><span class="hljs-built_in">sizeof</span>(*p);<br></code></pre></td></tr></table></figure><p>sizeof运算符无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。</p><p>sizeof运算符的结果部分地依赖于其作用的类型：</p><ul><li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li><li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。</li><li>对指针执行sizeof运算得到指针本身所占空间的大小。</li><li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。</li><li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。</li><li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li></ul><h3 id="逗号运算符">4.10 逗号运算符</h3><p>逗号运算符（commaoperator）含有两个运算对象，按照从左向右的顺序依次求值。</p><h3 id="类型转换">4.11 类型转换</h3><p>编译器会自动<strong>隐式转换</strong>：</p><ul><li>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。</li><li>在条件中，非布尔值转换成布尔类型。</li><li>初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</li><li>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。</li><li>如第6章将要介绍的，函数调用时也会发生类型转换。</li></ul><p><strong>算术转换</strong></p><p>如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型<strong>不小于</strong>带符号类型，那么带符号的运算对象转换成无符号的。例如，假设两个类型分别是unsignedint和int，则int类型的运算对象转换成unsigned int类型。</p><p>如果两个运算对象的类型分别是long和unsignedint，并且int和long的大小相同，则long类型的运算对象转换成unsignedint类型；如果long类型占用的空间比int更多，则unsignedint类型的运算对象转换成long类型。</p><p>其它<strong>隐式转换</strong>：</p><ul><li><p>数组转换成指针</p></li><li><p>指针的转换</p><p>常量整数值0或者字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void*；指向任意对象的指针能转换成const void *。</p></li><li><p>转换成布尔类型</p></li><li><p>转换成常量</p><p>允许将指向非常量类型的指针/引用转换成指向相应的常量类型的。</p></li><li><p>类类型定义的转换</p><p>例如需要标准库string类型的地方使用C风格字符串</p></li></ul><p><strong>显式转换</strong></p><p><strong>static_cast</strong>可以执行编译器无法自动执行的类型转换。任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> slope = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(j) / i;<br><br><span class="hljs-type">void</span> *p = &amp;d;<br><span class="hljs-type">double</span> *dp = <span class="hljs-built_in">static_const</span>&lt;<span class="hljs-type">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure><p><strong>const_cast</strong>是唯一能改变表达式的常量属性的显示转换（仅限底层const），不能用来改变表达式的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *pc;<br><span class="hljs-type">char</span> *p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(pc); <span class="hljs-comment">//正确，但通过p写值是未定义的行为</span><br><span class="hljs-comment">// const_cast绝对不是为了改变const变量的值而设计的！在函数参数的传递上const_cast的作用才显现出来。</span><br></code></pre></td></tr></table></figure><p><strong>reinterpret_cast</strong>非常危险，本质上依赖于机器。要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *ip;<br><span class="hljs-comment">// 由于显式地声称这种转换合法，所以编译器不会发出任何警告或错误信息。接下来再使用pc时就会认定它的值是char＊类型，编译器没法知道它实际存放的是指向int的指针。</span><br><span class="hljs-type">char</span> *pc = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(ip);<br></code></pre></td></tr></table></figure><p><strong>dynamic_cast</strong></p><p>19.2节详细介绍。</p><h3 id="运算符优先级表">4.12 运算符优先级表</h3><p><ahref="https://zh.wikipedia.org/wiki/C%E5%92%8CC%2B%2B%E9%81%8B%E7%AE%97%E5%AD%90">C和C++运算符- 维基百科，自由的百科全书</a></p><p>不同地方分级略有差异。</p><p>对于含有超过一个运算符的表达式，要想理解其含义关键要理解<strong>优先级、结合律和求值顺序</strong>。</p><h2 id="第5章-语句">第5章 语句</h2><h3 id="简单语句">5.1 简单语句</h3><p>空块的作用等价于空语句。</p><h3 id="语句作用域">5.2 语句作用域</h3><p>定义在控制结构当中的变量只在相应语句的内部可见。</p><h3 id="条件语句">5.3 条件语句</h3><p>如果要在switch结构中case标签内定义变量，最好用花括号限制在语句块内。</p><p>书中给的例子比较简略，详细的讨论可以参考：<ahref="https://blog.csdn.net/LvzJason/article/details/123445116">【C++】switchcase内部的变量定义问题</a>。变量定义在编译阶段就会执行，变量初始化是运行阶段的事。</p><h3 id="迭代语句">5.4 迭代语句</h3><p>无。</p><h3 id="跳转语句">5.5 跳转语句</h3><p>无。</p><h3 id="try语句块和异常处理">5.6 try语句块和异常处理</h3><p>异常处理包括：·</p><ul><li>throw表达式（throwexpression），异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发（raise）了异常。</li><li>try语句块（tryblock），异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句（catchclause）结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码（exceptionhandler）。</li><li>一套异常类（exceptionclass），用于在throw表达式和相关的catch子句之间传递异常的具体信息。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-keyword">using</span> std::runtime_error;<br><span class="hljs-comment">// 片段</span><br><span class="hljs-keyword">while</span> (cin &gt;&gt; item1 &gt;&gt; item2) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// execute code that will add the two Sales_items</span><br>        <span class="hljs-comment">// if the addition fails, the code throws a runtime_error exception</span><br>        <span class="hljs-comment">// first check that the data are for the same item </span><br>        <span class="hljs-keyword">if</span> (item1.<span class="hljs-built_in">isbn</span>() != item2.<span class="hljs-built_in">isbn</span>())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Data must refer to same ISBN&quot;</span>);<br><br>        <span class="hljs-comment">// if we&#x27;re still here, the ISBNs are the same</span><br>        cout &lt;&lt; item1 + item2 &lt;&lt; endl;<br>    &#125; <span class="hljs-built_in">catch</span> (runtime_error err) &#123;<br>        <span class="hljs-comment">// remind the user that the ISBNs must match </span><br>        <span class="hljs-comment">// and prompt for another pair</span><br>        cout &lt;&lt; err.<span class="hljs-built_in">what</span>() <br>             &lt;&lt; <span class="hljs-string">&quot;\nTry Again?  Enter y or n&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-type">char</span> c;<br>        cin &gt;&gt; c;<br>        <span class="hljs-keyword">if</span> (!cin || c == <span class="hljs-string">&#x27;n&#x27;</span>)<br>            <span class="hljs-keyword">break</span>;      <span class="hljs-comment">// break out of the while loop</span><br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>异常中断了程序的正常流程。异常发生时，调用者请求的一部分计算可能已经完成了，另一部分则尚未完成。通常情况下，略过部分程序意味着某些对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正常释放，等等。那些在异常发生期间正确执行了“清理”工作的程序被称作异常安全（exceptionsafe）的代码。然而经验表明，<strong>编写异常安全的代码非常困难</strong>，这部分知识也（远远）超出了本书的范围。</p><p>C++标准库定义了一组类，用于报告标准库函数遇到的问题。它们分别定义在4个头文件中：</p><ul><li>exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。</li><li>stdexcept头文件定义了几种常用的异常类。</li><li>new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节（第407页）详细介绍。</li><li>type_info头文件定义了bad_cast异常类型，这种类型将在19.2节（第731页）详细介绍。</li></ul><p>异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的constchar＊。该字符串的目的是提供关于异常的一些文本信息。</p><h2 id="第6章-函数">第6章 函数</h2><h3 id="函数基础">6.1 函数基础</h3><p>为了与C语言兼容，也可以使用关键字void表示函数没有形参。</p><p>我们把只存在于块执行期间的对象称为自动对象（automatic object）。</p><p><strong>局部静态对象</strong>（local staticobject）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><p>函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。函数应该在头文件中声明而在源文件中定义。</p><p><strong>分离式编译</strong></p><p>如果我们修改了其中一个源文件，那么只需重新编译那个改动了的文件。大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（Windows）或.o（UNIX）的文件，后缀名的含义是该文件包含对象代码（objectcode）。</p><h3 id="参数传递">6.2 参数传递</h3><p>和其他变量一样，形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。</p><p>熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。<strong>在C++语言中，建议使用引用类型的形参替代指针。</strong></p><p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。<strong>当函数无须修改引用形参的值时最好使用常量引用。</strong></p><p>我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 调用fcn函数时，既可以传入const int也可以传入int。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-comment">// 错误，重复定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 三个函数是等价的,每个函数的唯一形参都是const int＊类型的。当编译器处理对print函数的调用时，只检查传入的参数是否是const int＊类型。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><br><span class="hljs-comment">//形参也可以是数组的引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;arr)[<span class="hljs-number">10</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : arr)<br>        cout &lt;&lt; elem &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 由于数组的大小是构成数组类型的一部分，此时只能将print作用于大小为10的数组</span><br><br><span class="hljs-comment">// 传递多维数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> (*matrix)[<span class="hljs-number">10</span>], <span class="hljs-type">int</span> rowSize)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//形参argc表示数组中字符串的数量；形参argv是一个数组，它的元素是指向C风格字符串的指针。</span><br><span class="hljs-comment">//argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p><strong>可变形参</strong></p><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：</p><ul><li><p>如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。</span><br> <span class="hljs-keyword">if</span> (expected != actual)<br>     <span class="hljs-built_in">error_msg</span>(&#123;<span class="hljs-string">&quot;functionX&quot;</span>, expected, actual&#125;);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">error_msg</span>(&#123;<span class="hljs-string">&quot;functionX&quot;</span>, <span class="hljs-string">&quot;okay&quot;</span>&#125;);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">(initializer_list&lt;string&gt; il)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> beg = il.<span class="hljs-built_in">begin</span>(); beg != il.<span class="hljs-built_in">end</span>(); ++beg)<br>        cout &lt;&lt; *beg &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，关于它的细节将在16.4节（第618页）介绍。</p></li></ul><p>还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与C函数交互的接口程序，是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。</p><h3 id="返回类型和return语句">6.3 返回类型和return语句</h3><p>不要返回局部对象的引用或指针。</p><p>调用一个返回引用的函数得到左值，其他返回类型得到右值。</p><p>允许main函数没有return语句直接结束。如果控制到达了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。</p><p><strong>返回数组指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方式一，使用别名</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> arrT[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">using</span> arrT = <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-function">arrT* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-comment">// 方式二</span><br><span class="hljs-built_in">int</span> (*<span class="hljs-built_in">func</span>(<span class="hljs-type">int</span> i))[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 方式三，尾置返回类型（trailing return type）</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> -&gt; <span class="hljs-title">int</span><span class="hljs-params">(*)</span>[10]</span>;<br><span class="hljs-comment">// 方式四，使用decltype</span><br><span class="hljs-comment">// decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个＊符号。</span><br><span class="hljs-type">int</span> odd[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> even[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-keyword">decltype</span>(odd) *<span class="hljs-built_in">arrPtr</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span>) ? &amp;odd : &amp;even;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数重载">6.4 函数重载</h3><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。</p><p>main函数不能重载。</p><p><strong>底层const才可重载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误重载</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> Phone)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone*)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone* <span class="hljs-type">const</span>)</span></span>;<br><span class="hljs-comment">// 正确重载</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account&amp;)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> Account&amp;)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account*)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> Account*)</span></span>;<br></code></pre></td></tr></table></figure><p>当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会<strong>优先</strong>选用非常量版本的函数。</p><p><strong>const_cast用于重载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//也可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string的引用</span><br><span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-type">const</span> String &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt;= s2.<span class="hljs-built_in">size</span>() ? s1 : s2;<br>&#125;<br><span class="hljs-comment">//以下函数当它的实参不是常量时，得到的结果是一个普通的引用</span><br><span class="hljs-function">string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(string &amp;s1, string &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> &amp;r = <span class="hljs-built_in">shortString</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> string&amp;&gt;(s1),<br>                         <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> string&amp;&gt;(s2));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;string&amp;&gt;(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>在C++语言中，名字查找发生在类型检查之前。</p><p>如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。<strong>在不同的作用域中无法重载函数名。</strong></p><h3 id="特殊用途语言特性">6.5 特殊用途语言特性</h3><p><strong>默认实参</strong></p><p>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><p>在给定的作用域中一个形参只能被赋予<strong>一次</strong>默认实参。</p><p><strong>内联函数</strong></p><p>在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。内联函数可避免函数调用的开销。</p><p>将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。</p><p>内联说明只是向编译器发出的一个请求，<strong>编译器可以选择忽略这个请求</strong>。</p><p><strong>constexpr函数</strong></p><p>函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。</p><p>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名以及using声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> foo = <span class="hljs-built_in">new_sz</span>(); <span class="hljs-comment">// 正确</span><br><span class="hljs-comment">// 允许constexpr函数的返回值并非一个常量</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">size_t</span> cnt)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">new_sz</span>() * cnt; &#125;<br><span class="hljs-type">int</span> arr[<span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>)]; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> a2[<span class="hljs-built_in">scale</span>(i)]; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p><strong>调试帮助</strong></p><p>定义在cassert头文件中的assert预处理宏由预处理器而非编译器管理。</p><p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。</p><p>编译器为每个函数都定义了_ _func_ _，它是constchar的一个静态数组，用于存放函数的名字。</p><h3 id="函数匹配">6.6 函数匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误，二义性，无法匹配。只有一个就可以匹配。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>)</span></span>;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1.1</span>);<br><span class="hljs-comment">// 错误，二义性，无法匹配。只有一个就可以匹配。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-type">short</span>)</span></span>;<br><span class="hljs-built_in">ff</span>(<span class="hljs-number">3.14</span>);<br></code></pre></td></tr></table></figure><h3 id="函数指针">6.7 函数指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lengthCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;)</span></span>;<br><span class="hljs-comment">// 指针</span><br><span class="hljs-built_in">bool</span> (*pf)(<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;);<br>pf = lengthCompare;<br>pf = &amp;lengthCompare; <span class="hljs-comment">// 与上句等价，取地址符是可选的</span><br><span class="hljs-type">bool</span> b1 = <span class="hljs-built_in">pf</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;goodbye&quot;</span>);<br><span class="hljs-type">bool</span> b2 = (*pf)(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;goodbye&quot;</span>); <span class="hljs-comment">// 与上句等价，解引用符是可选的</span><br></code></pre></td></tr></table></figure><p>函数作为实参：此时它会自动转换成指针。</p><p>函数作为返回类型：<strong>必须显式地将返回类型指定为指针</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 别名</span><br><span class="hljs-comment">// 函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> Func2</span>;<br><span class="hljs-comment">// 指向函数的指针</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(*FuncP)</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> *Func2</span>;<br><span class="hljs-comment">// 函数类型</span><br><span class="hljs-keyword">using</span> F = <span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>);<br><span class="hljs-comment">// 指向函数的指针</span><br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>);<br><br><span class="hljs-function">PF <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-function">F <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 错误</span><br><span class="hljs-function">F *<span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 正确</span><br><br><span class="hljs-comment">// 直接声明f1</span><br><span class="hljs-built_in">int</span> (*<span class="hljs-built_in">f1</span>(<span class="hljs-type">int</span>))(<span class="hljs-type">int</span>*,<span class="hljs-type">int</span>);<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> -&gt; <span class="hljs-title">int</span> <span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>*,<span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>形参（parameter）实参（argument）</p><h2 id="第7章-类">第7章 类</h2><h3 id="定义抽象数据类型">7.1 定义抽象数据类型</h3><p>成员函数通过一个名为<strong>this</strong>的额外的隐式参数来访问调用它的那个对象。</p><p>默认情况下，this的类型是指向类类型非常量版本的常量指针。成员函数的参数列表之后的const关键字表示this是一个指向常量的指针。常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p><p>一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。</p><p>​ 在参数列表后面写上<strong>=default</strong>来要求编译器生成构造函数。=default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。<strong>和其他函数一样，如果=default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。</strong></p><p>构造函数初始值列表负责为新创建的对象的一个或几个数据成员赋初值。</p><h3 id="访问控制与封装">7.2 访问控制与封装</h3><p><strong>使用class和struct定义类唯一的区别就是默认的访问权限。</strong>如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。</p><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的<strong>友元</strong>（friend）。</p><p><strong>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。</strong>如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。<strong>许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。</strong></p><h3 id="类的其他特性">7.3 类的其他特性</h3><p>定义在类内部的成员函数是自动inline的。</p><p>通过在变量的声明中加入<strong>mutable</strong>关键字声明为可变数据成员，即使是在一个const成员函数内也可修改。</p><p><strong>当我们提供一个类内初始值时，必须以符号=或者花括号表示。</strong></p><p>一个const成员函数如果以引用的形式返回<code>* this</code>，那么它的返回类型将是常量引用。这对链式调用函数不利（<code>temp.a().b()</code>形式），可以采用以下重载避免：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// display overloaded on whether the object is const or not</span><br><span class="hljs-function">Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> </span>&#123; <span class="hljs-built_in">do_display</span>(os); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">const</span> Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-built_in">do_display</span>(os); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br><br><span class="hljs-comment">// function to do the work of displaying a Screen</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123;os &lt;&lt; contents;&#125;<br></code></pre></td></tr></table></figure><p>一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此<strong>类允许包含指向它自身类型的引用或指针</strong>。</p><p>类还可以把其他的类定义成<strong>友元</strong>，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。<strong>友元关系不存在传递性。</strong>要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。</p><h3 id="类的作用域">7.4 类的作用域</h3><p>一个类就是一个作用域。</p><p>编译器处理完类中的全部声明后才会处理成员函数的定义。</p><p>如果成员函数用到和类中成员变量相同的名字，可以用作用域运算符（::）或this指针显式访问类中成员变量。</p><h3 id="构造函数再探">7.5 构造函数再探</h3><p>使用使用<strong>构造函数初始值列表</strong>直接初始化，少了一步赋值操作效率更高；并且const成员变量或引用必须直接初始化。</p><p>构造函数初始值列表只说明用于初始化成员的值，而<strong>不限定初始化的具体执行顺序</strong>。</p><p>C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的<strong>委托构造函数</strong>（delegatingconstructor）。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Sales_data <span class="hljs-title">obj</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 错误，声明了一个函数而非对象</span><br>Sales_data obj; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作<strong>转换构造函数</strong>（convertingconstructor）。</p><p><strong>编译器只会自动地执行一步类型转换</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">item.<span class="hljs-built_in">combine</span>(<span class="hljs-string">&quot;9-999-99999-9&quot;</span>);<br><span class="hljs-comment">//错误，因为以上操作需要两步转换</span><br><span class="hljs-comment">//1.&quot;9-999-99999-9&quot;到string</span><br><span class="hljs-comment">//2.string到Sales_data对象</span><br></code></pre></td></tr></table></figure><p>可以将构造函数声明为<strong>explicit</strong>来阻止隐式转换。（1.只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复2.explict声明的构造函数不能用于拷贝初始化）</p><blockquote><p>举例：</p><ul><li>接受一个单参数的constchar＊的string构造函数（参见3.2.1节，第76页）不是explicit的。</li><li>接受一个容量参数的vector构造函数（参见3.3.1节，第87页）是explicit的。</li></ul></blockquote><p><strong>聚合类</strong>（aggregate class）特点：</p><ul><li>所有成员都是public的</li><li>没有定义任何构造函数</li><li>没有类内初始值（参见2.6.1节，第64页）</li><li>没有基类，也没有virtual函数</li></ul><p><strong>字面值常量类</strong>是数据成员都是字面值类型的聚合类，或者满足以下特点：</p><ul><li>数据成员都是字面值类型</li><li>至少含有一个constexpr构造函数</li><li>如果一个数据成员含有类内初始值，内置类型成员的初始值必须是一条常量表达式；某种类类型的初始值必须使用成员自己的constexpr构造函数。</li><li>必须使用析构函数的默认定义，该成员负责销毁类的对象。</li></ul><blockquote><p>构造函数不能是const的（参见7.1.4节，第235页），但是字面值常量类的构造函数可以是constexpr（参见6.5.2节，第213页）函数。</p></blockquote><h3 id="类的静态成员">7.6 类的静态成员</h3><p>当在类的外部定义静态成员时，不能重复static关键字，<strong>该关键字只出现在类内部的声明语句</strong>。</p><p>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部<strong>定义</strong>一下该成员。（不然可能找不到定义）</p><p>非静态数据成员必须是完全类型，静态数据成员可以是<strong>不完全类型</strong>。</p><p>可以使用静态成员作为<strong>默认实参</strong>。</p><h1 id="第ⅱ部分-c标准库">第Ⅱ部分 C++标准库</h1><h2 id="第8章-io库">第8章 IO库</h2><h3 id="io类">8.1 IO类</h3><table><thead><tr class="header"><th>头文件</th><th>类型</th></tr></thead><tbody><tr class="odd"><td>iostream</td><td>istream,wistream osteam,wostream iostream,wiostream</td></tr><tr class="even"><td>fsteam</td><td>ifstream,wifstream ofstream,wofstream fstream,ofstream</td></tr><tr class="odd"><td>sstream</td><td>isstringstream,wistringstream ostringstream,wostringstreamstringstream,wstringstream</td></tr></tbody></table><p>IO对象无拷贝或赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt;<span class="hljs-string">&quot;hi!&quot;</span>&lt;&lt;endl; <span class="hljs-comment">// 附加换行，刷新</span><br>cout&lt;&lt;<span class="hljs-string">&quot;hi!&quot;</span>&lt;&lt;flush; <span class="hljs-comment">// 刷新</span><br>cout&lt;&lt;<span class="hljs-string">&quot;hi!&quot;</span>&lt;&lt;ends; <span class="hljs-comment">// 附加空字符，刷新</span><br><span class="hljs-comment">// C++对ends的处理是在缓冲区附加’\0’然后刷新。windows和linux对’\0’的处理方式不同,在windows中会输出一个空格，而linux下则不会有输出。</span><br>cout&lt;&lt;unitbuf; <span class="hljs-comment">// 所有输出后立即刷新</span><br>cout&lt;&lt;nounitbuf; <span class="hljs-comment">// 回到正常缓冲方式</span><br></code></pre></td></tr></table></figure><p>如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。</p><p>标准库将cout和cin关联在一起，输入会导致输出缓冲区刷新。</p><p>使用<code>tie</code>成员函数，既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream。每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。</p><h3 id="文件输入输出">8.2 文件输入输出</h3><p>接受一个iostream类型引用（或指针）参数的函数，可以用一个对应的fstream（或sstream）类型来调用。</p><p><strong>文件模式</strong></p><ul><li>in 读</li><li>out 写</li><li>app 每次写前均定位到文件末尾</li><li>ate 打开文件后立即定位到文件末尾</li><li>trunc 截断文件</li><li>binary 以二进制方式进行IO</li></ul><p>open调用未显式指定输出模式，文件隐式地以out模式打开。out模式意味着同时使用trunc模式。</p><p>保留被ofstream打开的文件中已有数据的唯一方法是<strong>显式指定app或in模式</strong>。</p><h3 id="string流">8.3 string流</h3><p>无</p><h2 id="第9章-顺序容器">第9章 顺序容器</h2><h3 id="顺序容器概述">9.1 顺序容器概述</h3><table><thead><tr class="header"><th>容器</th><th>特点</th></tr></thead><tbody><tr class="odd"><td>vector</td><td>可变大小数组。支持快速随机访问。尾部之外的位置插入/删除很慢。</td></tr><tr class="even"><td>deque</td><td>双端队列。支持快速随机访问。头尾位置插入/删除很快。</td></tr><tr class="odd"><td>list</td><td>双向链表。只支持双向顺序访问。任何位置插入/删除很快。</td></tr><tr class="even"><td>forward_list</td><td>单向链表。只支持单项顺序访问。任何位置插入/删除很快。</td></tr><tr class="odd"><td>array</td><td>固定大小数组。支持快速随机访问。不能添加或删除元素。</td></tr><tr class="even"><td>string</td><td>与vector类似，专用于保存字符。</td></tr></tbody></table><p>现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。</p><h3 id="容器库概览">9.2 容器库概览</h3><p>较旧的编译器可能需要在两个尖括号之间键入空格，例如，vector&lt;vector&lt;string&gt;&gt;。</p><table><thead><tr class="header"><th>通用容器操作</th><th></th></tr></thead><tbody><tr class="odd"><td><strong>类型别名</strong></td><td></td></tr><tr class="even"><td>iterator</td><td>此容器类型的迭代器类型</td></tr><tr class="odd"><td>const_iterator</td><td>const版本</td></tr><tr class="even"><td>size_type</td><td>无符号整数类型，容器大小</td></tr><tr class="odd"><td>difference_type</td><td>带符号整数类型，迭代器距离</td></tr><tr class="even"><td>value_type</td><td>元素类型</td></tr><tr class="odd"><td>reference</td><td>元素的左值类型；等同于value_type&amp;</td></tr><tr class="even"><td>const_reference</td><td>元素的const左值类型</td></tr><tr class="odd"><td><strong>构造函数</strong></td><td></td></tr><tr class="even"><td>C c;</td><td>默认构造函数（与内置数组一样，标准库array的大小也是类型的一部分）</td></tr><tr class="odd"><td>C c1(c2);</td><td>构造c2的拷贝c1</td></tr><tr class="even"><td>C c(b,e);</td><td>构造c，将迭代器b、e范围内的元素拷贝到c（array不支持）</td></tr><tr class="odd"><td>C c{a,b,c...};</td><td>列表初始化c</td></tr><tr class="even"><td><strong>赋值与swap</strong></td><td></td></tr><tr class="odd"><td>c1=c2</td><td>将c1中元素替换为c2中元素</td></tr><tr class="even"><td>c1={a,b,c...}</td><td>将c1中元素替换为列表中元素（array不支持）</td></tr><tr class="odd"><td>a.swap(b)</td><td>交换</td></tr><tr class="even"><td>swap(a,b)</td><td>交换</td></tr><tr class="odd"><td><strong>大小</strong></td><td></td></tr><tr class="even"><td>c.size()</td><td>c中元素数目（forward_list不支持）</td></tr><tr class="odd"><td>c.max_size()</td><td>c可保存的最大元素数目</td></tr><tr class="even"><td>c.empty()</td><td>是否为空</td></tr><tr class="odd"><td><strong>添加/删除元素</strong></td><td>（array不支持）（不同容器中接口不同）</td></tr><tr class="even"><td>c.insert(args)</td><td>将args中的元素拷贝进c</td></tr><tr class="odd"><td>c.emplace(inits)</td><td>使用inits构造c中的一个元素</td></tr><tr class="even"><td>c.erase(args)</td><td>删除args指定的元素</td></tr><tr class="odd"><td>c.clear()</td><td>删除c中所有元素，返回void</td></tr><tr class="even"><td><strong>关系运算符</strong></td><td></td></tr><tr class="odd"><td>==, !=</td><td>所有容器都支持相等/不等运算符</td></tr><tr class="even"><td>&lt;, &lt;=, &gt;, &gt;=</td><td>关系运算符（无序关联容器不支持）</td></tr><tr class="odd"><td><strong>获取迭代器</strong></td><td></td></tr><tr class="even"><td>c.begin(), c.end()</td><td>返回指向c的首元素和尾元素之后位置的迭代器</td></tr><tr class="odd"><td>c.cbegin(), c.end()</td><td>const版本</td></tr><tr class="even"><td><strong>反向容器的额外成员</strong></td><td>（forward_list不支持）</td></tr><tr class="odd"><td>reverse_iterator</td><td>逆序寻址</td></tr><tr class="even"><td>const_reverse_iterator</td><td>const版本</td></tr><tr class="odd"><td>c.rbegin(), c.rend()</td><td>返回指向c的尾元素和首元素之前位置的迭代器</td></tr><tr class="even"><td>c.crbegin(), c.crend()</td><td>const版本</td></tr></tbody></table><p>虽然不能对内置数组类型进行拷贝或对象赋值操作，但array<strong>无此限制</strong>。</p><p>assign操作不适用于关联容器和array。</p><p><strong>赋值相关运算</strong>会导致指向左边容器内部的迭代器、引用和指针失效。</p><p><strong>swap操作</strong>不会导致容器内部的迭代器、引用和指针失效。array和string除外。</p><ul><li>对一个string调用swap会导致迭代器、引用和指针失效。</li><li>swap两个array会真正交换它们的元素。指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。</li></ul><h3 id="顺序容器操作">9.3 顺序容器操作</h3><table><thead><tr class="header"><th>顺序容器添加元素操作</th><th></th></tr></thead><tbody><tr class="odd"><td>c.push_back(t)</td><td>尾部创建</td></tr><tr class="even"><td>c.emplace_back(args)</td><td></td></tr><tr class="odd"><td>c.push_front()</td><td>头部创建</td></tr><tr class="even"><td>c.emplace_front(args)</td><td></td></tr><tr class="odd"><td>c.insert(p,t)</td><td>迭代器p指向的元素之前创建元素，<strong>返回指向新添加的元素的迭代器</strong></td></tr><tr class="even"><td>c.emplace(p,args)</td><td></td></tr><tr class="odd"><td>c.insert(p,n,t)</td><td>插入n个值为t的元素</td></tr><tr class="even"><td>c.insert(p,b,e)</td><td>插入迭代器b、e范围内的元素</td></tr><tr class="odd"><td>c.insert(p,il)</td><td>插入il（花括号包围的元素值列表）</td></tr></tbody></table><p>在新标准下，接受元素个数或范围的insert版本<strong>返回指向第一个新加入元素的迭代器</strong>。（在旧版本的标准库中，这些操作返回void。）如果范围为空，不插入任何元素，insert操作会将第一个参数返回。</p><p>emplace_front、emplace和emplace_back<strong>构造而不是拷贝元素</strong>。</p><p><strong>forward_list专有</strong>：</p><ul><li>insert_after</li><li>emplace_after</li><li>首前迭代器before_begin()、cbefore_begin()</li></ul><p>forward_list不支持push_back和emplace_back</p><p>vector、string不支持push_front和emplace_front</p><table><thead><tr class="header"><th>顺序容器访问元素操作</th><th>（返回引用）</th></tr></thead><tbody><tr class="odd"><td>c.back()</td><td>若c为空，函数行为未定义（forward_list不支持）</td></tr><tr class="even"><td>c.front()</td><td>若c为空，函数行为未定义</td></tr><tr class="odd"><td>c[n]</td><td>若n&gt;=c.size()，函数行为未定义</td></tr><tr class="even"><td>c.at(n)</td><td>若下表越界，抛出out_of_range异常</td></tr></tbody></table><p>at和下标只适用于string、vector、deque、array。</p><table><thead><tr class="header"><th>顺序容器删除元素操作</th><th>（一律不适用于array）</th></tr></thead><tbody><tr class="odd"><td>c.pop_back()</td><td>若c为空，函数行为未定义（forward_list不支持）</td></tr><tr class="even"><td>c.pop_front()</td><td>若c为空，函数行为未定义（vector、string不支持）</td></tr><tr class="odd"><td>c.erase(p)</td><td>删除迭代器p所指向元素，<strong>返回指向被删元素之后元素的迭代器</strong></td></tr><tr class="even"><td>c.erase(b,e)</td><td></td></tr><tr class="odd"><td>c.clear()</td><td></td></tr></tbody></table><p><strong>forward_list专有</strong>：</p><ul><li>erase_after</li></ul><p><strong>操作容器后的迭代器、指针和引用失效问题</strong></p><p>添加元素后：</p><ul><li>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li><li>如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。</li></ul><p>删除元素后：</p><ul><li>对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。</li><li>对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。</li></ul><h3 id="vector对象是如何增长的">9.4 vector对象是如何增长的</h3><p>resize改变容器中元素的数目size，reserve改变容器的容量capacity（只增大）。</p><p>可以调用shrink_to_fit来要求deque、vector或string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，<strong>具体的实现可以选择忽略此请求</strong>。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。</p><p>只有在执行insert操作时size与capacity相等，或者调用resize或reserve时给定的大小超过当前capacity，vector才可能重新分配内存空间。会分配多少超过给定容量的额外空间，<strong>取决于具体实现</strong>。</p><h3 id="额外的string操作">9.5 额外的string操作</h3><p>如果string搜索函数搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义为一个conststring::size_type类型，并初始化为值<strong>-1</strong>。由于npos是一个unsigned类型，此初始值意味着npos等于任何string最大的可能大小。</p><h3 id="容器适配器">9.6 容器适配器</h3><p>一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。</p><p>3个顺序容器适配器：stack、queue、priority_queue。</p><p>默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</p><p>stack只要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器类型来构造stack。queue适配器要求back、push_back、front和push_front，因此它可以构造于list或deque之上，但不能基于vector构造。priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造于vector或deque之上，但不能基于list构造。</p><h2 id="第10章-泛型算法">第10章 泛型算法</h2><h3 id="概述">10.1 概述</h3><p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。</p><h3 id="初识泛型算法">10.2 初识泛型算法</h3><p>无。</p><h3 id="定制操作">10.3 定制操作</h3><p><strong>谓词</strong>是一个可调用的表达式，其返回结果是一个能用作条件的值。</p><p>标准库算法所使用的谓词分为两类：一元谓词（unarypredicate，意味着它们只接受单一参数）和二元谓词（binarypredicate，意味着它们有两个参数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();<br>&#125;<br><span class="hljs-comment">// 接受一个二元谓词</span><br><span class="hljs-comment">// 按长度由短至长排序words</span><br><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(),words.<span class="hljs-built_in">end</span>(),isShorter);<br><span class="hljs-comment">// 可以利用lambda表达式捕获局部变量为一元谓词提供更多参数</span><br><span class="hljs-comment">// 获取指向第一个满足a.size() &gt;= sz的迭代器</span><br><span class="hljs-keyword">auto</span> wc = <span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(),words.<span class="hljs-built_in">end</span>(),<br>                 [sz](<span class="hljs-type">const</span> string &amp;a)<br>                  &#123;<span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt;= sz;&#125;);<br></code></pre></td></tr></table></figure><p>stable_sort稳定排序算法维持相等元素的原有顺序。</p><p><strong>lambda表达式</strong></p><p>当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。</p><p>捕获列表只用于<strong>局部非static变量</strong>，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。</p><p>值捕获 / 引用捕获。</p><p>如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。</p><p>如果我们希望能改变一个被捕获的变量的值，就必须在参数列表尾加上关键字mutable。</p><blockquote><p>被捕获的变量成为了static成员。</p></blockquote><p><strong>bind函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;<br><span class="hljs-keyword">auto</span> wc = <span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>                 <span class="hljs-built_in">bind</span>(check_size, _1, sz));<br><span class="hljs-comment">// 如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库ref函数</span><br><span class="hljs-function">ostrean &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> string &amp;s, <span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; s &lt;&lt; c;<br>&#125;<br><span class="hljs-comment">// 错误</span><br>for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(print, os, _1, <span class="hljs-string">&#x27; &#x27;</span>));<br><span class="hljs-comment">// 正确</span><br>for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(print, <span class="hljs-built_in">ref</span>(os), _1, <span class="hljs-string">&#x27; &#x27;</span>));<br></code></pre></td></tr></table></figure><h3 id="再探迭代器">10.4 再探迭代器</h3><p><strong>插入迭代器</strong>（insert iterator）</p><p>这些迭代器被绑定到一个容器上，可用来向容器插入元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>list&lt;<span class="hljs-type">int</span>&gt; lst2, lst3;<br><span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">cbegin</span>(), lst.<span class="hljs-built_in">cend</span>(), <span class="hljs-built_in">front_insert</span>(lst2)); <span class="hljs-comment">// 倒序</span><br><span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">cbegin</span>(), lst.<span class="hljs-built_in">cend</span>(), <span class="hljs-built_in">inserter</span>(lst3, lst3,<span class="hljs-built_in">begin</span>())); <span class="hljs-comment">// 正序</span><br></code></pre></td></tr></table></figure><p><strong>流迭代器</strong>（stream iterator）</p><p>这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in_iter</span><span class="hljs-params">(cin)</span></span>; <br>istream_iteraror&lt;<span class="hljs-type">int</span>&gt; eof;<br><span class="hljs-keyword">while</span>(in_iter != eof)<br>    vec.<span class="hljs-built_in">push_back</span>(*in_iter++);<br><span class="hljs-comment">// 等价</span><br><span class="hljs-function">istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in_iter</span><span class="hljs-params">(cin)</span>, eof</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(in_iter, eof)</span></span>;<br><span class="hljs-comment">// 运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的程序没有任何影响。</span><br></code></pre></td></tr></table></figure><p><strong>反向迭代器</strong>（reverse iterator）</p><p>这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。</p><p><strong>移动迭代器</strong>（move iterator）</p><p>这些专用的迭代器不是拷贝其中的元素，而是移动它们。我们将在13.6.2节（第480页）介绍移动迭代器。</p><h3 id="泛型算法结构">10.5 泛型算法结构</h3><p>无。</p><h3 id="特定容器算法">10.6 特定容器算法</h3><p>容器forward_list和list对一些通用算法定义了自己特有的版本。与通用算法不同，这些链表特有版本会修改给定的链表。</p><h2 id="第11章-关联容器">第11章 关联容器</h2><table><thead><tr class="header"><th>容器</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>map</td><td>键值对</td></tr><tr class="even"><td>set</td><td>键</td></tr><tr class="odd"><td>multimap</td><td>可重复</td></tr><tr class="even"><td>multiset</td><td>可重复</td></tr><tr class="odd"><td>unordered_map</td><td>哈希函数组织</td></tr><tr class="even"><td>unordered_set</td><td>哈希函数组织</td></tr><tr class="odd"><td>unordered_multimap</td><td>可重复</td></tr><tr class="even"><td>unordered_multiset</td><td>可重复</td></tr></tbody></table><h3 id="使用关联容器">11.1 使用关联容器</h3><p>无。</p><h3 id="关联容器概述">11.2 关联容器概述</h3><p>标准库类型pair定义在头文件utility中。</p><p>与其他标准库类型不同，pair的数据成员是public的，两个成员分别命名为first和second。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">pair&lt;string, string&gt; author&#123;<span class="hljs-string">&quot;James&quot;</span>, <span class="hljs-string">&quot;Joyce&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="关联容器操作">11.3 关联容器操作</h3><p><strong>关联容器额外的类型别名</strong></p><p>key_type 此容器类型的关键字类型</p><p>mapped_type 每个关键字关联的类型，仅限map</p><p>value_type 对于set，与key_type相同；对于map，为pair&lt;constkey_type， mapped_type&gt;</p><p>set的迭代器是const的。</p><p>对一个map使用下标操作，其行为与数组或vector上的下标操作很不相同：使用一个不在容器中的关键字作为下标，会<strong>添加</strong>一个具有此关键字的元素到map中。</p><p>因此，下标和at操作只适用于非const的map和unordered_map。</p><p>c.find(k)</p><p>c.count(k)</p><p>c.lower_bound(k)</p><p>c.upper_bound(k)</p><p>c.equal_range(k)</p><h3 id="无序容器">11.4 无序容器</h3><p>无序容器提供了一组管理桶的函数，可以用来性能调优。</p><p>自定义类型的无序容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">hasher</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;sd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;string&gt;()(sd.<span class="hljs-built_in">isbn</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eqOp</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;lhs, <span class="hljs-type">const</span> Sales_data &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br><span class="hljs-keyword">using</span> SD_multiset = unordered_multiset&lt;Sales_data, <span class="hljs-keyword">decltype</span>(hasher)*, <span class="hljs-keyword">decltype</span>(eqOp)*&gt;;<br><span class="hljs-comment">// 参数是桶大小、哈希函数指针和相等性判断运算符指针</span><br><span class="hljs-function">SD_multiset <span class="hljs-title">bookstore</span><span class="hljs-params">(<span class="hljs-number">42</span>,hasder,eqOp)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="第12章-动态内存">第12章 动态内存</h2><p><strong>静态内存</strong>用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。static对象在使用之前分配，在程序结束时销毁。</p><p><strong>栈内存</strong>用来保存定义在函数内的非static对象。栈对象仅在其定义的程序块运行时才存在</p><p>除了自动和static对象外，C++还支持动态分配对象，存储在<strong>堆内存</strong>中。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。</p><h3 id="动态内存与智能指针">12.1 动态内存与智能指针</h3><table><thead><tr class="header"><th>shared_ptr和unique_ptr都支持</th><th></th></tr></thead><tbody><tr class="odd"><td>shared_ptr&lt;T&gt; sp</td><td>空智能指针</td></tr><tr class="even"><td>unique_ptr&lt;T&gt; up</td><td></td></tr><tr class="odd"><td>p</td><td>若p指向一个对象，返回true</td></tr><tr class="even"><td>*p</td><td>解引用p，获得它指向的对象</td></tr><tr class="odd"><td>p-&gt;mem</td><td>等价于(*p).mem</td></tr><tr class="even"><td>p.get()</td><td>返回p中保存的指针。<strong>永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。</strong></td></tr><tr class="odd"><td>swap(p,q) / p.swap(q)</td><td>交换</td></tr></tbody></table><table><thead><tr class="header"><th>shared_ptr独有操作</th><th></th></tr></thead><tbody><tr class="odd"><td>make_shared&lt;T&gt;(args)</td><td>初始化shared_ptr</td></tr><tr class="even"><td>shared_ptr&lt;T&gt; p(q)</td><td></td></tr><tr class="odd"><td>p = q</td><td></td></tr><tr class="even"><td>p.unique()</td><td>p.use_count()为1则返回true</td></tr><tr class="odd"><td>p.use_count()</td><td>返回与p共享对象的智能指针数量；可能很慢，用于调试</td></tr></tbody></table><p>到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候<strong>自动释放</strong>对象。</p><p>自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象<strong>拷贝、赋值和销毁</strong>操作的任何默认定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">string *ps1 = <span class="hljs-keyword">new</span> string; <span class="hljs-comment">// 默认初始化为空string</span><br>string *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(); <span class="hljs-comment">// 值初始化为空string</span><br><span class="hljs-type">int</span> *pi1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// 默认初始化，*pi1的值未定义</span><br><span class="hljs-type">int</span> *pi2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(); <span class="hljs-comment">// 值初始化为0，*pi2为0</span><br><br><span class="hljs-comment">// 用new分配const对象是合法的。</span><br><span class="hljs-type">const</span> string *pcs = <span class="hljs-keyword">new</span> <span class="hljs-type">const</span> string;<br></code></pre></td></tr></table></figure><p>动态内存的一个基本问题是<strong>可能有多个指针指向相同的内存</strong>。</p><p>可以通过<strong>定位new</strong>向new传递额外的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// 如果分配失败，new抛出std::bad_alloc。</span><br><span class="hljs-type">int</span> *p2 = <span class="hljs-built_in">new</span> (nothrow) <span class="hljs-type">int</span>; <span class="hljs-comment">// 传递给new一个由标准库定义的名为nothrow的对象。如果分配失败，new返回一个空指针。</span><br><span class="hljs-comment">// bad_alloc、nothrow都定义在头文件new中</span><br></code></pre></td></tr></table></figure><p>接受指针参数的智能指针构造函数是explicit的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用<strong>直接初始化</strong>形式来初始化一个智能指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误，拷贝初始化</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1024</span>);<br><span class="hljs-comment">// 正确，直接初始化</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">1024</span>))</span></span>;<br></code></pre></td></tr></table></figure><p><strong>智能指针陷阱</strong>：</p><ul><li>不使用相同的内置指针值初始化（或reset）多个智能指针。</li><li>不delete get（）返回的指针。·不使用get（）初始化或reset另一个智能指针。</li><li>如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li><li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。</li></ul><table><thead><tr class="header"><th>定义和改变shared_ptr的其它方法</th><th></th></tr></thead><tbody><tr class="odd"><td>shared_ptr&lt;T&gt; p(q)</td><td>p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型</td></tr><tr class="even"><td>shared_ptr&lt;T&gt; p(u)</td><td>p从unique_ptr u那里接管对象所有权，将u置空</td></tr><tr class="odd"><td>shared_ptr&lt;T&gt; p(q, d)</td><td>p接管内置指针q所指向对象的所有权。p将使用可调用对象d来代替delete。</td></tr><tr class="even"><td>shared_ptr&lt;T&gt; p(p2, d)</td><td>p是shared_ptr p2的拷贝。p将使用可调用对象d来代替delete。</td></tr><tr class="odd"><td>p.reset()</td><td>释放</td></tr><tr class="even"><td>p.reset(q)</td><td></td></tr><tr class="odd"><td>p.reset(q, d)</td><td></td></tr></tbody></table><table><thead><tr class="header"><th>unique_ptr操作</th><th></th></tr></thead><tbody><tr class="odd"><td>unique_ptr&lt;T&gt; u1</td><td></td></tr><tr class="even"><td>unique_ptr&lt;T, D&gt; u2</td><td>u2会使用一个类型为D的可调用对象来释放它的指针</td></tr><tr class="odd"><td>unique_ptr&lt;T, D&gt; u(d)</td><td></td></tr><tr class="even"><td>u = nullptr</td><td></td></tr><tr class="odd"><td>u.release()</td><td>释放，返回指针，置空</td></tr><tr class="even"><td>u.reset()</td><td></td></tr><tr class="odd"><td>u.reset(q)</td><td></td></tr><tr class="even"><td>u.reset(nullptr)</td><td></td></tr></tbody></table><p>不能拷贝unique_ptr的规则有一个<strong>例外</strong>：我们可以拷贝或赋值一个将要被销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr。</p><p>unique_ptr管理删除器的方式与shared_ptr<strong>不同</strong>，其原因我们将在16.1.6节（第599页）中介绍。</p><table><thead><tr class="header"><th>weak_ptr操作</th><th></th></tr></thead><tbody><tr class="odd"><td>weak_ptr&lt;T&gt; w</td><td></td></tr><tr class="even"><td>weak_ptr&lt;T&gt; w(sp)</td><td>与shared_ptr sp指向相同对象得weak_ptr</td></tr><tr class="odd"><td>w = p</td><td>p可以是shared_ptr或weak_ptr</td></tr><tr class="even"><td>w.reset()</td><td></td></tr><tr class="odd"><td>w.use_count()</td><td>与w共享对象的shared_ptr的数量</td></tr><tr class="even"><td>w.expired()</td><td>w.use_count()为0返回true</td></tr><tr class="odd"><td>w.lock()</td><td>expired为true返回空shared_ptr，否则返回指向w的对象的shared_ptr</td></tr></tbody></table><h3 id="动态数组">12.2 动态数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方括号中的大小必须是整型，但不必是常量。</span><br><span class="hljs-type">int</span> *pia = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-built_in">get_size</span>()];<br><span class="hljs-comment">// 使用别名</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> arrT[<span class="hljs-number">42</span>];<br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> arrT;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">42</span>];<br></code></pre></td></tr></table></figure><p><strong>动态数组并不是数组类型</strong></p><p>由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end。这些函数使用数组维度（回忆一下，维度是数组类型的一部分）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围for语句来处理（所谓的）动态数组中的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// auto初始化</span><br><span class="hljs-keyword">auto</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">auto</span>(obj); <span class="hljs-comment">// p指向一个与obj类型相同的对象，该对象用obj进行初始化</span><br><span class="hljs-keyword">auto</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">auto</span>&#123;a,b,c&#125;; <span class="hljs-comment">// 错误，括号中只能有单个初始化器</span><br><br><span class="hljs-comment">// 不能用auto分配数组，只能</span><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]();<br></code></pre></td></tr></table></figure><p>用new分配一个大小为0的数组时，new返回一个<strong>合法</strong>的非空指针。</p><p>当我们释放一个指向数组的指针时，空方括号对是必需的：它指示编译器此指针指向一个对象数组的第一个元素。如果我们在delete一个指向数组的指针时忽略了方括号（或者在delete一个指向单一对象的指针时使用了方括号），其行为是<strong>未定义</strong>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p;<br><span class="hljs-keyword">delete</span> [] pa;<br></code></pre></td></tr></table></figure><p>unique_ptr支持直接管理动态数组，shared_ptr不支持。</p><p>如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器；并且，为了访问数组中的元素，不能使用下标，必须用get获取一个内置指针，然后用它来访问数组元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-type">int</span> *p)&#123;<span class="hljs-keyword">delete</span> [] p;&#125;)</span></span>;<br>sp.<span class="hljs-built_in">reset</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)<br>    *(sp.<span class="hljs-built_in">get</span>() + i) = i;<br></code></pre></td></tr></table></figure><p>标准库allocator类定义在头文件memory中，它帮助我们<strong>将内存分配和对象构造分离开来</strong>。</p><table><thead><tr class="header"><th>allocator</th><th></th></tr></thead><tbody><tr class="odd"><td>allocator&lt;T&gt; a</td><td></td></tr><tr class="even"><td>a.allocate(n)</td><td></td></tr><tr class="odd"><td>a.deallocate(p, n)</td><td>释放内存，n必须是p创建时所要求的大小。之前要destroy。</td></tr><tr class="even"><td>a.construct(p, args)</td><td>args被传递给类型为T的构造函数。</td></tr><tr class="odd"><td>a.destroy(p)</td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = alloc.<span class="hljs-built_in">allocate</span>(vi.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);<br><span class="hljs-keyword">auto</span> q = <span class="hljs-built_in">uninitialized_copy</span>(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), p);<br><span class="hljs-built_in">uninitialized_fill_n</span>(q, vi.<span class="hljs-built_in">size</span>(), <span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><h3 id="使用标准库文本查询程序">12.3 使用标准库：文本查询程序</h3><p>无。</p><h1 id="第ⅲ部分-类设计者的工具">第Ⅲ部分 类设计者的工具</h1><p><strong>直到学习完第13章，不要在类内的代码中分配动态内存。</strong></p><h2 id="第13章-拷贝控制">第13章 拷贝控制</h2><p>一个类通过定义五种特殊的成员函数来控制对象拷贝、移动、赋值和销毁时做什么，包括：</p><p>拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignmentoperator）、移动构造函数（moveconstructor）、移动赋值运算符（move-assignmentoperator）和析构函数（destructor）。</p><h3 id="拷贝赋值与销毁">13.1 拷贝、赋值与销毁</h3><p><strong>拷贝构造函数</strong></p><p>第一个参数是自身类类型的引用，且任何额外参数都有默认值。</p><p>拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生：</p><ul><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li><li>初始化标准库容器或是调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。</li></ul><p><strong>为什么拷贝构造函数自己的参数必须是引用类型？</strong></p><p>拷贝构造函数被用来初始化<strong>非引用类类型参数</strong>。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。</p><p>无论何时一个对象被销毁，就会自动调用其<strong>析构函数</strong>：</p><ul><li>变量在离开其作用域时被销毁。</li><li>当一个对象被销毁时，其成员被销毁。</li><li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。</li><li>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。</li><li>对于临时对象，当创建它的完整表达式结束时被销毁。</li></ul><p>定义为=default来<strong>显式地要求编译器生成合成的版本</strong>。</p><p>定义为=delete来<strong>显式删除</strong>。</p><p>与=default不同，=delete必须出现在函数第一次声明的时候。</p><p>对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象。</p><p>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p><h3 id="拷贝控制和资源管理">13.2 拷贝控制和资源管理</h3><p>可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</p><p>当你编写赋值运算符时，有两点需要记住：</p><ol type="1"><li>如果将一个对象赋予它自身，赋值运算符必须能正确工作。</li><li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作。</li></ol><h3 id="交换操作">13.3 交换操作</h3><p>自定义swap友元函数效率更高。</p><p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为<strong>拷贝并交换</strong>（copyand swap）的技术。在这个版本的赋值运算符中，参数并不是一个引用。</p><h3 id="拷贝控制示例">13.4 拷贝控制示例</h3><p>无。</p><h3 id="动态内存管理类">13.5 动态内存管理类</h3><p>无。</p><h3 id="对象移动">13.6 对象移动</h3><p>在旧C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。</p><p>标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p><p>通过&amp;&amp;而不是&amp;来获得<strong>右值引用</strong>（rvaluereference）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;r = i;<br><span class="hljs-type">int</span> &amp;&amp;rr = i;  <span class="hljs-comment">// 错误，不能将右值引用绑定到左值</span><br><span class="hljs-type">int</span> &amp;r2 = i * <span class="hljs-number">42</span>; <span class="hljs-comment">// 错误，i * 42是一个右值 </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = i * <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;&amp;rr2 = i * <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure><p>变量表达式都是左值，我们<strong>不能将一个右值引用绑定到一个右值引用类型的变量上</strong>。</p><p>可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。</p><p>noexcept是我们承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表后指定noexcept。不抛出异常的移动构造函数和移动赋值运算符<strong>必须</strong>标记为noexcept。除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。</p><p>🔺只有当一个类没有定义任何自己版本的拷贝控制成员，<strong>且类的每个非static数据成员都可以移动时</strong>，编译器才会为它合成移动构造函数或移动赋值运算符。</p><p>如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。</p><p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。</p><p>🔺<strong>所有五个拷贝控制成员应该看作一个整体</strong>：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。</p><blockquote><p>网上有一种说法称其为三/五法则</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 添加的移动构造函数</span><br>    <span class="hljs-built_in">HasPtr</span>(HasPtr &amp;&amp;p) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">ps</span>(p.ps), <span class="hljs-built_in">i</span>(p.i) &#123;p.ps = <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-comment">// 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符</span><br>    HasPtr&amp; <span class="hljs-keyword">operator</span>=(HasPtr rhs) &#123;<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个<strong>移动迭代器</strong>。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。</p><p>由于一个移后源对象具有<strong>不确定</strong>的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。通过在类代码中小心地使用move，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。</p><p><strong>引用限定符</strong>(&amp;或&amp;&amp;)分别指出this可以指向一个左值或右值。对于&amp;限定的函数，我们只能将它用于左值；对于&amp;&amp;限定的函数，只能用于右值。类似<strong>const限定符</strong>，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。一个函数可以同时用const和引用限定。在此情况下，引用限定符必须跟随在const限定符之后。</p><blockquote><p>可以用&amp;修饰=运算符函数阻止向右值赋值。</p></blockquote><p><strong>可以综合引用限定符和const来区分一个成员函数的重载版本。</strong></p><p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</p><h2 id="第14章-重载运算与类型转换">第14章 重载运算与类型转换</h2><h3 id="基本概念">14.1 基本概念</h3><p>当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。</p><p>使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是，逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。除此之外，&amp;&amp;和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。</span><br>string u = <span class="hljs-string">&quot;hi&quot;</span> + s; <span class="hljs-comment">// 如果+是string的成员，则产生错误</span><br></code></pre></td></tr></table></figure><p>将运算符定义为成员函数还是普通的非成员函数？</p><ul><li>赋值（=）、下标（[ ]）、调用（（））和成员访问箭头（-&gt;）运算符必须是成员。</li><li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li><li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。</li><li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li></ul><h3 id="输入和输出运算符">14.2 输入和输出运算符</h3><p>无。</p><h3 id="算术和关系运算符">14.3 算术和关系运算符</h3><p>通常情况下，我们把算术和关系运算符定义成<strong>非成员函数</strong>以允许对左侧或右侧的运算对象进行转换。</p><p>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。</p><h3 id="赋值运算符-1">14.4 赋值运算符</h3><p>在拷贝赋值和移动赋值运算符之外，标准库vector类还定义了第三种赋值运算符，该运算符接受花括号内的元素列表作为参数。</p><h3 id="下标运算符">14.5 下标运算符</h3><p>如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。</p><h3 id="递增和递减运算符-1">14.6 递增和递减运算符</h3><p>定义递增和递减运算符的类应该<strong>同时定义前置版本和后置版本</strong>。</p><p>为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用；后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。</p><p>后置版本接受一个额外的（不被使用）int类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 若显式调用</span><br>p.<span class="hljs-keyword">operator</span>++(<span class="hljs-number">0</span>); <span class="hljs-comment">// 调用后置版本</span><br>p.<span class="hljs-keyword">operator</span>++(); <span class="hljs-comment">// 调用前置版本</span><br></code></pre></td></tr></table></figure><h3 id="成员访问运算符-1">14.7 成员访问运算符</h3><p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</p><h3 id="函数调用运算符">14.8 函数调用运算符</h3><p>当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> wc = <span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(),words.<span class="hljs-built_in">end</span>(),<br>                 [sz](<span class="hljs-type">const</span> string &amp;a)<br>                  &#123; <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt;= sz;&#125;);<br><span class="hljs-comment">// 行为类似</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SizeComp</span> &#123;<br>    <span class="hljs-built_in">SizeComp</span>(<span class="hljs-type">size_t</span> n):<span class="hljs-built_in">sz</span>(n) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>() &gt;= sz; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">size_t</span> sz;<br>&#125;;<br></code></pre></td></tr></table></figure><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;string&gt;());<br></code></pre></td></tr></table></figure><p>比较两个无关指针将产生未定义的行为，但标准库规定其函数对象对于指针同样适用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string*&gt; nameTable;<br><span class="hljs-comment">// 错误</span><br><span class="hljs-built_in">sort</span>(nameTable,<span class="hljs-built_in">begin</span>(), nameTable.<span class="hljs-built_in">end</span>(),<br>    [](string *a, string *b)&#123;<span class="hljs-keyword">return</span> a &lt; b;&#125;);<br><span class="hljs-comment">// 正确</span><br><span class="hljs-built_in">sort</span>(nameTable.<span class="hljs-built_in">begin</span>(), nameTable.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">less</span>&lt;string*&gt;());<br></code></pre></td></tr></table></figure><p>可以使用function调用可调用对象（函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> i + j; &#125;<br><span class="hljs-keyword">auto</span> mod = [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> i % j; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">divide</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> denominator, <span class="hljs-type">int</span> divisor)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> denominator / divisor;<br>    &#125;<br>&#125;;<br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; f1 = add;<br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; f2 = divide;<br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; f2 = mod;<br></code></pre></td></tr></table></figure><p>不能（直接）将重载函数的名字存入function类型的对象中，需要通过函数指针消除二义性。</p><h3 id="重载类型转换与运算符">14.9 重载、类型转换与运算符</h3><p><strong>类型转换运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>通常情况下，<strong>不要为类定义相同的类型转换</strong>，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。</p><h2 id="第15章-面向对象程序设计">第15章 面向对象程序设计</h2><p>面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。</p><h3 id="oop概述">15.1 OOP：概述</h3><p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数</strong>（virtualfunction）。任何构造函数之外的非静态函数都可以是虚函数。成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。</p><p>使用基类的引用（或指针）调用一个虚函数时将发生<strong>动态绑定</strong>。</p><h3 id="定义基类和派生类">15.2 定义基类和派生类</h3><p>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p><p>派生类必须通过使用<strong>类派生列表</strong>（class derivationlist）明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种<strong>访问说明符</strong>中的一个：public、protected或者private。</p><p>C++标准并没有明确规定派生类的对象在内存中如何分布。</p><p><strong>编译器会隐式地执行派生类到基类的转换。</strong>我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。</p><p>每个类负责定义各自的接口。派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p><p>如果基类定义了一个静态成员，则在整个继承体系中<strong>只存在该成员的唯一定义</strong>。</p><p>派生类的<strong>声明包含类名但是不包含它的派生列表</strong>。一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类、一个函数或一个变量等。派生列表以及与定义有关的其他细节必须与类的主体一起出现。</p><p>用作基类的类必须已经定义而非仅仅声明（隐含一个类不能派生它本身）。</p><p>类名后跟一个关键字final<strong>防止继承</strong>。</p><p>派生类向基类的<strong>自动</strong>类型转换<strong>只对指针或引用类型有效</strong>，在派生类类型和基类类型之间不存在这样的转换。和内置指针一样，智能指针类也支持派生类向基类的类型转换。基类向派生类不存在隐式类型转换。</p><h3 id="虚函数">15.3 虚函数</h3><p>当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做<strong>并非必须</strong>，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p><p>使用override关键字来说明派生类中的虚函数，使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误。</p><p>final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。</p><p>虚函数也可以拥有<strong>默认实参</strong>，如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。</p><p><strong>使用作用域运算符可以强迫其执行虚函数的某个特定版本。</strong></p><h3 id="抽象基类">15.4 抽象基类</h3><p>纯虚（purevirtual）函数无须定义。在函数体的位置（即在声明语句的分号之前）书写=0。我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p><p>含有纯虚函数的类是<strong>抽象基类</strong>。不能创建抽象基类的对象。</p><h3 id="访问控制与继承">15.5 访问控制与继承</h3><p>protected关键字需要注意：派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。<strong>避免基类的protected保护被规避。</strong></p><p>某个类对其继承而来的成员的访问权限受到两个因素影响：</p><ol type="1"><li>在基类中该成员的访问说明符</li><li>在派生类的派生列表中的访问说明符</li></ol><p><strong>派生访问说明符</strong>对于派生类的<strong>成员（及友元）</strong>能否访问其直接基类的成员没什么影响，目的是控制派生类<strong>用户（包括派生类的派生类在内）</strong>对于基类成员的访问权限。</p><p><strong>派生类向基类转换的可访问性</strong></p><p>假定D继承自B，D的XX能否使用派生类向基类的转换：</p><table><thead><tr class="header"><th>继承方式</th><th>成员函数和友元</th><th>用户代码</th><th>派生类的成员和友元</th></tr></thead><tbody><tr class="odd"><td>public</td><td>✓</td><td>✓</td><td>✓</td></tr><tr class="even"><td>protected</td><td>✓</td><td>✗</td><td>✓</td></tr><tr class="odd"><td>private</td><td>✓</td><td>✗</td><td>✗</td></tr></tbody></table><p>友元关系不能传递和继承。</p><p>使用using声明语句可以改变可访问性（派生类只能为那些它可以访问的名字提供using声明）。</p><p>人们常常有一种错觉，认为在使用struct关键字和class关键字定义的类之间还有更深层次的差别。事实上，<strong>唯一的差别就是默认成员访问说明符及默认派生访问说明符</strong>；除此之外，再无其他不同之处。</p><h3 id="继承中的类作用域">15.6 继承中的类作用域</h3><p>派生类的作用域位于基类作用域<strong>之内</strong>。</p><p>即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员<strong>仍然是由静态类型决定</strong>。</p><p>派生类的成员将隐藏同名的基类成员（即使派生类成员和基类成员的形参列表不一致）。可以通过作用域运算符来使用一个被隐藏的基类成员。</p><p>如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。——解决方案：一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。</p><h3 id="构造函数与拷贝控制">15.7 构造函数与拷贝控制</h3><p>只要基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本。</p><p>如前所述（13.6），大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。</p><p>和构造函数及赋值运算符不同的是，析构函数<strong>只负责</strong>销毁派生类自己分配的资源。</p><p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中<strong>显式</strong>使用基类的拷贝（或移动）构造函数。</p><p>和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。</p><h3 id="容器与继承">15.8 容器与继承</h3><p>无。</p><h3 id="文本查询程序再探">15.9 文本查询程序再探</h3><p>无。</p><h2 id="第16章-模板与泛型编程">第16章 模板与泛型编程</h2><h3 id="定义模板">16.1 定义模板</h3><p>模板定义以关键字template开始，后跟一个<strong>模板参数列表</strong>（templateparameter list），这是一个逗号分隔的一个或多个模板参数（templateparameter）的列表，用小于号（&lt;）和大于号（&gt;）包围起来。</p><p>编译器生成的版本通常被称为模板的实例（instantiation）。</p><p>在模板参数列表中，class和typename的含义相同，可以互换使用。</p><p>除了定义类型参数，还可以在模板中定义<strong>非类型参数</strong>（nontypeparameter）。当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是<strong>常量表达式</strong>，从而允许编译器在编译时实例化模板。绑定到指针或引用非类型参数的实参必须具有<strong>静态的生存期</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;usigned N, <span class="hljs-type">unsigned</span> M&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p1)[N], <span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p2)[M])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1,p2);<br>&#125;<br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;hi&quot;</span>,<span class="hljs-string">&quot;mom&quot;</span>);<br><span class="hljs-comment">// 编译器实例化</span><br><span class="hljs-comment">// int compare(const char (&amp;p1)[3], const char (&amp;p2)[4])</span><br></code></pre></td></tr></table></figure><p>inline或constexpr说明符放在模板参数列表之后，返回类型之前。</p><p>与非模板代码不同，模板的头文件通常<strong>既包括声明也包括定义</strong>。</p><p>模板的提供者保证：当使用模板时，所有不依赖于模板参数的名字都必须是可见的。当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须是可见的。</p><p>模板的用户保证：用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的。</p><p><strong>与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。</strong></p><p>与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。</p><p>默认情况下，对于一个实例化了的类模板，<strong>其成员只有在使用时才被实例化</strong>。这意味着相同的实例可能出现在多个对象文件中。可以通过<strong>显式实例化</strong>（explicitinstantiation）来避免这种开销。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实例化声明与定义</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blob</span>&lt;string&gt;;<br><span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;)</span></span>;<br><span class="hljs-comment">// 默认情况下，一个类模板的成员函数只有当程序用到它时才会进行实例化。但是一个类模板的实例化定义会实例化该模板的所有成员。</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 当我们使用一个类模板类型时必须提供模板实参。在类模板自己的作用域中，可以直接使用模板名而不提供实参。</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>&#123;<br>    BlobOtr ret = *<span class="hljs-keyword">this</span>;<br>    ++*<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>在新标准中可以将模板类型参数声明为友元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 无法用typedef给模板定义别名，using可以。</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> twin = pair&lt;T,T&gt;;<br>twin&lt;string&gt; authors;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 用作用域运算符（::）来访问static成员或类型成员。对于模板，如何区分？</span><br>T::size_type *p;<br><span class="hljs-comment">// 是在定义一个名为p的变量还是将一个名为size_type的static成员与名为p的变量相乘？</span><br><span class="hljs-comment">// 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须使用关键字typename显式告诉编译器该名字是一个类型。</span><br></code></pre></td></tr></table></figure><p>在新标准中，我们可以为函数和类模板提供<strong>默认实参</strong>。如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个<strong>空尖括号对</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> F = less&lt;T&gt;&gt;<br><span class="hljs-type">int</span> <span class="hljs-built_in">compare</span>(<span class="hljs-type">const</span> T &amp;v1, <span class="hljs-type">const</span> T &amp;v2, F f = <span class="hljs-built_in">F</span>())<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(v1, v2)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(v2, v1)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为<strong>成员模板</strong>（membertemplate）。成员模板不能是虚函数。</p><p>通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，shared_ptr使用户重载删除器更为方便。</p><h3 id="模板实参推断">16.2 模板实参推断</h3><p>将实参传递给带模板类型的函数形参时，<strong>能够自动应用的类型转换只有</strong>const转换及数组或函数到指针的转换(如果形参是一个引用，则数组不会转换为指针)。如果函数参数类型不是模板参数，则对实参进行正常的类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 指定显式模板实参(按由左至右的顺序)</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;</span><br><span class="hljs-function">T1 <span class="hljs-title">sum</span><span class="hljs-params">(T2, T3)</span></span>;<br><span class="hljs-type">int</span> i, <span class="hljs-type">long</span> lng;<br><span class="hljs-keyword">auto</span> val3 = <span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(i, lng); <span class="hljs-comment">//long long sum(int, long);</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 尾置返回类型</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> It&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fcn</span><span class="hljs-params">(It beg, It end)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(*beg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> *beg;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了获得元素类型，我们可以使用标准库的类型转换（typetransformation）模板。这些模板定义在头文件type_traits中。这个头文件中的类通常用于所谓的<strong>模板元程序设计</strong>，这一主题已超出本书的范围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> It&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fcn</span><span class="hljs-params">(It beg, It end)</span> -&gt; <span class="hljs-keyword">typename</span> remove_reference&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(*beg)</span>&gt;::type</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> *beg;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 可以用函数模板为一个函数指针赋值</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> T&amp;)</span></span>;<br><span class="hljs-built_in">int</span> (*pf1)(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;) = compare;<br></code></pre></td></tr></table></figure><p>正常绑定规则之外的两个例外规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">(T&amp;&amp;)</span></span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">f3</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 实参是一个int类型的右值，T是int</span><br><span class="hljs-built_in">f3</span>(i); <span class="hljs-comment">// 第一个例外：将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数（T&amp;&amp;）时，编译器推断模板类型参数为实参的左值引用类型。因此，当我们调用f3（i）时，编译器推断T的类型为int&amp;，而非int。</span><br><span class="hljs-comment">// (通常，我们不能（直接）定义一个引用的引用。但是，通过类型别名或通过模板类型参数间接定义是可以的。)</span><br><span class="hljs-comment">//第二个例外：X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;；类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</span><br><span class="hljs-comment">//因此，可以将任意类型的实参传递给T&amp;&amp;类型的函数参数。</span><br></code></pre></td></tr></table></figure><p>在实际中，右值引用通常用于两种情况：模板转发其实参或模板被重载。</p><p><strong>std::move</strong>的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个函数参数是<strong>指向模板类型</strong>参数的右值引用（如T&amp;&amp;），它对应的实参的const属性和左值/右值属性将得到保持。</p><p><strong>std::forward</strong>的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD <span class="hljs-keyword">constexpr</span> _Ty&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-comment">// forward an lvalue as either an lvalue or an rvalue</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD <span class="hljs-keyword">constexpr</span> _Ty&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-comment">// forward an rvalue as an rvalue</span><br>    <span class="hljs-built_in">static_assert</span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="hljs-string">&quot;bad forward call&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<strong>std::forward</strong>实现翻转函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重载与模板">16.3 重载与模板</h3><p>函数匹配规则:</p><ol type="1"><li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</li><li>候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。</li><li>与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的（16.2.1）。</li><li>与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是，如果有多个函数提供同样好的匹配，则：<ul><li>如果同样好的函数中只有一个是非模板函数，则选择此函数。</li><li>如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。</li><li>否则，此调用有歧义。</li></ul></li></ol><p>在定义任何函数之前，记得<strong>声明所有重载的函数版本</strong>。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</p><h3 id="可变参数模板">16.4 可变参数模板</h3><p>一个可变参数模板（variadictemplate）就是一个接受可变数目参数的模板函数或模板类。</p><p>可变数目的参数被称为<strong>参数包</strong>（parameterpacket）。存在两种参数包：模板参数包（template parameterpacket），表示零个或多个模板参数；函数参数包（function parameterpacket），表示零个或多个函数参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp;... rest)</span></span>;<br><span class="hljs-comment">// Args是一个模板参数包；rest是一个函数参数包</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 用来终止递归调用</span><br><span class="hljs-comment">// 必须在可变参数版本之前声明</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> T &amp;t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; t;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp;... rest)</span> <span class="hljs-comment">// 扩展Args</span></span><br><span class="hljs-function"></span>&#123;<br>    os &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os,rest...); <span class="hljs-comment">// 扩展rest，递归</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可变参数函数通常将它们的参数转发给其他函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// work的实参既扩展Args又扩展args</span><br>    <span class="hljs-built_in">work</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模板特例化">16.5 模板特例化</h3><p>当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。重要的是要弄清：<strong>一个特例化版本本质上是一个实例，而非函数名的一个重载版本。</strong></p><p>为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中。因此，模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 比较任意两个类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> T&amp;)</span></span>;<br><span class="hljs-comment">// 处理字符串字面常量</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> N, <span class="hljs-type">size_t</span> M&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;)[N], <span class="hljs-type">const</span> (&amp;)[M])</span></span>;<br><span class="hljs-comment">// 无法将一个指针转换为一个数组的引用,因此需要下面的版本</span><br><span class="hljs-comment">// 处理字符数组的指针</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;p1, onst <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;p2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1, p2);<br>&#125;<br></code></pre></td></tr></table></figure><p>与函数模板不同，<strong>类模板的特例化不必为所有模板参数提供实参</strong>。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化（partialspecialization）本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span> &#123;<br>    <span class="hljs-keyword">typedef</span> T type;<br>&#125;<br><span class="hljs-comment">// 部分特例化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;T&amp;&gt;<br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;T&amp;&amp;&gt;<br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;;<br></code></pre></td></tr></table></figure><p>可以只特例化特定成员函数而不是特例化整个模板。</p><h1 id="第ⅳ部分-高级主题">第Ⅳ部分 高级主题</h1><p>这些特性分为两类：一类对于求解大规模的问题很有用；另一类适用于特殊问题而非通用问题。</p><h2 id="第17章-标准库特殊设施">第17章 标准库特殊设施</h2><h3 id="tuple类型">17.1 tuple类型</h3><p>tuple类似pair，但可以有任意数量的成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> item = <span class="hljs-built_in">make_tuple</span>(<span class="hljs-string">&quot;0-999-78345-X&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20.00</span>);<br><span class="hljs-keyword">auto</span> book = <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(item);<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(item)</span> trans</span>;<br><span class="hljs-type">size_t</span> sz = tuple_size&lt;trans&gt;::value;<br>tuple_element&lt;<span class="hljs-number">1</span>,trans&gt;::type cnt = <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(item)<br></code></pre></td></tr></table></figure><h3 id="bitset类型">17.2 bitset类型</h3><p>bitset类使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。</p><p>bitset可以用unsigned longlong、string、字符数组构造。字符数组如果不提供数组长度，必须是一个C风格字符串。</p><p><strong>string的下标编号习惯与bitset恰好相反</strong>：string中下标最大的字符（最右字符）用来初始化bitset中的低位（下标为0的二进制位）。</p><h3 id="正则表达式">17.3 正则表达式</h3><p>默认情况下，regex使用的正则表达式语言是ECMAScript。</p><p>regex_search和regex_match的参数：</p><p>(seq, m, r, mft) (seq, r, mft)</p><p>在字符序列seq中查找regex对象r中的正则表达式。</p><p>seq可以是一个string、表示范围的一对迭代器以及一个指向空字符结尾的字符数组的指针。</p><p>m是一个match对象，用来保持匹配结果的相关细节。</p><p>mft是一个可选的regex_constants::match_flag_type值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">pattern</span><span class="hljs-params">(<span class="hljs-string">&quot;[^c]ei&quot;</span>)</span></span>;<br>pattern = <span class="hljs-string">&quot;[[:alpha:]]*&quot;</span> + pattern + <span class="hljs-string">&quot;[[:alpha:]]&quot;</span>;<br><span class="hljs-function">regex <span class="hljs-title">r</span><span class="hljs-params">(pattern)</span></span>;<br>smatch results;<br>string test_str = <span class="hljs-string">&quot;receipt freind theif receive&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">regex_search</span>(test_str, results, r))<br>    cout &lt;&lt; results.<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (sregex_iterator <span class="hljs-built_in">it</span>(file.<span class="hljs-built_in">begin</span>(), file.<span class="hljs-built_in">end</span>(), r), end_it; it != end_it; ++it)<br>    cout &lt;&lt; it-&gt;<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>一个正则表达式的语法是否正确是在运行时解析的。</p><p>regex类保存类型char的正则表达式。wregex类保存类型wachar_t的正则表达式。</p><p>smatch表示string类型的输入序列；cmatch表示字符数组序列；wsmatch表示宽字符串（wstring）输入；而wcmatch表示宽字符数组。</p><p>正则表达式中的模式通常包含一个或多个子表达式（subexpression）。正则表达式语法通常用括号表示子表达式。第一个子匹配位置为0，表示整个模式对应的匹配，随后是每个子表达式对应的匹配。</p><h3 id="随机数">17.4 随机数</h3><p>随机数库的组成：</p><p>引擎 / 类型，生成随机unsigned整数序列</p><p>分布 / 类型，使用引擎返回服从特定概率分布的随机数</p><p>C++程序<strong>不应该使用库函数rand</strong>，而应使用default_random_engine类和恰当的分布类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">default_random_engine e;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>cout &lt;&lt; <span class="hljs-built_in">e</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-function">uniform_int_distribution&lt;<span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    cout &lt;&lt; <span class="hljs-built_in">u</span>(e) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p>一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。</p><h3 id="io库再探">17.5 IO库再探</h3><p>标准库定义了一组操纵符（manipulator）（参见1.2节，第6页）来修改流的格式状态。当操纵符改变流的格式状态时，通常改变后的状态<strong>对所有后续IO都生效</strong>。</p><p>标准库还提供了一组低层操作，支持<strong>未格式化IO</strong>（unformattedIO）。这些操作允许我们将一个流当作一个无解释的字节序列来处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>(ch))<br>    cout.<span class="hljs-built_in">put</span>(ch)<br><span class="hljs-type">int</span> ch;<br><span class="hljs-keyword">while</span> ((ch = cin.<span class="hljs-built_in">get</span>()) != EOF)<br>    cout.<span class="hljs-built_in">put</span>(ch)<br></code></pre></td></tr></table></figure><p>⬜17.5.3 流随机访问</p><h2 id="第18章-用于大型程序的工具">第18章 用于大型程序的工具</h2><h3 id="异常处理">18.1 异常处理</h3><p>当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句。控制权从一处转移到另一处，这有两个重要的含义：</p><ol type="1"><li>沿着调用链的函数可能会提早退出。</li><li>一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。</li></ol><p><strong>栈展开</strong>过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch子句为止；或者也可能一直没找到匹配的catch，则退出主函数后查找过程终止。一个异常如果没有被捕获，则它将终止当前的程序。</p><p>出于栈展开可能使用析构函数的考虑，<strong>析构函数不应该抛出不能被它自身处理的异常</strong>。</p><p>当我们抛出一条表达式时，该表达式的<strong>静态编译时类型</strong>决定了异常对象的类型。</p><p>抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在。</p><p>像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p><p>通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。否则异常对象将被切掉一部分。</p><p>空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内（用于重新抛出）。如果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。（通常与catch(...)捕获所有异常一起使用）</p><p>要想处理构造函数初始值抛出的异常，我们必须将构造函数写成<strong>函数try语句块</strong>（也称为函数测试块，functiontry block）的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>Blob&lt;T&gt;::<span class="hljs-built_in">Blob</span>(std::initializer_list&lt;T&gt; il) <span class="hljs-keyword">try</span>:<br><span class="hljs-built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)) &#123;<br>        <br>    &#125; <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::bad_alloc &amp;e) &#123; <span class="hljs-built_in">handle_out_of_memory</span>(e); &#125;<br></code></pre></td></tr></table></figure><p>初始化构造函数的参数时发生的异常<strong>不属于</strong>函数try语句块，属于调用表达式的一部分。</p><p><strong>noexcept</strong></p><p>提供noexcept说明（noexceptspecification）指定某个函数不会抛出异常。</p><p>对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型之前。我们也可以在函数指针的声明和定义中指定noexcept。在typedef或类型别名中则不能出现noexcept。在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数的=0之前。</p><p>noexcept有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为noexcept异常说明的bool实参出现时，它是一个运算符。</p><p>函数指针及该指针所指的函数必须具有一致的异常说明。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-03-05-exception-class-hierarchy.jpg"alt="标准exception类层次" /><figcaption aria-hidden="true">标准exception类层次</figcaption></figure><h3 id="命名空间">18.2 命名空间</h3><p>命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。</p><p>命名空间可以是<strong>不连续的</strong>。</p><p>在通常情况下，我们不把#include放在命名空间内部。如果我们这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。</p><p>全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在<strong>全局命名空间</strong>（globalnamespace）中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。</p><p>C++11新标准引入了一种新的嵌套命名空间，称为<strong>内联命名空间</strong>（inlinenamespace）（在关键字namespace前添加关键字inline）。和普通的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。</p><p><strong>未命名的命名空间</strong>（unnamednamespace）是指关键字namespace后紧跟花括号括起来的一系列声明语句。它可以在某个给定的文件内不连续，但是不能跨越多个文件。</p><p>如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别。</p><p>在标准C++引入命名空间的概念之前，程序需要将名字声明成static的以使得其对于整个文件有效。<strong>在文件中进行静态声明的做法是从C语言继承而来的</strong>。在C语言中，声明为static的全局实体在其所在的文件外不可见。在文件中进行静态声明的做法已经被C++标准取消了，<strong>现在的做法是使用未命名的命名空间</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 别名</span><br><span class="hljs-keyword">namespace</span> Qlib = cplusplus_primer::QueryLib;<br>Qlib::Query q;<br></code></pre></td></tr></table></figure><p><strong>using声明</strong>（usingdeclaration）一次只引入命名空间的一个成员。有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止。</p><p>一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。在类的作用域中，这样的声明语句<strong>只能指向基类成员</strong>。</p><p><strong>using指示</strong>（usingdirective）使得某个特定的命名空间中所有的名字都可见，一直到using指示所在的作用域结束都能使用。</p><p>using指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用域中。</p><p>🔺using指示具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> blip &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">16</span>, j = <span class="hljs-number">15</span>, k = <span class="hljs-number">23</span>;<br>&#125;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 正确，blip的j隐藏再命名空间中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">manip</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// using指示</span><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> blip;<br>    ++i; <span class="hljs-comment">// blip::j</span><br>    ++j; <span class="hljs-comment">// 二义性，全局的j还是blip::j?</span><br>    ++::j; <span class="hljs-comment">// 全局的j</span><br>    ++blip::j; <span class="hljs-comment">// blip::j</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">97</span>; <span class="hljs-comment">// 局部的k隐藏了blip::k</span><br>    ++k; <span class="hljs-comment">// 局部的k</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然存在风险，using指示也并非一无是处，例如<strong>在命名空间本身的实现文件中就可以使用using指示</strong>。</p><p><strong>当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间。</strong>这一例外对于传递类的引用或指针的调用同样有效。</p><p>标准库move和forward函数极易冲突。</p><p>对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。</p><p>与using声明不同的是，对于using指示来说，引入一个与已有函数形参列表完全相同的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前作用域的版本即可。</p><h3 id="多重继承与虚继承">18.3 多重继承与虚继承</h3><p>在派生类的派生列表中可以包含多个基类，每个基类包含一个可选的访问说明符。</p><p>在多重继承关系中，派生类的对象包含有每个基类的子对象。</p><p>如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数<strong>定义它自己的版本</strong>。</p><p>编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意一种基类都<strong>一样好</strong>。</p><p>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。</p><p><strong>虚继承</strong>的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类（virtualbaseclass）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含<strong>唯一一个</strong>共享的虚基类子对象。</p><p>指定虚基类的方式是在派生列表中添加关键字virtual。虚派生只影响<strong>从指定了虚基类的派生类中进一步派生出的类</strong>，它不会影响派生类本身。</p><p><strong>虚基类成员的可见性</strong></p><p>假定类B定义了一个名为x的成员，D1和D2都是从B虚继承得到的，D继承了D1和D2，则在D的作用域中，x通过D的两个基类都是可见的。如果我们通过D的对象使用x，有三种可能性：</p><ol type="1"><li><p>如果在D1和D2中都没有x的定义，则x将被解析为B的成员，此时不存在二义性，一个D的对象只含有x的一个实例。</p></li><li><p>如果x是B的成员，同时是D1和D2中某一个的成员，则同样没有二义性，派生类的x比共享虚基类B的x优先级更高。</p></li><li><p>如果在D1和D2中都有x的定义，则直接访问x将产生二义性问题。</p></li></ol><p>与非虚的多重继承体系一样，解决这种二义性问题最好的方法是在派生类中为成员自定义新的实例。</p><p>在虚继承中，<strong>虚基类是由最低层的派生类初始化的</strong>。</p><p>基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。</p><p>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则<strong>先构造虚基类</strong>，然后按照声明的顺序逐一构造其他非虚基类。</p><h2 id="第19章-特殊工具与技术">第19章 特殊工具与技术</h2><h3 id="控制内存分配">19.1 控制内存分配</h3><p>当使用一条<strong>new表达式</strong>时：</p><ol type="1"><li>new表达式调用一个名为operator new（或者operatornew[]）的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。</li><li>编译器运行相应的构造函数以构造这些对象，并为其传入初始值。</li><li>对象被分配了空间并构造完成，返回一个指向该对象的指针。</li></ol><p>当使用一条<strong>delete表达式</strong>时：</p><ol type="1"><li>对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数。</li><li>编译器调用名为operator delete（或者operator delete[]）的标准库函数释放内存空间。</li></ol><p>应用程序可以在全局作用域中定义operator new函数和operatordelete函数，也可以将它们定义为成员函数。<strong>不能改变new运算符和delete运算符的基本含义。</strong></p><p>标准库定义了operator new函数和operator delete函数的8个重载版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 可能抛出bad_alloc异常 </span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>);<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-comment">// 承诺不会抛出bad_alloc异常，使用方法可见12.1.2，传入nothrow对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, <span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>, <span class="hljs-type">nothrow_t</span>&amp;) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, <span class="hljs-type">nothrow_t</span>&amp;) <span class="hljs-keyword">noexcept</span>;<br></code></pre></td></tr></table></figure><p>如果我们想要自定义operatornew函数，则可以为它提供额外的形参。此时，用到这些自定义函数的new表达式必须使用new的定位形式(🔺12.1.2<strong>定位new</strong>)将实参传给新增的形参。</p><p>一般情况下可以自定义具有任何形参的operatornew，但以下形式只供标准库使用，<strong>不能被用户重新定义</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, <span class="hljs-type">void</span>*)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 编写operator new和operator delete的一种简单方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">void</span> *mem = <span class="hljs-built_in">malloc</span>(size))<br>        <span class="hljs-keyword">return</span> mem;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *mem)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-built_in">free</span>(mem); &#125;<br></code></pre></td></tr></table></figure><p>调用析构函数会销毁对象，但是不会释放内存。</p><h3 id="运行时类型识别">19.2 运行时类型识别</h3><p>运行时类型识别（run-time typeidentification，<strong>RTTI</strong>）的功能由两个运算符实现：</p><ul><li>typeid运算符，用于返回表达式的类型。</li><li>dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。</li></ul><p>这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。</p><p>如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个bad_cast异常。</p><p>当typeid作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。</p><p>在某些情况下RTTI非常有用，比如当我们想为具有继承关系的类实现相等运算符时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>  <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Base&amp;, <span class="hljs-type">const</span> Base&amp;);<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">// Base的接口成员</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp;)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// Base的数据成员和其他用于实现的成员</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Derived的其它接口成员</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp;)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// Derived的数据成员和其他用于实现的成员</span><br>&#125;<br><br><span class="hljs-comment">// 类型一致才虚调用equal函数</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Base &amp;lhs, <span class="hljs-type">const</span> Base &amp;rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">typeid</span>(lhs) == <span class="hljs-built_in">typeid</span>(rhs) &amp;&amp; lhs.<span class="hljs-built_in">equal</span>(rhs);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Derived::equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Base &amp;lhs)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> Derived&amp;&gt;(rhs);<br>    <span class="hljs-comment">// 执行比较两个Derived对象的操作并返回结果</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Base::equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Base &amp;lhs)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 执行比较两个Base对象的操作并返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>type_info类的精确定义随着编译器的不同而略有差异。不过，C++标准规定type_info类必须定义在typeinfo头文件中，并且至少提供以下操作：</p><p>t1 == t2</p><p>t1 != t2</p><p>t.name() : 返回类型名（C风格字符串）</p><p>t1.before(t2) : 返回t1是否位于t2之前（bool）</p><h3 id="枚举类型">19.3 枚举类型</h3><p>枚举类型（enumeration）使我们可以将一组整型常量组织在一起。</p><p>C++包含两种枚举：限定作用域的和不限定作用域的。C++11新标准引入了<strong>限定作用域</strong>的枚举类型（scopedenumeration）。</p><p>(在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的。在不限定作用域的枚举类型中，<strong>枚举成员的作用域与枚举类型本身的作用域相同</strong>。)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 限定作用域的枚举（或者等价地使用enum struct）</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">open_modes</span> &#123;input, output, append&#125;;<br><span class="hljs-comment">// 不限定作用域的枚举（或者等价地使用enum）</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">color</span> &#123;red,yellow,green&#125;;<br><span class="hljs-comment">// 如果enum是未命名的，则我们只能在定义该enum时定义它的对象。</span><br><span class="hljs-keyword">enum</span> &#123;floatPrec = <span class="hljs-number">6</span>, doublePrec = <span class="hljs-number">10</span>, double_doublePrec = <span class="hljs-number">10</span>&#125;;<br></code></pre></td></tr></table></figure><p>一个不限定作用域的枚举类型的对象或枚举成员<strong>才能</strong>自动地转换成整型（反过来不行）。</p><p>不限定作用域的enum未指定成员的默认大小，因此每个<strong>前向声明</strong>必须指定成员的大小。限定作用域的enum成员大小隐式地定义成int。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">intValues</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br></code></pre></td></tr></table></figure><h3 id="类成员指针">19.4 类成员指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 数据成员指针</span><br><span class="hljs-comment">// pdata可以指向一个常量（非常量）Screen对象的string成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::string Screen::*<span class="hljs-built_in">data</span>() &#123; <span class="hljs-keyword">return</span> &amp;Screen::contents; &#125;<br>&#125;<br><span class="hljs-type">const</span> string Screen::*pdata;<br>pdata = &amp;Screen::contents;<br>pdata = Screen::<span class="hljs-built_in">data</span>();<br><br>Screen myScreen, *pScreen = &amp;myScreen;<br><span class="hljs-keyword">auto</span> s = myScreen.*pdata;<br>s = pScreen-&gt;*pdata;<br><br><span class="hljs-comment">// 成员函数指针</span><br><span class="hljs-built_in">char</span> (Screen::*pmf)(Screen::pos, Screen::pos) <span class="hljs-type">const</span>;<br>pmf = &amp;Screen::get;<br>pmf = Screen::get; <span class="hljs-comment">// 和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则</span><br><span class="hljs-type">char</span> c1 = (pScreen-&gt;*pmf)();<br><br><span class="hljs-comment">// 与普通的函数指针不同，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符</span><br><span class="hljs-keyword">auto</span> fp = &amp;string::empty;<br><span class="hljs-built_in">find_if</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), fp); <span class="hljs-comment">// 错误,执行if (fp(*it))</span><br><br><span class="hljs-comment">// 1.使用function</span><br>function&lt;<span class="hljs-type">bool</span> (<span class="hljs-type">const</span> string&amp;)&gt; fcn = &amp;string::empty;<br><span class="hljs-built_in">find_if</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), fcn); <span class="hljs-comment">// 执行 if (((*it).*p)())</span><br><br><span class="hljs-comment">// 2.使用mem_fcn</span><br><span class="hljs-built_in">find_if</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fcn</span>(&amp;string&amp;&amp;empty));<br><br><span class="hljs-comment">// 3.使用bind</span><br><span class="hljs-built_in">find_if</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(&amp;string::empty, _1));<br></code></pre></td></tr></table></figure><h3 id="嵌套类">19.5 嵌套类</h3><p>一个类可以定义在另一个类的内部，前者称为嵌套类（nestedclass）或嵌套类型（nested type）。</p><p>和成员函数一样，嵌套类必须声明在类的内部，但是可以定义在类的内部或者外部。</p><h3 id="union一种节省空间的类">19.6 union：一种节省空间的类</h3><p>当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。</p><p>union不能含有引用类型的成员。</p><p>union不能继承，不能含有虚函数。</p><p>默认情况下，union的成员都是公有的（与struct相同）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">Token</span> &#123;<br>    <span class="hljs-type">char</span> cval;<br>    <span class="hljs-type">int</span> ival;<br>    <span class="hljs-type">double</span> dval;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在<strong>匿名union</strong>的定义所在的作用域内该union的成员都是可以直接访问的。匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。</p><p>对于union来说，要想构造或销毁类类型的成员必须执行<strong>非常复杂</strong>的操作，因此我们通常把含有类类型成员的union内嵌在另一个类当中。（这个确实复杂）</p><h3 id="局部类">19.7 局部类</h3><p>类可以定义在某个函数的内部，我们称这样的类为局部类（localclass）。</p><p>局部类中不允许声明静态数据成员。</p><p>局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员。如果局部类定义在某个函数内部，则该函数的普通局部变量不能被该局部类使用。</p><p>定义成员时用到的名字可以出现在类的任意位置。如果某个名字不是局部类的成员，则继续在外层函数作用域中查找；如果还没有找到，则在外层函数所在的作用域中查找。</p><p>可以在局部类的内部再嵌套一个<strong>嵌套类</strong>。</p><h3 id="固有的不可移植的特性">19.8 固有的不可移植的特性</h3><p>为了支持低层编程，C++定义了一些固有的<strong>不可移植</strong>（nonportable）的特性。</p><blockquote><p>不可移植的特性是指因机器而异的特性，当我们将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。</p></blockquote><p><strong>位域</strong>（C++从C语言继承）</p><p>因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用<strong>无符号类型</strong>保存一个位域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Bit mode: <span class="hljs-number">2</span>; <span class="hljs-comment">// mode占2位二进制数</span><br></code></pre></td></tr></table></figure><p>取地址运算符（&amp;）不能作用于位域，因此任何指针都无法指向类的位域。</p><p><strong>volatile限定符</strong>（C++从C语言继承）</p><p>当对象的值可能在程序的控制或检测之外被改变时（例如一个由系统时钟定时更新的变量），应该将该对象声明为volatile。关键字volatile告诉编译器不应对这样的对象进行优化。</p><p>volatile限定符的用法和const<strong>很相似</strong>，但互相没什么影响，可以兼具。</p><p><strong>链接指示：extern "C"</strong>（C++新增）</p><p>C++使用链接指示（linkage directive）指出任意非C++函数所用的语言。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效。</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">void</span>(*)(<span class="hljs-type">int</span>))</span></span>;<br><span class="hljs-comment">// 因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给C++函数传入一个指向C函数的指针，则必须使用类型别名。</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> <span class="hljs-title">FC</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(FC *)</span></span>;<br><span class="hljs-comment">// 通过使用链接指示对函数进行定义，我们可以令一个C++函数在其他语言编写的程序中可用</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">double</span> dparm)</span> </span>&#123;<span class="hljs-comment">/*...*/</span>&#125;<br><span class="hljs-comment">// 有时需要在C和C++中编译同一个源文件，在编译C++程序的时候有条件地包含进来一些代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-comment">// 正在编译C++程序</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// C语言不支持函数重载</span><br><span class="hljs-comment">// C版本的calc函数可以在C或C++程序中调用，而使用了类类型形参的C++函数只能在C++程序中调用。</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> SmallInt <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">const</span> SmallInt&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> BigNum <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum&amp;)</span></span>;<br></code></pre></td></tr></table></figure><p>其中<strong>位域</strong>和<strong>volatile</strong>使得程序更容易访问硬件；<strong>链接指示</strong>使得程序更容易访问用其他语言编写的代码。</p><h1 id="练习选取">练习选取</h1>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DX11与DX12区别</title>
      <link href="//posts/Article/difference-between-DX11-and-DX12/"/>
      <url>//posts/Article/difference-between-DX11-and-DX12/</url>
      
        <content type="html"><![CDATA[<p>实践总结</p><span id="more"></span><h1 id="常量缓冲区的使用">1 常量缓冲区的使用</h1><p>DX11创建常量缓冲区后，用设备上下文将其绑定到管线。刷新时用设备上下文更新常量缓冲区。绘制时用设备上下文下绘制命令。</p><p>DX12依次创建根签名（绑定到PSO）、描述符堆、常量缓冲区视图（绑定到描述符堆）。刷新时用资源接口更新常量缓冲区。绘制时用命令列表设置根签名、绑定根参数和描述符堆、下绘制命令。</p><blockquote><p>DX11中的<strong>设备上下文</strong>（ID3D11DeviceContext）被DX12废弃。DX12用<strong>PSO</strong>（ID3D12PipelineState）代替其进行管线设置，用<strong>命令列表</strong>（ID3D12GraphicsCommandList）代替其装配管线和下绘制命令，用<strong>资源接口</strong>（ID3D12Resource）代替其进行资源的map和unmap。</p><p>DX12提出了<strong>根签名</strong>（ID3D12RootSignature），用以将着色器需要用到的数据绑定到对应的寄存器槽上供着色器访问。根签名是根参数数组，<strong>根参数</strong>（CD3DX12_ROOT_PARAMETER）可以是描述符表、根描述符、根常量。根签名会绑定到PSO。</p></blockquote><p>设常量缓冲区：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ConstantBuffer</span><br>&#123;<br>    DirectX::XMMATRIX world;<br>    DirectX::XMMATRIX view;<br>    DirectX::XMMATRIX proj;<br>    DirectX::XMFLOAT4 color;<br>    <span class="hljs-type">uint32_t</span> useCustomColor;<br>    <span class="hljs-type">uint32_t</span> pads[<span class="hljs-number">3</span>];<br>&#125;;<br><br><span class="hljs-comment">// HLSL</span><br>cbuffer ConstantBuffer : <span class="hljs-built_in">register</span>(b0)<br>&#123;<br>    matrix g_World; <br>    matrix g_View;  <br>    matrix g_Proj;<br>    vector g_Color;<br>    uint g_UseCustomColor;<br>&#125;<br></code></pre></td></tr></table></figure><p>DX11做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1.新建常量缓冲区描述</span><br>D3D11_BUFFER_DESC cbd;<br><span class="hljs-built_in">ZeroMemory</span>(&amp;cbd, <span class="hljs-built_in">sizeof</span>(cbd));<br>cbd.Usage = D3D11_USAGE_DYNAMIC;<br>cbd.ByteWidth = <span class="hljs-built_in">sizeof</span>(ConstantBuffer); <span class="hljs-comment">// ConstantBuffer是常量缓冲区结构体</span><br>cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;<br>cbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;<br><span class="hljs-comment">// m_pd3dDevice类型是ComPtr&lt;ID3D11Device&gt;</span><br><span class="hljs-built_in">HR</span>(m_pd3dDevice-&gt;<span class="hljs-built_in">CreateBuffer</span>(&amp;cbd, <span class="hljs-literal">nullptr</span>, m_pConstantBuffer.<span class="hljs-built_in">GetAddressOf</span>())); <span class="hljs-comment">// 不使用初始数据</span><br><br><span class="hljs-comment">// 2.将常量缓冲区绑定到顶点着色器和像素着色器供它们使用</span><br><span class="hljs-comment">// 此常量缓冲区寄存于b0，从b0开始只有一个</span><br><span class="hljs-comment">// m_pd3dImmediateContext类型为ComPtr&lt;ID3D11DeviceContext&gt;</span><br>m_pd3dImmediateContext-&gt;<span class="hljs-built_in">VSSetConstantBuffers</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, m_pConstantBuffer.<span class="hljs-built_in">GetAddressOf</span>()); <br>m_pd3dImmediateContext-&gt;<span class="hljs-built_in">PSSetConstantBuffers</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, m_pConstantBuffer.<span class="hljs-built_in">GetAddressOf</span>()); <br><br><span class="hljs-comment">// 3.绘制时更新常量缓冲区</span><br>D3D11_MAPPED_SUBRESOURCE mappedData;<br><span class="hljs-built_in">HR</span>(m_pd3dImmediateContext-&gt;<span class="hljs-built_in">Map</span>(m_pConstantBuffer.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>, D3D11_MAP_WRITE_DISCARD, <span class="hljs-number">0</span>, &amp;mappedData));<br><span class="hljs-built_in">memcpy_s</span>(mappedData.pData, <span class="hljs-built_in">sizeof</span>(m_CBuffer), &amp;m_CBuffer, <span class="hljs-built_in">sizeof</span>(m_CBuffer)); <span class="hljs-comment">// m_CBuffer类型为ConstantBuffer</span><br>m_pd3dImmediateContext-&gt;<span class="hljs-built_in">Unmap</span>(m_pConstantBuffer.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>);<br><br>m_pd3dImmediateContext-&gt;(IndexCount, <span class="hljs-number">1</span>, StartIndexLocation, BaseVertexLocation, <span class="hljs-number">0</span>); <span class="hljs-comment">// 绘制</span><br></code></pre></td></tr></table></figure><p>DX12做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1.创建根签名</span><br>CD3DX12_ROOT_PARAMETER slotRootParameter[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 根参数</span><br><br>CD3DX12_DESCRIPTOR_RANGE cbvTable0; <span class="hljs-comment">// 创建一个常量缓冲区描述符表，寄存于b0</span><br>cbvTable0.<span class="hljs-built_in">Init</span>(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>slotRootParameter[<span class="hljs-number">0</span>].<span class="hljs-built_in">InitAsDescriptorTable</span>(<span class="hljs-number">1</span>, &amp;cbvTable0);<br><br><span class="hljs-function">CD3DX12_ROOT_SIGNATURE_DESC <span class="hljs-title">rootSigDesc</span><span class="hljs-params">(<span class="hljs-number">1</span>, slotRootParameter, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT)</span></span>; <span class="hljs-comment">// 根签名是根参数数组</span><br><br>ComPtr&lt;ID3DBlob&gt; serializedRootSig = <span class="hljs-literal">nullptr</span>;<br>ComPtr&lt;ID3DBlob&gt; errorBlob = <span class="hljs-literal">nullptr</span>;<br>HRESULT hr = <span class="hljs-built_in">D3D12SerializeRootSignature</span>(&amp;rootSigDesc, D3D_ROOT_SIGNATURE_VERSION_1,<br>serializedRootSig.<span class="hljs-built_in">GetAddressOf</span>(), errorBlob.<span class="hljs-built_in">GetAddressOf</span>()); <span class="hljs-comment">// 序列化，使GPU理解</span><br><br><span class="hljs-built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="hljs-built_in">CreateRootSignature</span>(<br><span class="hljs-number">0</span>,<br>serializedRootSig-&gt;<span class="hljs-built_in">GetBufferPointer</span>(),<br>serializedRootSig-&gt;<span class="hljs-built_in">GetBufferSize</span>(),<br><span class="hljs-built_in">IID_PPV_ARGS</span>(mRootSignature.<span class="hljs-built_in">GetAddressOf</span>()))); <span class="hljs-comment">// mRootSignature类型为ComPtr&lt;ID3D12RootSignature&gt;</span><br><br><span class="hljs-comment">// 2.创建描述符堆</span><br>D3D12_DESCRIPTOR_HEAP_DESC cbvHeapDesc;<br>cbvHeapDesc.NumDescriptors = numDescriptors; <span class="hljs-comment">// numDescriptors为常量缓冲区描述符数量</span><br>cbvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;<br>cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;<br>cbvHeapDesc.NodeMask = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="hljs-built_in">CreateDescriptorHeap</span>(&amp;cbvHeapDesc,<br>    <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;mCbvHeap)));<br><br><span class="hljs-comment">// 3.创建常量缓冲区视图绑定到描述符堆上</span><br><span class="hljs-comment">// 若用到帧资源，每个帧资源都要创建一个常量缓冲区视图</span><br><span class="hljs-keyword">auto</span> handle = <span class="hljs-built_in">CD3DX12_CPU_DESCRIPTOR_HANDLE</span>(mCbvHeap-&gt;<span class="hljs-built_in">GetCPUDescriptorHandleForHeapStart</span>());<br>handle.<span class="hljs-built_in">Offset</span>(heapIndex, mCbvSrvUavDescriptorSize); <span class="hljs-comment">// heapIndex是在描述符堆中的偏移</span><br><br>UINT CBByteSize = d3dUtil::<span class="hljs-built_in">CalcConstantBufferByteSize</span>(<span class="hljs-built_in">sizeof</span>(ConstantBuffer)); <span class="hljs-comment">// CBByteSize为常量缓冲区尺寸</span><br>D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc;<br>cbvDesc.BufferLocation = CBAddress; <span class="hljs-comment">// 偏移位置</span><br>cbvDesc.SizeInBytes = CBByteSize;<br>md3dDevice-&gt;<span class="hljs-built_in">CreateConstantBufferView</span>(&amp;cbvDesc, handle); <span class="hljs-comment">// md3dDevice类型为ComPtr&lt;ID3D12Device&gt;</span><br><br><span class="hljs-comment">// 4.创建PSO时绑定根签名</span><br>D3D12_GRAPHICS_PIPELINE_STATE_DESC opaquePsoDesc;<br>opaquePsoDesc.pRootSignature = mRootSignature.<span class="hljs-built_in">Get</span>();<br><br><span class="hljs-comment">// 5.绘制时更新缓冲区，在命令列表设置根签名</span><br><span class="hljs-comment">// 更新缓冲区略，使用ID3D12Resource</span><br>ID3D12DescriptorHeap* descriptorHeaps[] = &#123; mCbvHeap.<span class="hljs-built_in">Get</span>() &#125;;<br><span class="hljs-comment">// mCommandList类型为ComPtr&lt;ID3D12GraphicsCommandList&gt;</span><br>mCommandList-&gt;<span class="hljs-built_in">SetDescriptorHeaps</span>(_countof(descriptorHeaps), descriptorHeaps); <span class="hljs-comment">// 设置描述符堆</span><br><br>mCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootSignature</span>(mRootSignature.<span class="hljs-built_in">Get</span>()); <span class="hljs-comment">// 设置根签名</span><br><br><span class="hljs-keyword">auto</span> cbvHandle = <span class="hljs-built_in">CD3DX12_GPU_DESCRIPTOR_HANDLE</span>(mCbvHeap-&gt;<span class="hljs-built_in">GetGPUDescriptorHandleForHeapStart</span>());<br>cbvHandle.<span class="hljs-built_in">Offset</span>(cbvIndex, mCbvSrvUavDescriptorSize); <span class="hljs-comment">// cbvIndex是在描述符堆中的偏移</span><br>mCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootDescriptorTable</span>(<span class="hljs-number">0</span>, cbvHandle); <span class="hljs-comment">// 绑定根参数和描述符堆，寄存到b0</span><br><br>mCommandList-&gt;<span class="hljs-built_in">DrawIndexedInstanced</span>(IndexCount, <span class="hljs-number">1</span>, StartIndexLocation, BaseVertexLocation, <span class="hljs-number">0</span>); <span class="hljs-comment">// 绘制</span><br></code></pre></td></tr></table></figure><h1 id="渲染方式">2 渲染方式</h1><p>Direct3D 11支持两种渲染方式：<strong>立即渲染</strong>（immediaterendering，利用immediatecontext实现）以及<strong>延迟渲染</strong>（deferredrendering，利用deferredcontext实现）。立即渲染将缓冲区中的命令直接借驱动层发往GPU执行，延迟渲染与命令列表模型相似（但执行命令列表时仍然要依赖immediatecontext）。前者延续了Direct3D 11之前一贯的绘制方式，而后者则为Direct3D11中新添加的绘制方式。</p><p>Direct3D12取消了立即渲染方式，完全采用<strong>“命令列表-&gt;命令队列”模型</strong>，使多个命令列表同时记录命令，借此充分发挥多核心处理器的性能。</p><h1 id="资源转换">3 资源转换</h1><p>为了实现常见的渲染效果，经常会通过GPU对某个资源按顺序进行先写后读这两种操作。当GPU的写操作还没有完成抑或甚至还没有开始，却开始读取资源，便会导致<strong>资源冒险</strong>（resourcehazard）。</p><p>为此，Direct3D专门针对资源设计了一组相关状态。资源在创建伊始会处于默认状态，该状态将一直持续到应用程序通过Direct3D将其转换（transition）为另一种状态为止。这就使GPU能够针对资源状态转换与防止资源冒险作出适当的行为。例如，如果要对某个资源（比如纹理）执行写操作时，需要将它的状态转换为渲染目标状态；而要对该纹理进行读操作时，再把它的状态变为着色器资源状态。根据Direct3D给出的转换信息，GPU就可以采取适当的措施避免资源冒险的发生。譬如，在读取某个资源之前，它会等待所有与之相关的写操作执行完毕。</p><p>Direct3D11中由驱动管理资源转换。一个自动跟踪状态转换的系统会强行增加程序的额外开销。</p><p>Direct3D 12中，通过命令列表设置转换资源屏障（transition resourcebarrier,<code>D3D12_RESOURCE_BARRIER</code>）数组，即可指定资源的转换。</p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
            <tag> DirectX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake笔记</title>
      <link href="//posts/Notebook/CMake-note/"/>
      <url>//posts/Notebook/CMake-note/</url>
      
        <content type="html"><![CDATA[<p>一个跨平台的安装（编译）工具</p><span id="more"></span><p class="note note-primary">二次整理自网络教程。</p><h1 id="cmake-examples总结">1 cmake-examples总结</h1><p>项目地址：<a href="https://github.com/ttroy50/cmake-examples">GitHub- ttroy50/cmake-examples: Useful CMake Examples</a></p><p>中文辅助学习网址：<ahref="https://sfumecjf.github.io/cmake-examples-Chinese/">前言 · GitBook(sfumecjf.github.io)</a>（部分内容少于官方，比如01-E、01-L、03以后的部分）</p><h2 id="basic">01-basic</h2><h3 id="a-你好cmake">A 你好cmake</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>) <span class="hljs-comment">#设置CMake最小版本</span><br><span class="hljs-keyword">project</span> (hello_cmake) <span class="hljs-comment">#设置工程名</span><br><span class="hljs-keyword">add_executable</span>(hello_cmake main.cpp) <span class="hljs-comment">#生成可执行文件</span><br></code></pre></td></tr></table></figure><p>在windows上如果要生成makefile而不是sln，不能用MSVC，应该用<strong>MinGW</strong>。添加环境变量CMAKE_GENERATOR为MinGWMakefiles，或者命令行中使用 -G “MinGW Makefiles”。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 编译命令</span><br><span class="hljs-comment"># MinGW</span><br>mkdir build<br><span class="hljs-built_in">cd</span> build/<br>cmake ..<br>make<br><span class="hljs-comment"># 通用命令，符合modern cmake,支持Makefile、Ninja、MSVC等不同的底层。</span><br>cmake . <span class="hljs-literal">-B</span> build<br>cmake <span class="hljs-literal">--build</span> build<br></code></pre></td></tr></table></figure><h3 id="b-头文件">B 头文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── include<br>│   └── Hello.h<br>└── src<br>    ├── Hello.cpp<br>    └── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span> (hello_headers)<br><span class="hljs-comment">#创建一个变量，名字叫SOURCE。它包含了所有的cpp文件。</span><br><span class="hljs-keyword">set</span>(SOURCES<br>    src/Hello.cpp<br>    src/main.cpp<br>)<br><span class="hljs-comment">#等价于命令：add_executable(hello_headers src/Hello.cpp src/main.cpp)。建议直接罗列。</span><br><span class="hljs-keyword">add_executable</span>(hello_headers <span class="hljs-variable">$&#123;SOURCES&#125;</span>) <br><span class="hljs-comment">#设置这个可执行文件hello_headers需要包含的库的路径</span><br><span class="hljs-comment">#PRIVATE指定了库的范围</span><br><span class="hljs-keyword">target_include_directories</span>(hello_headers<br>    PRIVATE <br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>)<br><br><span class="hljs-comment">#PROJECT_SOURCE_DIR指工程顶层目录</span><br><span class="hljs-comment">#PROJECT_Binary_DIR指编译目录</span><br></code></pre></td></tr></table></figure><h3 id="c-静态库">C 静态库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── include<br>│   └── static<br>│       └── Hello.h<br>└── src<br>    ├── Hello.cpp<br>    └── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span>(hello_library)<br><span class="hljs-comment">##############################</span><br><span class="hljs-comment"># Create a library</span><br><span class="hljs-comment">##############################</span><br><span class="hljs-comment">#库的源文件Hello.cpp生成静态库hello_library</span><br><span class="hljs-keyword">add_library</span>(hello_library STATIC <br>    src/Hello.cpp<br>)<br><span class="hljs-comment"># target_include_directories为一个目标（可能是一个库library也可能是可执行文件）添加头文件路径。</span><br><span class="hljs-keyword">target_include_directories</span>(hello_library<br>    PUBLIC <br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>)<br><span class="hljs-comment">##############################</span><br><span class="hljs-comment"># Create an executable</span><br><span class="hljs-comment">##############################</span><br><span class="hljs-comment">#生成可执行文件</span><br><span class="hljs-keyword">add_executable</span>(hello_binary <br>    src/main.cpp<br>)<br><span class="hljs-comment">#链接可执行文件和静态库</span><br><span class="hljs-keyword">target_link_libraries</span>( hello_binary<br>    PRIVATE <br>        hello_library<br>)<br></code></pre></td></tr></table></figure><p><strong>target_include_directories范围</strong></p><ul><li>PRIVATE - 目录被添加到目标（库）的包含路径中。</li><li>INTERFACE -目录没有被添加到目标（库）的包含路径中，而是链接了这个库的其他目标（库或者可执行程序）包含路径中</li><li>PUBLIC -目录既被添加到目标（库）的包含路径中，同时添加到了链接了这个库的其他目标（库或者可执行程序）的包含路径中</li></ul><h3 id="d-共享库">D 共享库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── include<br>│   └── shared<br>│       └── Hello.h<br>└── src<br>    ├── Hello.cpp<br>    └── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span>(hello_library)<br><span class="hljs-comment">##############################</span><br><span class="hljs-comment"># Create a library</span><br><span class="hljs-comment">##############################</span><br><span class="hljs-comment">#根据Hello.cpp生成动态库</span><br><span class="hljs-keyword">add_library</span>(hello_library SHARED <br>    src/Hello.cpp<br>)<br><span class="hljs-comment">#给动态库hello_library起一个别的名字hello::library</span><br><span class="hljs-keyword">add_library</span>(hello::library ALIAS hello_library)<br><span class="hljs-keyword">target_include_directories</span>(hello_library<br>    PUBLIC <br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>)<br><span class="hljs-comment">##############################</span><br><span class="hljs-comment"># Create an executable</span><br><span class="hljs-comment">##############################</span><br><span class="hljs-keyword">add_executable</span>(hello_binary<br>    src/main.cpp<br>)<br><span class="hljs-keyword">target_link_libraries</span>( hello_binary<br>    PRIVATE <br>        hello::library<br>)<br></code></pre></td></tr></table></figure><h3 id="e-安装">E 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── cmake-examples.conf<br>├── CMakeLists.txt<br>├── include<br>│   └── installing<br>│       └── Hello.h<br>└── src<br>    ├── Hello.cpp<br>    └── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span>(cmake_examples_install)<br><span class="hljs-comment">##############################</span><br><span class="hljs-comment"># Create a library</span><br><span class="hljs-comment">##############################</span><br><span class="hljs-comment">#生成共享库</span><br><span class="hljs-keyword">add_library</span>(cmake_examples_inst SHARED<br>    src/Hello.cpp<br>)<br><span class="hljs-keyword">target_include_directories</span>(cmake_examples_inst<br>    PUBLIC <br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>)<br><br><span class="hljs-comment">##############################</span><br><span class="hljs-comment"># Create an executable</span><br><span class="hljs-comment">##############################</span><br><span class="hljs-keyword">add_executable</span>(cmake_examples_inst_bin<br>    src/main.cpp<br>)<br><span class="hljs-keyword">target_link_libraries</span>( cmake_examples_inst_bin<br>    PRIVATE <br>        cmake_examples_inst<br>)<br><br><span class="hljs-comment">##############################</span><br><span class="hljs-comment"># Install</span><br><span class="hljs-comment">##############################</span><br><br><span class="hljs-comment"># Binaries</span><br><span class="hljs-keyword">install</span> (TARGETS cmake_examples_inst_bin<br>    DESTINATION bin)<br><br><span class="hljs-comment"># Library</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> may not work on windows</span><br><span class="hljs-keyword">install</span> (TARGETS cmake_examples_inst<br>    LIBRARY DESTINATION lib)<br><br><span class="hljs-comment"># Header files</span><br><span class="hljs-keyword">install</span>(DIRECTORY <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/ <br>    DESTINATION <span class="hljs-keyword">include</span>)<br><br><span class="hljs-comment"># Config</span><br><span class="hljs-keyword">install</span> (FILES cmake-examples.conf<br>    DESTINATION etc)<br></code></pre></td></tr></table></figure><p>windows上<strong>CMAKE_INSTALL_PREFIX</strong>默认是C:Files(x86)。如果要修改安装路径，使用 -DCMAKE_INSTALL_PREFIX='D:'。</p><h3 id="f-构建类型">F 构建类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-comment">#如果没有指定则设置默认编译方式</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE <span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> CMAKE_CONFIGURATION_TYPES)<br>  <span class="hljs-comment">#在命令行中输出message里的信息</span><br>  <span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;Setting build type to &#x27;RelWithDebInfo&#x27; as none was specified.&quot;</span>)<br>  <span class="hljs-comment">#不管CACHE里有没有设置过CMAKE_BUILD_TYPE这个变量，都强制赋值这个值为RelWithDebInfo</span><br>  <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE RelWithDebInfo CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;Choose the type of build.&quot;</span> FORCE)<br>  <span class="hljs-comment"># 当使用cmake-gui的时候，设置构建级别的四个可选项</span><br>  <span class="hljs-keyword">set_property</span>(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS <span class="hljs-string">&quot;Debug&quot;</span> <span class="hljs-string">&quot;Release&quot;</span><br>    <span class="hljs-string">&quot;MinSizeRel&quot;</span> <span class="hljs-string">&quot;RelWithDebInfo&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">project</span> (build_type)<br><span class="hljs-keyword">add_executable</span>(cmake_examples_build_type main.cpp)<br></code></pre></td></tr></table></figure><p><strong>cmake优化级别</strong></p><ul><li><p>Release ——不可以打断点调试，程序开发完成后发行使用的版本，占的体积小。它对代码做了优化，因此速度会非常快，</p><p>在编译器中使用命令： <code>-O3 -DNDEBUG</code>可选择此版本。</p></li><li><p>Debug ——调试的版本，体积大。</p><p>在编译器中使用命令： <code>-g</code> 可选择此版本。</p></li><li><p>MinSizeRel—— 最小体积版本</p><p>在编译器中使用命令：<code>-Os -DNDEBUG</code>可选择此版本。</p></li><li><p>RelWithDebInfo—— 既优化又能调试。</p><p>在编译器中使用命令：<code>-O2 -g -DNDEBUG</code>可选择此版本。</p></li></ul><p>命令行中使用-DCMAKE_BUILD_TYPE=Release可以设置</p><h3 id="g-编译选项">G 编译选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-comment">#强制设置默认C++编译标志变量为缓存变量。该缓存变量被定义在文件中（CMakeCache.txt），相当于全局变量，源文件中也可以使用这个变量。是全局的。</span><br><span class="hljs-keyword">set</span> (CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -DEX2&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;Set C++ Compiler Flags&quot;</span> FORCE)<br><span class="hljs-keyword">project</span> (compile_flags)<br><span class="hljs-keyword">add_executable</span>(cmake_examples_compile_flags main.cpp)<br><span class="hljs-comment">#为可执行文件添加私有编译定义。只为这个目标设置编译选项。</span><br><span class="hljs-keyword">target_compile_definitions</span>(cmake_examples_compile_flags <br>    PRIVATE EX3<br>)<br></code></pre></td></tr></table></figure><p>除了以上两种方法设置编译选项，还可以在命令行中使用-DCMAKE_CXX_FLAGS=（是全局的）。</p><h3 id="h-包含第三方库">H 包含第三方库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span> (third_party_include)<br><span class="hljs-comment">#使用库文件系统和系统查找boost install</span><br><span class="hljs-keyword">find_package</span>(Boost <span class="hljs-number">1.46</span>.<span class="hljs-number">1</span> REQUIRED COMPONENTS filesystem system)<br><span class="hljs-comment">#这是第三方库，而不是自己生成的静态动态库</span><br><span class="hljs-comment">#是否找到</span><br><span class="hljs-keyword">if</span>(Boost_FOUND)<br>    <span class="hljs-keyword">message</span> (<span class="hljs-string">&quot;boost found&quot;</span>)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">message</span> (FATAL_ERROR <span class="hljs-string">&quot;Cannot find Boost&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">add_executable</span>(third_party_include main.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>( third_party_include<br>    PRIVATE<br>        Boost::filesystem<br>)<br></code></pre></td></tr></table></figure><h3 id="i-使用clang编译工程">I 使用clang编译工程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── main.cpp<br>├── pre_test.sh<br>├── run_test.sh<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span> (hello_cmake)<br><span class="hljs-keyword">add_executable</span>(hello_cmake main.cpp)<br></code></pre></td></tr></table></figure><p>此示例与<ahref="https://sfumecjf.github.io/cmake-examples-Chinese/A-hello-cmake">hello-cmake</a>示例相同，不同之处在于它使用脚本将编译器从默认的gcc更改为<ahref="http://clang.llvm.org/">clang</a>的最基本方法。</p><p>CMake提供了控制程序编译以及链接的选项，选项如下:</p><ul><li><p>CMAKE_C_COMPILER - 用于编译c代码的程序。</p></li><li><p>CMAKE_CXX_COMPILER - 用于编译c++代码的程序。</p></li><li><p>CMAKE_LINKER - 用于链接二进制文件的程序。</p></li></ul><h3 id="j-使用ninja编译工程">J 使用ninja编译工程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── main.cpp<br>├── pre_test.sh<br>├── run_test.sh<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span> (hello_cmake)<br><span class="hljs-keyword">add_executable</span>(hello_cmake main.cpp)<br></code></pre></td></tr></table></figure><p>使用cmake-h查看支持的构建工具生成器。有三种，分别是命令行构建工具生成器、IDE构建工具生成器、其它生成器。使用-G选择生成器。</p><h3 id="k-导入目标">K 导入目标</h3><p>与H相似。</p><h3 id="l-c标准">L C++标准</h3><ol type="1"><li><ahref="https://sfumecjf.github.io/cmake-examples-Chinese/01-basic/i-common-method">common-method</a>.可以与大多数版本的CMake一起使用的简单方法。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><span class="hljs-keyword">project</span> (hello_cpp11)<br><br><span class="hljs-comment"># try conditional compilation</span><br><span class="hljs-keyword">include</span>(CheckCXXCompilerFlag)<br>CHECK_CXX_COMPILER_FLAG(<span class="hljs-string">&quot;-std=c++11&quot;</span> COMPILER_SUPPORTS_CXX11)<br>CHECK_CXX_COMPILER_FLAG(<span class="hljs-string">&quot;-std=c++0x&quot;</span> COMPILER_SUPPORTS_CXX0X)<br><br><span class="hljs-comment"># check results and add flag</span><br><span class="hljs-keyword">if</span>(COMPILER_SUPPORTS_CXX11)<span class="hljs-comment">#</span><br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)<br><span class="hljs-keyword">elseif</span>(COMPILER_SUPPORTS_CXX0X)<span class="hljs-comment">#</span><br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++0x&quot;</span>)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;The compiler $&#123;CMAKE_CXX_COMPILER&#125; has no C++11 support. Please use a different C++ compiler.&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">add_executable</span>(hello_cpp11 main.cpp)<br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><ahref="https://sfumecjf.github.io/cmake-examples-Chinese/01-basic/ii-cxx-standard">cxx-standard</a>.使用CMake v3.1中引入的CMAKE_CXX_STANDARD变量。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.1</span>)<br><span class="hljs-keyword">project</span> (hello_cpp11)<br><br><span class="hljs-comment"># set the C++ standard to C++ 11</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><br><span class="hljs-keyword">add_executable</span>(hello_cpp11 main.cpp)<br></code></pre></td></tr></table></figure><p>它会选择最近的正确标准而不会报错。</p><ol start="3" type="1"><li><ahref="https://sfumecjf.github.io/cmake-examples-Chinese/01-basic/iii-compile-features">compile-features</a>.使用CMake v3.1中引入的target_compile_features函数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.1</span>)<br><span class="hljs-keyword">project</span> (hello_cpp11)<br><span class="hljs-keyword">add_executable</span>(hello_cpp11 main.cpp)<br><br><span class="hljs-comment"># set the C++ standard to the appropriate standard for using auto</span><br><span class="hljs-keyword">target_compile_features</span>(hello_cpp11 PUBLIC cxx_auto_type)<br><br><span class="hljs-comment"># Print the list of known compile features for this version of CMake</span><br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;List of compile features: $&#123;CMAKE_CXX_COMPILE_FEATURES&#125;&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="sub-projects">02-sub-projects</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt 最高层<br>├── subbinary<br>│   ├── CMakeLists.txt  生成可执行文件<br>│   └── main.cpp<br>├── sublibrary1<br>│   ├── CMakeLists.txt 生成静态库<br>│   ├── include<br>│   │   └── sublib1<br>│   │       └── sublib1.h<br>│   └── src<br>│       └── sublib1.cpp<br>└── sublibrary2<br>    ├── CMakeLists.txt 生成仅有头文件的库<br>    └── include<br>        └── sublib2<br>            └── sublib2.h<br></code></pre></td></tr></table></figure><p>将头文件移至每个项目include目录下的子文件夹可以防止文件名冲突</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span>(subprojects)<br><br><span class="hljs-comment"># Add sub directories</span><br><span class="hljs-keyword">add_subdirectory</span>(sublibrary1)<br><span class="hljs-keyword">add_subdirectory</span>(sublibrary2)<br><span class="hljs-keyword">add_subdirectory</span>(subbinary)<br></code></pre></td></tr></table></figure><p>CMake中有一些变量会自动创建:</p><table><thead><tr class="header"><th>Variable</th><th>Info</th></tr></thead><tbody><tr class="odd"><td>PROJECT_NAME</td><td>当前project（）设置的项目的名称。</td></tr><tr class="even"><td>CMAKE_PROJECT_NAME</td><td>由project（）命令设置的第一个项目的名称，即顶层项目。</td></tr><tr class="odd"><td>PROJECT_SOURCE_DIR</td><td>当前项目的源文件目录。</td></tr><tr class="even"><td>PROJECT_BINARY_DIR</td><td>当前项目的构建目录。</td></tr><tr class="odd"><td>name_SOURCE_DIR</td><td>在此示例中，创建的源目录为 <code>sublibrary1_SOURCE_DIR</code>,<code>sublibrary2_SOURCE_DIR</code>, and<code>subbinary_SOURCE_DIR</code></td></tr><tr class="even"><td>name_BINARY_DIR</td><td>本工程的二进制目录是<code>sublibrary1_BINARY_DIR</code>,<code>sublibrary2_BINARY_DIR</code>,和<code>subbinary_BINARY_DIR</code></td></tr></tbody></table><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">project</span>(subbinary)<br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)<br><br><span class="hljs-comment"># Link the static library from subproject1 using its alias sub::lib1</span><br><span class="hljs-comment"># Link the header only library from subproject2 using its alias sub::lib2</span><br><span class="hljs-comment"># This will cause the include directories for that target to be added to this project</span><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>    sub::lib1<br>    sub::lib2<br>)<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">project</span> (sublibrary1)<br><br><span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> src/sublib1.cpp)<br><span class="hljs-keyword">add_library</span>(sub::lib1 ALIAS <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br><br><span class="hljs-keyword">target_include_directories</span>( <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>    PUBLIC <br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">project</span> (sublibrary2)<br><br><span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> INTERFACE)<br><span class="hljs-keyword">add_library</span>(sub::lib2 ALIAS <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br><br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>    INTERFACE<br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>)<br></code></pre></td></tr></table></figure><h2 id="code-generation">03-code-generation</h2><p>代码生成是一个很好用的功能，它可以使用一份公共的描述文件，生成不同语言下的源代码。这个功能使得需要人工编写的代码大幅减少，同时也增加了互操作性。</p><h3 id="configure-file">1 configure-file</h3><p>使用CMake中的configure_file函数注入CMake变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── CMakeLists.txt<br>├── main.cpp<br>├── path.h.in<br>├── ver.h.in<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span> (cf_example)<br><br><span class="hljs-comment"># set a project version</span><br><span class="hljs-keyword">set</span> (cf_example_VERSION_MAJOR <span class="hljs-number">0</span>)<br><span class="hljs-keyword">set</span> (cf_example_VERSION_MINOR <span class="hljs-number">2</span>)<br><span class="hljs-keyword">set</span> (cf_example_VERSION_PATCH <span class="hljs-number">1</span>)<br><span class="hljs-keyword">set</span> (cf_example_VERSION <span class="hljs-string">&quot;$&#123;cf_example_VERSION_MAJOR&#125;.$&#123;cf_example_VERSION_MINOR&#125;.$&#123;cf_example_VERSION_PATCH&#125;&quot;</span>)<br><br><span class="hljs-comment"># Call configure files on ver.h.in to set the version.</span><br><span class="hljs-comment"># Uses the standard $&#123;VARIABLE&#125; syntax in the file</span><br><span class="hljs-keyword">configure_file</span>(ver.h.in <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/ver.h)<br><br><span class="hljs-comment"># configure the path.h.in file.</span><br><span class="hljs-comment"># This file can only use the @VARIABLE@ syntax in the file</span><br><span class="hljs-keyword">configure_file</span>(path.h.in <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/path.h @ONLY)<br><br><span class="hljs-keyword">add_executable</span>(cf_example<br>    main.cpp<br>)<br><br><span class="hljs-comment"># include the directory with the new files</span><br><span class="hljs-keyword">target_include_directories</span>( cf_example<br>    PUBLIC<br>        <span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span><br>)<br></code></pre></td></tr></table></figure><h3 id="protocol-buffers">2 Protocol Buffers</h3><p>使用Google Protocol Buffers来生成C++源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tree">├── AddressBook.proto<br>├── CMakeLists.txt<br>├── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span> (protobuf_example)<br><br><span class="hljs-comment"># find the protobuf compiler and libraries</span><br><span class="hljs-keyword">find_package</span>(Protobuf REQUIRED)<br><br><span class="hljs-comment"># check if protobuf was found</span><br><span class="hljs-keyword">if</span>(PROTOBUF_FOUND)<br>    <span class="hljs-keyword">message</span> (<span class="hljs-string">&quot;protobuf found&quot;</span>)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">message</span> (FATAL_ERROR <span class="hljs-string">&quot;Cannot find Protobuf&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># Generate the .h and .cxx files</span><br>PROTOBUF_GENERATE_CPP(PROTO_SRCS PROTO_HDRS AddressBook.proto)<br><br><span class="hljs-comment"># Print path to generated files</span><br><span class="hljs-keyword">message</span> (<span class="hljs-string">&quot;PROTO_SRCS = $&#123;PROTO_SRCS&#125;&quot;</span>)<br><span class="hljs-keyword">message</span> (<span class="hljs-string">&quot;PROTO_HDRS = $&#123;PROTO_HDRS&#125;&quot;</span>)<br><br><span class="hljs-comment"># Add an executable</span><br><span class="hljs-keyword">add_executable</span>(protobuf_example<br>    main.cpp<br>    <span class="hljs-variable">$&#123;PROTO_SRCS&#125;</span><br>    <span class="hljs-variable">$&#123;PROTO_HDRS&#125;</span>)<br><br><span class="hljs-keyword">target_include_directories</span>(protobuf_example<br>    PUBLIC<br>    <span class="hljs-variable">$&#123;PROTOBUF_INCLUDE_DIRS&#125;</span><br>    <span class="hljs-variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><br>)<br><br><span class="hljs-comment"># link the exe against the libraries</span><br><span class="hljs-keyword">target_link_libraries</span>(protobuf_example<br>    PUBLIC<br>    <span class="hljs-variable">$&#123;PROTOBUF_LIBRARIES&#125;</span><br>)<br></code></pre></td></tr></table></figure><h2 id="static-analysis">04-static-analysis</h2>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【3D-RPG】DOG-Knight开发笔记</title>
      <link href="//posts/Notebook/3D-RPG-DOG-Knight-develop-note/"/>
      <url>//posts/Notebook/3D-RPG-DOG-Knight-develop-note/</url>
      
        <content type="html"><![CDATA[<p>unity开发</p><span id="more"></span><p class="note note-primary">二次整理自网络教程。</p><h1 id="前言">前言</h1><p>本项目参考<ahref="https://www.bilibili.com/video/BV1rf4y1k7vE?spm_id_from=333.999.0.0&amp;vd_source=1614cbf0a650cda8c72c85046d0d9e51">教程</a>开发。</p><p>开发本项目的在于学习unity使用。</p><p>前置教程：</p><ul><li>Unity官方 C#初级编程 <ahref="https://www.bilibili.com/video/BV1oy4y1q7jJ">点击跳转</a></li><li>Unity官方 C#中级编程 <ahref="https://www.bilibili.com/video/BV1f5411G7bp">点击跳转</a></li></ul><h1 id="一-准备工作">一 准备工作</h1><p>开发环境：unity 2020.3.26f1c1 LTS</p><p>IDE：VSCode</p><p>创建3D项目，自行升级到URP渲染管线：</p><ul><li>安装URP插件，右键创建Pipeline Asset，放入ProjectSettings-&gt;Graphics/Quality中的可编程渲染管线设置。</li><li>在素材商店选择合适的免费素材导入到工程中，可以点击素材中的.unitypackage文件升级到URP，也可以在Edit-&gt;RenderPipeline中升级。</li></ul><h1 id="二-搭建场景">二 搭建场景</h1><p>Window-&gt;Rendering-&gt;Lighting 设置并烘焙灯光。</p><p>Shadows在URP Asset里设置。</p><p><strong>视点移动</strong>：</p><ul><li>alt+左键 第三人称转动<br /></li><li>中键 平移<br /></li><li>右键 第一人称转动</li><li>右键+WASD 第一人称视角漫游</li></ul><p><strong>放置技巧</strong>：</p><ul><li><p>v选择顶点，按住拖拽自动吸附到其它顶点上；ctrl+shift，按住拖拽自动吸附到其它平面上</p></li><li><p>ctrl+shift+F：快速定位相机到当前窗口</p></li><li><p>scene面板中F或hierarchy窗口中双击：快速定位到选中物体</p></li></ul><p>安装的第三方工具可以通过Tools使用。Polybrush调整地形，快速刷上Prefab。Probuilder快速制作素材。ProGrids参考线辅助移动。</p><p>使用Navigation烘焙智能导航</p><p>cinemachine添加跟随人物的相机（CM FreeLook）。</p><p>创建Global Volume生成各种效果（记得在MainCamera里面启动Rendering-&gt;Post Processing）。</p><p>为人物自制Animator，不同Layer放置不同类别动画，在代码中SetParameters来控制动画。可以通过Animator OverrideController基于现有Animator快速创建新的。可以为每个Animation添加单独的Behaviour脚本。</p><p>使用Shader Graph自制材质。</p><p>在URP Asset自带的Forward Render中添加RenderObjects，为指定的Layer的游戏对象设置遮挡剔除（09课）。</p><p>想让游戏对象不阻挡射线，可以设置为Ignore Raycast Layer或者关闭MeshCollider。</p><h1 id="三-代码编写">三 代码编写</h1><h2 id="managers">3.1 Managers</h2><p>此类代码用于全局管理，都是单例的。单例泛型类实现如下.</p><p>此外，它们不随关卡变化销毁，需在各自<code>Awake()</code>方法里加上<code>DontDestroyOnLoad(this);</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">MonoBehaviour</span> <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T instance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T Instance<br>    &#123;<br>        <span class="hljs-keyword">get</span> =&gt; instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> IsInitialized<br>    &#123;<br>        <span class="hljs-keyword">get</span> =&gt; instance != <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>)<br>            Destroy(gameObject);<br>        <span class="hljs-keyword">else</span><br>            instance = (T)<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestory</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">this</span>)<br>        &#123;<br>            instance = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mousemanager">3.1.1 MouseManager</h3><p><strong>通过观察者模式控制鼠标点击触发的操作</strong></p><p>继承<code>UnityEngine.Events</code>中的<code>UnityEvent&lt;&gt;</code>可以建立事件类。（由于没有继承自MonoBehaviour，需要给类加上[System.Serializable]，其变量才能在窗口中显示出来。）在窗口中控制事件类的对象触发的操作。</p><p>也可以自行创建委托代替事件类，编写代码控制委托触发的操作。这里我是用这种方法。</p><p><strong>Update()</strong></p><p><code>Camera.main.ScreenPointToRay(Input.mousePosition)</code>获取摄像机向鼠标位置发出的光线，<code>Physics.Raycast(ray, out hitInfo)</code>获取光线碰撞信息到hitInfo，然后根据hitInfo获取游戏对象的tag，根据tag设置鼠标的纹理<code>Cursor.SetCursor</code>。</p><p><code>Input.GetMouseButtonDown(0)</code>当鼠标左键点击时，根据当前点击游戏对象的tag触发委托，进行移动、攻击等操作。</p><h3 id="gamemanager">3.1.2 GameManager</h3><p>创建IEndGameObserver接口作为观察者：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEndGameObserver</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EndNotify</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用列表<code>List&lt;IEndGameObserver&gt;</code>储存观察者，主体包含一下管理观察者的方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddObserver</span>(<span class="hljs-params">IEndGameObserver observer</span>)</span><br>&#123;<br>    endGameObservers.Add(observer);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveObserver</span>(<span class="hljs-params">IEndGameObserver observer</span>)</span><br>&#123;<br>    endGameObservers.Remove(observer);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyObservers</span>()</span><br>&#123;<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> observer <span class="hljs-keyword">in</span> endGameObservers)<br>    &#123;<br>        observer.EndNotify();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外在GameManager中添加玩家状态、相机这些需要全局使用的游戏对象。</p><h3 id="savemanager">3.1.3 SaveManager</h3><p>将游戏数据用JsonUtility转化为json，利用PlayerPrefs保存游戏数据。Windows的默认保存位置在注册表HKEY_CURRENT_USER。</p><p><strong>Update()</strong></p><p>根据键盘输入进行保存和加载操作。</p><h2 id="character">3.2 Character</h2><p>此类代码用于游戏主角/敌人的控制。仅简单描述其逻辑。</p><h3 id="playercontroller">3.2.1 PlayerController</h3><p><strong>Awake()</strong></p><p>通过<code>GetComponent&lt;&gt;</code>获取身上的各种组件。</p><p><strong>OnEnable()</strong></p><p>将指定的方法添加到MouseManager的委托中，使其被鼠标点击触发。</p><p>将玩家的CharacterStats注册到GameManager中。</p><p><strong>Start()</strong></p><p>加载存档数据。</p><p><strong>OnDisable()</strong></p><p>为了防止场景切换时发生错误，将指定的方法从MouseManager的委托中移除。</p><p><strong>Update()</strong></p><p>如果死亡，通过GameManager向所有观察者发布死亡消息。</p><p>通过Animator切换/控制Animation。</p><p>记录攻击CD的倒计时。</p><p><strong>移动</strong></p><p>中断所有协程。控制NavMeshAgent。</p><p><strong>攻击</strong></p><p>获取攻击目标，进行暴击判定。通过协程移动并攻击。</p><p><code>Physics.OverlapSphere(transform.position, sightRadius)</code>找到视野内的所有colliders。</p><p>使用AnimationEvent控制伤害造成的时机。对可击飞目标的Rigidbody加力。</p><h3 id="enemycontroller">3.2.2 EnemyController</h3><p>通过<code>[RequireComponent(typeof(NavMeshAgent))]</code>自动添加组件。</p><p>通过<code>[Header("Basic Settings")]</code>设置窗口头部。</p><p>使用枚举EnemyStates规定敌人的状态<code>GUARD,PATROL,CHASE,DEAD</code>。</p><p>实现IEndGameObserver接口（以作为观察者）的<code>EndNotify()</code>方法，进行被通知之后的操作。</p><p>创建ExtensionMethod为transform添加<code>IsFacingTarget(this Transform transform, Transform target)</code>扩展方法，便于判断角色是否面对目标</p><p><strong>Awake()</strong></p><p>通过<code>GetComponent&lt;&gt;</code>获取身上的各种组件。</p><p><strong>Start()</strong></p><p>通过GameManager添加自己为观察者。</p><p><strong>OnDisable()</strong></p><p>移除观察者。</p><p><strong>Update()</strong></p><p>根据当前状态行动（switch）。切换动画。记录攻击CD的倒计时。</p><p>使用<code>Random.Range</code>和<code>NavMesh.SamplePosition</code>获得随机巡逻点。</p><p><strong>OnDrawGizmosSelected()</strong></p><p>绘制显示敌人视野范围的小组件。</p><p><strong>子类Grunt</strong></p><p>为Grunt添加击飞方法</p><p><strong>子类Golem</strong></p><p>为Golem添加击飞方法和扔石头方法</p><h2 id="character-stats">3.3 Character Stats</h2><p>此类代码用于记录游戏数据。</p><p>CharacterData_SO、AttackData_SO继承自ScriptableObject，使用字段记录基本数据、攻击数据。CharacterStats类使用属性和方法提供对前者的控制。</p><h2 id="ui">3.4 UI</h2><p>使用canvas、image、button。</p><h3 id="healthbarui">3.4.1 HealthBarUI</h3><p>挂载在每个敌人身上。需要在敌人身上创建barPoint作为血条位置参考。</p><p><strong>Awake()</strong></p><p>将血条更新方法添加到CharacterStats的委托中，在收到伤害时触发。</p><p><strong>OnEnable()</strong></p><p>对于Render Mode为World Space的HealthBarCanvas，每个脚本均创建独立的Bar Holder，以红/绿image叠加显示血条。</p><p><strong>LateUpdate()</strong></p><p>更新血条位置（根据敌人位置）和朝向（根据相机朝向）</p><p>刷新血条显示冷却时间。</p><h3 id="playerhealthui">3.4.2 PlayerHealthUI</h3><p>挂载在玩家身上。Render Mode为ScreenSpace。在每一帧更新血量和经验值。</p><h3 id="mainmenu">3.4.3 MainMenu</h3><p>挂载在Menu Canvas上。给主界面UI相应按钮注册鼠标点击事件。</p><h3 id="scenefader">3.4.4 SceneFader</h3><p>挂载在Fade Canvas上。利用Canvas Group的alpha通道实现渐入渐出。</p><h2 id="transition">3.5 Transition</h2><h3 id="transitiondesitination">3.5.1 TransitionDesitination</h3><p>目的地枚举<code>ENTER, A, B, C, EXIT</code>。</p><h3 id="transitionpoint">3.5.2 TransitionPoint</h3><p>传送类型枚举<code>SameScene, DifferentScene</code>。</p><p>传送门挂载TransitionPoint和TransitionDesitination，设定传送类型和目的地。</p><p>将传送门的Box Collider标记为IsTrigger，通过<code>void OnTriggerStay(Collider other)</code>和<code>void OnTriggerExit(Collider other)</code>方法改变变量canTrans，标记是否可以传送。</p><p><strong>Update()</strong></p><p>按E传送。</p><h3 id="scenecontroller">3.5.3 SceneController</h3><p>单例模式。</p><p>通过协程异步加载场景并传送。</p><p>所有的传送方法均放在这里。</p><h1 id="四-打包及运行">四 打包及运行</h1><p>File-&gt;Build Settings中将所有场景加入，Edit-&gt;ProjectSettings-&gt;Player中设置游戏名。</p><p>使用IL2CPP作为脚本后端打包，游戏更小性能更高。</p><h1 id="版本控制">版本控制</h1><p>版本控制系统<strong>plasticSCM</strong>有两种使用方式：</p><ol type="1"><li><p>通过unityhub创建仓库把项目托管到plasticSCM，使用unity自带的plastichub作为服务器<a href="https://plastichub.unity.cn/">Plastic Hub(unity.cn)</a>。</p></li><li><p>在引擎里打开Window里的plasticSCM，通过uniy登录plasticSCM官网，创建仓库，使用官方<a href="https://www.plasticscm.com/">PlasticSCM</a>作为服务器。</p></li></ol><p>以上两种方式建立的仓库的服务器不同，但在登录同一个plasticSCM账号的客户端都能看到。后者这个有更大的免费容量（50GB）。</p><p>如果已经安装了plasticSCM客户端，此时不再需要安装plasticSCM插件。不然会出现编译错误（dll冲突）和奇怪BUG（Preference里的ExternalTools选项卡为空白）。</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《pytorch深度学习实战》笔记</title>
      <link href="//posts/Notebook/Deep-Learning-with-Pytorch-note/"/>
      <url>//posts/Notebook/Deep-Learning-with-Pytorch-note/</url>
      
        <content type="html"><![CDATA[<p>Deep Learning with Pytorch</p><span id="more"></span><p>Eli Stevens，Luca Antiga ，Thomas Viehmann 著</p><p>牟大恩 译</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-pytorch深度学习实战笔记_s.jpg"alt="封面" /><figcaption aria-hidden="true">封面</figcaption></figure><p><ahref="https://github.com/deep-learning-with-pytorch/dlwpt-code">代码仓库</a></p><p class="note note-primary">摘录整理。笔记目录不完全按照原书目录。</p><p class="note note-warning">这本书的中文翻译有一些地方不通顺。稍修正。</p><h1 id="第1部分-pytorch核心">第1部分 PyTorch核心</h1><h2 id="第1章-深度学习和pytorch库简介">第1章深度学习和PyTorch库简介</h2><p>深度学习使用大量数据来近似<strong>输入和输出相距很远的复杂函数</strong>，如输入是图像，输出是对输入进行描述的一行文本；或输入是书面文字，输出是朗读该文字的自然语音。</p><p>深度学习是一个巨大的空间，本书只覆盖该空间的一小部分。具体来说，包括一些使用PyTorch进行较小范围的图像分类和分割的项目，通过一些示例处理二维和三维的图像数据集。</p><p>为什么用PyTorch？</p><ul><li>Theano是最早的深度学习框架之一，目前它已经停止开发。</li><li>TensorFlow：<ul><li>完全对Keras进行封装，将其提升为一流的API；</li><li>提供了一种立即执行的“急切模式（eagermode）”，这种模式有点儿类似于PyTorch处理计算的方式；</li><li>TensorFlow 2.0默认采用急切模式。</li></ul></li><li>JAX是谷歌的一个库，它是独立于TensorFlow开发的，作为一个与GPU、Autograd和JIT编译器具有对等功能的NumPy库，它已经开始获得关注。</li><li>PyTorch：<ul><li>Caffe2完全并入PyTorch，作为其后端模块；</li><li>替换了从基于Lua的Torch项目重用的大多数低级别代码；</li><li>增加对开放式神经网络交换（Open Neural NetworkExchange，ONNX）的支持，这是一种与外部框架无关的模型描述和交换格式；</li><li>增加一种称为“TorchScript”的延迟执行的“图模型”运行环境；</li><li>发布了1.0版本；</li><li>取代CNTK和Chainer成为各自企业赞助商选择的框架。</li></ul></li></ul><p>随着TorchScript和eager模式的出现，PyTorch和TensorFlow的特征集开始趋同，尽管在这些特征的呈现和整体体验上仍然存在很大的差异。</p><p>事实上，由于性能原因，PyTorch大部分是用C++和CUDA编写的，CUDA是一种来自英伟达的类C++的语言，可以被编译并在GPU上以并行方式运行。有一些方法可以直接在C++环境中运行PyTorch，我们将在第15章中讨论这些方法。此功能的动机之一是为生产环境中部署模型提供可靠的策略。但是，大多数情况下我们都是使用Python来与PyTorch交互的，包括构建模型、训练模型以及使用训练过的模型解决实际问题等。</p><p>在PyTorch中，将运算从CPU转移到GPU不需要额外的函数调用。</p><h2 id="第2章-预训练网络">第2章 预训练网络</h2><p>这章主要下载使用了一些不同种类的预训练网络。</p><p>在深度学习中，在新数据上运行训练过的模型的过程被称为<strong>推理（inference）</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> models<br><span class="hljs-comment"># 找到预定义的模型</span><br><span class="hljs-built_in">dir</span>(models)<br><span class="hljs-comment"># 首字母大写的名称指的是实现了许多流行模型的Python类，它们的体系结构不同，即输入和输出之间操作的编排不同。首字母小写的名称指的是一些便捷函数，它们返回这些类实例化的模型，有时使用不同的参数集。例如，resnet101表示返回一个有101层网络的ResNet实例，resnet152表示返回一个有152层网络的ResNet实例，以此类推。</span><br></code></pre></td></tr></table></figure><p>训练时候开启<code>model.train()</code>，启用 BatchNormalization 和Dropout。测试（评估）时开启<code>model.eval()</code>。</p><h2 id="第3章-从张量开始">第3章 从张量开始</h2><p>张量可简单理解为多维数组。</p><p>Python列表或数字元组是在内存中单独分配的Python对象的集合，而PyTorch张量或NumPy数组通常是连续内存块的视图，这些内存块包含未装箱的数字类型，而不是Python对象。</p><p>tensor操作和numpy类似。</p><p>为了避免张量运算时粗心造成的对齐错误，可以对张量命名。</p><p>张量构造函数通过dtype参数指定包含在张量中的数字的数据类型：</p><ul><li>torch.float32或torch.float：32位浮点数。</li><li>torch.float64或torch.double：64位双精度浮点数。</li><li>torch.float16或torch.half：16位半精度浮点数。</li><li>torch.int8：8位有符号整数。</li><li>torch.uint8：8位无符号整数。</li><li>torch.int16或torch.short：16位有符号整数。</li><li>torch.int32或torch.int：32位有符号整数。</li><li>torch.int64或torch.long：64位有符号整数。</li><li>torch.bool：布尔型。</li></ul><p>张量的默认数据类型是32位浮点数。</p><p>我们在大部分时间使用32位浮点数和64位有符号整数，原因如下：</p><ol type="1"><li><p>在神经网络中发生的计算通常是用32位浮点精度执行的。采用更高的精度，如64位，并不会提高模型精度，反而需要更多的内存和计算时间。16位半精度浮点数的数据类型在标准CPU中并不存在，而是由现代GPU提供的。如果需要的话，可以切换到半精度来减少神经网络占用的空间，这样做对精度的影响也很小。</p></li><li><p>张量可以作为其他张量的索引，在这种情况下，PyTorch期望索引张量为64位的整数。创建一个将整数作为参数的张量，例如使用torch.tensor([2,2])，默认会创建一个64位的整数张量。</p></li></ol><p>张量操作分类：</p><ul><li>创建操作——用于构造张量的函数，如ones()和from_numpy()。</li><li>索引、切片、连接、转换操作——用于改变张量的形状、步长或内容的函数，如transpose()。</li><li>数学操作——通过运算操作张量内容的函数。</li><li>逐点操作——通过对每个元素分别应用一个函数来得到一个新的张量，如abs()和cos()。</li><li>归约操作——通过迭代张量来计算聚合值的函数，如mean()、std()和norm()。</li><li>比较操作——在张量上计算数字谓词的函数，如equal()和max()。</li><li>频谱操作——在频域中进行变换和操作的函数。</li><li>其他操作——作用于向量的特定函数（如cross()），或对矩阵进行操作的函数（如trace()）。</li><li>BLAS和LAPACK操作——符合基本线性代数子程序（Basic Linear AlgebraSubprogram，BLAS）规范的函数，用于标量、向量—向量、矩阵—向量和矩阵—矩阵操作。</li><li>随机采样——从概率分布中随机生成值的函数，如randn()和normal()。</li><li>序列化——保存和加载张量的函数，如load()和save()。</li><li>并行化——用于控制并行CPU执行的线程数的函数，如set_num_threads()。</li></ul><p>张量是Storage实例的<strong>视图</strong>。</p><p>一个张量的值在存储区中从最右的维度开始向前排列被定义为连续张量。在PyTorch中一些张量操作只对连续张量起作用，如view()方法。在这种情况下，PyTorch将抛出一个提供有用信息的异常，并要求我们显式地调用contiguous()方法。值得注意的是，如果张量已经是连续的，那么调用contiguous()方法不会产生任何操作，也不会影响性能。一个连续张量转置后不再是连续张量。</p><p>张量还有设备（device）的概念，即张量数据在计算机上的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">points_gpu = torch.tensor([[<span class="hljs-number">4.0</span>, <span class="hljs-number">1.0</span>], [<span class="hljs-number">5.0</span>, <span class="hljs-number">3.0</span>], [<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>]], device=<span class="hljs-string">&#x27;cuda&#x27;</span>)<br></code></pre></td></tr></table></figure><p>pytorch可以与numpy<strong>互操作</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">points = torch.ones(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>points_np = points.numpy()<br>points = torch.from_numpy(points_np)<br></code></pre></td></tr></table></figure><p>PyTorch在内部使用pickle来序列化张量对象，并为存储添加专用的序列化代码。通过以下方法可以将张量points写到ourpoints.t文件中并读：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;../data/p1ch3/ourpoints.t&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>   torch.save(points, f)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;../data/p1ch3/ourpoints.t&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>   points = torch.load(f)<br></code></pre></td></tr></table></figure><h2 id="第4章-使用张量表征真实数据">第4章 使用张量表征真实数据</h2><p>简单讲了下如何加载各种类型的数据。</p><h2 id="第5章-学习的机制">第5章 学习的机制</h2><h3 id="手动求导并更新参数">手动求导并更新参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br>torch.set_printoptions(edgeitems=<span class="hljs-number">2</span>, linewidth=<span class="hljs-number">75</span>)<br><span class="hljs-comment"># t_u是输入数据，t_c是输出真值</span><br>t_c = [<span class="hljs-number">0.5</span>,  <span class="hljs-number">14.0</span>, <span class="hljs-number">15.0</span>, <span class="hljs-number">28.0</span>, <span class="hljs-number">11.0</span>,  <span class="hljs-number">8.0</span>,  <span class="hljs-number">3.0</span>, -<span class="hljs-number">4.0</span>,  <span class="hljs-number">6.0</span>, <span class="hljs-number">13.0</span>, <span class="hljs-number">21.0</span>]<br>t_u = [<span class="hljs-number">35.7</span>, <span class="hljs-number">55.9</span>, <span class="hljs-number">58.2</span>, <span class="hljs-number">81.9</span>, <span class="hljs-number">56.3</span>, <span class="hljs-number">48.9</span>, <span class="hljs-number">33.9</span>, <span class="hljs-number">21.8</span>, <span class="hljs-number">48.4</span>, <span class="hljs-number">60.4</span>, <span class="hljs-number">68.4</span>]<br>t_c = torch.tensor(t_c)<br>t_u = torch.tensor(t_u)<br><span class="hljs-comment"># 定义模型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">model</span>(<span class="hljs-params">t_u, w, b</span>):<br>    <span class="hljs-keyword">return</span> w * t_u + b<br><span class="hljs-comment"># 定义损失函数，即输出拟合值和输出真值的平方差</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loss_fn</span>(<span class="hljs-params">t_p, t_c</span>):<br>    squared_diffs = (t_p - t_c)**<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> squared_diffs.mean()<br><span class="hljs-comment"># 定义权重和偏差</span><br>w = torch.ones(())<br>b = torch.zeros(())<br><span class="hljs-comment"># 计算损失函数</span><br>t_p = model(t_u, w, b)<br>loss = loss_fn(t_p, t_c)<br><span class="hljs-comment"># 损失/权重变化率，损失/偏差变化率</span><br>delta = <span class="hljs-number">0.1</span><br>loss_rate_of_change_w = \<br>    (loss_fn(model(t_u, w + delta, b), t_c) - <br>     loss_fn(model(t_u, w - delta, b), t_c)) / (<span class="hljs-number">2.0</span> * delta)<br>loss_rate_of_change_b = \<br>    (loss_fn(model(t_u, w, b + delta), t_c) - <br>     loss_fn(model(t_u, w, b - delta), t_c)) / (<span class="hljs-number">2.0</span> * delta)<br><span class="hljs-comment"># 设置学习率，更新权重</span><br>learning_rate = <span class="hljs-number">1e-2</span><br>w = w - learning_rate * loss_rate_of_change_w<br>b = b - learning_rate * loss_rate_of_change_b<br><span class="hljs-comment"># 为了更好更新权重，使delta趋近无穷小，也就是计算导数</span><br><span class="hljs-comment"># loss_fn的导数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dloss_fn</span>(<span class="hljs-params">t_p, t_c</span>):<br>    dsq_diffs = <span class="hljs-number">2</span> * (t_p - t_c) / t_p.size(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 除法来自均值的导数</span><br>    <span class="hljs-keyword">return</span> dsq_diffs<br><span class="hljs-comment"># model关于权重和偏差的导数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dmodel_dw</span>(<span class="hljs-params">t_u, w, b</span>):<br>    <span class="hljs-keyword">return</span> t_u<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dmodel_db</span>(<span class="hljs-params">t_u, w, b</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span><br><span class="hljs-comment"># 关于w和b的损失梯度的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grad_fn</span>(<span class="hljs-params">t_u, t_c, t_p, w, b</span>):<br>    dloss_dtp = dloss_fn(t_p, t_c)<br>    dloss_dw = dloss_dtp * dmodel_dw(t_u, w, b)<br>    dloss_db = dloss_dtp * dmodel_db(t_u, w, b)<br>    <span class="hljs-keyword">return</span> torch.stack([dloss_dw.<span class="hljs-built_in">sum</span>(), dloss_db.<span class="hljs-built_in">sum</span>()])<br><span class="hljs-comment"># 循环训练</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">training_loop</span>(<span class="hljs-params">n_epochs, learning_rate, params, t_u, t_c</span>):<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n_epochs + <span class="hljs-number">1</span>):<br>        w, b = params<br><br>        t_p = model(t_u, w, b)  <br>        loss = loss_fn(t_p, t_c)<br>        grad = grad_fn(t_u, t_c, t_p, w, b)  <br><br>        params = params - learning_rate * grad<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Epoch %d, Loss %f&#x27;</span> % (epoch, <span class="hljs-built_in">float</span>(loss))) <br>            <br>    <span class="hljs-keyword">return</span> params<br><br><span class="hljs-comment"># 开始训练</span><br>t_un = <span class="hljs-number">0.1</span> * t_u<br>params = training_loop(<br>    n_epochs = <span class="hljs-number">5000</span>, <br>    learning_rate = <span class="hljs-number">1e-2</span>, <br>    params = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>]), <br>    t_u = t_un, <br>    t_c = t_c)<br><br></code></pre></td></tr></table></figure><p>如果学习率过大，会导致参数更新过度、无法收敛；但如果学习率过小，则更新非常小，所以损失下降得非常慢，最终停滞不前。可以通过学习率自适应来解决这个问题，也就是说，根据更新的大小进行更改。</p><p>对于上例，权重的梯度大约是偏置梯度的50倍。这意味着权重和偏置存在于不同的比例空间中，在这种情况下，如果学习率足够大，能够有效更新其中一个参数，那么对于另一个参数来说，学习率就会变得不稳定，而一个只适合于另一个参数的学习率也不足以有意义地改变前者。可以采用归一化输入的方法使输入靠近输出，对于上例可以将t_u乘0.1。</p><h3 id="自动求导手动更新参数">自动求导手动更新参数</h3><p>PyTorch张量可以记住它们自己从何而来，根据产生它们的操作和父张量，它们可以根据输入自动提供这些操作的导数链。这意味着我们不需要手动推导模型，给定一个前向表达式，无论嵌套方式如何，PyTorch都会<strong>自动提供</strong>表达式相对其输入参数的梯度。</p><p>调用backward()将导致导数在叶节点上累加。再次调用backward()（就像在任何训练循环中一样），每个叶节点上的梯度将在上一次迭代中计算的梯度之上累加（求和），这会导致梯度计算不正确。为了防止这种情况发生，我们需要在每次迭代时明确地将梯度归零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">params = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>], requires_grad=<span class="hljs-literal">True</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">training_loop</span>(<span class="hljs-params">n_epochs, learning_rate, params, t_u, t_c</span>):<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n_epochs + <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 在调用loss.backward()之前的任何时间完成,清空累积的梯度</span><br>        <span class="hljs-keyword">if</span> params.grad <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: <br>            params.grad.zero_()<br>        <br>        t_p = model(t_u, *params) <br>        loss = loss_fn(t_p, t_c)<br>        <span class="hljs-comment"># PyTorch反向遍历计算图以计算梯度</span><br>        loss.backward()<br>        <br>        <span class="hljs-comment"># 在with块中对参数进行更新，在这里PyTorch自动求导机制将不起作用</span><br>        <span class="hljs-keyword">with</span> torch.no_grad(): <br>            params -= learning_rate * params.grad<br><br>        <span class="hljs-keyword">if</span> epoch % <span class="hljs-number">500</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Epoch %d, Loss %f&#x27;</span> % (epoch, <span class="hljs-built_in">float</span>(loss)))<br>            <br>    <span class="hljs-keyword">return</span> params<br></code></pre></td></tr></table></figure><h3 id="自动求导并更新参数">自动求导并更新参数</h3><p>使用优化器模块封装整个过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">params = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>], requires_grad=<span class="hljs-literal">True</span>)<br>learning_rate = <span class="hljs-number">1e-2</span><br>optimizer = optim.SGD([params], lr=learning_rate)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">training_loop</span>(<span class="hljs-params">n_epochs, optimizer, params, t_u, t_c</span>):<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n_epochs + <span class="hljs-number">1</span>):<br>        t_p = model(t_u, *params) <br>        loss = loss_fn(t_p, t_c)<br>        <span class="hljs-comment"># 清空累积梯度</span><br>        optimizer.zero_grad()<br>        <span class="hljs-comment"># 计算梯度</span><br>        loss.backward()<br>        <span class="hljs-comment"># 查看params.grad并更新params，从中减去学习率乘梯度，就像手动求导并更新参数</span><br>        optimizer.step()<br><br>        <span class="hljs-keyword">if</span> epoch % <span class="hljs-number">500</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Epoch %d, Loss %f&#x27;</span> % (epoch, <span class="hljs-built_in">float</span>(loss)))<br>            <br>    <span class="hljs-keyword">return</span> params<br></code></pre></td></tr></table></figure><h3 id="分割数据集">分割数据集</h3><p>为了避免过拟合，可以单独分出一部分数据作为验证集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 整个样本和验证集大小</span><br>n_samples = t_u.shape[<span class="hljs-number">0</span>]<br>n_val = <span class="hljs-built_in">int</span>(<span class="hljs-number">0.2</span> * n_samples)<br><br><span class="hljs-comment"># 打乱顺序</span><br>shuffled_indices = torch.randperm(n_samples)<br><br><span class="hljs-comment"># 划分训练集和验证集</span><br>train_indices = shuffled_indices[:-n_val]<br>val_indices = shuffled_indices[-n_val:]<br>train_t_u = t_u[train_indices]<br>train_t_c = t_c[train_indices]<br>val_t_u = t_u[val_indices]<br>val_t_c = t_c[val_indices]<br>train_t_un = <span class="hljs-number">0.1</span> * train_t_u<br>val_t_un = <span class="hljs-number">0.1</span> * val_t_u<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">training_loop</span>(<span class="hljs-params">n_epochs, optimizer, params, train_t_u, val_t_u,</span><br><span class="hljs-params">                  train_t_c, val_t_c</span>):<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n_epochs + <span class="hljs-number">1</span>):<br>        train_t_p = model(train_t_u, *params)<br>        train_loss = loss_fn(train_t_p, train_t_c)<br><br>        <span class="hljs-comment"># 对于val_loss，关闭自动求导，不构建自动求导图。</span><br>        <span class="hljs-comment"># 这不是必要的，因为后面并未对val_loss调用backward()。但是可以提高性能。</span><br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            val_t_p = model(val_t_u, *params)<br>            val_loss = loss_fn(val_t_p, val_t_c)<br>            <span class="hljs-keyword">assert</span> val_loss.requires_grad == <span class="hljs-literal">False</span> <br>        <br>        optimizer.zero_grad()<br>        <span class="hljs-comment"># 只在训练集上反向传播并更新参数</span><br>        train_loss.backward() <br>        optimizer.step()<br><br>        <span class="hljs-keyword">if</span> epoch &lt;= <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> epoch % <span class="hljs-number">500</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>, Training loss <span class="hljs-subst">&#123;train_loss.item():<span class="hljs-number">.4</span>f&#125;</span>,&quot;</span><br>                  <span class="hljs-string">f&quot; Validation loss <span class="hljs-subst">&#123;val_loss.item():<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>)<br>            <br>    <span class="hljs-keyword">return</span> params<br></code></pre></td></tr></table></figure><p>使用相关的<code>set_grad_enabled()</code>，还可以根据一个布尔表达式设定启用或禁用自动求导的条件。</p><h2 id="第6章-使用神经网络拟合数据">第6章 使用神经网络拟合数据</h2><p>神经元即线性变换+非线性激活函数。</p><p>激活函数两个作用：</p><ol type="1"><li>允许输出函数在不同的值上有不同的斜率，这是线性函数无法做到的。</li><li>将前面的线性运算的输出集中到给定的范围内。</li></ol><h3 id="线性模型">线性模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br><span class="hljs-comment"># 这里继续使用第5章的数据，但是需要添加以下代码，在轴1处扩充一个维度。nn中的所有模块都被编写为可以同时为多个输入产生输出。</span><br>t_c = torch.tensor(t_c).unsqueeze(<span class="hljs-number">1</span>) <br>t_u = torch.tensor(t_u).unsqueeze(<span class="hljs-number">1</span>) <br><br><span class="hljs-comment"># 入参：输入张量大小，输出张量大小，偏置（默认为True）</span><br>linear_model = nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <br>optimizer = optim.SGD(linear_model.parameters(), lr=<span class="hljs-number">1e-2</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">training_loop</span>(<span class="hljs-params">n_epochs, optimizer, model, loss_fn, t_u_train, t_u_val,</span><br><span class="hljs-params">                  t_c_train, t_c_val</span>):<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n_epochs + <span class="hljs-number">1</span>):<br>        t_p_train = model(t_u_train)<br>        loss_train = loss_fn(t_p_train, t_c_train)<br><br>        t_p_val = model(t_u_val) <br>        loss_val = loss_fn(t_p_val, t_c_val)<br>        <br>        optimizer.zero_grad()<br>        loss_train.backward() <br>        optimizer.step()<br><br>        <span class="hljs-keyword">if</span> epoch == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> epoch % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>, Training loss <span class="hljs-subst">&#123;loss_train.item():<span class="hljs-number">.4</span>f&#125;</span>,&quot;</span><br>                  <span class="hljs-string">f&quot; Validation loss <span class="hljs-subst">&#123;loss_val.item():<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>可以用<code>nn.MSELoss()</code>代替前面自定义的<code>loss_fn</code>做损失函数入参。</p><h3 id="神经网络">神经网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># seq_model可以直接替换上面的linear_model作为入参</span><br>seq_model = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>), <br>            nn.Tanh(),<br>            nn.Linear(<span class="hljs-number">13</span>, <span class="hljs-number">1</span>)) <br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Sequential(</span><br><span class="hljs-string">  (0): Linear(in_features=1, out_features=13, bias=True)</span><br><span class="hljs-string">  (1): Tanh()</span><br><span class="hljs-string">  (2): Linear(in_features=13, out_features=1, bias=True)</span><br><span class="hljs-string">)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># 调用model.parameters()将从第1个和第2个线性模块收集权重和偏置</span><br><span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> seq_model.named_parameters():<br>    <span class="hljs-built_in">print</span>(name, param.shape)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0.weight torch.Size([13, 1])</span><br><span class="hljs-string">0.bias torch.Size([13])</span><br><span class="hljs-string">2.weight torch.Size([1, 13])</span><br><span class="hljs-string">2.bias torch.Size([1])</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># 可以用OrderedDict对模块进行命名</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<br>seq_model = nn.Sequential(OrderedDict([<br>    (<span class="hljs-string">&#x27;hidden_linear&#x27;</span>, nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)),<br>    (<span class="hljs-string">&#x27;hidden_activation&#x27;</span>, nn.Tanh()),<br>    (<span class="hljs-string">&#x27;output_linear&#x27;</span>, nn.Linear(<span class="hljs-number">8</span>, <span class="hljs-number">1</span>))<br>]))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Sequential(</span><br><span class="hljs-string">  (hidden_linear): Linear(in_features=1, out_features=8, bias=True)</span><br><span class="hljs-string">  (hidden_activation): Tanh()</span><br><span class="hljs-string">  (output_linear): Linear(in_features=8, out_features=1, bias=True)</span><br><span class="hljs-string">)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>下图是seq_model的结构：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.jpg"alt="第一个简单神经网络结构" /><figcaption aria-hidden="true">第一个简单神经网络结构</figcaption></figure><h2 id="第7章-区分鸟和飞机从图像学习">第7章区分鸟和飞机：从图像学习</h2><h3 id="读取微小图像数据集">读取微小图像数据集</h3><p>CIFAR-10由60000张微小的（32像素×32像素）RGB图像组成，用一个整数对应10个级别中的1个：飞机（0）、汽车（1）、鸟（2）、猫（3）、鹿（4）、狗（5）、青蛙（6）、马（7）、船（8）和卡车（9）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br>torch.set_printoptions(edgeitems=<span class="hljs-number">2</span>, linewidth=<span class="hljs-number">75</span>)<br>torch.manual_seed(<span class="hljs-number">123</span>)<br><br>data_path = <span class="hljs-string">&#x27;../data-unversioned/p1ch7/&#x27;</span><br><br><span class="hljs-comment"># 预计算均值和方差用在transforms.Normalize中</span><br>tensor_cifar10 = datasets.CIFAR10(data_path, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">False</span>,transform=transforms.ToTensor())<br>imgs = torch.stack([img_t <span class="hljs-keyword">for</span> img_t, _ <span class="hljs-keyword">in</span> tensor_cifar10], dim=<span class="hljs-number">3</span>)<br><span class="hljs-comment"># torch.Size([3, 32, 32, 50000])</span><br>imgs.view(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>).mean(dim=<span class="hljs-number">1</span>)<br>imgs.view(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>).std(dim=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 读取的同时将PIL图像转化为张量并归一化</span><br>cifar10 = datasets.CIFAR10(<br>    data_path, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">False</span>,<br>    transform=transforms.Compose([<br>        transforms.ToTensor(),<br>        transforms.Normalize((<span class="hljs-number">0.4915</span>, <span class="hljs-number">0.4823</span>, <span class="hljs-number">0.4468</span>),<br>                             (<span class="hljs-number">0.2470</span>, <span class="hljs-number">0.2435</span>, <span class="hljs-number">0.2616</span>))<br>    ]))<br>cifar10_val = datasets.CIFAR10(<br>    data_path, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">False</span>,<br>    transform=transforms.Compose([<br>        transforms.ToTensor(),<br>        transforms.Normalize((<span class="hljs-number">0.4915</span>, <span class="hljs-number">0.4823</span>, <span class="hljs-number">0.4468</span>),<br>                             (<span class="hljs-number">0.2470</span>, <span class="hljs-number">0.2435</span>, <span class="hljs-number">0.2616</span>))<br>    ]))<br></code></pre></td></tr></table></figure><h3 id="区分鸟和飞机">区分鸟和飞机</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 取出鸟和飞机</span><br>class_names = [<span class="hljs-string">&#x27;airplane&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>]<br>label_map = &#123;<span class="hljs-number">0</span>: <span class="hljs-number">0</span>, <span class="hljs-number">2</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-comment"># cifar2对象已满足了Dataset的基本要求，即已定义了__len__()和__getitem__()函数</span><br>cifar2 = [(img, label_map[label])<br>          <span class="hljs-keyword">for</span> img, label <span class="hljs-keyword">in</span> cifar10 <br>          <span class="hljs-keyword">if</span> label <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]<br>cifar2_val = [(img, label_map[label])<br>              <span class="hljs-keyword">for</span> img, label <span class="hljs-keyword">in</span> cifar10_val<br>              <span class="hljs-keyword">if</span> label <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]<br><br><span class="hljs-comment"># softmax用概率表示输出</span><br><span class="hljs-comment"># 每个输出均在[0,1]内且输出总和为1</span><br><span class="hljs-comment"># def softmax(x):</span><br><span class="hljs-comment">#     return torch.exp(x) / torch.exp(x).sum()</span><br><br><span class="hljs-comment"># 训练</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br><span class="hljs-comment"># 输入数据加载器</span><br>train_loader = torch.utils.data.DataLoader(cifar2, batch_size=<span class="hljs-number">64</span>,<br>                                           shuffle=<span class="hljs-literal">True</span>)<br>model = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">3072</span>, <span class="hljs-number">512</span>),<br>            nn.Tanh(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">2</span>),<br>            nn.LogSoftmax(dim=<span class="hljs-number">1</span>))<br><br>learning_rate = <span class="hljs-number">1e-2</span><br>optimizer = optim.SGD(model.parameters(), lr=learning_rate)<br>loss_fn = nn.NLLLoss()<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_epochs):<br>    <span class="hljs-comment"># 在小批量上估计的梯度是在整个数据集上估计的梯度的较差近似值，有助于收敛并防止优化在过程中陷入局部极小。</span><br>    <span class="hljs-comment"># 在每个迭代周期重新打乱数据集有助于确保在小批量上估计的梯度序列代表在整个数据集上估计的梯度。</span><br>    <span class="hljs-keyword">for</span> imgs, labels <span class="hljs-keyword">in</span> train_loader:<br>        batch_size = imgs.shape[<span class="hljs-number">0</span>]<br>        outputs = model(imgs.view(batch_size, -<span class="hljs-number">1</span>))<br>        loss = loss_fn(outputs, labels)<br><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Epoch: %d, Loss: %f&quot;</span> % (epoch, <span class="hljs-built_in">float</span>(loss))) <br><br><span class="hljs-comment"># 计算分类正确率</span><br>val_loader = torch.utils.data.DataLoader(cifar2_val, batch_size=<span class="hljs-number">64</span>,<br>                                         shuffle=<span class="hljs-literal">False</span>)<br>correct = <span class="hljs-number">0</span><br>total = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">with</span> torch.no_grad():<br>   <span class="hljs-keyword">for</span> imgs, labels <span class="hljs-keyword">in</span> val_loader:<br>       batch_size = imgs.shape[<span class="hljs-number">0</span>]<br>       outputs = model(imgs.view(batch_size, -<span class="hljs-number">1</span>))<br>       _, predicted = torch.<span class="hljs-built_in">max</span>(outputs, dim=<span class="hljs-number">1</span>)<br>       total += labels.shape[<span class="hljs-number">0</span>]<br>       correct += <span class="hljs-built_in">int</span>((predicted == labels).<span class="hljs-built_in">sum</span>())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: %f&quot;</span>, correct / total)<br><br>Accuracy: <span class="hljs-number">0.794000</span><br></code></pre></td></tr></table></figure><p>nn.LogSoftmax()和nn.NLLLoss()的组合相当于使用nn.CrossEntropyLoss()。<strong>交叉熵损失函数</strong>是PyTorch的一个特性，实际上nn.NLLLoss()计算的是交叉熵，但将对数概率预测作为输入，其中nn.CrossEntropyLoss()用于计算分数（有时称为logits）。从技术上讲，nn.NLLLoss()计算的是把所有质量放在目标上的狄拉克分布和由对数概率输入给出的预测分布之间的交叉熵。</p><p>从神经网络中丢弃最后一个nn.LogSoftmax()，转而使用nn.CrossEntropyLoss()是很常见的。</p><h2 id="第8章-使用卷积进行泛化">第8章 使用卷积进行泛化</h2><h3 id="搭建卷积神经网络">搭建卷积神经网络</h3><p>仍然使用上一章加载好的数据。</p><p>torch.nn模块提供一维、二维、三维的卷积，其中nn.Conv1d用于时间序列，nn.Conv2d用于图像，nn.Conv3d用于体数据和视频。</p><p>卷积核各个方向的大小都相同是很常见的，因此PyTorch为此提供了一个快捷方式：每当为二维卷积指定kernel_size=3时，即3×3，Python是以tuple(3,3)提供的。对于三维卷积，核大小为3则表示是3×3×3。</p><p>给一个nn.Module的一个属性分配一个nn.Module实例，会自动将模块注册为<strong>子模块</strong>。子模板必须是顶级属性，而不是隐藏在list或dict实例中，否则优化器将无法定位子模块以及它们的参数。对于子模块需要列表和字典的情况，PyTorch提供<strong>nn.ModuleList</strong>和<strong>nn.ModuleDict</strong>。</p><p>虽然在1.0版本中像tanh这样的通用科学函数在torch.nn.functional中依然存在，但不建议使用这些入口点，而是使用顶级torch命名空间的函数。像max_pool2d()这样的小众函数将保留在torch.nn.functional中。</p><p>nn.Module模块实现了一个将模型所有参数移动到GPU上的<strong>to()</strong>方法，当你传递一个dtype参数时使用该方法还可以强制转换类型。对于Module.to来说，模块的实例会被修改，而Tensor.to会返回一个新的张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># PyTorch对于每个nn模块都有对应的函数式API。这里的“函数式”指的是“没有内部状态”，换句话说，“其输出值取决于输入参数的值”。</span><br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">16</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)<br>        self.conv2 = nn.Conv2d(<span class="hljs-number">16</span>, <span class="hljs-number">8</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)<br>        self.fc1 = nn.Linear(<span class="hljs-number">8</span> * <span class="hljs-number">8</span> * <span class="hljs-number">8</span>, <span class="hljs-number">32</span>)  <span class="hljs-comment"># 8通道的8*8像素图像</span><br>        self.fc2 = nn.Linear(<span class="hljs-number">32</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>    out = F.max_pool2d(torch.tanh(self.conv1(x)), <span class="hljs-number">2</span>)<br>    out = F.max_pool2d(torch.tanh(self.conv2(out)), <span class="hljs-number">2</span>)<br>    out = out.view(-<span class="hljs-number">1</span>, <span class="hljs-number">8</span> * <span class="hljs-number">8</span> * <span class="hljs-number">8</span>)  <span class="hljs-comment"># 从PyTorch 1.3开始我们可以用nn.Flatten</span><br>    out = torch.tanh(self.fc1(out))<br>    out = self.fc2(out)<br>    <span class="hljs-keyword">return</span> out<br><br><br><span class="hljs-keyword">import</span> datetime  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">training_loop</span>(<span class="hljs-params">n_epochs, optimizer, model, loss_fn, train_loader</span>):<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n_epochs + <span class="hljs-number">1</span>):   <br>        loss_train = <span class="hljs-number">0.0</span><br>        <span class="hljs-keyword">for</span> imgs, labels <span class="hljs-keyword">in</span> train_loader:    <br><br>            outputs = model(imgs)     <br>            loss = loss_fn(outputs, labels)    <br><br>            optimizer.zero_grad()   <br>            loss.backward()  <br>            optimizer.step()   <br><br>            loss_train += loss.item()    <span class="hljs-comment"># 使用item()方法将损失转换为一个数字很重要，以避免梯度变化</span><br><br>        <span class="hljs-keyword">if</span> epoch == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> epoch % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125; Epoch &#123;&#125;, Training loss &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>                datetime.datetime.now(), epoch,<br>                loss_train / <span class="hljs-built_in">len</span>(train_loader)))    <span class="hljs-comment"># 除以训练数据加载器的长度，得到每批平均损失，这是一种比求总和更直观的方法</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params">model, train_loader, val_loader</span>):<br>    <span class="hljs-keyword">for</span> name, loader <span class="hljs-keyword">in</span> [(<span class="hljs-string">&quot;train&quot;</span>, train_loader), (<span class="hljs-string">&quot;val&quot;</span>, val_loader)]:<br>        correct = <span class="hljs-number">0</span><br>        total = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">with</span> torch.no_grad():   <br>            <span class="hljs-keyword">for</span> imgs, labels <span class="hljs-keyword">in</span> loader:<br>                outputs = model(imgs)<br>                _, predicted = torch.<span class="hljs-built_in">max</span>(outputs, dim=<span class="hljs-number">1</span>)     <span class="hljs-comment"># 将最大值的索引作为输出</span><br>                total += labels.shape[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 计算样本的数量，因此total会随着批处理的大小而增加</span><br>                correct += <span class="hljs-built_in">int</span>((predicted == labels).<span class="hljs-built_in">sum</span>())  <span class="hljs-comment"># 比较具有最大概率的预测类和真实值标签，我们首先得到一个布尔数组。统计这个批次中预测值和实际值一致的项的总数</span><br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy &#123;&#125;: &#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(name , correct / total))<br></code></pre></td></tr></table></figure><h3 id="模型设计">模型设计</h3><p>训练模型涉及2个关键步骤：一是<strong>优化</strong>，当我们需要减少训练集上的损失时；二是<strong>泛化</strong>，当模型不仅要处理训练集，还要处理以前没有见过的数据，如验证集时。旨在简化这2个步骤的数学工具有时被归入正则化的标签之下。</p><p><strong>在损失中添加一个正则化项</strong></p><p>这是为了减小模型本身的权重，从而限制训练对它们增长的影响，对较大权重进行惩罚，使得损失更平滑，并且从拟合单个样本中获得的收益相对较少。</p><p>这类较流行的正则化项是<strong>L2正则化</strong>，它是模型中所有权重的平方和，而L1正则化是模型中所有权重的绝对值之和。它们都通过一个（小）因子进行缩放，这个因子是我们在训练前设置的超参数。</p><p>L2正则化也称为<strong>权重衰减</strong>。叫这个名字的原因是考虑到SGD和反向传播，L2正则化对参数w_i的负梯度为−2* lambda *w_i，其中lambda是前面提到的超参数，在PyTorch中简称为权重衰减。因此，在损失函数中加入L2正则化，相当于在优化步骤中将每个权重按其当前值的比例递减（因此称为权重衰减）。注意，权重衰减适用于网络的所有参数，例如偏置。</p><p>在PyTorch中，我们可以通过在损失中添加一项来很容易地实现正则化。计算完损失后，无论损失函数是什么，我们都可以对模型的参数进行迭代，将它们各自的平方（对于L2）或绝对值（对于L1）相加，然后反向传播。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">l2_lambda = <span class="hljs-number">0.001</span><br>l2_norm = <span class="hljs-built_in">sum</span>(p.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2.0</span>).<span class="hljs-built_in">sum</span>()<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> model.parameters())    <span class="hljs-comment"># 对L1正则化则使用abs()替换pow(2.0)</span><br>loss = loss + l2_lambda * l2_norm<br></code></pre></td></tr></table></figure><p>但是，PyTorch中的SGD优化器已经有一个weight_decay参数，该参数对应2*lambda，它在前面描述的更新过程中直接执行权重衰减。它完全等价于在损失中加入L2范数，而不需要在损失中累加项，也不涉及自动求导。</p><p><strong>不太依赖于单一输入：Dropout</strong></p><p>将网络每轮训练迭代中的神经元随机部分清零。Dropout在每次迭代中有效地生成具有不同神经元拓扑的模型，使得模型中的神经元在过拟合过程中协调记忆过程的机会更少。另一种观点是，Dropout在整个网络中干扰了模型生成的特征，产生了一种接近于增强的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.conv1_dropout = nn.Dropout2d(p=<span class="hljs-number">0.4</span>)<br></code></pre></td></tr></table></figure><blockquote><p>在训练过程中Dropout通常是活跃的，而在生产过程中评估一个训练模型时，会绕过Dropout，或者等效地给其分配一个等于0的概率。这是通过Dropout模块的train属性来控制的。回想一下，PyTorch允许我们在任意nn.Model子类上通过调用model.train()或model.eval()来实现2种模式的切换。调用将自动复制到子模块上，这样如果其中有Dropout，它将在随后的前向和后向传递中表现出相应的行为。</p></blockquote><p><strong>保持激活检查：批量归一化</strong></p><p>批量归一化使用在该中间位置收集的小批量样本的平均值和标准差来对中间输入进行移位和缩放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.conv1_batchnorm = nn.BatchNorm2d(num_features=n_chans1)<br></code></pre></td></tr></table></figure><blockquote><p>就像Dropout一样，批量归一化在训练和推理过程中需要表现出不同的行为。实际上，在推理时，我们希望避免特定输入的输出依赖于我们提供给模型的其他输入的统计数据的情况。因此，我们需要一种方法来继续归一化，但是这次要一次性固定所有的归一化参数。</p><p>在处理小批量时，除了估计当前小批量的平均值和标准差，PyTorch还更新代表整个数据集的平均值和标准差的运行估计数，作为近似值。这样，当用户指定model.eval()，并且模型包含批量归一化模块时，运行估计将被冻结并用于归一化。为了解冻运行估计并返回使用小批量统计信息，我们调用model.train()，就像我们对Dropout所做的那样。</p></blockquote><h1 id="第2部分-从现实世界的图像中学习肺癌的早期检测">第2部分从现实世界的图像中学习：肺癌的早期检测</h1><h2 id="第9章-使用pytorch来检测癌症">第9章 使用PyTorch来检测癌症</h2><p>本书这一部分的项目将以人体躯干的三维CT扫描作为输入，并输出疑似恶性肿瘤的位置（如果存在的话）。</p><blockquote><p>至少8GB内存的GPU，在CPU上尝试训练我们将建立的模型可能需要几个星期。还需要至少220GB的空闲磁盘空间来存储原始训练数据、缓存数据和训练过的模型。</p></blockquote><p>CT扫描本质上是三维X射线，以单通道数据的三维数组表示。</p><p>CT扫描的每一个体素都有一个数字值，大致对应其内部物质的平均质量密度。这些数据的大多数可视化显示高密度的骨骼和金属植入物是白色的，低密度的空气和肺组织是黑色的，脂肪和组织是灰色的。同样，这看起来有点儿像X射线，但有一些关键的区别。CT扫描和X射线的主要区别在于，X射线是在二维平面上的三维强度投影，在本例中是组织和骨密度，而CT扫描保留了数据的第三维。</p><p>CT扫描实际上测量的是放射性密度，它是被检查材料的质量密度和原子序数的函数。</p><p><strong>完整的端到端解决方案</strong></p><p>步骤1：加载原始CT扫描数据，并将其转换为可以使用PyTorch处理的数据格式。将原始数据转换为可以使用PyTorch处理的格式是你面对任何项目要执行的第1步。对于二维图像数据，该过程稍微简单，而对于非图像数据则更简单。</p><p>步骤2：使用PyTorch实现一种称为分割的技术来识别肺部潜在肿瘤的体素，这大致类似于生成一个用于输入分类器中的区域的热力图。这将使我们能够把注意力集中在肺部潜在的肿瘤上，而忽略大量无关的解剖结构，例如，一个人的胃里不可能有肺癌细胞。一般来说，在学习过程中，能够专注于一个单一的小任务是最好的。根据经验，在某些情况下，越复杂的模型结构可以产生越高级的结果，例如，我们在第2章中看到的GAN游戏。但是从头开始设计它们首先需要广泛掌握基本构建块，就像在跑之前要先学会走一样。</p><p>步骤3：将所关注的体素分组成块，即候选结节。在本项目，我们将在热力图上找到每个热点的粗略中心。每个结节都可以通过其中心点的索引、行和列来定位。我们这样做是为了向最终分类器呈现一个简单的、有约束的问题。对体素进行分组不会直接涉及PyTorch，这就是为什么我们将其分为一个单独的步骤。通常，当使用多步骤解决方案时，在较大的、以深度学习为动力的项目之间会有非深度学习黏合的步骤。</p><p>步骤4：利用三维卷积将候选结节分为实际结节或非结节。这在概念上类似于我们在第8章中提到的二维卷积。从候选结构决定肿瘤性质的特征对于所讨论的肿瘤来说是局部的，因此这种方法应该在限制输入数据大小和排除相关信息之间做出合理的平衡。做出这样的范围限制决策可以约束每个单独的任务，这有助于限制故障诊断时要检查的内容的数量。</p><p>步骤5：使用单个结节的联合分类来诊断患者。与上一步中的结节分类类似，我们将尝试仅根据影像数据判断结节是良性还是恶性。我们将对每个肿瘤的恶性程度进行最简单的预测，因为只要有一个肿瘤是恶性的，病人就会患上癌症。其他项目可能希望使用不同的方法将每个实例的预测聚合到一个文件中，在这里，我们会问：“有什么可疑之处吗？”所以最大值很适合用于聚合。如果我们要寻找定量信息，如“A型组织和B型组织的比例”，我们可能会选择一个合适的平均值。</p><p>我们将用于训练的数据为步骤3和步骤4提供了人工标注的输出，这使得我们可以将步骤2和步骤3看作与步骤4相对独立的项目。人体专家已经为结节的位置标注了数据，因此我们可以按照自己喜欢的顺序处理步骤2、步骤3或步骤4。</p><h2 id="第10章-将数据源组合成统一的数据集">第10章将数据源组合成统一的数据集</h2><p>我们的CT数据来自2个文件：一个.mhd文件包含元数据头信息，另一个.raw文件包含组成三维数组的原始数据。我们所讨论的CT扫描的每个文件的名称都以一个称为系列UID的唯一标识符开始，该名称依据医学中的数字成像和通信（DICOM）命名法。例如，对于uid1.2.3系列，有2个文件——1.2.3.mhd和1.2.3.raw。Ct类将使用上述2个文件生成三维数组，并进行矩阵转换，将病人坐标系（我们将在10.6节中详细讨论）转换为数组所需的索引、行和列坐标。这些坐标在图中显示为(I,R,C)，在代码中用_irc变量后缀表示。</p><p><strong>candidates.csv</strong>文件包含所有可能看起来像结节的肿块信息，无论这些肿块是恶性肿瘤、良性肿瘤还是其他。其中包含了CT序列、候选结节的位置，以及一个标示（指示该候选者是否真的是结节）:</p><blockquote><p>seriesuid,coordX,coordY,coordZ,class</p></blockquote><p>class是一个布尔值：0表示非结节的候选者，1表示结节的候选者，可能是恶性的或良性的。</p><p><strong>annotations.csv</strong>文件包含一些已标记为实际结节的候选者的信息：</p><blockquote><p>seriesuid,coordX,coordY,coordZ,diameter_mm</p></blockquote><p>annotations.csv文件中提供的位置信息并不总是与candidates.csv中的坐标精确对齐。</p><p>每个结节的信息：结节状态（用于训练模型进行分类）、直径（有助于在训练中获得良好的传播，因为大结节和小结节的特征不同）、序列（定位正确的CT扫描）和候选中心（在更大的CT扫描中寻找候选者）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>CandidateInfoTuple = namedtuple(<br>  <span class="hljs-string">&#x27;CandidateInfoTuple&#x27;</span>,<br>  <span class="hljs-string">&#x27;isNodule_bool, diameter_mm, series_uid, center_xyz&#x27;</span>,<br>)<br></code></pre></td></tr></table></figure><p>CT扫描的原始文件格式是DICOM，UNA已经将我们在本章中使用的数据转换为MetaIO格式，可以将数据文件的格式视为黑盒，并使用SimpleITK将它们加载到更熟悉的NumPy数组中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> SimpleITK <span class="hljs-keyword">as</span> sitk<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ct</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, series_uid</span>):<br>    mhd_path = glob.glob(<br>     <span class="hljs-string">&#x27;data-unversioned/part2/luna/subset*/&#123;&#125;.mhd&#x27;</span>.<span class="hljs-built_in">format</span>(series_uid)   <span class="hljs-comment"># 我们不关心跟踪给定的series_uid属于哪个子集，所以我们对数据集使用通配符来匹配</span><br>     )[<span class="hljs-number">0</span>]<br><br>    ct_mhd = sitk.ReadImage(mhd_path)  <span class="hljs-comment"># 除了传进来的.mhd文件，sitk.ReadImage还隐式地使用了.raw文件</span><br>    ct_a = np.array(sitk.GetArrayFromImage(ct_mhd), dtype=np.float32)    <span class="hljs-comment"># 再创建一个NumPy数组，因为我们想将值类型转换为np.float3</span><br></code></pre></td></tr></table></figure><p>我们使用创建CT扫描时分配的序列UID（series_uid）来识别特定的CT扫描。DICOM大量使用UID来表示单个DICOM文件、文件组、疗程等。UID在概念上与UUID相似，但是它们的创建过程不同，格式也不同。出于我们的目的，我们可以将它们视为不透明的ASCII字符串，作为引用各种CT扫描的唯一键。在正式场合，只有字符0～9和句号（.）是DICOMUID的有效字符。</p><p>10个子集每个有大约90个CT扫描，总共888个。每个CT扫描表示为2个文件：一个带有.mhd扩展名，一个带有.raw扩展名。然而，在多个文件之间分割的数据隐藏在sitk例程后面，这不是我们需要直接关注的。</p><p><strong>亨氏单位</strong></p><p>CT扫描以亨氏（HounsfieldUnit，缩写为HU）单位表达，它是一个奇特的单位。空气是−1000HU（接近于0g/cm3，其中g/cm3表示克/立方厘米），水是0 HU（1g/cm3），骨骼至少是+1000 HU（2～3g/cm3）。HU值通常存储在磁盘上，作为有符号的12位整数插入16位整数中，这非常符合CT扫描仪所能提供的精度水平。一些CT扫描仪使用对应负密度的HU值来表示CT扫描仪视角之外的体素。出于我们的目的，病人身体之外的所有东西都应该是空气，因此我们通过将值的下限设置为−1000HU来丢弃该视角信息。同样，骨骼、金属植入物等的精确密度与我们的用例无关，因此我们将密度限制在大约2g/cm3（1000 HU），尽管这种做法在生物学上并不准确。</p><h2 id="第11章-训练分类模型以检测可疑肿瘤">第11章训练分类模型以检测可疑肿瘤</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LunaModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_channels=<span class="hljs-number">1</span>, conv_channels=<span class="hljs-number">8</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        self.tail_batchnorm = nn.BatchNorm3d(<span class="hljs-number">1</span>)<br><br>        self.block1 = LunaBlock(in_channels, conv_channels)<br>        self.block2 = LunaBlock(conv_channels, conv_channels * <span class="hljs-number">2</span>)<br>        self.block3 = LunaBlock(conv_channels * <span class="hljs-number">2</span>, conv_channels * <span class="hljs-number">4</span>)<br>        self.block4 = LunaBlock(conv_channels * <span class="hljs-number">4</span>, conv_channels * <span class="hljs-number">8</span>)<br><br>        self.head_linear = nn.Linear(<span class="hljs-number">1152</span>, <span class="hljs-number">2</span>)<br>        self.head_softmax = nn.Softmax(dim=<span class="hljs-number">1</span>)<br><br>        self._init_weights()<br><br>    <span class="hljs-comment"># see also https://github.com/pytorch/pytorch/issues/18182</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_init_weights</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> self.modules():<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(m) <span class="hljs-keyword">in</span> &#123;<br>                nn.Linear,<br>                nn.Conv3d,<br>                nn.Conv2d,<br>                nn.ConvTranspose2d,<br>                nn.ConvTranspose3d,<br>            &#125;:<br>                nn.init.kaiming_normal_(<br>                    m.weight.data, a=<span class="hljs-number">0</span>, mode=<span class="hljs-string">&#x27;fan_out&#x27;</span>, nonlinearity=<span class="hljs-string">&#x27;relu&#x27;</span>,<br>                )<br>                <span class="hljs-keyword">if</span> m.bias <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    fan_in, fan_out = \<br>                        nn.init._calculate_fan_in_and_fan_out(m.weight.data)<br>                    bound = <span class="hljs-number">1</span> / math.sqrt(fan_out)<br>                    nn.init.normal_(m.bias, -bound, bound)<br><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, input_batch</span>):<br>        bn_output = self.tail_batchnorm(input_batch)<br><br>        block_out = self.block1(bn_output)<br>        block_out = self.block2(block_out)<br>        block_out = self.block3(block_out)<br>        block_out = self.block4(block_out)<br><br>        conv_flat = block_out.view(<br>            block_out.size(<span class="hljs-number">0</span>),<br>            -<span class="hljs-number">1</span>,<br>        )<br>        linear_output = self.head_linear(conv_flat)<br><br>        <span class="hljs-keyword">return</span> linear_output, self.head_softmax(linear_output)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LunaBlock</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_channels, conv_channels</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        self.conv1 = nn.Conv3d(<br>            in_channels, conv_channels, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">True</span>,<br>        )<br>        self.relu1 = nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        self.conv2 = nn.Conv3d(<br>            conv_channels, conv_channels, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">True</span>,<br>        )<br>        self.relu2 = nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br><br>        self.maxpool = nn.MaxPool3d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, input_batch</span>):<br>        block_out = self.conv1(input_batch)<br>        block_out = self.relu1(block_out)<br>        block_out = self.conv2(block_out)<br>        block_out = self.relu2(block_out)<br><br>        <span class="hljs-keyword">return</span> self.maxpool(block_out)<br></code></pre></td></tr></table></figure><h2 id="第12章-通过指标和数据增强来提升训练">第12章通过指标和数据增强来提升训练</h2><p>定义和计算精度、召回率、真/假阳性或阴性。</p><p>使用F1分数和其他质量指标。</p><p>平衡和增强数据以减少过拟合。</p><p>使用TensorBoard绘制质量指标。</p><h2 id="第13章-利用分割法寻找可疑结节">第13章利用分割法寻找可疑结节</h2><p>用像素模型分割数据。</p><p>使用U-Net进行分割。</p><p>理解使用骰子损失的掩码预测。</p><p>评估分割模型的性能。</p><h2 id="第14章-端到端的结节分析及下一步的方向">第14章端到端的结节分析及下一步的方向</h2><p>连接分割和分类模型。</p><p>为新任务微调网络。</p><p>向TensorBoard添加直方图和其他指标类型。</p><p>从过拟合到泛化。</p><h1 id="第3部分-部署">第3部分 部署</h1><h2 id="第15章-部署到生产环境">第15章 部署到生产环境</h2><h3 id="pytorch模型的服务">15.1 PyTorch模型的服务</h3><p>使用flask在服务器端接受请求以运行模型返回结果。</p><p>使用Sanic异步并行处理批处理请求。</p><h3 id="导出模型">15.2 导出模型</h3><p><strong>ONNX</strong></p><p>从某种意义上说，深度学习模型是一个具有非常特定的指令集的程序，由矩阵乘法、卷积、ReLU、tanh等精细运算组成。因此，如果我们可以序列化计算，我们可以在另一个理解其低级操作的运行时中重新执行它。ONNX是描述这些操作及其参数的标准格式。</p><p>大多数现代深度学习框架都支持将它们的计算序列化到ONNX，其中一些框架可以加载ONNX文件并执行它（尽管PyTorch不是这样）。一些低占用（“边缘”）设备接受将ONNX文件作为输入，并为特定设备生成低级指令。一些云计算提供商现在允许上传ONNX文件，并通过REST端点查看它公开的内容。</p><p><strong>TorchScript</strong></p><p>当互操作性不是关键，但我们需要避开PythonGIL或以其他方式导出网络时，我们可以使用PyTorch自己的表示——TorchScript图。</p><p>制作TorchScript模型最简单的一种方法是跟踪它。这看起来很像ONNX导出。这并不奇怪，因为跟踪也是ONNX模型在底层使用的方法。这里我们只是使用torch.jit.trace()函数将虚拟输入输入模型中。</p><h3 id="与pytorch-jit编译器交互">15.3 与PyTorch JIT编译器交互</h3><p>PyTorch JIT编译器在PyTorch1.0中首次亮相，它是PyTorch许多创新的核心，其中最重要的是提供了一组丰富的部署选项。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-10-11-4种调用PyTorch函数的方法.jfif"alt="4种调用PyTorch函数的方法" /><figcaption aria-hidden="true">4种调用PyTorch函数的方法</figcaption></figure><h3 id="libtorchc中的pytorch">15.4 LibTorch：C++中的PyTorch</h3><p>放弃Python而直接使用C++ API。</p><h3 id="部署到移动设备">15.5　部署到移动设备</h3><p>PyTorch的C++部分，即LibTorch，可以在Android上编译，我们可以使用AndroidJava本地接口（Java NativeInterface，JNI）从Java编写的应用程序中访问它。但我们实际上只需要PyTorch中的几个函数，加载JITed模型，将输入转换为张量和IValue，在模型中运行它们，然后返回结果。为了省去使用JNI的麻烦，PyTorch开发人员将这些函数封装到一个名为PyTorchMobile的小型库中。</p><h3 id="新兴技术pytorch模型的企业服务">15.6新兴技术：PyTorch模型的企业服务</h3><p>略。</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《DirectX 12 3D 游戏开发实战》笔记</title>
      <link href="//posts/Notebook/Introduction-to-3D-Game-Programming-with-DirectX-12-note/"/>
      <url>//posts/Notebook/Introduction-to-3D-Game-Programming-with-DirectX-12-note/</url>
      
        <content type="html"><![CDATA[<p>Introduction to 3D Game Programming with DirectX 12</p><span id="more"></span><p>Frank D. Luna 著</p><p>王陈 译</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-DX123D_s.jpg"alt="封面" /><figcaption aria-hidden="true">封面</figcaption></figure><p class="note note-primary">摘录整理。</p><p class="note note-warning">未完成</p><h2 id="注意">注意</h2><p><a href="https://github.com/d3dcoder/d3d12book">配套代码地址</a></p><p>对书中第一个实例进行编译时可能遇到错误，可以参考<ahref="https://i-got-it.blog.csdn.net/article/details/112689870">这篇文章</a>。将项目属性中的【语言】的【符合模式】设置为<strong>否</strong>（或者<strong>默认</strong>），检查就不严格了。</p><h1 id="前言">前言</h1><p>DirectX SDK在MSDN上的最新文档为《Direct3D 12 ProgrammingGuide》，即《Direct3D 12编程指南》。</p><p>书中创建演示项目需要注意的地方（书中使用VS2015）：</p><blockquote><p>以VS2022为例，创建新项目，C++ -&gt; Windows桌面向导 -&gt;选择桌面应用程序，勾选空项目</p></blockquote><p>通过在源代码文件Common/d3dApp.h中使用#pragma预处理指令来链接所需的库文件，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;d3dcompiler.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;D3D12.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;dxgi.lib&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>对于创建演示程序而言，该预处理指令使我们免于打开项目属性页面并在连接器配置项下指定附加依赖库。</p><blockquote><p>可能需要修改CompileShader里shader文件的相对路径。比如如果没有勾选“将解决方案和目录放在同一目录中”，原相对路劲需要加上..//，因为多了一层。</p></blockquote><blockquote><p>本书使用<ahref="https://directx11.tech/#/misc/Compile?id=方法3：运行期间编译着色器代码，生成字节码">方法3</a>编译着色器文件。</p></blockquote><p>尤其是到了Direct3D12，更像Mantle等API那样<strong>实现了前所未有的更底层的硬件抽象</strong>，削减驱动层的工作，转交给开发者负责，从而令图形的处理流程更加“智能”，使用起来犹如贴地飞行的“快感”。</p><p>DirectX包罗系列与多媒体以及游戏开发有关的API，因此<strong>Direct3D只是DirectX的一个子集</strong>。详细信息请见《DirectXGraphics and Graming》（ee663274）。本书则侧重Direct3D的讲解。</p><blockquote><p>建议先把本书<strong>附录ABC</strong>看完。</p></blockquote><h1 id="第一部分-必备的数学知识">第一部分 必备的数学知识</h1><h2 id="第1章-向量代数">第1章 向量代数</h2><p><strong>向量</strong>（vector）是一种兼具大小（也称为模，magnitude）和方向的量。具有这两种属性的量皆称为向量值物理量（vector-valuedquantity）。</p><p>Direct3D采用的是<strong>左手坐标系</strong>（left-handed coordinatesystem）。如果我们伸出左手，并拢手指，假设它们指向的是x轴的正方向，再弯曲四指指向y轴的正方向，则最后伸直拇指的方向大约就是z轴的正方向。</p><p>把一个向量的长度变为单位长度称为向量的<strong>规范化</strong>（normalizing）处理。</p><p>对于具有n个向量的一般集合而言，为了将其正交化为规范正交集，我们就要使用<strong>格拉姆—施密特正交化</strong>（Gram-SchmidtOrthogonalization）方法进行处理。</p><p>只有3D向量的叉积有定义（不存在2D向量叉积）。</p><p>对于Windows 8及其以上版本来讲，DirectXMath（其前身为XNAMath数学库，DirectXMath正是基于此而成）是一款为Direct3D应用程序量身打造的3D数学库，而它也自此成为了WindowsSDK的一部分。该数学库采用了<strong>SIMD流指令扩展2</strong>（StreamingSIMD Extensions2，SSE2）指令集。借助128位宽的<strong>单指令多数据</strong>（SingleInstruction MultipleData，SIMD）寄存器，利用一条SIMD指令即可同时对4个32位浮点数或整数进行运算。</p><p>对于希望了解如何开发一个优秀的SIMD向量库，乃至希望深入理解DirectXMath库设计原理的读者，我们在这里推荐一篇文章<strong>《DesigningFast Cross-Platform SIMD VectorLibraries（设计快速的跨平台SIMD向量库）》</strong>。</p><p><strong>DirectXMath库</strong>对应头文件#include&lt;DirectXMath.h&gt;和#include&lt;DirectXPackedVector.h&gt;。除此之外并不需要其他的库文件，因为所有的代码都以内联的方式实现在头文件里。DirectXMath.h文件中的代码都存在于DirectX命名空间之中，而DirectXPackedVector.h文件中的代码则都位于DirectX::PackedVector命名空间以内。</p><p>在DirectXMath库中，核心的向量类型是<strong>XMVECTOR</strong>，它将被映射到SIMD硬件寄存器。通过SIMD指令的配合，利用这种具有128位的类型能一次性处理4个32位的浮点数。在开启SSE2后，此类型在x86和x64平台的定义是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> __m128 XMVECTOR;<br></code></pre></td></tr></table></figure><p>这里的__m128是一种特殊的SIMD类型（定义见xmmintrin.h）。在计算向量的过程中，必须通过此类型才可充分地利用SIMD技术。正如前文所述，我们将通过SIMD技术来处理2D和3D向量运算，而计算过程中用不到的向量分量则将它置零并忽略。</p><p>XMVECTOR类型的数据需要<strong>按16字节对齐</strong>，<strong>对于局部变量和全局变量而言都是自动实现的</strong>。至于类中的数据成员，建议分别使用XMFLOAT2（2D向量）、XMFLOAT3（3D向量）和XMFLOAT4（4D向量）类型来加以代替。</p><p>XMVECTOR使用方法：</p><ol type="1"><li>局部变量或全局变量用XMVECTOR类型。</li><li>对于类中的数据成员，使用XMFLOAT2、XMFLOAT3和XMFLOAT4类型。</li><li>在运算之前，通过加载函数将XMFLOATn类型转换为XMVECTOR类型。</li><li>用XMVECTOR实例来进行运算。</li><li>通过存储函数将XMVECTOR类型转换为XMFLOATn类型。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// XMFLOATn定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">XMFLOAT2</span><br>&#123;<br>  <span class="hljs-type">float</span> x;<br>  <span class="hljs-type">float</span> y;<br><br>  <span class="hljs-built_in">XMFLOAT2</span>() &#123;&#125;<br>  <span class="hljs-built_in">XMFLOAT2</span>(<span class="hljs-type">float</span> _x, <span class="hljs-type">float</span> _y) : <span class="hljs-built_in">x</span>(_x), <span class="hljs-built_in">y</span>(_y) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">XMFLOAT2</span><span class="hljs-params">(_In_reads_(<span class="hljs-number">2</span>) <span class="hljs-type">const</span> <span class="hljs-type">float</span> *pArray)</span> : </span><br><span class="hljs-function">    x(pArray[<span class="hljs-number">0</span>]), y(pArray[<span class="hljs-number">1</span>]) &#123;</span>&#125;<br><br>  XMFLOAT2&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> XMFLOAT2&amp; Float2) <br>  &#123; x = Float2.x; y = Float2.y; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>&#125;;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">XMFLOAT3</span><br>&#123;<br>  <span class="hljs-type">float</span> x;<br>  <span class="hljs-type">float</span> y;<br>  <span class="hljs-type">float</span> z;<br><br>  <span class="hljs-built_in">XMFLOAT3</span>() &#123;&#125;<br>  <span class="hljs-built_in">XMFLOAT3</span>(<span class="hljs-type">float</span> _x, <span class="hljs-type">float</span> _y, <span class="hljs-type">float</span> _z) : <span class="hljs-built_in">x</span>(_x), <span class="hljs-built_in">y</span>(_y), <span class="hljs-built_in">z</span>(_z) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">XMFLOAT3</span><span class="hljs-params">(_In_reads_(<span class="hljs-number">3</span>) <span class="hljs-type">const</span> <span class="hljs-type">float</span> *pArray)</span> : </span><br><span class="hljs-function">    x(pArray[<span class="hljs-number">0</span>]), y(pArray[<span class="hljs-number">1</span>]), z(pArray[<span class="hljs-number">2</span>]) &#123;</span>&#125;<br><br>  XMFLOAT3&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> XMFLOAT3&amp; Float3) <br>  &#123; x = Float3.x; y = Float3.y; z = Float3.z; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">XMFLOAT4</span><br>&#123;<br>  <span class="hljs-type">float</span> x;<br>  <span class="hljs-type">float</span> y;<br>  <span class="hljs-type">float</span> z;<br>  <span class="hljs-type">float</span> w;<br><br>  <span class="hljs-built_in">XMFLOAT4</span>() &#123;&#125;<br>  <span class="hljs-built_in">XMFLOAT4</span>(<span class="hljs-type">float</span> _x, <span class="hljs-type">float</span> _y, <span class="hljs-type">float</span> _z, <span class="hljs-type">float</span> _w) : <br>    <span class="hljs-built_in">x</span>(_x), <span class="hljs-built_in">y</span>(_y), <span class="hljs-built_in">z</span>(_z), <span class="hljs-built_in">w</span>(_w) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">XMFLOAT4</span><span class="hljs-params">(_In_reads_(<span class="hljs-number">4</span>) <span class="hljs-type">const</span> <span class="hljs-type">float</span> *pArray)</span> : </span><br><span class="hljs-function">    x(pArray[<span class="hljs-number">0</span>]), y(pArray[<span class="hljs-number">1</span>]), z(pArray[<span class="hljs-number">2</span>]), w(pArray[<span class="hljs-number">3</span>]) &#123;</span>&#125;<br><br>  XMFLOAT4&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> XMFLOAT4&amp; Float4) <br>  &#123; x = Float4.x; y = Float4.y; z = Float4.z; w = Float4.w; <span class="hljs-keyword">return</span> <br>    *<span class="hljs-keyword">this</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将数据从XMFLOAT2类型中加载到XMVECTOR类型</span><br><span class="hljs-function">XMVECTOR XM_CALLCONV <span class="hljs-title">XMLoadFloat2</span><span class="hljs-params">(<span class="hljs-type">const</span> XMFLOAT2 *pSource)</span></span>;<br><br><span class="hljs-comment">// 将数据从XMFLOAT3类型中加载到XMVECTOR类型</span><br><span class="hljs-function">XMVECTOR XM_CALLCONV <span class="hljs-title">XMLoadFloat3</span><span class="hljs-params">(<span class="hljs-type">const</span> XMFLOAT3 *pSource)</span></span>;<br><br><span class="hljs-comment">// 将数据从XMFLOAT4类型中加载到XMVECTOR类型</span><br><span class="hljs-function">XMVECTOR XM_CALLCONV <span class="hljs-title">XMLoadFloat4</span><span class="hljs-params">(<span class="hljs-type">const</span> XMFLOAT4 *pSource)</span></span>;<br><br><span class="hljs-comment">// 将数据从XMVECTOR类型中存储到XMFLOAT2类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> XM_CALLCONV <span class="hljs-title">XMStoreFloat2</span><span class="hljs-params">(XMFLOAT2 *pDestination, FXMVECTOR V)</span></span>;<br><br><span class="hljs-comment">// 将数据从XMVECTOR类型中存储到XMFLOAT3类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> XM_CALLCONV <span class="hljs-title">XMStoreFloat3</span><span class="hljs-params">(XMFLOAT3 *pDestination, FXMVECTOR V)</span></span>;<br><br><span class="hljs-comment">// 将数据从XMVECTOR类型中存储到XMFLOAT4类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> XM_CALLCONV <span class="hljs-title">XMStoreFloat4</span><span class="hljs-params">(XMFLOAT4 *pDestination, FXMVECTOR V)</span></span>;<br><br><span class="hljs-comment">// 只希望从XMVECTOR实例中得到某一个向量分量或将某一向量分量转换为XMVECTOR类型时的存取方法</span><br><span class="hljs-function"><span class="hljs-type">float</span> XM_CALLCONV <span class="hljs-title">XMVectorGetX</span><span class="hljs-params">(FXMVECTOR V)</span></span>;<br><span class="hljs-function"><span class="hljs-type">float</span> XM_CALLCONV <span class="hljs-title">XMVectorGetY</span><span class="hljs-params">(FXMVECTOR V)</span></span>;<br><span class="hljs-function"><span class="hljs-type">float</span> XM_CALLCONV <span class="hljs-title">XMVectorGetZ</span><span class="hljs-params">(FXMVECTOR V)</span></span>;<br><span class="hljs-function"><span class="hljs-type">float</span> XM_CALLCONV <span class="hljs-title">XMVectorGetW</span><span class="hljs-params">(FXMVECTOR V)</span></span>;<br><br><span class="hljs-function">XMVECTOR XM_CALLCONV <span class="hljs-title">XMVectorSetX</span><span class="hljs-params">(FXMVECTOR V, <span class="hljs-type">float</span> x)</span></span>;<br><span class="hljs-function">XMVECTOR XM_CALLCONV <span class="hljs-title">XMVectorSetY</span><span class="hljs-params">(FXMVECTOR V, <span class="hljs-type">float</span> y)</span></span>;<br><span class="hljs-function">XMVECTOR XM_CALLCONV <span class="hljs-title">XMVectorSetZ</span><span class="hljs-params">(FXMVECTOR V, <span class="hljs-type">float</span> z)</span></span>;<br><span class="hljs-function">XMVECTOR XM_CALLCONV <span class="hljs-title">XMVectorSetW</span><span class="hljs-params">(FXMVECTOR V, <span class="hljs-type">float</span> w)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>为了使代码更具通用性</strong>，不受具体平台、编译器的影响，我们将利用FXMVECTOR、GXMVECTOR、HXMVECTOR和CXMVECTOR类型来传递XMVECTOR类型的参数。基于特定的平台和编译器，它们会被自动地定义为适当的类型。</p><p>一定要把调用约定注解XM_CALLCONV加在函数名之前，它会根据编译器的版本确定出对应的调用约定属性。</p><p>传递XMVECTOR参数的规则如下：</p><ol type="1"><li>前3个XMVECTOR参数应当用类型FXMVECTOR；</li><li>第4个XMVECTOR参数应当用类型GXMVECTOR；</li><li>第5、6个XMVECTOR参数应当用类型HXMVECTOR；</li><li>其余的XMVECTOR参数应当用类型CXMVECTOR。</li></ol><p>传递XMVECTOR参数的规则仅适用于“输入”参数。“输出”的XMVECTOR参数（即XMVECTOR&amp;或XMVECTOR*）则不会占用SSE/SSE2寄存器，所以它们的处理方式与非XMVECTOR类型的参数一致。</p><p>在编写<strong>构造函数</strong>时，前3个XMVECTOR参数用FXMVECTOR类型，其余XMVECTOR参数则用CXMVECTOR类型。另外，<strong>对于构造函数不要使用XM_CALLCONV注解</strong>。</p><p>XMVECTOR类型的<strong>常量实例</strong>应当用XMVECTORF32类型来表示。</p><p>即使在数学上计算的结果是标量（如点积），库函数所返回的类型依旧是XMVECTOR，而得到的标量结果则被复制到XMVECTOR中的各个分量之中。这样做的原因之一是：将标量和SIMD向量的混合运算次数降到最低，使用户除了自定义的计算之外全程都使用SIMD技术，以<strong>提升计算效率</strong>。</p><h2 id="第2章-矩阵代数">第2章 矩阵代数</h2><p>从几何的角度来解释<strong>行列式</strong>，行列式反映了在线性变换下，（n维多面体）体积变化的相关信息。另外，行列式也应用于解线性方程组的克莱姆法则（Cramer’sRule，亦称克莱默法则）。此书中学习行列式的主要目的是：利用它推导出求逆矩阵的公式。此外，行列式还可以用于证明：方阵A是可逆的，当且仅当detA不为0。</p><p>在3D图形学中，主要使用4X4矩阵。</p><p>存在逆矩阵的方阵称为<strong>可逆矩阵</strong>（invertiblematrix），不存在逆矩阵的方阵称作<strong>奇异矩阵</strong>（singularmatrix）。 <span class="math display">\[A^{-1}=\frac{A^*}{detA}\]</span>对于规模较小的矩阵（4x4及其以下规模的矩阵）来说，运用伴随矩阵的方法将得到不错的计算效率。但针对规模更大的矩阵而言，就要使用诸如高斯消元法（Gaussianelimination，也作高斯消去法）等其他手段。由于我们关注于3D计算机图形学中所涉及的具有特殊形式的矩阵，因此也就提前确定出了它们的求逆矩阵公式。</p><p>DirectXMath以定义在DirectXMath.h头文件中的XMMATRIX类来表示4x4矩阵。</p><p>就像通过XMFLOAT2 (2D)，XMFLOAT3 (3D)和XMFLOAT4(4D)来存储类中不同维度的向量一样，DirectXMath文档也建议我们用XMFLOAT4X4来存储类中的矩阵类型数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">XMFLOAT4X4</span><br>&#123;<br>  <span class="hljs-keyword">union</span><br>  &#123;<br>    <span class="hljs-keyword">struct</span><br>    &#123;<br>      <span class="hljs-type">float</span> _11, _12, _13, _14;<br>      <span class="hljs-type">float</span> _21, _22, _23, _24;<br>      <span class="hljs-type">float</span> _31, _32, _33, _34;<br>      <span class="hljs-type">float</span> _41, _42, _43, _44;<br>    &#125;;<br>    <span class="hljs-type">float</span> m[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br>  &#125;;<br><br>  <span class="hljs-built_in">XMFLOAT4X4</span>() &#123;&#125;<br>  <span class="hljs-built_in">XMFLOAT4X4</span>(<span class="hljs-type">float</span> m00, <span class="hljs-type">float</span> m01, <span class="hljs-type">float</span> m02, <span class="hljs-type">float</span> m03,<br>             <span class="hljs-type">float</span> m10, <span class="hljs-type">float</span> m11, <span class="hljs-type">float</span> m12, <span class="hljs-type">float</span> m13,<br>             <span class="hljs-type">float</span> m20, <span class="hljs-type">float</span> m21, <span class="hljs-type">float</span> m22, <span class="hljs-type">float</span> m23,<br>             <span class="hljs-type">float</span> m30, <span class="hljs-type">float</span> m31, <span class="hljs-type">float</span> m32, <span class="hljs-type">float</span> m33);<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">XMFLOAT4X4</span><span class="hljs-params">(_In_reads_(<span class="hljs-number">16</span>) <span class="hljs-type">const</span> <span class="hljs-type">float</span> *pArray)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">float</span>    <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> Row, <span class="hljs-type">size_t</span> Column)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m[Row][Column]; &#125;<br>  <span class="hljs-function"><span class="hljs-type">float</span>&amp;   <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> Row, <span class="hljs-type">size_t</span> Column)</span> </span>&#123; <span class="hljs-keyword">return</span> m[Row][Column]; &#125;<br><br>  XMFLOAT4X4&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> XMFLOAT4X4&amp; Float4x4);<br>&#125;;<br></code></pre></td></tr></table></figure><p>加载与存储：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> XMMATRIX XM_CALLCONV <span class="hljs-title">XMLoadFloat4x4</span><span class="hljs-params">(<span class="hljs-type">const</span> XMFLOAT4X4* pSource)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> XM_CALLCONV <span class="hljs-title">XMStoreFloat4x4</span><span class="hljs-params">(XMFLOAT4X4* pDestination, FXMMATRIX M)</span></span>;<br></code></pre></td></tr></table></figure><p>在声明具有XMMATRIX参数的函数时，除了要注意1个XMMATRIX应计作4个XMVECTOR参数这一点之外，其他的规则与传入XMVECTOR类型的参数时相一致。假设传入函数的FXMVECTOR参数不超过两个，则第一个XMMATRIX参数应当为FXMMATRIX类型，其余的XMMATRIX参数均应为CXMMATRIX类型。</p><p>在32位Windows操作系统上的__fastcall调用约定中，XMMATRIX类型的参数是不能传至SSE/SSE2寄存器的，因为这些寄存器此时只支持3个XMVECTOR参数传入。而XMMATRIX参数却是由4个XMVECTOR构成，所以矩阵类型的数据只能通过堆栈来加以引用。</p><p>DirectXMath建议用户总是在<strong>构造函数</strong>中采用CXMMATRIX类型来获取XMMATRIX参数，而且对于构造函数也不要使用XM_CALLCONV约定注解。</p><h2 id="第3章-变换">第3章 变换</h2><p>旋转矩阵有个有趣的性质：每个行向量都为单位长度且两两正交。也就是说，这些行向量都是规范正交的（orthonormal，即互相正交且具有单位长度）。若一个矩阵的行向量都是规范正交的，则称此矩阵为<strong>正交矩阵</strong>（orthogonalmatrix）。正交矩阵有个引人注目的性质，即它的逆矩阵与转置矩阵是相等的。</p><p><strong>仿射变换</strong>（affinetransformation）是由一个线性变换与一个平移变换组合而成的。</p><p>我们通过4x4矩阵来表示变换，并利用1x4齐次坐标来描述点和向量。在采用齐次坐标表示法时，我们将坐标扩充为四元组，其中，第四个坐标w的取值将根据被描述对象是点还是向量而定。具体来讲：</p><blockquote><p>1．(x,y,z,0)表示向量</p><p>2．(x,y,z,1)表示点</p></blockquote><p>设w=1能使点被正确地平移，设w=0则可以防止向量坐标受到平移操作的影响。</p><p>我们能够将一个改变几何体的复合变换（缩放、旋转和平移），解释为一种对应的坐标变换。由于我们以后通常要将世界空间的坐标变换矩阵定义为缩放、旋转和平移操作组成的复合变换，所以了解这一点是很重要的。</p><p>由于矩阵的乘法运算满足<strong>结合律</strong>，因此我们就能够将若干种变换矩阵合而为一。此矩阵给予物体的变换效果，与合成它的多个单一矩阵对物体按次序进行变换的净效果相同。</p><h1 id="第二部分-direct3d基础">第二部分 Direct3D基础</h1><h2 id="第4章-direct3d的初始化">第4章 Direct3D的初始化</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-03-30-framework.jpg"alt="图片截取自Lemnik" /><figcaption aria-hidden="true">图片截取自Lemnik</figcaption></figure><p>GPU的生产厂商如NVIDIA、Intel和AMD等公司就必须与Direct3D团队一同合作，为用户提供与Direct3D设备相兼容的驱动。</p><p>除了添加一些新的渲染特性以外，Direct3D12经重新设计已焕然一新，较之上一个版本的主要改变在于其性能优化方面在大大减少了CPU开销的同时，又改进了对多线程的支持。为了达到这些性能目标，Direct3D12的API较Direct3D11<strong>更偏于底层</strong>。另外，API抽象程度的降低使它更趋于具体化，与现代GPU的构架也更为契合，因此也就促使开发者要付出比昔日更多的努力。当然，使用这种更复杂的API所得到的回报是：性能的提升。</p><p><strong>组件对象模型</strong>（Component ObjectModel，COM）是一种令DirectX不受编程语言束缚，并且使之向后兼容的技术。</p><blockquote><p>我们通常将COM对象视为一种接口，但考虑当前编程的目的，遂将它当作一个C++类来使用。用C++语言编写DirectX程序时，COM帮我们隐藏了大量底层细节。我们只需知道：要获取指向某COM接口的指针，需借助特定函数或另一COM接口的方法——而不是用C++语言中的关键字new去创建一个COM接口。另外，COM对象会统计其引用次数；因此，在使用完某接口时，我们便应调用它的Release方法（COM接口的所有功能都是从IUnknown这个COM接口继承而来的，包括Release方法在内），而不是用delete来删除——当COM对象的引用计数为0时，它将自行释放自己所占用的内存。</p></blockquote><p>为了辅助用户管理COM对象的生命周期，Windows运行时库（Windows RuntimeLibrary，WRL）专门为此提供了Microsoft::WRL::ComPtr类（#include&lt;wrl.h&gt;），我们可以<strong>把它当作是COM对象的智能指针</strong>。当一个ComPtr实例超出作用域范围时，它便会自动调用相应COM对象的Release方法，继而省掉了我们手动调用的麻烦。</p><p>本书中常用的3个ComPtr方法如下。</p><ol type="1"><li><p>Get：返回一个指向此底层COM接口的指针。此方法常用于把原始的COM接口指针作为参数传递给函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ComPtr&lt;ID3D12RootSignature&gt; mRootSignature;<br>...<br><span class="hljs-comment">// SetGraphicsRootSignature需要获取ID3D12RootSignature*类型的参数</span><br>mCommandList-&gt;<span class="hljs-built_in">SetGraphicsRootSignature</span>(mRootSignature.<span class="hljs-built_in">Get</span>());<br></code></pre></td></tr></table></figure></li><li><p>GetAddressOf：返回指向此底层COM接口指针的地址。凭此方法即可利用函数参数返回COM接口的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">ComPtr&lt;ID3D12CommandAllocator&gt; mDirectCmdListAlloc; <br>... <br><span class="hljs-built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="hljs-built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT,mDirectCmdListAlloc.<span class="hljs-built_in">GetAddressOf</span>()));<br></code></pre></td></tr></table></figure></li><li><p>Reset：将此ComPtr实例设置为nullptr释放与之相关的所有引用（同时减少其底层COM接口的引用计数）。此方法的功能与将ComPtr目标实例赋值为nullptr的效果相同。</p></li></ol><p>COM接口<strong>都以大写字母“I”作为开头</strong>。例如，表示命令列表的COM接口为ID3D12GraphicsCommandList。</p><p><strong>2D纹理</strong>（2Dtexture）是一种由数据元素构成的矩阵（可将此“矩阵”看作2D数组）。</p><p>并不是任意类型的数据元素都能用于组成纹理，它只能存储<strong>DXGI_FORMAT枚举类型</strong>中描述的特定格式的数据元素。下面是一些相关的格式示例：</p><blockquote><p>DXGI_FORMAT_R32G32B32_FLOAT：每个元素由3个32位浮点数分量构成。</p><p>DXGI_FORMAT_R16G16B16A16_UNORM：每个元素由4个16位分量构成，每个分量都被映射到[0, 1] 区间。</p><p>DXGI_FORMAT_R32G32_UINT：每个元素由2个32位无符号整数分量构成。</p><p>DXGI_FORMAT_R8G8B8A8_UNORM：每个元素由4个8位无符号分量构成，每个分量都被映射到[0, 1] 区间。</p><p>DXGI_FORMAT_R8G8B8A8_SNORM：每个元素由4个8位有符号分量构成，每个分量都被映射到[−1, 1] 区间。</p><p>DXGI_FORMAT_R8G8B8A8_SINT：每个元素由4个8位有符号整数分量构成，每个分量都被映射到[−128, 127] 区间。</p><p>DXGI_FORMAT_R8G8B8A8_UINT：每个元素由4个8位无符号整数分量构成，每个分量都被映射到[0, 255] 区间。</p></blockquote><p>为了避免动画中出现画面闪烁的现象，最好将动画帧完整地绘制在一种称为后台缓冲区的离屏（off-screen，即不可直接呈现在显示设备上之意）纹理内。前台缓冲区存储的是当前显示在屏幕上的图像数据，而动画的下一帧则被绘制在后台缓冲区里。当后台缓冲区中的动画帧绘制完成之后，两种缓冲区的角色互换：后台缓冲区变为前台缓冲区呈现新一帧的画面，而前台缓冲区则为了展示动画的下一帧转为后台缓冲区，等待填充数据。前后台缓冲的这种互换操作称为<strong>呈现</strong>（presenting，亦有译作提交、显示等）。呈现是一种高效的操作，只需交换指向当前前台缓冲区和后台缓冲区的两个指针即可实现。</p><p>前台缓冲区和后台缓冲区构成了<strong>交换链</strong>（swapchain），在Direct3D中用IDXGISwapChain接口来表示。</p><blockquote><p>即便纹理中存储的不是颜色信息，大家有时也称纹理的元素为像素（如“法线图中的像素”）。</p></blockquote><p><strong>深度缓冲区</strong>（depthbuffer）这种纹理资源存储的并非图像数据，而是特定像素的深度信息。深度值的范围为0.0～1.0。0.0代表观察者在视锥体（viewfrustum，亦有译作视域体、视景体、视截体或视体等，意即观察者能看到的空间范围，形如从四棱锥中截取的四棱台，常称该形为平截头体（frustum））中能看到离自己最近的物体，1.0则代表观察者在视锥体中能看到离自己最远的物体。深度缓冲区中的元素与后台缓冲区内的像素呈一一对应关系（即后台缓冲区中第i行第j列的元素对应于深度缓冲区内第i行第j列的元素）。</p><blockquote><p>若使用了深度缓冲，则物体的绘制顺序也就变得无关紧要了。</p></blockquote><p>深度缓冲可用的格式包括以下几种：</p><blockquote><p>DXGI_FORMAT_D32_FLOAT_S8X24_UINT：该格式共占用64位，取其中的32位指定一个浮点型深度缓冲区，另有8位（无符号整数）分配给模板缓冲区（stencilbuffer），并将该元素映射到[0,255]区间，剩下的24位仅用于填充对齐（padding）不作他用。</p><p>DXGI_FORMAT_D32_FLOAT：指定一个32位浮点型深度缓冲区。</p><p>DXGI_FORMAT_D24_UNORM_S8_UINT：指定一个无符号24位深度缓冲区，并将该元素映射到[0,1]区间。另有8位（无符号整型）分配给模板缓冲区，将此元素映射到[0,255]区间。</p><p>DXGI_FORMAT_D16_UNORM：指定一个无符号16位深度缓冲区，把该元素映射到[0,1]区间。</p></blockquote><blockquote><p>深度缓冲区将总是与模板缓冲区如影随形，深度缓冲区叫作<strong>深度/模板缓冲区</strong>更为得体。</p></blockquote><p>在发出绘制命令之前，我们需要将与本次<strong>绘制调用</strong>（drawcall）相关的资源<strong>绑定</strong>（bind或称链接，link）到渲染流水线上。部分资源可能在每次绘制调用时都会有所变化，所以我们也就要每次按需更新绑定。但是，GPU资源并非直接与渲染流水线相绑定，而是要通过一种名为<strong>描述符</strong>（descriptor）的对象来对它间接引用，我们可以把描述符视为一种对送往GPU的资源进行描述的轻量级结构。从本质上来讲，它实际上即为一个中间层；若指定了资源描述符，GPU将既能获得实际的资源数据，也能了解到资源的必要信息。</p><p>为什么我们要额外使用描述符这个中间层呢？</p><blockquote><p>究其原因，GPU资源实质都是一些普通的内存块。由于资源的这种通用性，它们便能被设置到渲染流水线的不同阶段供其使用。一个常见的例子是先把纹理用作渲染目标（即Direct3D的绘制到纹理技术），随后再将该纹理作为一个着色器资源（即此纹理会经采样而用作着色器的输入数据）。不管是充当渲染目标、深度/模板缓冲区还是着色器资源等角色，仅靠资源本身是无法体现出来的。而且，我们有时也许只希望将资源中的部分数据绑定至渲染流水线，但如何从整个资源中将它们选取出来呢？再者，创建一个资源可能用的是无类型格式，这样的话，GPU甚至不会知道这个资源的具体格式。</p><p>解决上述问题就是引入描述符的原因。除了指定资源数据，描述符还会为GPU解释资源：它们会告知Direct3D某个资源将如何使用（即此资源将被绑定在流水线的哪个阶段上），而且我们可借助描述符来指定欲绑定资源中的局部数据。这就是说，如果某个资源在创建的时候采用了无类型格式，那么我们就必须在为它创建描述符时指明其具体类型。</p></blockquote><p><strong>视图（view）与描述符（descriptor）是同义词。</strong>“视图”虽是Direct3D先前版本里的常用术语，但它仍然沿用在Direct3D12的部分API中。在本书里，两者交替使用，例如，“常量缓冲区视图（constantbuffer view）”与“常量缓冲区描述符（constant bufferdescriptor）”表达的是同一事物。</p><p>每个描述符都有一种具体类型，此类型指明了资源的具体作用。<strong>本书常用的描述符</strong>如下：</p><ol type="1"><li>CBV/SRV/UAV描述符分别表示的是常量缓冲区视图（constantbufferview）、着色器资源视图（shader resourceview）和无序访问视图（unorderedaccess view）这3种资源。</li><li>采样器（sampler，亦有译为取样器）描述符表示的是采样器资源（用于纹理贴图）。</li><li>RTV描述符表示的是渲染目标视图资源（render target view）。</li><li>DSV描述符表示的是深度/模板视图资源（depth/stencil view）。</li></ol><p><strong>描述符堆</strong>（descriptorheap）中存有一系列描述符（可将其看作是描述符数组），本质上是存放用户程序中某种特定类型描述符的一块内存。我们需要为每一种类型的描述符都创建出单独的描述符堆。另外，也可以为同一种描述符类型创建出多个描述符堆。</p><p><strong>能用多个描述符来引用同一个资源。</strong>例如，可以通过多个描述符来引用同一个资源中不同的局部数据。而且，前文曾提到过，一种资源可以绑定到渲染流水线的不同阶段。因此，对于每个阶段都需要设置独立的描述符。例如，当一个纹理需要被用作渲染目标与着色器资源时，我们就要为它分别创建两个描述符：一个RTV描述符和一个SRV描述符。类似地，如果以无类型格式创建了一个资源，又希望该纹理中的元素可以根据需求当作浮点值或整数值来使用，那么就需要为它分别创建两个描述符：一个指定为浮点格式，另一个指定为整数格式。</p><p><strong>创建描述符的最佳时机为初始化期间。</strong>由于在此过程中需要执行一些类型的检测和验证工作，所以最好不要在运行时（runtime）才创建描述符。</p><p><strong>超级采样</strong>和<strong>多重采样</strong>的关键区别是显而易见的。对于超级采样来说，图像颜色要根据每一个子像素来计算，因此每个子像素都可能各具不同的颜色。而以多重采样的方式来求取图像颜色时，每个像素只需计算一次，最后，再将得到的颜色数据复制到多边形覆盖的所有可见子像素之中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DXGI_SAMPLE_DESC</span><br>&#123;<br>  UINT Count;<br>  UINT Quality;<br>&#125; DXGI_SAMPLE_DESC;<br><span class="hljs-comment">// Count成员指定了每个像素的采样次数，Quality成员则用于指示用户期望的图像质量级别（对于不同的硬件生产商而言，“质量级别”的意义可能千差万别）。</span><br><span class="hljs-comment">// 根据给定的纹理格式和采样数量，我们就能用ID3D12Device::CheckFeatureSupport方法查询到对应的质量级别。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS</span> &#123;<br> DXGI_FORMAT              Format;<br> UINT                     SampleCount;<br> D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS Flags;<br> UINT                     NumQualityLevels;<br>&#125; D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS;<br><br><span class="hljs-comment">// 作为参数兼具输入和输出的属性</span><br><span class="hljs-comment">// 对于某种纹理格式和采样数量的组合来讲，其质量级别的有效范围为 0 至NumQualityLevels–1。</span><br>D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS msQualityLevels;<br>msQualityLevels.Format = mBackBufferFormat;<br>msQualityLevels.SampleCount = <span class="hljs-number">4</span>;<br>msQualityLevels.Flags = D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE;<br>msQualityLevels.NumQualityLevels = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 这只是ID3D12Device::CheckFeatureSupport用法的冰山一角</span><br><span class="hljs-built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="hljs-built_in">CheckFeatureSupport</span>(D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS,<br>                                              &amp;msQualityLevels,<br>                                              <span class="hljs-built_in">sizeof</span>(msQualityLevels)));<br></code></pre></td></tr></table></figure><p><strong>功能级别</strong>为不同级别所支持的功能进行了严格的界定（每个功能级别所支持的特定功能可参见SDK文档）。例如，一款支持功能级别11的GPU，除了个别特例之外（像类似于多重采样数量这样的信息仍然需要查询，因为Direct3D规范允许这些Direct3D11硬件在此方面有各自不同的实现），必须支持完整的Direct3D11功能集。功能集使程序员的开发工作更加便捷——只要了解所支持的功能集，就能知道有哪些Direct3D功能可供使用。</p><p>DirectX图形基础结构（DirectX GraphicsInfrastructure，<strong>DXGI</strong>，也有译作DirectX图形基础设施）是一种与Direct3D配合使用的API。设计DXGI的基本理念是使多种图形API中所共有的底层任务能借助一组通用API来进行处理。例如，为了保证动画的流畅性，2D渲染与3D渲染两组API都要用到交换链和页面翻转功能，这里所用的交换链接口IDXGISwapChain实际上就属于DXGIAPI。DXGI还用于处理一些其他常用的图形功能，如切换全屏模式（full-screenmode。另一种是窗口模式，windowedmode），枚举显示适配器、显示设备及其支持的显示模式（分辨率、刷新率等）等这类图形系统信息。除此之外，它还定义了Direct3D支持的各种表面格式信息（DXGI_FORMAT）。</p><p><strong>显示适配器</strong>（displayadapter）是一种硬件设备（例如独立显卡），然而系统也可以用软件显示适配器来模拟硬件的图形处理功能。一个系统中可能会存在数个适配器（比如装有数块显卡）。适配器用接口IDXGIAdapter来表示。我们可以用下面的代码来枚举一个系统中的所有适配器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3DApp::LogAdapters</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  UINT i = <span class="hljs-number">0</span>;<br>  IDXGIAdapter* adapter = <span class="hljs-literal">nullptr</span>;<br>  std::vector&lt;IDXGIAdapter*&gt; adapterList;<br>  <span class="hljs-keyword">while</span>(mdxgiFactory-&gt;<span class="hljs-built_in">EnumAdapters</span>(i, &amp;adapter) != DXGI_ERROR_NOT_FOUND)<br>  &#123;<br>    DXGI_ADAPTER_DESC desc;<br>    adapter-&gt;<span class="hljs-built_in">GetDesc</span>(&amp;desc);<br><br>    std::wstring text = <span class="hljs-string">L&quot;***Adapter: &quot;</span>;<br>    text += desc.Description;<br>    text += <span class="hljs-string">L&quot;\n&quot;</span>;<br><br>    <span class="hljs-built_in">OutputDebugString</span>(text.<span class="hljs-built_in">c_str</span>());<br><br>    adapterList.<span class="hljs-built_in">push_back</span>(adapter);<br><br>    ++i;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; adapterList.<span class="hljs-built_in">size</span>(); ++i)<br>  &#123;<br>    <span class="hljs-built_in">LogAdapterOutputs</span>(adapterList[i]);<br>    <span class="hljs-built_in">ReleaseCom</span>(adapterList[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>称每一台显示设备都是一个<strong>显示输出</strong>（displayoutput，有的文档也作adapteroutput，适配器输出）实例，用IDXGIOutput接口来表示。每个适配器都与一组显示输出相关联。通过以下代码，我们就可以枚举出与某块适配器关联的所有显示输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3DApp::LogAdapterOutputs</span><span class="hljs-params">(IDXGIAdapter* adapter)</span></span><br><span class="hljs-function"></span>&#123;<br>  UINT i = <span class="hljs-number">0</span>;<br>  IDXGIOutput* output = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">while</span>(adapter-&gt;<span class="hljs-built_in">EnumOutputs</span>(i, &amp;output) != DXGI_ERROR_NOT_FOUND)<br>  &#123;<br>    DXGI_OUTPUT_DESC desc;<br>    output-&gt;<span class="hljs-built_in">GetDesc</span>(&amp;desc);<br><br>    std::wstring text = <span class="hljs-string">L&quot;***Output: &quot;</span>;<br>    text += desc.DeviceName;<br>    text += <span class="hljs-string">L&quot;\n&quot;</span>;<br>    <span class="hljs-built_in">OutputDebugString</span>(text.<span class="hljs-built_in">c_str</span>());<br><br>    <span class="hljs-built_in">LogOutputDisplayModes</span>(output, DXGI_FORMAT_B8G8R8A8_UNORM);<br><br>    <span class="hljs-built_in">ReleaseCom</span>(output);<br><br>    ++i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>“Microsoft Basic RenderDriver（Microsoft基本呈现驱动程序）”是Windows8及后续系统版本中包含的软件适配器。</p><p>在系统显卡驱动正常工作的情况下，它不会关联任何显示输出。</p></blockquote><p>每种显示设备都有一系列它所支持的<strong>显示模式</strong>，可以用下列DXGI_MODE_DESC结构体中的数据成员来加以表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DXGI_MODE_DESC</span><br>&#123;<br>  UINT Width;                   <span class="hljs-comment">// 分辨率宽度</span><br>  UINT Height;                  <span class="hljs-comment">// 分辨率高度</span><br>  DXGI_RATIONAL RefreshRate;    <span class="hljs-comment">// 刷新率，单位为赫兹Hz</span><br>  DXGI_FORMAT Format;           <span class="hljs-comment">// 显示格式</span><br>  DXGI_MODE_SCANLINE_ORDER ScanlineOrdering; <span class="hljs-comment">// 逐行扫描vs.隔行扫描</span><br>  DXGI_MODE_SCALING Scaling;    <span class="hljs-comment">// 图像如何相对于屏幕进行拉伸</span><br>&#125; DXGI_MODE_DESC;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DXGI_RATIONAL</span><br>&#123;<br>  UINT Numerator;<br>  UINT Denominator;<br>&#125; DXGI_RATIONAL;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">DXGI_MODE_SCANLINE_ORDER</span><br>&#123;<br>  DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED    = <span class="hljs-number">0</span>,<br>  DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE    = <span class="hljs-number">1</span>,<br>  DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST = <span class="hljs-number">2</span>,<br>  DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST = <span class="hljs-number">3</span><br>&#125; DXGI_MODE_SCANLINE_ORDER;[<span class="hljs-number">19</span>]<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">DXGI_MODE_SCALING</span><br>&#123;<br>  DXGI_MODE_SCALING_UNSPECIFIED  = <span class="hljs-number">0</span>, <br>  DXGI_MODE_SCALING_CENTERED   = <span class="hljs-number">1</span>,        <span class="hljs-comment">// 不做缩放，将图像显示在屏幕正中</span><br>  DXGI_MODE_SCALING_STRETCHED   = <span class="hljs-number">2</span>        <span class="hljs-comment">// 根据屏幕的分辨率对图像进行拉伸缩放</span><br>&#125; DXGI_MODE_SCALING; <br></code></pre></td></tr></table></figure><p>一旦确定了显示模式的具体格式（DXGI_FORMAT），我们就能通过下列代码，获得某个显示输出对此格式所支持的全部显示模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3DApp::LogOutputDisplayModes</span><span class="hljs-params">(IDXGIOutput* output, DXGI_FORMAT format)</span></span><br><span class="hljs-function"></span>&#123;<br>  UINT count = <span class="hljs-number">0</span>;<br>  UINT flags = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 以nullptr作为参数调用此函数来获取符合条件的显示模式的个数</span><br>  output-&gt;<span class="hljs-built_in">GetDisplayModeList</span>(format, flags, &amp;count, <span class="hljs-literal">nullptr</span>);<br><br>  <span class="hljs-function">std::vector&lt;DXGI_MODE_DESC&gt; <span class="hljs-title">modeList</span><span class="hljs-params">(count)</span></span>;<br>  output-&gt;<span class="hljs-built_in">GetDisplayModeList</span>(format, flags, &amp;count, &amp;modeList[<span class="hljs-number">0</span>]);<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x : modeList)<br>  &#123;<br>    UINT n = x.RefreshRate.Numerator;<br>    UINT d = x.RefreshRate.Denominator;<br>    std::wstring text =<br>      <span class="hljs-string">L&quot;Width = &quot;</span> + std::<span class="hljs-built_in">to_wstring</span>(x.Width) + <span class="hljs-string">L&quot; &quot;</span> +<br>      <span class="hljs-string">L&quot;Height = &quot;</span> + std::<span class="hljs-built_in">to_wstring</span>(x.Height) + <span class="hljs-string">L&quot; &quot;</span> +<br>      <span class="hljs-string">L&quot;Refresh = &quot;</span> + std::<span class="hljs-built_in">to_wstring</span>(n) + <span class="hljs-string">L&quot;/&quot;</span> + std::<span class="hljs-built_in">to_wstring</span>(d) +<br>      <span class="hljs-string">L&quot;\n&quot;</span>;<br><br>    ::<span class="hljs-built_in">OutputDebugString</span>(text.<span class="hljs-built_in">c_str</span>());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在进入全屏模式之时，枚举显示模式就显得尤为重要。为了获得最优的全屏性能，我们所指定的显示模式（包括刷新率）一定要与显示器支持的显示模式完全匹配。</p></blockquote><p><strong>资源驻留</strong></p><p>在Direct3D12中，应用程序通过控制资源在显存中的去留，<strong>主动管理资源的驻留情况</strong>（即residency。无论资源是否本已位于显存中，都可对其进行管理。在Direct3D11中则由系统自动管理）。该技术的基本思路为使应用程序占用最小的显存空间。这是因为显存的空间有限，很可能不足以容下整个游戏的所有资源，或者用户还有运行中的程序也在同时使用显存。这里给出一条与性能相关的提示：程序应当避免在短时间内于显存中交换进出相同的资源，这会引起过高的开销。最理想的情况是，所清出的资源在短时间内不会再次使用。游戏关卡或游戏场景的切换是关于常驻资源的好例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HRESULT <span class="hljs-title">ID3D12Device::MakeResident</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    UINT NumObjects,</span></span><br><span class="hljs-params"><span class="hljs-function">    ID3D12Pageable *<span class="hljs-type">const</span> *ppObjects)</span></span>;<br><br><span class="hljs-function">HRESULT <span class="hljs-title">ID3D12Device::Evict</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    UINT NumObjects,</span></span><br><span class="hljs-params"><span class="hljs-function">    ID3D12Pageable *<span class="hljs-type">const</span> *ppObjects)</span></span>;<br><span class="hljs-comment">// 第一个参数则表示该数组中资源的数量，第二个参数都是ID3D12Pageable资源数组。</span><br></code></pre></td></tr></table></figure><blockquote><p>GPU较之于显卡的地位大致相当于CPU较之于主板。相应的，GPU控制的显存基本相当于CPU控制的内存，而后者在本书中也常被称为系统内存（systemmemory）。CPU内部有多级缓存与寄存器，分别用于缓存指令与控制CPU；GPU内部亦有缓存与寄存器，分别用于缓存纹理、缓存着色器指令等以及控制GPU。有的文献在划分GPU的组成结构时，会把GPU的寄存器及其控制的内存统称为GPUmemory （GPU存储器）。</p></blockquote><p><strong>CPU与GPU间的交互</strong></p><p>同步是一种我们不乐于执行的操作，因为这意味着一种处理器要以空闲状态等待另一种处理器完成某些任务。</p><p>每个GPU都至少维护着一个<strong>命令队列</strong>（commandqueue，本质上是环形缓冲区，即ring buffer）。借助Direct3DAPI，CPU可利用命令列表（commandlist）将命令提交到这个队列中去。当一系列命令被提交至命令队列之时，它们<strong>并不会被GPU立即执行</strong>。由于GPU可能正在处理先前插入命令队列内的命令，因此，后来新到的命令会一直在这个队列之中等待执行。</p><blockquote><p>相对于Direct3D 12而言，Direct3D11支持两种绘制方式：即<strong>立即渲染</strong>（immediaterendering，利用immediatecontext实现）以及<strong>延迟渲染</strong>（deferredrendering，利用deferredcontext实现）。前者将缓冲区中的命令直接借驱动层发往GPU执行，后者则与本文中介绍的命令列表模型相似（但执行命令列表时仍然要依赖immediatecontext）。前者延续了Direct3D 11之前一贯的绘制方式，而后者则为Direct3D11中新添加的绘制方式。到了Direct3D12便取消了立即渲染方式，完全采用“命令列表-&gt;命令队列”模型，使多个命令列表同时记录命令，借此充分发挥多核心处理器的性能。可见，Direct3D11在绘制方面乃承上启下之势，而Direct3D 12则进行了彻底的革新。</p></blockquote><p>在Direct3D12中，命令队列被抽象为ID3D12CommandQueue接口来表示。要通过填写D3D12_COMMAND_QUEUE_DESC结构体来描述队列，再调用ID3D12Device::CreateCommandQueue方法创建队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Microsoft::WRL::ComPtr&lt;ID3D12CommandQueue&gt; mCommandQueue;<br>D3D12_COMMAND_QUEUE_DESC queueDesc = &#123;&#125;;<br>queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;<br>queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;<br><span class="hljs-built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="hljs-built_in">CreateCommandQueue</span>(&amp;queueDesc, <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;mCommandQueue)));<br></code></pre></td></tr></table></figure><p>IID_PPV_ARGS辅助宏的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IID_PPV_ARGS(ppType) __uuidof(**(ppType)), IID_PPV_ARGS_Helper(ppType)</span><br><span class="hljs-comment">// __uuidof(**(ppType))将获取(**(ppType))的COM接口ID（globallyunique identifier，全局唯一标识符，GUID），在上述代码段中得到的即为ID3D12CommandQueue接口的COM ID。</span><br><span class="hljs-comment">// IID_PPV_ARGS辅助函数的本质是将ppType强制转换为void**类型。我们在全书中都会见到此宏的身影，这是因为在调用Direct3D 12中创建接口实例的API时，大多都有一个参数是类型为void**的待创接口COM ID。</span><br></code></pre></td></tr></table></figure><p>ExecuteCommandLists是一种常用的ID3D12CommandQueue接口方法，利用它可将<strong>命令列表</strong>里的命令添加到<strong>命令队列</strong>之中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ID3D12CommandQueue::ExecuteCommandLists</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// 第二个参数里命令列表数组中命令列表的数量</span></span></span><br><span class="hljs-params"><span class="hljs-function">  UINT Count, </span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-comment">// 待执行的命令列表数组，指向命令列表数组中第一个元素的指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">  ID3D12CommandList *<span class="hljs-type">const</span> *ppCommandLists)</span></span>;<br><span class="hljs-comment">// GPU将从数组里的第一个命令列表开始顺序执行。</span><br></code></pre></td></tr></table></figure><p>继承于ID3D12CommandList接口的ID3D12GraphicsCommandList接口封装了一系列图形渲染命令，有数种方法向<strong>命令列表</strong>添加命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// mCommandList为一个指向ID3D12CommandList接口的指针</span><br>mCommandList-&gt;<span class="hljs-built_in">RSSetViewports</span>(<span class="hljs-number">1</span>, &amp;mScreenViewport);<br>mCommandList-&gt;<span class="hljs-built_in">ClearRenderTargetView</span>(mBackBufferView, Colors::LightSteelBlue, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>mCommandList-&gt;<span class="hljs-built_in">DrawIndexedInstanced</span>(<span class="hljs-number">36</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 当命令都被加入命令列表之后，我们必须调用ID3D12GraphicsCommandList::Close方法来结束命令的记录,然后才可提交命令列表</span><br>mCommandList-&gt;<span class="hljs-built_in">Close</span>();<br></code></pre></td></tr></table></figure><p><strong>命令分配器</strong>（commandallocator）存储记录在<strong>命令列表</strong>内的命令。</p><p>创建命令分配器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HRESULT <span class="hljs-title">ID3D12Device::CreateCommandAllocator</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">    D3D12_COMMAND_LIST_TYPE type,</span></span><br><span class="hljs-params"><span class="hljs-function">    REFIID riid,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span> **ppCommandAllocator)</span></span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">type:</span><br><span class="hljs-comment">D3D12_COMMAND_LIST_TYPE_DIRECT 存储可供GPU直接执行的命令</span><br><span class="hljs-comment">D3D12_COMMAND_LIST_TYPE_BUNDLE 将命令列表打包优化</span><br><span class="hljs-comment">D3D12_COMMAND_LIST_TYPE_COMPUTE 只接收与通用计算有关的命令</span><br><span class="hljs-comment">D3D12_COMMAND_LIST_TYPE_COPY 只接收与复制操作有关的命令</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>创建命令列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HRESULT <span class="hljs-title">ID3D12Device::CreateCommandList</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    UINT nodeMask,</span></span><br><span class="hljs-params"><span class="hljs-function">    D3D12_COMMAND_LIST_TYPE type,</span></span><br><span class="hljs-params"><span class="hljs-function">    ID3D12CommandAllocator *pCommandAllocator,</span></span><br><span class="hljs-params"><span class="hljs-function">    ID3D12PipelineState *pInitialState,</span></span><br><span class="hljs-params"><span class="hljs-function">    REFIID riid,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span> **ppCommandList)</span></span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">nodemask: GPU掩码</span><br><span class="hljs-comment">type: 同上</span><br><span class="hljs-comment">pCommandAllocator: 与所建命令列表相关联的命令分配器,类型必须与所创命令列表的类型相匹配</span><br><span class="hljs-comment">pInitialState: 指定命令列表的渲染流水线初始状态</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>我们可以创建出多个关联于同一命令分配器的命令列表，但是不能同时用它们来记录命令。因此，当其中的一个命令列表在记录命令时，必须关闭同一命令分配器的其他命令列表。</p><p>可以通过ID3D12GraphicsCommandList::Reset方法，安全地复用命令列表占用的相关底层内存来记录新的命令集。<strong>重置命令列表并不会影响命令队列中的命令</strong>，因为相关的命令分配器仍在维护着其内存中被命令队列引用的系列命令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HRESULT <span class="hljs-title">ID3D12GraphicsCommandList::Reset</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">    ID3D12CommandAllocator *pAllocator,</span></span><br><span class="hljs-params"><span class="hljs-function">    ID3D12PipelineState *pInitialState)</span></span>;<br></code></pre></td></tr></table></figure><p>向GPU提交了一整帧的渲染命令后，使用ID3D12CommandAllocator::Reset方法复用命令分配器中的内存绘制下一帧。类似std::vector::clear方法（使向量的size归零，但是仍保持其当前的capacity），命令队列可能会引用命令分配器中的数据，在没有确定GPU执行完命令分配器中的所有命令之前，<strong>千万不要重置命令分配器</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HRESULT <span class="hljs-title">ID3D12CommandAllocator::Reset</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>实现GPU和CPU间的同步</strong>：强制CPU等待，直到GPU完成所有命令的处理，达到某个指定的<strong>围栏点</strong>（fencepoint）为止。我们将这种方法称为刷新命令队列（flushing the commandqueue），可以通过围栏（fence）来实现这一点。围栏用ID3D12Fence接口来表示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HRESULT <span class="hljs-title">ID3D12Device::CreateFence</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">  UINT64 InitialValue,</span></span><br><span class="hljs-params"><span class="hljs-function">  D3D12_FENCE_FLAGS Flags,</span></span><br><span class="hljs-params"><span class="hljs-function">  REFIID riid,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-type">void</span> **ppFence)</span></span>;<br><br><span class="hljs-comment">// 示例</span><br><span class="hljs-built_in">ThrowIfFailed</span>(md3dDevice-&gt;<span class="hljs-built_in">CreateFence</span>(<br>    <span class="hljs-comment">// 我们将此值设为0，每当需要标记一个新的围栏点时就将它加1</span><br>    <span class="hljs-number">0</span>, <br>    D3D12_FENCE_FLAG_NONE,<br>    <span class="hljs-built_in">IID_PPV_ARGS</span>(&amp;mFence)));<br><br></code></pre></td></tr></table></figure><p>如何用一个围栏来刷新命令队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">UINT64 mCurrentFence = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">D3DApp::FlushCommandQueue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 增加围栏值，接下来将命令标记到此围栏点</span><br>  mCurrentFence++;<br><br>  <span class="hljs-comment">// 向命令队列中添加一条用来设置新围栏点的命令</span><br>  <span class="hljs-comment">// 由于这条命令要交由GPU处理（即由GPU端来修改围栏值），所以在GPU处理完命令队列中此Signal()以前的所有命令之前，它并不会设置新的围栏点</span><br>  <span class="hljs-comment">// ID3D12CommandQueue::Signal方法从GPU端设置围栏值，而ID3D12Fence::Signal方法则从CPU端设置围栏值。</span><br>  <span class="hljs-built_in">ThrowIfFailed</span>(mCommandQueue-&gt;<span class="hljs-built_in">Signal</span>(mFence.<span class="hljs-built_in">Get</span>(), mCurrentFence));<br><br>  <span class="hljs-comment">// 在CPU端等待GPU，直到后者执行完这个围栏点之前的所有命令</span><br>  <span class="hljs-keyword">if</span>(mFence-&gt;<span class="hljs-built_in">GetCompletedValue</span>() &lt; mCurrentFence)<br>  &#123;<br>    HANDLE eventHandle = <span class="hljs-built_in">CreateEventEx</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, EVENT_ALL_ACCESS);<br><br>    <span class="hljs-comment">// 若GPU命中当前的围栏（即执行到Signal()指令，修改了围栏值），则激发预定事件</span><br>    <span class="hljs-built_in">ThrowIfFailed</span>(mFence-&gt;<span class="hljs-built_in">SetEventOnCompletion</span>(mCurrentFence, eventHandle));<br><br>    <span class="hljs-comment">// 等待GPU命中围栏，激发事件</span><br>    <span class="hljs-built_in">WaitForSingleObject</span>(eventHandle, INFINITE);<br>    <span class="hljs-built_in">CloseHandle</span>(eventHandle);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在第7章以前也只能暂时使用这个简单的办法了。</p></blockquote><p><strong>资源转换</strong></p><p>当GPU的写操作还没有完成抑或甚至还没有开始，却开始读取资源，便会导致<strong>资源冒险</strong>（resourcehazard）。为此，Direct3D专门针对资源设计了一组相关状态。资源在创建伊始会处于默认状态，该状态将一直持续到应用程序通过Direct3D将其转换（transition）为另一种状态为止。例如，如果要对某个资源（比如纹理）执行写操作时，需要将它的状态转换为渲染目标状态；而要对该纹理进行读操作时，再把它的状态变为着色器资源状态。根据Direct3D给出的转换信息，GPU就可以采取适当的措施避免资源冒险的发生。譬如，在读取某个资源之前，它会等待所有与之相关的写操作执行完毕。</p><p>通过命令列表设置<strong>转换资源屏障</strong>（transition resourcebarrier）数组，即可指定资源的转换；当我们希望以一次API调用来转换多个资源的时候，这种数组就派上了用场。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CD3DX12_RESOURCE_BARRIER继承自D3D12_RESOURCE_BARRIER结构体，并添加了一些辅助方法。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CD3DX12_RESOURCE_BARRIER</span> : <span class="hljs-keyword">public</span> D3D12_RESOURCE_BARRIER<br>&#123;<br>  <span class="hljs-comment">// [...] 辅助方法</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> CD3DX12_RESOURCE_BARRIER <span class="hljs-title">Transition</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    _In_ ID3D12Resource* pResource,</span></span><br><span class="hljs-params"><span class="hljs-function">    D3D12_RESOURCE_STATES stateBefore,</span></span><br><span class="hljs-params"><span class="hljs-function">    D3D12_RESOURCE_STATES stateAfter,</span></span><br><span class="hljs-params"><span class="hljs-function">    UINT subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES,</span></span><br><span class="hljs-params"><span class="hljs-function">    D3D12_RESOURCE_BARRIER_FLAGS flags = D3D12_RESOURCE_BARRIER_FLAG_NONE)</span></span><br><span class="hljs-function">  </span>&#123;<br>    CD3DX12_RESOURCE_BARRIER result;<br>    <span class="hljs-built_in">ZeroMemory</span>(&amp;result, <span class="hljs-built_in">sizeof</span>(result));<br>    D3D12_RESOURCE_BARRIER &amp;barrier = result;<br>    result.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;<br>    result.Flags = flags;<br>    barrier.Transition.pResource = pResource;<br>    barrier.Transition.StateBefore = stateBefore;<br>    barrier.Transition.StateAfter = stateAfter;<br>    barrier.Transition.Subresource = subresource;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-comment">// [...] 其他辅助方法</span><br>&#125;;<br><br><span class="hljs-comment">// 示例</span><br><span class="hljs-comment">// 可以将此资源屏障转换看作是一条告知GPU某资源状态正在进行转换的命令。所以在执行后续的命令时，GPU便会采取必要措施以防资源冒险</span><br>mCommandList-&gt;<span class="hljs-built_in">ResourceBarrier</span>(<br>    <span class="hljs-number">1</span>,<br>    &amp;CD3DX12_RESOURCE_BARRIER::<span class="hljs-built_in">Transition</span>(<br>        <span class="hljs-built_in">CurrentBackBuffer</span>(),<br>        D3D12_RESOURCE_STATE_PRESENT, <br>        D3D12_RESOURCE_STATE_RENDER_TARGET));<br></code></pre></td></tr></table></figure><blockquote><p>Direct3D12中的许多结构体都有其对应的<strong>扩展辅助结构变体</strong>（variation），考虑到使用上的方便性，我们更偏爱于运用那些变体。以CD3DX12作为前缀的变体全都定义在d3dx12.h头文件当中，这个文件并不属于DirectX12SDK的核心部分，但是可以通过微软的官方网站下载获得。为了方便起见，本书源代码的Common目录里附有一份d3dx12.h头文件。</p></blockquote><p><strong>命令与多线程</strong></p><p>Direct3D12的设计目标是为用户提供一个高效的多线程环境，命令列表也是一种发挥Direct3D多线程优势的途径。对于内含许多物体的庞大场景而言，仅通过一个构建命令列表来绘制整个场景会占用不少的CPU时间。因此，可以采取一种<strong>并行创建命令列表</strong>的思路。例如，我们可以创建4条线程，每条分别负责构建一个命令列表来绘制25%的场景物体。</p><p>以下是一些在<strong>多线程环境中使用命令列表要注意的问题</strong>：</p><ol type="1"><li><p><strong>命令列表</strong>并非自由线程（notfree-threaded）对象。也就是说，多线程既不能同时共享相同的命令列表，也不能同时调用同一命令列表的方法。所以，每个线程通常都只使用各自的命令列表。</p></li><li><p><strong>命令分配器</strong>亦不是线程自由的对象。这就是说，多线程既不能同时共享同一个命令分配器，也不能同时调用同一命令分配器的方法。所以，每个线程一般都仅使用属于自己的命令分配器。</p></li><li><p><strong>命令队列</strong>是线程自由对象，所以多线程可以同时访问同一命令队列，也能够同时调用它的方法。特别是每个线程都能同时向命令队列提交它们自己所生成的命令列表。</p></li><li><p>出于性能的原因，应用程序必须在初始化期间，指出用于并行记录命令的命令列表最大数量。</p></li></ol><p><strong>为了简单起见，本书不会使用多线程技术。</strong>完成本书的阅读后，读者可以通过查阅SDK中的Multithreading12示例来学习怎样并行生成命令列表。如果希望应用程序充分利用系统资源，应该通过多线程技术来发挥CPU多核心的并行处理能力。</p><p><strong>初始化Direct3D</strong></p><p><strong>对Direct3D进行初始化的步骤</strong>：</p><ol type="1"><li>用D3D12CreateDevice函数创建ID3D12Device接口实例。</li><li>创建一个ID3D12Fence对象，并查询描述符的大小。</li><li>检测用户设备对4X MSAA质量级别的支持情况。</li><li>依次创建命令队列、命令列表分配器和主命令列表。</li><li>描述并创建交换链。</li><li>创建应用程序所需的描述符堆。</li><li>调整后台缓冲区的大小，并为它创建渲染目标视图。</li><li>创建深度/模板缓冲区及与之关联的深度/模板视图。</li><li>设置视口（viewport）和裁剪矩形（scissor rectangle）。</li></ol><p><strong>计时与动画</strong></p><p>MSDN对QueryPerformanceCounter函数作有如下备注：“按道理来讲，对于一台具有多个处理器的计算机而言，无论在哪一个处理器上调用此函数都应返回当前时刻的计数值。然而，由于基本输入/输出系统（BIOS）或硬件抽象层（HAL）上的缺陷，导致了在不同的处理器上可能会得到不同的结果。</p><p>全书的演示程序都使用了d3dUtil.h、d3dUtil.cpp、d3dApp.h和d3dApp.cpp中的框架代码，可以从本书的官方网站下载到这些文件。d3dUtil.h和d3dUtil.cpp文件中含有程序所需的实用工具代码，d3dApp.h和d3dApp.cpp文件内包含用于封装Direct3D示例程序的Direct3D应用程序类核心代码。</p><blockquote><p>在析构函数中刷新命令队列的原因是：在销毁GPU引用的资源以前，必须等待GPU处理完队列中的所有命令。否则，可能造成应用程序在退出时崩溃。</p></blockquote><p>对于本书的所有示例程序来说，我们每次都会重写D3DApp中的6个虚函数。这6个函数用于针对特定的示例来实现所需的具体功能。这种设定的好处是把初始化代码、消息处理等流程都统一实现在D3DApp类中，继而使我们可以把精力集中在特定例程中的关键代码之上。以下是对这6个框架方法的概述。</p><ol type="1"><li>Initialize：通过此方法为程序编写初始化代码，例如分配资源、初始化对象和建立3D场景等。</li><li>MsgProc：该方法用于实现应用程序主窗口的窗口过程函数（procedurefunction）。</li><li>CreateRtvAndDsvDescriptorHeaps：此虚函数用于创建应用程序所需的RTV和DSV描述符堆。</li><li>OnResize：当D3DApp::MsgProc函数接收到WM_SIZE消息时便会调用此方法。</li><li>Update：在绘制每一帧时都会调用该抽象方法，我们通过它来随着时间的推移而更新3D应用程序（如呈现动画、移动摄像机、做碰撞检测以及检查用户的输入等）。</li><li>Draw：在绘制每一帧时都会调用的抽象方法。我们在该方法中发出渲染命令，将当前帧真正地绘制到后台缓冲区中。当完成帧的绘制后，再调用IDXGISwapChain::Present方法将后台缓冲区的内容显示在屏幕上。</li></ol><h2 id="第5章-渲染流水线">第5章 渲染流水线</h2><p>如果给出一台具有确定位置和朝向的虚拟摄像机（virtualcamera）以及某个3D场景的几何描述，那么<strong>渲染流水线</strong>则是以此虚拟摄像机为视角进行观察，并据此生成给定3D场景2D图像的一整套处理步骤。</p><p>从观察效果上看，平行线最终会相交于消失点（vanishingpoint，又称灭点）。</p><p>实体3D对象是借助<strong>三角形网格</strong>（trianglemesh）来近似表示的，因而我们要以三角形作为3D物体建模的基石。</p><p>每款显示器所能发出的红、绿、蓝三色光的强度都是有限的。为了便于描述光的强度，我们常将它量化为范围在0～1归一化区间中的值。0代表无强度，1则表示强度最大，处于两者之间的值就表示对应的中间强度。例如，强度值（0.25,0.67,1.0）就表明此光线由强度为25%的红色光、强度为67%的绿色光以及强度为100%的蓝色光混合而成。</p><p>颜色向量也有它们自己专属的颜色运算，即<strong>分量式</strong>（modulation或componentwise）乘法。</p><p>我们通常还会用到另一种名为alpha分量（alphacomponent）的颜色分量。alpha分量常用于表示颜色的不透明度（opacity。值为0.0表示完全透明，值为1.0表示不透明）。</p><p>一般来说，128位颜色值常用于高精度的颜色运算（例如位于像素着色器中的各种运算）。在这种情况下，由于运算所用的精度较高，因此可有效降低计算过程中所产生的误差。但是，最终存储在后台缓冲区中的像素颜色数据，却往往都是以32位颜色值来表示。而目前的物理显示设备仍不足以充分发挥出更高色彩分辨率的优势。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5.jpg"alt="渲染流水线的各个阶段" /><figcaption aria-hidden="true">渲染流水线的各个阶段</figcaption></figure><ol type="1"><li><p><strong>输入装配器</strong>（InputAssembler，IA）阶段会从显存中读取几何数据（顶点和索引，vertex andindex），再将它们装配为几何图元（geometricprimitive，亦译作几何基元，如三角形和线条这种构成图形的基本元素）。</p><p>在Direct3D中，我们要通过一种名为<strong>顶点缓冲区</strong>（vertexbuffer）的特殊数据结构，将顶点与渲染流水线相绑定。顶点缓冲区利用连续的内存来存储一系列顶点。</p><p>通过指定<strong>图元拓扑</strong>（primitivetopology，或称基元拓扑）来告知Direct3D如何用顶点数据来表示几何图元。</p><blockquote><p>经过观察可以发现，在<strong>三角形带</strong>中，次序为偶数的三角形与次序为奇数三角形的绕序（windingorder，也译作环绕顺序等，即装配图元的顶点顺序为逆时针或顺时针方向）是不同的，这就是剔除（culling，亦称消隐）问题的由来。为了解决这个问题，GPU内部会对偶数三角形中前两个顶点的顺序进行调换，以此使它们与奇数三角形的绕序保持一致。</p></blockquote><p>先创建一个顶点列表和一个索引列表。在顶点列表中收录一份所有独立的顶点，并在<strong>索引列表</strong>中存储顶点列表的索引值，这些索引定义了顶点列表中的顶点是如何组合在一起，从而构成三角形的。</p></li><li><p>待图元被装配完毕后，其顶点就会被送入<strong>顶点着色器</strong>阶段（vertexshaderstage，简记作VS）。我们可以把顶点着色器看作一种输入与输出数据皆为单个顶点的函数。每个要被绘制的顶点都须经过顶点着色器的处理再送往后续阶段。</p><p>我们可以利用顶点着色器来实现许多特效，例如变换、光照和位移贴图（displacementmapping，也译作置换贴图。map有映射之意，因此也有译作位移映射，类似的还有在后面将见到的纹理贴图、法线贴图等）。</p></li><li><p><strong>曲面细分</strong>阶段（tessellationstages）是利用镶嵌化处理技术对网格中的三角形进行细分（subdivide），以此来增加物体表面上的三角形数量。再将这些新增的三角形偏移到适当的位置，使网格表现出更加细腻的细节。</p></li><li><p><strong>几何着色器</strong>（geometry shaderstage，GS）阶段是可选阶段。几何着色器接受的输入应当是完整的图元。几何着色器的主要优点是可以创建或销毁几何体。几何着色器的常见拿手好戏是将一个点或一条线扩展为一个四边形。</p></li><li><p>裁剪。苏泽兰（萨瑟兰德）-霍奇曼裁剪算法（Sutherland-Hodgmanclipping algorithm，前者IvanSutherland是图形界的奠基人，可以了解一下）。</p></li><li><p><strong>光栅化</strong>阶段（rasterizationstage，RS，亦有将rasterization译作像素化或栅格化）的主要任务是为投影至屏幕上的3D三角形计算出对应的像素颜色。</p><p>当裁剪操作完成之后，硬件会通过透视除法将物体从齐次裁剪空间变换为规格化设备坐标（NDC）。一旦物体的顶点位于NDC空间内，构成2D图像的2D顶点坐标就会被变换到后台缓冲区中称为视口（viewport）的矩形里。</p><blockquote><p>在我们选择的这种约定当中（也就是计算三角形法线的方法），根据观察者的视角看去，顶点绕序为顺时针方向的三角形为正面朝向，而顶点绕序为逆时针方向的三角形为背面朝向。可以通过DX设定这个约定。</p></blockquote></li><li><p><strong>像素着色器</strong>（pixelshader，PS）是一种由GPU来执行的程序。它会针对每一个像素片段（pixelfragment，亦有译作片元）进行处理（即每处理一个像素就要执行一次像素着色器），并根据顶点的插值属性作为输入来计算出对应的像素颜色。</p></li><li><p>通过像素着色器生成的像素片段会被移送至渲染流水线的<strong>输出合并</strong>（OutputMerger，OM）阶段。</p></li></ol><h2 id="第6章-利用direct3d绘制几何体">第6章 利用Direct3D绘制几何体</h2><p>在着色器代码中，未标明索引的语义将<strong>默认其索引值为0</strong>。</p><p>输入布局：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">D3D12_INPUT_LAYOUT_DESC</span><br>&#123;<br>  <span class="hljs-type">const</span> D3D12_INPUT_ELEMENT_DESC *pInputElementDescs;<br>  UINT NumElements;<br>&#125; D3D12_INPUT_LAYOUT_DESC;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">D3D12_INPUT_ELEMENT_DESC</span><br>&#123;<br>  <span class="hljs-comment">// 将顶点结构体（图6.1中的struct Vertex）中的元素与顶点着色器输入签名映射。</span><br>  LPCSTR SemanticName;<br>  <span class="hljs-comment">// 使用索引区分相同语义的输入。未标明索引的语义将默认其索引值为0，如POSITION与POSITION0等价。</span><br>  UINT SemanticIndex;<br>  <span class="hljs-comment">// 顶点元素数据类型。</span><br>  DXGI_FORMAT Format;<br>  <span class="hljs-comment">// 指定输入槽。Direct3D共支持16个输入槽（索引值为0～15），可以通过它们来向输入装配阶段传递顶点数据。</span><br>  UINT InputSlot;<br>  <span class="hljs-comment">// 在特定输入槽中，从C++顶点结构体的首地址到其中某点元素起始地址的偏移量（用字节表示）。</span><br>  UINT AlignedByteOffset;<br>  <span class="hljs-comment">// 有D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA和D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA两种。</span><br>  D3D12_INPUT_CLASSIFICATION InputSlotClass;<br>  <span class="hljs-comment">// 若要采用实例化这种高级技术，则将此参数设为1。</span><br>  UINT InstanceDataStepRate;<br>&#125; D3D12_INPUT_ELEMENT_DESC;<br></code></pre></td></tr></table></figure><p>为了使GPU可以访问顶点数组，就需要把它们放置在称为缓冲区（buffer）的GPU资源（ID3D12Resource）里。我们把存储顶点的缓冲区叫作<strong>顶点缓冲区</strong>（vertexbuffer）。缓冲区的结构比纹理更为简单：既非多维资源，也不支持mipmap、过滤器以及多重采样等技术。当需要向GPU提供如顶点这类数据元素所构成的数组时，我们便会使用缓冲区。</p><p>在Direct3D12中，<strong>所有的资源均用ID3D12Resource接口表示</strong>。相比之下，Direct3D11则采用如ID3D11Buffer与ID3D11Texture2D等多种不同的接口来表示各种不同的资源。</p><p>对于<strong>静态几何体</strong>（staticgeometry，即每一帧都不会发生改变的几何体）而言，我们会将其顶点缓冲区置于<strong>默认堆</strong>（D3D12_HEAP_TYPE_DEFAULT）中来优化性能。一般说来，游戏中的大多数几何体（如树木、建筑物、地形和动画角色）都是如此处理。</p><p>CPU不能向默认堆中的顶点缓冲区写入数据，需要<strong>上传缓冲区</strong>作为中介，通过把资源提交至上传堆，才得以将数据从CPU复制到GPU显存中。</p><p>与顶点相似，为了使GPU可以访问索引数组，就需要将它们放置于GPU的缓冲区资源（ID3D12Resource）内。我们称存储索引的缓冲区为<strong>索引缓冲区</strong>（indexbuffer）。</p><blockquote><p>为了将顶点缓冲区绑定到渲染流水线上，我们需要给这种资源创建一个顶点缓冲区视图（vertexbuffer view）。与RTV（render targetview，渲染目标视图）不同的是，我们无须为顶点缓冲区视图创建描述符堆。</p><p>索引缓冲区同理。</p></blockquote><p>在Direct3D中，编写着色器的语言为高级着色语言（High Level ShadingLanguage，HLSL），其语法与C++十分相似，这使得它较易于学习。</p><blockquote><p>注意，<strong>SV_POSITION</strong>语义比较特殊（SV代表系统值，即systemvalue），它所修饰的顶点着色器输出元素存有齐次裁剪空间中的顶点位置信息。因此，我们必须为输出位置信息的参数附上SV_POSITION语义，使GPU可以在进行例如裁剪、深度测试和光栅化等处理之时，借此实现其他属性所无法介入的有关运算。</p><p>系统值语义是在Direct3D 10引入的。Direct3D10及其后续版本中的SV_Position语义，与Direct3D9中的POSITION语义等价。其它语义的对照关系与使用方法请参考《Semantics》（bb509647）。</p><p>如果没有使用几何着色器（我们会在第12章中介绍这种着色器），那么顶点着色器<strong>必须</strong>用SV_POSITION语义来输出顶点在齐次裁剪空间中的位置，因为（在没有使用几何着色器的情况下）执行完顶点着色器之后，硬件期望获取顶点位于齐次裁剪空间之中的坐标。如果使用了几何着色器，则可以把输出顶点在齐次裁剪空间中位置的工作交给它来处理。</p></blockquote><p>像素着色器返回一个4D颜色值，而位于此函数参数列表后的SV_TARGET语义则表示该返回值的类型应当与渲染目标格式（rendertarget format）相匹配（该输出值会被存于渲染目标之中）。</p><p>与顶点缓冲区和索引缓冲区不同的是，<strong>常量缓冲区</strong>通常由CPU每帧更新一次。举个例子，如果摄像机每帧都在不停地移动，那么常量缓冲区也需要在每一帧都随之以新的视图矩阵而更新。所以，我们会把常量缓冲区创建到一个上传堆而非默认堆中，这样做能使我们从CPU端更新常量。</p><p>通常来讲，在绘制调用开始执行之前，我们应将不同的着色器程序所需的各种类型的资源绑定到渲染流水线上。实际上，不同类型的资源会被绑定到特定的寄存器槽（registerslot）上，以供着色器程序访问。比如说，前文代码中的顶点着色器和像素着色器需要的是一个<strong>绑定到寄存器b0的常量缓冲区</strong>。在本书的后续内容中，我们会用到这两种着色器更高级的配置方法，以使多个常量缓冲区、纹理（texture）和采样器（sampler）都能与各自的寄存器槽相绑定。</p><p><strong>根签名</strong>（rootsignature）定义的是：在执行绘制命令之前，那些应用程序将绑定到渲染流水线上的资源，它们会被映射到着色器的对应输入寄存器。</p><p>如果更改了根签名，则会失去现存的所有绑定关系。也就是说，在修改了根签名后，我们需要按新的根签名定义重新将所有的对应资源绑定到渲染流水线上。<strong>尽量减少每帧渲染过程中根签名的修改次数。</strong></p><p>阶段都是可编程的，但是有些特定环节却只能接受配置。例如配置渲染流水线中光栅化阶段。</p><p>大多数控制图形流水线状态的对象被统称为<strong>流水线状态对象</strong>（PipelineState Object，PSO），用ID3D12PipelineState接口来表示。</p><blockquote><p>ID3D12PipelineState对象集合了大量的流水线状态信息。为了保证性能，我们将所有这些对象都集总在一起，一并送至渲染流水线。通过这样的一个集合，Direct3D便可以确定所有的状态是否彼此兼容，而驱动程序则能够据此而提前生成硬件本地指令及其状态。<strong>在Direct3D11的状态模型中，这些渲染状态片段都是要分开配置的。</strong>然而这些状态实际都有一定的联系，以致如果其中的一个状态发生改变，那么驱动程序可能就要为了另一个相关的独立状态而对硬件重新进行编程。由于一些状态在配置流水线时需要改变，因而硬件状态也就可能被频繁地改写。为了避免这些冗余的操作，驱动程序往往会推迟针对硬件状态的编程动作，直到明确整条流水线的状态发起绘制调用后，才正式生成对应的本地指令与状态。<strong>但是这种延迟操作需要驱动在运行时进行额外的记录工作，即追踪状态的变化，而后才能在运行时生成改写硬件状态的本地代码。</strong>在Direct3D12的新模型中，驱动程序可以在初始化期间生成对流水线状态编程的全部代码，这便是我们将大多数的流水线状态指定为一个集合所带来的好处。</p></blockquote><h2 id="第7章-利用direct3d绘制几何体续">第7章利用Direct3D绘制几何体（续）</h2><p>为了解决<strong>每帧结尾刷新命令队列</strong>导致的低效率（GPU、CPU空闲时间）：以CPU每帧都需更新的资源作为基本元素，创建一个<strong>环形数组</strong>（circulararray，也有译作循环数组）。我们称这些资源为<strong>帧资源</strong>（frameresource），而这种循环数组通常是由3个帧资源元素所构成的。CPU比GPU<strong>提前处理</strong>两帧，以确保GPU可持续工作。</p><blockquote><p>帧资源可保证持续向GPU提供数据，当GPU在处理第n帧的时候，CPU可以继续构建和提交绘制第n+1和n+2帧的命令。但帧资源不可保证不发生等待，若CPU速度远快于GPU，CPU必有空闲时间。空闲时间可以被游戏的其它部分利用。</p></blockquote><p>把单次绘制调用过程中，需要向渲染流水线提交的数据集称为<strong>渲染项</strong>（renderitem）。</p><blockquote><p>渲染项一般包括绘制单个物体需要的顶点缓冲区、索引缓冲区、常量数据、图元类型、DrawIndexedInstanced方法的参数。一个几何物体可能由多个渲染项组成。</p></blockquote><p>基于资源的更新频率对常量数据进行分组。不要在着色器内使用过多的<strong>常量缓冲区</strong>。</p><p>7.6详细讲解了<strong>根签名</strong>的使用。</p><h2 id="第8章-光照">第8章 光照</h2><p>可以把<strong>材质</strong>看作是确定光照与物体表面如何进行交互的属性集。</p><p>本书中（以及大多数实时应用程序）所采用的光照模型均为<strong>局部光照模型</strong>（localilluminationmodel），每个物体的光照皆独立于其他物体，忽略来自场景中其他物体所反弹来的光。反之为<strong>全局光照模型</strong>（globalillumination model）。</p><blockquote><p>Phong lighting是per pixel lighting。</p></blockquote><p>使用矩阵<spanclass="math inline">\(A\)</span>对图形进行变换，若变换是非等比变换或剪切变换（sheartransformation），变换后的法向量不再具有正交性，需要使用逆转置矩阵<spanclass="math inline">\((A^{-1})^T\)</span>再对其进行变换。</p><p><strong>微表面模型</strong>（microfacet）：</p><p>可以认为理想镜面（perfectmirror）的粗糙度为0，<strong>微表面法线</strong>（micro-normal）都与<strong>宏表面法线</strong>（macro-normal）的方向相同。随着粗糙度的增加，微观表面法线的方向开始纷纷偏离宏观表面法线，由此反射光逐渐扩展为一个<strong>镜面瓣</strong>（specularlobe）。</p><p>光源方向和观察方向角平分线上的方向向量为<strong>半向量</strong>，确定了方向与半向量相同的微表面在所有微表面中所占的比例，就可以确定有多少光通过<strong>镜面反射</strong>进入观察者眼中。</p><p>记半向量<span class="math inline">\(h\)</span>与宏表面法线<spanclass="math inline">\(n\)</span>夹角为<spanclass="math inline">\(\theta_{h}\)</span>，粗糙度为<spanclass="math inline">\(m\)</span>，一种微表面法线分布的数学模型： <spanclass="math display">\[S(\theta_{h})=\frac{m+8}{8}(n\cdot h)^m\]</span> <strong>菲涅尔项</strong>（Fresnel Term）的Schlickapproximation： <span class="math display">\[R_0=(\frac{n1-n2}{n1+n2})^2\]</span> <span class="math display">\[R(\theta)=R_0+(1-R_0)(1-cos\theta)^5\]</span> 本节使用的光照模型伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">shininess = <span class="hljs-number">1</span> - roughness<br>m = shininess * <span class="hljs-number">256.0f</span>; <span class="hljs-comment">// 控制粗糙度</span><br><br>halfVec = normalize(toEye + lightVec); <span class="hljs-comment">// 半向量</span><br><br>roughnessFactor = (m + <span class="hljs-number">8.0f</span>) * <span class="hljs-built_in">pow</span>(max(dot(halfVec, normal), <span class="hljs-number">0.0f</span>), m) / <span class="hljs-number">8.0f</span>; <span class="hljs-comment">// 粗糙度因子</span><br><br>f = <span class="hljs-number">1.0f</span> - saturate(dot(normal, lightVec))<br>fresnelFactor = R0 + (<span class="hljs-number">1.0f</span> - R0)* f^<span class="hljs-number">5</span>; <span class="hljs-comment">// 菲涅尔因子</span><br><br>specularAlbedo = fresnelFactor * roughnessFactor<br><br>light = (diffuseAlbedo + specularAlbedo) * lightStrength<br><br>litColor = ambient + directLight<br>         = ambientLight * diffuseAlbedo + directional/point/spotLight <span class="hljs-comment">// lightStrength与lightVec计算方法不同</span><br></code></pre></td></tr></table></figure><h2 id="第9章-纹理贴图">第9章 纹理贴图</h2><p>纹理贴图（texturemapping）是一种将图像数据映射到网格三角形上的技术。加载纹理，然后在着色器中对纹理进行采样。</p><p>渲染到纹理（render-to-texture）即将数据渲染到一个纹理后，再用它作为着色器资源。</p><p>针对GPU而专门设计DDS格式：</p><ul><li>mipmap</li><li>GPU能自行解压的压缩格式</li><li>纹理数组</li><li>cube map</li><li>volume texture</li></ul><blockquote><p>由于块压缩算法（block compressionalgorithm）要以4x4的像素块为基础进行处理，所以纹理的尺寸必须为<strong>4的倍数</strong>。</p></blockquote><h2 id="第10章-混合">第10章 混合</h2><p>混合（blending）将当前要光栅化的sourcepixel与之前已光栅化至后台缓冲区的destinationpixel相融合，可以用来绘制半透明等效果。alpha分量通常用来调节透明度。</p><p>在绘制混合物体时，需要禁止深度写入，保留深度读取与深度测试，确保混合物体不能遮挡非混合物体，非混合物体可以遮挡混合物体。</p><h2 id="第11章-模板">第11章 模板</h2><p>模板（stencil）缓冲区与深度缓冲区、后台缓冲区分辨率相同，像素一一对应，可以通过<strong>模板测试</strong>指定绘制区域。</p><p>实现镜像效果：</p><ol type="1"><li>先绘制镜子外其它物体，然后将模板缓冲区清零</li><li>将镜子绘制到模板缓冲区中</li><li>将其他物体的镜像绘制到后台缓冲区和模板缓冲区中</li><li>用混合技术将镜子绘制到后台缓冲区中</li></ol><p><strong>双重混合</strong>：将物体的几何形状投射到平面而形成阴影时，可能会有两个甚至更多的平面阴影三角形相互重叠。若此时用透明度这一混合技术来渲染阴影，则这些三角形的重叠部分会混合多次，使之看起来更暗。可以用模板测试防止同一像素被绘制多次。</p><p><strong>深度复杂性</strong>（depthcomplexity）指通过深度测试竞争，向后台缓冲区中某一特定元素写入像素片段的次数。overdraw非常影响性能。可以通过模板测试将深度复杂性可视化。本来深度测试发生于渲染流水线像素着色器阶段之后的输出合并阶段，但可以通过<strong>提前z测试</strong>（earlyz-test）在处理像素着色器之前进行深度测试，该功能由图形驱动负责，无法通过图形API控制。</p><h2 id="第12章-几何着色器">第12章 几何着色器</h2><p>几何着色器（geometryshader）输入和输出都是图元，可用于修改或舍弃图元。</p><p>将一个三角形细分为四个面积相等的三角形的几何着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VertexOut</span><br>&#123;<br>    float3 PosL  : POSITION;<br>    float3 NormalL : NORMAL;<br>    float2 Tex   : TEXCOORD;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GeoOut</span><br>&#123;<br>    float4 PosH  : SV_POSITION;<br>    float3 PosW  : POSITION;<br>    float3 NormalW : NORMAL;<br>    float2 Tex   : TEXCOORD;<br>    <span class="hljs-type">float</span> FogLerp : FOG;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Subdivide</span><span class="hljs-params">(VertexOut inVerts[<span class="hljs-number">3</span>], out VertexOut outVerts[<span class="hljs-number">6</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//       1</span><br>    <span class="hljs-comment">//       *</span><br>    <span class="hljs-comment">//      / \</span><br><span class="hljs-comment">    //     /   \</span><br><span class="hljs-comment">    //  m0*-----*m1</span><br>    <span class="hljs-comment">//   / \   / \</span><br><span class="hljs-comment">    //  /   \ /   \</span><br><span class="hljs-comment">    // *-----*-----*</span><br>    <span class="hljs-comment">// 0    m2     2</span><br><br>    VertexOut m[<span class="hljs-number">3</span>];<br><br>    <span class="hljs-comment">// 计算三角形边上的中点</span><br>    m[<span class="hljs-number">0</span>].PosL = <span class="hljs-number">0.5f</span>*(inVerts[<span class="hljs-number">0</span>].PosL+inVerts[<span class="hljs-number">1</span>].PosL);<br>    m[<span class="hljs-number">1</span>].PosL = <span class="hljs-number">0.5f</span>*(inVerts[<span class="hljs-number">1</span>].PosL+inVerts[<span class="hljs-number">2</span>].PosL);<br>    m[<span class="hljs-number">2</span>].PosL = <span class="hljs-number">0.5f</span>*(inVerts[<span class="hljs-number">2</span>].PosL+inVerts[<span class="hljs-number">0</span>].PosL);<br><br>    <span class="hljs-comment">// 把顶点投影到单位球面上</span><br>    m[<span class="hljs-number">0</span>].PosL = <span class="hljs-built_in">normalize</span>(m[<span class="hljs-number">0</span>].PosL);<br>    m[<span class="hljs-number">1</span>].PosL = <span class="hljs-built_in">normalize</span>(m[<span class="hljs-number">1</span>].PosL);<br>    m[<span class="hljs-number">2</span>].PosL = <span class="hljs-built_in">normalize</span>(m[<span class="hljs-number">2</span>].PosL);<br><br>    <span class="hljs-comment">// 求出法线</span><br>    m[<span class="hljs-number">0</span>].NormalL = m[<span class="hljs-number">0</span>].PosL;<br>    m[<span class="hljs-number">1</span>].NormalL = m[<span class="hljs-number">1</span>].PosL;<br>    m[<span class="hljs-number">2</span>].NormalL = m[<span class="hljs-number">2</span>].PosL;<br><br>    <span class="hljs-comment">// 对纹理坐标进行插值</span><br>    m[<span class="hljs-number">0</span>].Tex = <span class="hljs-number">0.5f</span>*(inVerts[<span class="hljs-number">0</span>].Tex+inVerts[<span class="hljs-number">1</span>].Tex);<br>    m[<span class="hljs-number">1</span>].Tex = <span class="hljs-number">0.5f</span>*(inVerts[<span class="hljs-number">1</span>].Tex+inVerts[<span class="hljs-number">2</span>].Tex);<br>    m[<span class="hljs-number">2</span>].Tex = <span class="hljs-number">0.5f</span>*(inVerts[<span class="hljs-number">2</span>].Tex+inVerts[<span class="hljs-number">0</span>].Tex);<br><br>    outVerts[<span class="hljs-number">0</span>] = inVerts[<span class="hljs-number">0</span>];<br>    outVerts[<span class="hljs-number">1</span>] = m[<span class="hljs-number">0</span>];<br>    outVerts[<span class="hljs-number">2</span>] = m[<span class="hljs-number">2</span>];<br>    outVerts[<span class="hljs-number">3</span>] = m[<span class="hljs-number">1</span>];<br>    outVerts[<span class="hljs-number">4</span>] = inVerts[<span class="hljs-number">2</span>];<br>    outVerts[<span class="hljs-number">5</span>] = inVerts[<span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutputSubdivision</span><span class="hljs-params">(VertexOut v[<span class="hljs-number">6</span>], </span></span><br><span class="hljs-params"><span class="hljs-function">   inout TriangleStream&lt;GeoOut&gt; triStream)</span></span><br><span class="hljs-function"></span>&#123;<br>    GeoOut gout[<span class="hljs-number">6</span>];<br><br>    [unroll]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 将顶点变换到世界空间</span><br>        gout[i].PosW = <span class="hljs-built_in">mul</span>(<span class="hljs-built_in">float4</span>(v[i].PosL, <span class="hljs-number">1.0f</span>), gWorld).xyz;<br>        gout[i].NormalW = <span class="hljs-built_in">mul</span>(v[i].NormalL,(float3x3)gWorldInvTranspose);<br><br>        <span class="hljs-comment">// 把顶点变换到齐次裁剪空间</span><br>        gout[i].PosH = <span class="hljs-built_in">mul</span>(<span class="hljs-built_in">float4</span>(v[i].PosL, <span class="hljs-number">1.0f</span>), gWorldViewProj);<br>        gout[i].Tex  = v[i].Tex;<br>    &#125;<br><br>    <span class="hljs-comment">//       1</span><br>    <span class="hljs-comment">//       *</span><br>    <span class="hljs-comment">//      / \</span><br><span class="hljs-comment">    //     /   \</span><br><span class="hljs-comment">    //  m0*-----*m1</span><br>    <span class="hljs-comment">//   / \   / \</span><br><span class="hljs-comment">    //  /   \ /   \</span><br><span class="hljs-comment">    // *-----*-----*</span><br>    <span class="hljs-comment">// 0    m2     2</span><br><br>    <span class="hljs-comment">// 我们可以将细分的小三角形绘制到两个三角形带中去：</span><br>    <span class="hljs-comment">//   三角形带1: 底端的3个三角形</span><br>    <span class="hljs-comment">//   三角形带2: 顶部的三角形</span><br><br>    [unroll]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; ++j)<br>    &#123;<br>        triStream.<span class="hljs-built_in">Append</span>(gout[j]);<br>    &#125;<br>    triStream.<span class="hljs-built_in">RestartStrip</span>();<br><br>    triStream.<span class="hljs-built_in">Append</span>(gout[<span class="hljs-number">1</span>]);<br>    triStream.<span class="hljs-built_in">Append</span>(gout[<span class="hljs-number">5</span>]);<br>    triStream.<span class="hljs-built_in">Append</span>(gout[<span class="hljs-number">3</span>]); <br>&#125;<br><br><span class="hljs-comment">// 至多输出8个顶点。输入的图元是三角形，输出一个三角形带。</span><br>[<span class="hljs-built_in">maxvertexcount</span>(<span class="hljs-number">8</span>)]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GS</span><span class="hljs-params">(triangle VertexOut gin[<span class="hljs-number">3</span>], inout TriangleStream&lt;GeoOut&gt;)</span></span><br><span class="hljs-function"></span>&#123;<br>    VertexOut v[<span class="hljs-number">6</span>];<br>    <span class="hljs-built_in">Subdivide</span>(gin, v);<br>    <span class="hljs-built_in">OutputSubdivision</span>(v, triStream);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>alpha-to-coverage</strong>：让硬件检测像素着色器所返回的alpha值，并将其用于确定MSAA覆盖的情况。令成员<code>D3D12_BLEND_DESC::AlphaToCoverageEnable = true</code>来实现。</p><h2 id="第13章-计算着色器">第13章 计算着色器</h2><p>计算着色器（computeshader）用于实现数据并行算法，不必渲染出任何图形，因此不属于渲染流水线中的一部分（使用自己的PSO，调用称为dispatchcall而不是draw call）。</p><blockquote><p>将GPU用于非图形应用程序的情况称为通用GPU程序设计（General Purpose GPUprogramming，GPGPU programming）。</p></blockquote><p>在GPU编程的过程中，根据程序具体的执行需求，可将线程划分为由<strong>线程组</strong>（threadgroup）构成的网格（grid）。一个线程组运行于一个多处理器之上，性能起见每个多处理器至少拥有两个线程组。</p><p>以NVIDIA的产品为例，硬件将线程组中的线程分为多个<strong>warp</strong>（每个warp中有32个线程），多处理器会以SIMD32的方式（即32个线程同时执行相同的指令序列）来处理warp。每个CUDA核心都可处理一个线程。</p><p>启动线程组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 线程布局，即XYZ三轴上线程组的数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ID3D12GraphicsCommandList::Dispatch</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"> UINT ThreadGroupCountX,</span></span><br><span class="hljs-params"><span class="hljs-function"> UINT ThreadGroupCountY,</span></span><br><span class="hljs-params"><span class="hljs-function"> UINT ThreadGroupCountZ)</span></span>;<br></code></pre></td></tr></table></figure><p>将两个纹理进行简单累加的计算着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">cbuffer cbSettings<br>&#123;<br>  <span class="hljs-comment">// 计算着色器能访问的常量缓冲区数据</span><br>&#125;;<br><br><span class="hljs-comment">// 数据源及着色器的输出</span><br>Texture2D gInputA;<br>Texture2D gInputB;<br>RWTexture2D&lt;float4&gt; gOutput; <span class="hljs-comment">// 对应DXGI_FORMAT_R8G8B8A8_UNORM</span><br><br><span class="hljs-comment">// 线程组中的线程数。组中的线程可以被设置为1D、2D或3D的网格布局</span><br>[<span class="hljs-built_in">numthreads</span>(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CS</span><span class="hljs-params">(int3 dispatchThreadID : SV_DispatchThreadID)</span> <span class="hljs-comment">// 线程ID</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 对两种源像素中横纵坐标分别为x、y处的纹素进行求和，并将结果保存到相应的gOutput纹素中</span><br>    gOutput[dispatchThreadID.xy] = <br>      gInputA[dispatchThreadID.xy] +<br>      gInputB[dispatchThreadID.xy];<br>&#125;<br></code></pre></td></tr></table></figure><p>调度线程ID由线程组ID与组内线程ID推算出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dispatchThreadID.xyz = groupID.xyz * ThreadGroupSize.xyz + groupThreadID.xyz;<br></code></pre></td></tr></table></figure><p>使用消费结构化缓冲区（consume structuredbuffer，一种输入缓冲区）与追加结构化缓冲区（append structuredbuffer，一种输出缓冲区），便不用再考虑索引问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Particle</span><br>&#123;<br>    float3 Position;<br>    float3 Velocity;<br>    float3 Acceleration;<br>&#125;;<br><br><span class="hljs-type">float</span> TimeStep = <span class="hljs-number">1.0f</span> / <span class="hljs-number">60.0f</span>;<br><br>ConsumeStructuredBuffer&lt;Particle&gt; gInput;<br>AppendStructuredBuffer&lt;Particle&gt; gOutput;<br>[<span class="hljs-built_in">numthreads</span>(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CS</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对输入缓冲区中的数据元素之一进行处理（即“消费”，从缓冲区中移除一个元素）</span><br>    Particle p = gInput.<span class="hljs-built_in">Consume</span>();<br><br>    p.Velocity += p.Acceleration*TimeStep;<br>    p.Position += p.Velocity*TimeStep;<br><br>    <span class="hljs-comment">// 将规范化向量追加到输出缓冲区</span><br>    gOutput.<span class="hljs-built_in">Append</span>( p );<br>&#125;<br></code></pre></td></tr></table></figure><p>每个线程组都有一块称为共享内存（sharedmemory）或线程本地存储器（thread localstorage）的内存空间，访问速度很快，但是大小有限制。</p><blockquote><p>shader model 4.0（对应DirectX 10）与Shader model 5.0（对应DirectX11）分别支持组内共享内存为16KB与32KB。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">Texture2D gInput;<br>RWTexture2D&lt;float4&gt; gOutput;<br><br>groupshared float4 gCache[<span class="hljs-number">256</span>];<br><br>[<span class="hljs-built_in">numthreads</span>(<span class="hljs-number">256</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CS</span><span class="hljs-params">(int3 groupThreadID : SV_GroupThreadID,</span></span><br><span class="hljs-params"><span class="hljs-function">     int3 dispatchThreadID : SV_DispatchThreadID)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 每个线程都对纹理进行采样，再将采集数据存储在共享内存中</span><br>  gCache[groupThreadID.x] = gInput[dispatchThreadID.xy];<br><br>  <span class="hljs-comment">// 等待组内的所有线程都完成各自的任务</span><br>  <span class="hljs-built_in">GroupMemoryBarrierWithGroupSync</span>();<br><br>  <span class="hljs-comment">// 此时，读取共享内存的任意元素并执行计算任务都是安全的</span><br>  float4 left = gCache[groupThreadID.x - <span class="hljs-number">1</span>];<br>  float4 right = gCache[groupThreadID.x + <span class="hljs-number">1</span>];<br><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第14章-曲面细分阶段">第14章 曲面细分阶段</h2>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
            <tag> DirectX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Fundamentals of Computer Graphics》第五版笔记</title>
      <link href="//posts/Notebook/Fundamentals-of-Computer-Graphics-5th-note/"/>
      <url>//posts/Notebook/Fundamentals-of-Computer-Graphics-5th-note/</url>
      
        <content type="html"><![CDATA[<p>图形学虎书第5版笔记</p><span id="more"></span><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-11-17-fundamentals-of-computer-graphics-5th.jpg"alt="封面" /><figcaption aria-hidden="true">封面</figcaption></figure><p>2022年出版。</p><p><a href="https://www.cs.cornell.edu/~srm/fcg5/">本书网站</a></p><p class="note note-warning">未完成</p><h1 id="introduction">1 Introduction</h1><p>计算机图形学一词描述了使用计算机来创建和操作图像的任何方式。</p><p>这一章定义了基础术语、提供了历史背景和一些计算机图形学相关的信息来源。</p><p>本书尽量避免依赖具体硬件或API。</p><h2 id="graphics-areas">1.1 Graphics Areas</h2><p>大多数人认同的计算机图形学<strong>主要领域</strong>：</p><ul><li>建模</li><li>渲染</li><li>动画</li></ul><p>其它领域：</p><ul><li>人机交互</li><li>虚拟现实</li><li>可视化</li><li>图像处理</li><li>三维扫描</li><li>计算摄影</li></ul><h2 id="major-applications">1.2 Major Applications</h2><ul><li>视频游戏</li><li>卡通</li><li>视觉效果</li><li>动画电影</li><li>CAD/CAM（computer-aided design / computer-aided manufacturing）</li><li>仿真</li><li>医学图像</li><li>信息可视化</li></ul><h2 id="graphics-apis">1.3 Graphics APIs</h2><p>每种图形程序都需要两种API，用于视觉输出的<strong>图形API</strong>和获取用户输入的<strong>用户界面API</strong>。</p><p>图形和用户界面API有两种主导范式，一种是Java那样图形和用户界面工具包是集成的、可移植的包，完全标准化并作为语言的一部分得到支持；一种是Direct3D和OpenGL那样绘图命令是与C++等语言相关的软件库的一部分，而用户界面软件是一个独立的实体，可能因系统而异。</p><h2 id="graphics-pipeline">1.4 Graphics Pipeline</h2><p>3D图形管线是一个高效绘制<strong>透视3D图元</strong>的特殊软件/硬件子系统。</p><p><strong>Z缓冲</strong>用内存缓冲区暴力解决从后到前顺序绘制三角形的问题。</p><p>管线中的几何操作几乎都在<strong>4D坐标空间</strong>中完成，三个传统几何坐标和一个齐次坐标。</p><p>以不同距离查看模型时，可以将模型用变化的<strong>LOD</strong>（levelof detail）表示以提高绘制效率。</p><h2 id="numerical-issues">1.5 Numerical Issues</h2><p>许多图形程序只是3D数值代码。</p><p>所有现代计算机都遵守1985年的IEEE浮点标准。</p><blockquote><p>以32位浮点数为例，1位符号位、8位指数位、23位尾数位。</p><p>特殊数表示方法如下：</p><p>无穷数的符号位为1或0，指数位全为1，尾数位全为0。</p><p>NaN的符号位为1或0，指数位全为1，尾数位不为0即可。</p><p>另外，符号位为1或0，指数位全为0，尾数位全为0，表示+0或-0。</p></blockquote><p>对于特殊数有以下计算规则（a是正数）： <span class="math display">\[+a/(+\infty)=+0\]</span> <span class="math display">\[-a/(+\infty)=-0\]</span> <span class="math display">\[+a/(-\infty)=-0\]</span> <span class="math display">\[-a/(-\infty)=+0\]</span> <span class="math display">\[\infty+\infty=+\infty\]</span> <span class="math display">\[\infty-\infty=NaN\]</span> <span class="math display">\[\infty\times\infty=\infty\]</span> <span class="math display">\[\infty/\infty = NaN\]</span> <span class="math display">\[\infty/a=\infty\]</span> <span class="math display">\[\infty/0=\infty\]</span> <span class="math display">\[0/0=NaN\]</span> <span class="math display">\[+a/+0=+\infty\]</span> <span class="math display">\[-a/+0=-\infty\]</span> 任何包含NaN的算术表达式的结果都是NaN。</p><p>任何涉及NaN的布尔表达式都为false。</p><h2 id="efficiency">1.6 Efficiency</h2><p>目前内存的速度没有跟上处理器的速度，比起操作计数应该更关注<strong>内存访问模式</strong>。</p><p>提高代码速度的步骤：</p><ol type="1"><li>以最直接的方式编写代码。根据需要即时计算中间结果而不是存储他们。</li><li>以优化模式编译。</li><li>使用现有的任何分析工具查找性能瓶颈。</li><li>检查数据结构以寻找改进局部性的方法。如果可能，使数据单元大小与目标架构上的缓存/页面大小匹配</li><li>如果分析揭示了数值计算中的瓶颈，请检查编译器生成的汇编代码是否存在效率下降的情况。重写源代码以解决发现的任何问题</li></ol><p>现代CPU执行浮点运算的速度通常与执行整数运算的速度一样快。</p><h2 id="designing-and-coding-graphics-programs">1.7 Designing and CodingGraphics Programs</h2><p>为几何实体（向量、矩阵）和图形实体（RGB颜色、图像）设计合适的类。</p><p>作者认为位置和位移应该是不同的类。</p><p>建议几何计算使用单精度、颜色计算使用双精度。</p><p><strong>DEBUG</strong>方法：</p><ol type="1"><li>创建一张图像观察哪里错了，提出假设并测试。直接使用图像作为DEBUG输出。</li><li>固定随机种子，在单线程中运行，使用debugger。</li><li>编写可视化程序显示程序内部状态。</li></ol><h1 id="miscellaneous-math">2 Miscellaneous Math</h1><p>此章笔记略。</p><p>2.1 Sets and Mappings</p><p>2.2 Solving Quadratic Equations</p><p>2.3 Trigonometry</p><blockquote><p>Spherical Trigonometry 球面三角学</p><p>Solid Angles 立体角</p></blockquote><p>2.4 Vectors</p><p>2.5 Integration</p><p>2.6 Density Functions</p><p>2.7 Curves and Surfaces</p><p>2.8 Linear Interpolation</p><p>2.9 Triangles</p><p>2.10 Discrete probability</p><p>2.11 Continuous probability</p><p>2.12 Monte Carlo Integration</p><h2 id="faq">FAQ</h2><p><strong>为什么没有向量除法？</strong></p><p>向量除法没有好的类比。</p><p>实数域上的可除代数只出现在1、2、4维，分别对应到实数、复数、四元数，如果不要求是结合代数的话还有8维八元数。其他维数的实线性空间没法定义在非零元上可逆的乘法。</p><p><ahref="https://www.zhihu.com/question/263743071/answer/272508737">为什么复数没有定义叉乘点乘，向量没有定义除法？</a></p><p><a href="https://pages.uoregon.edu/koch/Hurwitz.pdf">Hurwitz.pdf(uoregon.edu)</a></p><p><strong>什么是quasi–Monte Carlo(QMC)？</strong></p><p>即拟蒙特卡罗方法，使用<strong>低差异序列</strong>而不是伪随机数进行数值积分或研究其它数值问题。</p><p>低差异序列高效的生成在高维空间分布均匀的随机数。</p><p><a href="https://zhuanlan.zhihu.com/p/20197323">低差异序列（一）-常见序列的定义及性质</a></p><p>🔺<strong>什么是四元数？</strong>（自己整理） <spanclass="math display">\[q=w+xi+yj+zk\]</span> <span class="math display">\[i^2=j^2=k^2=-1\]</span> <span class="math display">\[jk=-kj=i\]</span> <span class="math display">\[ki=-ik=j\]</span> <span class="math display">\[ij=-ji=k\]</span> <span class="math display">\[\|q\|=\sqrt{w^2+x^2+y^2+z^2}\]</span> <span class="math display">\[q_v=xi+yj+zk\]</span> <span class="math display">\[q_w=w\]</span> <span class="math display">\[q^*=q_w-q_v\]</span> <span class="math display">\[q^{-1}=q^*/\|q\|\]</span> <span class="math display">\[q1_v\cdot q2_v=x1x2+y1y2+z1z2\]</span> <span class="math display">\[q1_v\times q2_v=(y1z2-y2z1)i+(z1x2-z2x1)j+(x1y2-x2y1)k\]</span> <span class="math display">\[q1\cdot q2=q1_wq2_w+q1_v\cdot q2_v\]</span> <span class="math display">\[q1\times q2=(q1_wq2_w-q1_v\cdot q2_v)+(q1_wq2_v+q2_wq1_v+q1_v\timesq2_v)\]</span> 单位四元数存在于四维空间的单位球上，满足<spanclass="math inline">\(\|q\|=1\)</span>。</p><p>将三维球投影到二维平面y=0得到一个圆，球上y=0的点投影位于圆上，y&gt;0半球和y&lt;0半球的点投影位于圆内，圆内一点对应两个三维点。将四维球投影到三维超平面w=0得到一个三维球的情况类似，三维球内一点对应两个四元数，三维球面上的点唯一对应一个<strong>纯四元数</strong>（w=0）。所以将三维旋转矩阵转换为四元数时有两个对应值，四元数的范围是2倍覆盖于3D旋转。四元数所在群为S3，四元数代表的三维旋转是SO(3)，前者是后者的两倍覆盖。</p><p>对于旋转轴<span class="math inline">\((a,b,c)\)</span>和旋转角<spanclass="math inline">\(\theta\)</span>，对应四元数： <spanclass="math display">\[q=cos(\theta/2)+sin(\theta/2)ai+sin(\theta/2)bj+sin(\theta/2)ck\]</span> <span class="math display">\[q^{-1}=cos(\theta/2)-sin(\theta/2)ai-sin(\theta/2)bj-sin(\theta/2)ck\]</span> 将三维点<span class="math inline">\(d\)</span>（将其表示为w=0的纯四元数）做以上旋转，得到的新点： <spanclass="math display">\[d_r=q\times d\times q^{-1}\]</span>这个运算形式是为了限制其结果所在空间，只有纯四元数与三维空间的点一一对应，对纯四元数运算得到纯四元数，才表示三维点旋转得到三维点。每次转<spanclass="math inline">\(\theta/2\)</span>的原因如下图。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-08-02-quaternion-3d-rotation.png" /></p><p>复数可以表示二维平面（横轴为实部，纵轴为虚部）上的旋转。二维向量1+i与横轴正半轴夹角为45度，任何二维向量乘1+i相当于将其旋转45度。参考<ahref="https://betterexplained.com/articles/a-visual-intuitive-guide-to-imaginary-numbers/">AVisual, Intuitive Guide to Imaginary Numbers – BetterExplained</a>。</p><p><strong>什么是万向锁？</strong></p><p>使用<strong>基于物体自身坐标系的欧拉角</strong>表示旋转时会产生万向锁问题。为方便理解，假设物体旋转前自身xyz轴与世界xyz轴重合，第一次绕自身的z轴旋转，第二次绕自身的x轴旋转，第三次绕自身的y轴旋转，当第二次旋转使自身的y轴与世界z轴（即旋转前自身的z轴）重合时，第三次绕自身的y轴旋转就是绕世界z轴旋转（即绕旋转前自身的z轴旋转），这样第三次旋转与第一次旋转都是在绕同一个轴旋转，丢失了一个自由度。</p><p>所以同一旋转，欧拉角表示不唯一，并且欧拉不能插值，所以用四元数表示旋转。</p><h1 id="raster-images">3 Raster Images</h1><p>Raster images是通用的输入和输出形式，Vectorimages在输出时也要光栅化。</p><h2 id="raster-devices">3.1 Raster Devices</h2><p>输出</p><ul><li><p>显示器（Display）</p><ul><li><p>Transmissive：不发光，调节通过其的光通量，需要背光源。如LCD（Liquidcrystal display）。</p></li><li><p>Emissive：自发光，直接控制光通量。如LED（Light-emittingdiode）。</p><blockquote><p>LED与LCD显示屏的划分源自厂商的宣传，实际上，LED显示屏指采用LED作为背光源的LCD，LCD显示屏指使用CCFL为背光源的LCD。</p></blockquote></li></ul></li><li><p>硬拷贝器（Hardcopy）</p><ul><li>Binary：喷墨打印机。</li><li>Continuous tone：热升华打印机。</li></ul></li></ul><p>输入</p><ul><li>2D array sensor：数码相机。</li><li>1D array sensor：平板扫描仪。</li></ul><h2 id="images-pixels-and-geometry">3.2 Images, Pixels, andGeometry</h2><p>图片区域到像素值集合的映射： <span class="math display">\[I(x,y):R\to V\]</span> 像素值是图片上一个采样点的局部平均颜色。</p><p>图片大小一般用宽*高表示，单个像素索引为<spanclass="math inline">\((column_i,row_j)\)</span>。</p><p>存储浮点数的一般称为high dynamic range (HDR)图片，存储整数的一般称为low dynamic range (LDR) 图片。</p><p>显示器强度和输入像素值<spanclass="math inline">\(a\)</span>是非线性关系，<strong>伽马编码</strong>的伽马值为<spanclass="math inline">\(\gamma\)</span>： <span class="math display">\[displayed\ intensity=(maximum\ intensity)a^{\gamma}\]</span> 测得伽马值<spanclass="math inline">\(\gamma\)</span>后，可以对a进行<strong>伽马矫正</strong>（即用另一个伽马编码抵消）：<span class="math display">\[a_c=a^{\frac{1}{\gamma}}\]</span></p><p><span class="math display">\[\begin{align}displayed\ intensity &amp;= (maximum\intensity){a_c}^{\gamma} \\&amp;= (maximum\ intensit)a\end{align}\]</span></p><blockquote><p>图片在存储像素值时使用<strong>sRGB</strong>格式进行伽马编码（伽马值小于1，0.45），与显示器在显示图片时的伽马编码（伽马值大于1，2.2）抵消。</p><p>对图片伽马编码起源于对CRT显示器的伽马编码的抵消，但如今液晶显示器已经可以人工设定伽马值，<strong>不做线性显示器是因为需要伽马编码</strong>，人眼对暗部细节的感知灵敏度更高，伽马编码相比线性编码存储更多的暗部信息。</p><p>在shader中做计算时需要在线性空间计算，因此将图片读出的像素值转换到线性空间计算，再转换回去。</p></blockquote><p>人眼感知的内容见19章。</p><h2 id="rgb-color">3.3 RGB Color</h2><p>红黄蓝三原色<strong>减色混合</strong>得到其它的颜色。显示器使用红绿蓝的<strong>加色混合</strong>。</p><h2 id="alpha-compositing">3.4 Alpha Compositing</h2><p>前景颜色<span class="math inline">\(c_f\)</span>和背景颜色<spanclass="math inline">\(c_b\)</span>： <span class="math display">\[c=\alpha c_f+(1-\alpha)c_b\]</span></p><h1 id="ray-tracing">4 Ray Tracing</h1><p><strong>对象顺序渲染</strong>依次考虑每个对象，<strong>图像顺序渲染</strong>依次考虑每个像素。光追是渲染3D场景的图像顺序算法。</p><h2 id="the-basci-ray-tracing-algorithm">4.1 The Basci Ray-TracingAlgorithm</h2><p>基础光线追踪器有三部分：</p><ol type="1"><li>ray generation 基于摄影集合计算每个像素的视线的原点和方向</li><li>ray intersection 找到与视线相交的最近物体</li><li>shading基于视线相交结果计算像素颜色（结果包括命中点、光照、表面法线等）</li></ol><h2 id="perspective">4.2 Perspective</h2><p>直线透视（linearperspective）：场景中的直线在图片中依然是直线。（鱼眼镜头就不是直线透视）</p><p>平行投影（parallelprojection）：保留平行关系和形状尺寸，用于机械和建筑设计。</p><ul><li>直角投影（orthographic）：投影平面与视点方向垂直。</li><li>斜投影（oblique）：不垂直。</li></ul><blockquote><p>透视投影也有斜投影，只是不常用。</p></blockquote><p>透视投影（perspective projection）：近大远小，即人眼成像方法。</p><h2 id="computing-viewing-rays">4.3 Computing Viewing Rays</h2><p>光线的参数方程： <span class="math display">\[p(t)=e+t(s-e)\]</span> 从视点e行进到一点s，t是参数。</p><p>相机坐标系<spanclass="math inline">\(\{u,v,w\}\)</span>是<strong>右手坐标系</strong>，从相机视角来看，u指向右方，v指向上方，w指向后方（与相机视角方向相反）。</p><p>对于平行投影，光线的方向相同原点不同；对于透视投影，光线的原点相同方向不同。</p><h2 id="ray-object-intersection">4.4 Ray-Object Intersection</h2><p>光线： <span class="math display">\[\vec{p}(t)=\vec{e}+t\vec{d}\]</span> 球心为<spanclass="math inline">\(\vec{c}\)</span>，光线<strong>击中球</strong>：<span class="math display">\[(\vec{p}-\vec{c})\cdot(\vec{p}-\vec{c})-R^2=0\]</span> 击中球处<spanclass="math inline">\(\vec{p}\)</span>的单位法线： <spanclass="math display">\[\vec{n}=(\vec{p}-\vec{c})/R\]</span> 三角形顶点为<spanclass="math inline">\(\vec{a}\)</span>、<spanclass="math inline">\(\vec{b}\)</span>、<spanclass="math inline">\(\vec{c}\)</span>，光线<strong>击中三角形</strong>：<span class="math display">\[\vec{p}=\alpha+\beta(\vec{b}-\vec{a})+\gamma(\vec{c}-\vec{a})\]</span> 击中点位于三角形内的条件是<spanclass="math inline">\(\beta&gt;0,\gamma&gt;0,\beta+\gamma&lt;1\)</span>。</p><p>设计程序时应该设定一个Surface类作为所有可与光线相交的对象和efficiencystructures（参见12.3）的父类。</p><h2 id="shading">4.5 Shading</h2><p>五种光源：</p><p>point lights 从一点发光</p><p>directional lights 从单一方向照亮场景</p><p>ambient lights 填充阴影的恒量照明（没有阴影测试）</p><p>area lights 发光的场景几何</p><p>environment lights 使用图像来表示来自天空等远处光源的光</p><p>计算所需的四个向量：<strong>着色点<spanclass="math inline">\(\vec{x}\)</span>、法线<spanclass="math inline">\(\vec{n}\)</span>、光照方向<spanclass="math inline">\(\vec{l}\)</span>、视点方向<spanclass="math inline">\(\vec{v}\)</span></strong>。</p><p>计算阴影时，检测表面<span class="math inline">\(s\)</span>上一点<spanclass="math inline">\(p\)</span>与光源<spanclass="math inline">\(l\)</span>的连线是否被遮蔽，为了避免数值计算的不精确导致<spanclass="math inline">\(p\)</span>被<spanclass="math inline">\(s\)</span>遮蔽，将<spanclass="math inline">\(p\)</span>沿着其与<spanclass="math inline">\(l\)</span>的连线移动一小段距离。</p><h2 id="historical-notes">4.6 Historical Notes</h2><p>光追的渐进时间复杂度低于基础的对象顺序渲染算法。随着硬件的进步实时光追越来越普遍。</p><h1 id="surface-shading">5 Surface Shading</h1><p>着色模型完全独立于渲染系统的其余部分，相同的模型可以用于光线跟踪和光栅化系统。</p><p>本章介绍点光源照明的不透明表面的基本着色模型。</p><h2 id="point-like-light-sources">5.1 Point-like light sources</h2><p>点光源由其位置和强度描述。</p><p>手电筒和太阳也算点状光源，一个够小，一个够远。</p><p>irradiance <strong>辐照度</strong>E 单位<spanclass="math inline">\(W/m^2\)</span></p><p>radiance <strong>辐射率</strong>L 单位<spanclass="math inline">\(W/(m^2*sr)\)</span></p><h2 id="basic-reflection-models">5.2 Basic reflection models</h2><p>镜面反射发生在表面顶部，并在反射方向附近反射；漫反射发生在表面之下，并向各个方向出现。</p><p><strong>Lambertian reflection</strong>： <spanclass="math display">\[L_r=kE=\frac{R}{\pi}E\]</span> albedoR表示反射的辐照度的百分比，k的取值原因参见第14章（能量守恒）。</p><p>Lambertian着色是理想的漫反射着色，颜色与视点无关。适用于纸张、平面油漆、泥土、树皮、石头等粗糙材质。（颜色的精确预测参见第18章）</p><p><strong>Specular reflection</strong>：</p><p>Modified Blinn–Phong model。 <span class="math display">\[L_r=(\frac{R}{\pi}+k_smax(0,n\cdot h)^p)E\]</span> <span class="math inline">\(\vec{h}\)</span>是光照方向<spanclass="math inline">\(\vec{l}\)</span>和视点方向<spanclass="math inline">\(\vec{v}\)</span>的半向量，点积<spanclass="math inline">\((n\cdot h)^p\)</span>描述了反射强度，<spanclass="math inline">\(\vec{h}\)</span>与<spanclass="math inline">\(\vec{n}\)</span>越接近反射越强，<strong>Phong指数</strong><spanclass="math inline">\(p\)</span>越大反射越强。</p><p>颜色与视点相关。适用于金属、塑料、光泽或半光泽油漆、大量植物叶子。</p><p>p的典型取值：</p><p>10——"eggshell"</p><p>100——mildly shiny</p><p>1000——really glossy</p><p>10,000——nearly mirror-like</p><p>（关于BRDF的完整讨论参见第14章）</p><p><strong>Calculating shading</strong></p><p>可以分为计算辐照度与计算反射光两部分，彼此无关。上面已计算反射光。</p><p>计算辐照度： <span class="math display">\[E=\frac{max(0,n\cdot l)}{r^2}I\ \ (point)\]</span> <span class="math display">\[E=max(0,n\cdot l)H\ \ (directional)\]</span></p><p><span class="math inline">\(I\)</span>和<spanclass="math inline">\(H\)</span>为光源强度。</p><p>光线追踪和光栅化之间获取计算所需量的方式有很大不同，但实际的着色计算本身是相同的。所有向量都要归一化。</p><h2 id="ambient-illumination">5.3 Ambient illumination</h2><p><span class="math display">\[L_r=k_aI_a\]</span></p><p>防止阴影完全变黑，并可以轻松调整整个场景对比度。</p><h1 id="linear-algebra">6 Linear Algebra</h1><p>此章笔记略。</p><p>6.1 Determinants</p><p>6.2 Matrices</p><p>6.3 Computing with Matrices and Determinants</p><p>6.4 Eigenvalues and Matrix Diagonalization</p><h2 id="faq-1">FAQ</h2><p><strong>逐元素的矩阵乘法称为什么？</strong></p><p>Hadamard积。</p><p><strong>奇异值和特征值的区别？</strong></p><p><ahref="https://www.zhihu.com/question/19666954/answer/54788626">矩阵的奇异值与特征值有什么相似之处与区别之处？-赵文和的回答</a></p><h1 id="transformation-matrices">7 Transformation Matrices</h1><p>此章笔记略。参见GAMES101-03/04笔记。</p><p>7.1 2D Linear Transformations</p><p>7.2 3D Linear Transformations</p><p>7.3 Translation and Affine Transformations</p><p>7.4 Inverses of Transformation Matrices</p><p>7.5 Coordinate Transformations</p><h1 id="viewing">8 Viewing</h1><p>此章笔记略。参见GAMES101-03/04笔记。</p><p>8.1 Viewing Transformations</p><p>8.2 Projective Transformations</p><p>8.3 Perspective Projection</p><p>8.4 Some Properties of the Perspective Transform</p><p>8.5 Field-of-View</p><p>❓这章末尾的一个FAQ我没有看懂：</p><ul><li>The tessellated spheres I draw in perspective look like ovals. Isthis a bug?</li></ul><p>No. It is correct behavior. If you place your eye in the samerelative position to the screen as the virtual viewer has with respectto the viewport, then these ovals will look like circles because theythemselves are viewed at an angle.</p><h1 id="the-graphics-pipeline">9 The Graphics Pipeline</h1><p>找到图像中被几何图元占据的所有像素的过程称为光栅化，因此<strong>对象顺序渲染</strong>也可以称为<strong>光栅化渲染</strong>。光栅化从对象开始到更新图像中的像素为止的操作序列称为图形管线。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-11-22-graphics-pipeline.png" /></p><h2 id="rasterization">9.1 Rasterization</h2><p><strong>Line Drawing</strong></p><p><strong>Triangle Rasterization</strong></p><p><strong>Perspective Correct Interpolation</strong></p><p>透视投影是非线性的，因此透视投影或需要对重心坐标进行矫正。应从屏幕空间逆变换回三维空间，再用重心坐标插值。</p><p>可参考：<ahref="https://zhuanlan.zhihu.com/p/400257532">矫正透视投影插值及属性插值详解</a></p><p>Clipping可以发生在变换前或齐次坐标空间。这节只讲了求点与平面交点的公式，裁剪三角形参见12.4.3。</p><h2 id="operations-before-and-after-rasterization">9.2 Operations Beforeand After Rasterization</h2><p><strong>Simple 2D Drawing</strong></p><p>没有vertex或fragment阶段。</p><p><strong>A Minimal 3D Pipeline</strong></p><p>做MVP和视口变换，需要按前后顺序绘制面元。</p><p><strong>Using a z-Buffer for Hidden Surfaces</strong></p><p>使用z-Buffer给每个fragment存一个深度值。考虑到精度问题，谨慎选择近平面n和远平面f，使n尽量大，f尽量小。</p><p><strong>Per-vertex Shading</strong></p><p>即Gouraud shading。</p><p><strong>Per-fragment Shading</strong></p><p>即Phong shading。（和Phong illumination model是两种东西）</p><p><strong>Texture Mapping</strong></p><p>给每个顶点赋纹理坐标。</p><p><strong>Shading Frequency</strong></p><p>根据实际需要选择不同着色频率的shading 方法。</p><p>（这节没提flat shading）</p><h2 id="simple-antialiasing">9.3 Simple Antialiasing</h2><p>MSAA通过给每个fragment存储一个color加上一个coverage mask和一组 depthvalues。</p><h2 id="culling-primitives-for-efficiency">9.4 Culling Primitives forEfficiency</h2><p>三种Culling 策略（同时使用）：</p><ul><li>view volume culling</li><li>occlusion culling</li><li>backface culling</li></ul><h1 id="signal-processing">10 Signal Processing</h1><p>信号处理。</p><p>10.1 Digital Audio: Sampling in 1D</p><p>10.2 Convolution</p><p>10.3 Convolution Filters</p><p>10.4 Signal Processing for Images</p><p>10.5 Sampling Theory</p><h1 id="texture">11 Texture</h1><p>本章讨论使用纹理来表示表面细节、阴影和反射。</p><p>重点是纹理映射函数和克服纹理映射（重采样）造成的aliasing。</p><h2 id="looking-up-texture-values">11.1 Looking Up Texture Values</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">Color <span class="hljs-title function_">texture_lookup</span><span class="hljs-params">(Texture t, <span class="hljs-type">float</span> u, <span class="hljs-type">float</span> v)</span> &#123;<br>    <span class="hljs-type">int</span> i = round(u * t.width()- <span class="hljs-number">0.5</span>)<br>    <span class="hljs-type">int</span> j = round(v * t.height()- <span class="hljs-number">0.5</span>)<br>    <span class="hljs-keyword">return</span> t.get_pixel(i,j)<br>&#125;<br><br>Color shade_surface_point(Surface s, Point p, Texture t) &#123;<br>    Vector normal = s.get_normal(p)<br>    (u,v) = s.get_texcoord(p)<br>    Color diffuse_color = texture_lookup(u,v)<br>    <span class="hljs-comment">// compute shading using diffuse_color and normal</span><br>    <span class="hljs-comment">// return shading result</span><br>&#125;<br></code></pre></td></tr></table></figure><p>需要知道surface S到texture T的映射关系get_texcoord： <spanclass="math display">\[\begin{align}\phi&amp;:S\to T \\&amp;:(x,y,z)\longmapsto (u,v)\end{align}\]</span></p><h2 id="texture-coordinate-functions">11.2 Texture CoordinateFunctions</h2><p>也称作UV mapping或surface parameterization。</p><p>设计<spanclass="math inline">\(\phi\)</span>需要考虑的几个竞争性目标：</p><ul><li>Bijectivity，即injective和surjective。</li><li>Size distortion，<spanclass="math inline">\(\phi\)</span>的导数的变化不应太大，即表面上间隔大致相同的点对映射到纹理上间隔也应大致相同。</li><li>Shape distortion，不同方向上<spanclass="math inline">\(\phi\)</span>的导数不应相差太大，即形状不应变化太大，表面上的圆形映射到纹理上也是圆形。</li><li>Continuity，<spanclass="math inline">\(\phi\)</span>应该是连续的或者具有尽可能少的不连续性，即不应有太多接缝，表面上的相邻点应映射到纹理中的相邻点。</li></ul><p><strong>Geometrically Determined Coordinates</strong></p><p>对于简单形状或特俗情况。</p><p>Planar Projection</p><p>Spherical Coordinates</p><p>Cylindrical Coordinates</p><p>Cubemaps</p><p><strong>Interpolated Texture Coordinates</strong></p><p>对于需要细粒度控制纹理坐标的三角形网格表面。</p><p>顶点存纹理坐标，对整个三角形进行重心插值。</p><p><strong>Tiling, Wrapping Modes, and TextureTransformations</strong></p><p>可以对纹理进行平铺、缩放、平移。</p><p><strong>Continuity and Seams</strong></p><p>对于任何封闭的三维表面，没有连续的双射函数将整个表面映射成纹理图像是拓扑学的基本结论。在纹理坐标突然改变的表面上引入接缝曲线，可以在其他地方降低失真。</p><p><strong>Texture coordinates in rendering systems</strong></p><p>在光线追踪渲染器中，支持光线相交的每种类型的表面必须不仅能够计算相交点和表面法线，而且还能够计算相交点的纹理坐标。光线击中时，由三角形网格表示的几何体可以根据存储在顶点的纹理坐标通过重心插值来计算纹理坐标，对于其他类型的几何体必须直接计算纹理坐标。</p><p>在基于光栅化的系统中，三角形通常是唯一受支持的几何类型，所有曲面都必须转换为这种形式。光栅化器对纹理坐标进行插值，以便fragment着色器的每次调用都具有适合其的纹理坐标。</p><h2 id="antialiasing-texture-lookups">11.3 Antialiasing TextureLookups</h2><p>参考GAMES101-09笔记。</p><h2 id="applications-of-texture-mapping">11.4 Applications of TextureMapping</h2><ol type="1"><li><p>Controlling Shading Parameters：basecolor，metallic，roughness等贴图。</p></li><li><p>Normal Maps and Bump Maps：法线贴图 (切线参考系下)是凹凸贴图的导数。</p></li><li><p>Displacement Maps：位移贴图实际改变曲面。（光追中没有idealway应用位移贴图）</p></li><li><p>ShadowMaps：用一个单独的渲染pass提前计算，在光源处光栅化得到的深度图即为阴影贴图。执行一个普通渲染pass时，若需要知道一个fragment对光源是否可见时，将其投影到阴影贴图中（使用最初用于渲染阴影贴图的透视图投影），并将查找值<spanclass="math inline">\(d_{map}\)</span>与实际距光源距离<spanclass="math inline">\(d\)</span>进行比较，若<spanclass="math inline">\(d&gt;d_{map}\)</span>说明有阴影，相等则没有。</p><p>由于数值计算的精度问题，需要引入shadow bias判断相等关系。</p><p>对阴影贴图插值没有意义，在阴影边界会导致问题。阴影贴图中的纹理查找使用最近邻重构来完成。减少aliasing，可以使用多个样本，对1或0的阴影结果（而不是深度）进行平均，这被称为percentagecloser filtering（PCF）。</p></li><li><p>Environment Maps：环境贴图。</p></li></ol><h2 id="procedural-3d-textures">11.5 Procedural 3D Textures</h2><p>3D纹理容易定义映射函数，没有distortion。适合由固体介质雕刻而成的表面，如大理石雕像。</p><p>3D纹理若存储为3D光栅图像或体积会消耗大量内存。因此3D纹理坐标最常用于程序纹理，纹理值使用数学过程计算，而不是从纹理图像中查找来计算的。</p><p>3D Stripe Textures</p><p>Solid Noise (Perlin noise)</p><h1 id="data-structures-for-graphics">12 Data Structures forGraphics</h1><h2 id="triangle-meshes">12.1 Triangle Meshes</h2><p>带宽比存储更宝贵。</p><p><strong>Mesh Topology</strong></p><p>manifold来自拓扑学的数学领域。一个二维流形是这样一个表面：任何一点的小邻域可以被平滑为一小块平表面。</p><p>边为manifold的条件：正好只由两个三角形share。</p><p>点为manifold的条件：周围正好只有一个完整的三角形环。</p><p>manifold不能有boundary，但实际应用中可以放宽条件：边由一个或两个三角形share，点连到一组边相连的三角形。</p><p>默认情况下，front是三角形顶点<strong>逆时针</strong>绕序的那一面。网格若朝向一致，称为consistentlyoriented。manifold可能无法定义为朝向一致，如Mobius band。</p><p><strong>Indexed Mesh Storage</strong></p><p>通过存储索引减小内存消耗。</p><p><strong>Triangle Strips and Fans</strong></p><p>更高效的三角形组织方式。n+2个顶点描述n个三角形。</p><p><strong>Data Structures for Mesh Connectivity</strong></p><p>修改网格需要知道点、边、三角形之间的关系。</p><p>低效的数据结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">Triangle &#123;<br>    Vertex v[<span class="hljs-number">3</span>]<br>   Edge e[<span class="hljs-number">3</span>]<br> &#125;<br><br>Edge &#123;<br>    Vertex v[<span class="hljs-number">2</span>]<br>    Triangle t[<span class="hljs-number">2</span>]<br>&#125;<br><br>Vertex &#123;<br>    Triangle t[]<br>    Edge e[]<br>&#125;<br></code></pre></td></tr></table></figure><p>The Triangle-Neighbor Structure：</p><p>以三角形为核心。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">Triangle &#123;<br>    Edge nbr[<span class="hljs-number">3</span>];<br>    Vertex v[<span class="hljs-number">3</span>];<br>&#125;<br><br>Edge &#123; <span class="hljs-comment">// the i-th edge of triangle t</span><br>    Triangle t;<br>    <span class="hljs-type">int</span> i; <span class="hljs-comment">// in &#123;0,1,2&#125;</span><br>&#125;<br><br>Vertex &#123;<br>    <span class="hljs-comment">// ... per-vertex data ...</span><br>    Edge e; <span class="hljs-comment">// any edge leaving vertex</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The Winged-EdgeStructure：</p><p>以边为核心。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">Edge &#123;<br>    Edge lprev, lnext, rprev, rnext;<br>    Vertex head, tail;<br>    Face left, right;<br>&#125;<br><br>Face &#123;<br>    <span class="hljs-comment">// ... per-face data ...</span><br>    Edge e; <span class="hljs-comment">// any adjacent edge</span><br>&#125;<br><br>Vertex &#123;<br>    <span class="hljs-comment">// ... per-vertex data ...</span><br>    Edge e; <span class="hljs-comment">// any incident edge</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The Half-Edge Structure：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">HEdge &#123;<br>    HEdge pair, next;<br>    Vertex v;<br>    Face f;<br>&#125;<br>Face &#123;<br>    <span class="hljs-comment">// ... per-face data ...</span><br>    HEdge h; <span class="hljs-comment">// any h-edge of this face </span><br>&#125;<br><br>Vertex &#123;<br>    <span class="hljs-comment">// ... per-vertex data ...</span><br>    HEdge h; <span class="hljs-comment">// any h-edge pointing toward this vertex</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="scene-graphs">12.2 Scene Graphs</h2><p>用层级结构组织对象，便于得到对象的子对象的transform矩阵（如车的轮子）。</p><p>对于光栅化，使用很多API支持的矩阵栈实现。</p><p>对于光追，使用instancing技术，存储对象和transform矩阵，显式的变换在渲染时完成。如果有一条光线要和变换后的对象相交，将反变换光线和未变换的对象相交。</p><p>优点：</p><ul><li>未变换的对象可能更容易做相交。</li><li>大量变换后的对象可以共享一个未变换的对象。</li></ul><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-11-26-scene-graph-instancing.png" /></p><h2 id="spatial-data-structures">12.3 Spatial Data Structures</h2><p>空间数据结构旨在组织空间中的对象，以便有效地查找对象。可用于光追、视图剔除、碰撞检测。</p><p><strong>Bounding Boxes</strong></p><p>只有当光线击中边界框时，才会测试光线是否与表面相交。</p><p><strong>Hierarchical Bounding Boxes</strong></p><p>BVH (Bounding Volume Hierarchies) 算法。划分对象。</p><p><strong>Uniform Spatial Subdivision</strong></p><p>均匀划分空间。</p><p><strong>Axis-Aligned Binary Space Partitioning</strong></p><p>axis-aligned BSP。划分空间。</p><h2 id="bsp-trees-for-visibility">12.4 BSP Trees for Visibility</h2><p>预先计算BSP树，运行时根据视点位置调用树，执行遍历，产生用于视图剔除的画家算法所需的从后向前的多边形顺序。</p><h2 id="tiling-multidimensional-arrays">12.5 Tiling MultidimensionalArrays</h2><p>通过tiling更好地组织多维数组的内存布局。例如，对于二维数组的普通布局方式，同行的相邻元素在内存中紧邻对方，但同列的相邻元素在内存中间隔（列数个）元素。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-11-27-memory-tile.png" /></p><p>tile尺寸应与机器上的内存单元大小接近。</p><h1 id="sampling">13 Sampling</h1><p>13.1 Integration</p><p>13.2 Continuous Probability</p><p>13.3 Monte Carlo Integration</p><p>13.4 Choosing Random Points</p><h1 id="physics-based-rendering">14 Physics-Based Rendering</h1><p>严格遵循物理模型而不是phenomenological。</p><p>推荐了pharr的PBR。</p><h2 id="photons">14.1 Photons</h2><p>Photon在图形学里只是遵循几何光学的能量包。 <spanclass="math display">\[q=hf=\frac{hc}{\lambda}\]</span> <span class="math inline">\(h=6.63\times10^{-34}Js\)</span>是Plank’s Constant。</p><h2 id="smooth-metals">14.2 Smooth Metals</h2><p>Schlick approximation： <span class="math display">\[R_0(\lambda)=(\frac{n1(\lambda)-n2(\lambda)}{n1(\lambda)+n2(\lambda)})^2\]</span> <span class="math display">\[R(\theta,\lambda)=R_0(\lambda)+(1-R_0(\lambda))(1-cos\theta)^5\]</span> n为折射率（refractive indices）。</p><h2 id="smooth-dielectrics">14.3 Smooth Dielectrics</h2><p>一个启发式：不是导体就是电介质。</p><p>光滑均匀的电介质是透明的，如玻璃、水和眼睛的晶状体；混合物接近不透明，如皮肤、牛奶、头发、布料和几乎所有日常材料。</p><p>对于光滑电介质只有三个重要的属性：</p><ol type="1"><li>在每个入射角度和波长下反射的光有多少</li><li>在给定的距离和波长内，光在材料中传播时被吸收的比例是多少</li><li>反射光和折射光的方向是什么</li></ol><p><strong>Reflectivity of a Dielectric</strong></p><p>电介质和金属同样适用Schlick approximation。</p><p>常用折射率n：水1.33，玻璃1.4-1.7，钻石2.4。</p><p><strong>Refraction and Beer's law</strong></p><p>Snell’s Law： <span class="math display">\[\eta_isin\theta_i=\eta_tsin\theta_t\]</span> Beer's law： <span class="math display">\[I(s)=I(0)a^s\]</span> <span class="math inline">\(a\)</span>是degree ofattenuation，<span class="math inline">\(s\)</span>是距界面距离，<spanclass="math inline">\(I\)</span>是光强。描述了光线被物质吸收产生的衰减。</p><h2 id="dielectrics-with-subsurface-scattering">14.4 Dielectrics withSubsurface Scattering</h2><p>仅用光滑的电介质就可以呈现出一系列令人惊讶的材质。</p><p>冰块可以通过在内部放置小气泡变得不透明，也可以通过使表面粗糙变得不透明。</p><p>人类皮肤可以被建模成一个粗糙的表面和折射率稍微不同的多层、色素粒子（遵循比尔定律）、血液（遵循比尔定律）。</p><h2 id="a-brute-force-photon-tracer">14.5 A Brute Force PhotonTracer</h2><p>描述了最基本的光子追踪过程。</p><h2 id="radiometry">14.6 Radiometry</h2><p>参见GAMES101-14笔记。</p><h2 id="radiometry-of-scattering">14.7 Radiometry of Scattering</h2><p>讲了BRDF的定义和Ideal Diffuse BRDF。参见GAMES101-17笔记。</p><h2 id="transport-equation">14.8 Transport Equation</h2><p>即反射方程： <span class="math display">\[L_r(x,w_r)=\int_{\Omega}L_i(x,w_i)f(x,w_i,w_r)\cos \theta_id\omega_i\]</span> 但书这里的写法很不一样： <span class="math display">\[L_s(x,k_o)=\int_{all\x^{&#39;}}\frac{\rho(k_i.k_o)L_s(x^{&#39;},x-x^{&#39;})v(x,x^{&#39;})}{\left\|x-x^{&#39;}\right \|^2}dA^{&#39;}\]</span> <span class="math display">\[v(x,x^{&#39;})=\begin{align}\left\{\begin{matrix}1\ &amp;if\ x\ and\ x^{&#39;}\ are\ mutually\ visible,\\0\ &amp;otherwise.\end{matrix}\right.\end{align}\]</span> <span class="math inline">\(\rho\)</span>代表BRDF。</p><h2 id="materials-in-practice">14.9 Materials in Practice</h2><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-11-27-taxonomy-of-BSDF-Lobes.png" /></p><p><ahref="https://casual-effects.com/research/McGuire2020BSDF/index.html">ATaxonomy of Bidirectional Scattering Distribution Function Lobes forRendering Engineers</a></p><h2 id="monte-carlo-ray-tracing">14.10 Monte Carlo Ray Tracing</h2><p>参见GAMES101-16笔记。路径追踪是分布式光追的简化版本，每个像素发射多条光线，但但每次弹射只产生一条光线。</p><h1 id="curves">15 Curves</h1><p>15.1 Curves</p><p>15.2 Curve Properties</p><p>15.3 Polynomial Pieces</p><p>15.4 Putting Pieces Together</p><p>15.5 Cubics</p><p>15.6 Approximating Curves</p><p>15.7 Summary</p><h1 id="computer-animation">16 Computer Animation</h1><p>16.1 Principles of Animation</p><p>16.2 Keyframing</p><p>16.3 Deformations</p><p>16.4 Character Animation</p><p>16.5 Physics-Based Animation</p><p>16.6 Procedural Techniques</p><p>16.7 Groups of Objects</p><h1 id="using-graphics-hardware">17 Using Graphics Hardware</h1><p>17.1 Hardware Overview</p><p>17.2 What Is Graphics Hardware</p><p>17.3 Heterogeneous Multiprocessing</p><p>17.4 Graphics Hardware Programming: Buffers, State, and Shaders</p><p>17.5 State Machine</p><p>17.6 Basic OpenGL Application Layout</p><p>17.7 Geometry</p><p>17.8 A First Iook at Shaders</p><p>17.9 Vertex Buffer Objects</p><p>17.10 Vertex Array Objects</p><p>17.11 Transformation Matrices</p><p>17.12 Shading with Per-Vertex Attributes</p><p>17.13 Shading in the Fragment Processor</p><p>17.14 Meshes and Instancing</p><p>17.15 Texture Objects</p><p>17.16 Object-Oriented Design for Graphics Hardware Programming</p><p>17.17 Continued Learning</p><h1 id="color">18 Color</h1><p>18.1 Colorimetry</p><p>18.2 Color Spaces</p><p>18.3 Chromatic Adaptation</p><p>18.4 Color Appearance</p><h1 id="visual-perception">19 Visual Perception</h1><p>19.1 Vision Science</p><p>19.2 Visual Sensitivity</p><p>19.3 Spatial Vision</p><p>19.4 Objects, Locations, and Events</p><p>19.5 Picture Perception</p><h1 id="tone-reproduction">20 Tone Reproduction</h1><p>20.1 Classification</p><p>20.2 Dynamic Range</p><p>20.3 Color</p><p>20.4 Image Formation</p><p>20.5 Frequency-Based Operators</p><p>20.6 Gradient-Domain Operators</p><p>20.7 Spatial Operators</p><p>20.8 Division</p><p>20.9 Sigmoids</p><p>20.10 Other Approaches</p><p>20.11 Night Tonemapping</p><p>20.12 Discussion</p><h1 id="implicit-modeling">21 Implicit Modeling</h1><p>21.1 Implicit Functions, Skeletal Primitives, and SummationBlending</p><p>21.2 Rendering</p><p>21.3 Space Partitioning</p><p>21.4 More on Blending</p><p>21.5 Constructive Solid Geometry</p><p>21.6 Warping</p><p>21.7 Precise Contact Modeling</p><p>21.8 The BlobTree</p><p>21.9 Interactive Implicit Modeling Systems</p><h1 id="computer-graphics-in-games">22 Computer Graphics in Games</h1><p>22.1 Platforms</p><p>22.2 Limited Resources</p><p>22.3 Optimization Techniques</p><p>22.4 Game Types</p><p>22.5 The Game Production Process</p><h1 id="visualization">23 Visualization</h1><p>23.1 Background</p><p>23.2 Data Types</p><p>23.3 Human-Centered Design Process</p><p>23.4 Visual Encoding Principles</p><p>23.5 Interaction Principles</p><p>23.6 Composite and Adjacent Views</p><p>23.7 Data Reduction</p><p>23.8 Examples</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES笔记</title>
      <link href="//posts/Notebook/GAMES-note/"/>
      <url>//posts/Notebook/GAMES-note/</url>
      
        <content type="html"><![CDATA[<p>GAMES系列网络课程简要学习笔记</p><span id="more"></span><p class="note note-primary">二次整理自网络教程。</p><p><a href="https://games-cn.org/">计算机图形学与混合现实在线平台 –GAMES: Graphics And Mixed Environment Symposium</a></p><h1 id="games101-现代计算机图形学入门">GAMES101现代计算机图形学入门</h1><p>闫令琪老师</p><p><ahref="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101</a></p><p>参考书：Fundamentals of Computer Graphics 第四版</p><h2 id="overview-of-computer-graphics">01 Overview of ComputerGraphics</h2><p>What is Computer Graphics?</p><ul><li>The use of computers to synthesize and manipulate visualinformation</li></ul><p>Why study Computer Graphics?</p><ul><li>Applications</li><li>Fundamental Intellectual Challenges</li><li>Technical Challenges</li></ul><p>Course Topics</p><ul><li>Rasterization</li><li>Curves and Meshed</li><li>Ray Tracing</li><li>Animation / Simulation</li></ul><p>GAMES101不教API和工具。</p><p>CV和CG是互逆的一对。</p><p>要求：Do not publish your code (on Github, etc.) for assignmentsusing our skeleton code.</p><h2 id="review-of-linear-algebra">02 Review of Linear Algebra</h2><p>Graphics' Dependencies</p><ul><li>Basic mathematics<ul><li>Linear algebra, calculus, statisics</li></ul></li><li>Basic physics<ul><li>Optics, Mechanics</li></ul></li><li>Misc<ul><li>Signal processing</li><li>Numerical analysis</li></ul></li><li>And a bit of aesthetics</li></ul><p>这节课主要复习基础线代，不再赘述。</p><h2 id="transformation">03 Transformation</h2><ul><li>Why study transformation<ul><li>Modeling</li><li>Viewing</li></ul></li></ul><h3 id="d-transformation">2D transformation</h3><p>Scale Matrix: <span class="math display">\[\begin{pmatrix}x^{&#39;}  \\y^{&#39;}\end{pmatrix}=\begin{pmatrix}s_{x} &amp; 0\\0 &amp; s_{y}\end{pmatrix}\cdot\begin{pmatrix}x  \\y\end{pmatrix}\]</span> Reflection Matrix: (with respect to the Y-axis) <spanclass="math display">\[\begin{pmatrix}x^{&#39;}  \\y^{&#39;}\end{pmatrix}=\begin{pmatrix}-1 &amp; 0\\0 &amp; 1\end{pmatrix}\cdot\begin{pmatrix}x  \\y\end{pmatrix}\]</span> Shear Matrix: (just like shear a square to a rhombus) <spanclass="math display">\[\begin{pmatrix}x^{&#39;}  \\y^{&#39;}\end{pmatrix}=\begin{pmatrix}1 &amp; a\\0 &amp; 1\end{pmatrix}\cdot\begin{pmatrix}x  \\y\end{pmatrix}\]</span> Rotation Matrix: (about the origin(0,0), CCW by default) <spanclass="math display">\[\begin{pmatrix}x^{&#39;}  \\y^{&#39;}\end{pmatrix}=\begin{pmatrix}cos\theta  &amp; -sin\theta\\sin\theta &amp; cos\theta\end{pmatrix}\cdot\begin{pmatrix}x  \\y\end{pmatrix}\]</span>用顶点在原点的正方形在坐标轴上的另外两个顶点转一下就推导出来了。</p><h3 id="homogeneous-coordinates">Homogeneous coordinates</h3><p>From (affine map = linear map + translation) <spanclass="math display">\[\begin{pmatrix}x^{&#39;}  \\y^{&#39;}\end{pmatrix}=\begin{pmatrix}a &amp; b\\c &amp; d\end{pmatrix}\cdot\begin{pmatrix}x  \\y\end{pmatrix}+\begin{pmatrix}t_{x}  \\t_{y}\end{pmatrix}\]</span> to (using homogenous coordinates) <spanclass="math display">\[\begin{pmatrix}x^{&#39;}  \\y^{&#39;}  \\1\end{pmatrix}=\begin{pmatrix}a &amp; b &amp; t_{x} \\c &amp; d &amp; t_{y} \\0 &amp; 0 &amp; 1\end{pmatrix}\cdot\begin{pmatrix}x  \\y  \\1\end{pmatrix}\]</span></p><p>2D Point = <span class="math inline">\((x, y, 1)^T\)</span></p><p>2D vector = <span class="math inline">\((x, y, 0)^T\)</span></p><ul><li>vector + vector = vector</li><li>point - point = vector</li><li>point + vector = point</li><li><strong>point + point = midpoint</strong></li></ul><p><span class="math display">\[\begin{pmatrix}x  \\y  \\w\end{pmatrix}is\ the\ 2D\ Point\begin{pmatrix}x/w  \\y/w  \\1\end{pmatrix},\ w\ \ne\ 0\]</span></p><p>How to rotate around a given point c?</p><ol type="1"><li>Translate center to origin</li><li>Rotate</li><li>Translate back</li></ol><p>矩阵乘法没有交换律但是有结合律。</p><h2 id="transformation-cont.">04 Transformation Cont.</h2><h3 id="d-transformation-1">3D transformation</h3><p><span class="math display">\[R_{x}(\alpha)=\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; cos\alpha  &amp; -sin\alpha  &amp; 0\\0 &amp; sin\alpha  &amp; cos\alpha  &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\\R_{y}(\alpha)=\begin{pmatrix}cos\alpha &amp; 0 &amp; sin\alpha &amp; 0\\0 &amp; 1  &amp; 0  &amp; 0\\-sin\alpha &amp; 0  &amp; cos\alpha  &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\\R_{z}(\alpha)=\begin{pmatrix}cos\alpha &amp; -sin\alpha &amp; 0 &amp; 0\\sin\alpha &amp; cos\alpha  &amp; 0 &amp; 0\\0 &amp; 0  &amp; 0  &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p><p>按叉乘，<span class="math inline">\(y\times z=x\)</span>，<spanclass="math inline">\(z\times x=y\)</span>，<spanclass="math inline">\(x\timesy=z\)</span>，<strong>循环对称</strong>，所以y的旋转矩阵看上去和另外两个是相反的。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-04-11-Euler.jpg"alt="Euler angles" /> <span class="math display">\[R_{xyz}(\alpha,\beta,\gamma)=R_x(\alpha)R_y(\beta)R_z(\gamma)\]</span> Rodrigues's Rotation Formula</p><p>Rotation by angle <span class="math inline">\(\alpha\)</span> aroundaxis <span class="math inline">\(n\)</span> <spanclass="math display">\[R(n,\alpha)=cos(\alpha)I+(1-cos(\alpha))nn^T+sin(\alpha)\begin{pmatrix}0 &amp; -n_z &amp; n_y \\n_z &amp; 0 &amp; -n_x \\-n_y &amp; n_x &amp; 0\end{pmatrix}\]</span></p><h3 id="viewing-transformation">Viewing transformation</h3><h4 id="view-camera-transformation">View / Camera transformation</h4><p>camera</p><ul><li>Position <span class="math inline">\(\vec{e}\)</span> (origin)</li><li>Look-at direction <span class="math inline">\(\hat{g}\)</span> (Zaxis)</li><li>Up direction <span class="math inline">\(\hat{t}\)</span> (Yaxis)</li></ul><p><span class="math display">\[M_{view}=R_{view}T_{view}=\begin{bmatrix}x_{\hat{g}\times\hat{t} }  &amp; y_{\hat{g}\times\hat{t} }  &amp;z_{\hat{g}\times\hat{t} }  &amp; 0 \\x_{t}  &amp; y_{t}  &amp; z_{t}  &amp; 0 \\x_{-g}  &amp; y_{-g}  &amp; z_{-g}  &amp; 0 \\0  &amp; 0  &amp; 0  &amp; 1\end{bmatrix}\begin{bmatrix}1  &amp; 0  &amp; 0  &amp; -x_e \\0  &amp; 1  &amp; 0  &amp; -y_e \\0  &amp; 0  &amp; 1  &amp; -z_e \\0  &amp; 0  &amp; 0  &amp; 1\end{bmatrix}\]</span></p><h4 id="projection-transformation">Projection transformation</h4><p>Orthographic projection</p><p>投影空间为cuboid，六个面延长之后分别与x轴交于l、r，与y轴交于t、b，与z轴交于n、f。<span class="math display">\[M_{ortho}=\begin{bmatrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2}\\0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2}\\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span> Perspective projection</p><p>投影空间为frustum，先挤压为cuboid，再Orthographic projection。 <spanclass="math display">\[M_{squish}=\begin{bmatrix}n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0\end{bmatrix}\]</span> <span class="math display">\[M_{persp} = M_{ortho}M_{squish}=\begin{bmatrix}\frac{2n}{r-l} &amp; 0 &amp; \frac{l+r}{l-r} &amp; 0 \\0 &amp; \frac{2n}{t-b} &amp; \frac{b+t}{b-t} &amp; 0 \\0 &amp; 0 &amp; \frac{n+f}{n-f} &amp; \frac{2nf}{f-n} \\0 &amp; 0 &amp; 1 &amp; 0\end{bmatrix} \\\]</span>透视投影得到的点在齐次坐标系（称为在裁剪空间内），需要使用<strong>透视除法</strong>将该点从齐次坐标系转换到笛卡尔坐标系（称为在NDC（标准设备坐标）内）。透视除法将顶点四个分量都除以w。</p><h2 id="rasterization-1-triangles">05 Rasterization 1 (Triangles)</h2><p>FOV（field of view）视场角计算方法：</p><p>水平FOV=2artan(胶片宽/2/镜头焦距）</p><p>垂直FOV=2artan(胶片高/2/镜头焦距）</p><p>MVP（Model、View、Projection）转换后在屏幕上光栅化成像。</p><p>屏幕空间即像素矩阵，每个像素看作一个小方块。</p><p>Viewport transform matrix: <span class="math display">\[M_{viewport}=\begin{pmatrix}\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2}\\0 &amp; \frac{height}{2}  &amp; 0 &amp; \frac{height}{2}\\0 &amp; 0  &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]</span> 与z不相关，在xy平面做变换：<spanclass="math inline">\([-1,1]^2\)</span>到<spanclass="math inline">\([0,width]\times[0,height]\)</span>。</p><p><strong>光栅化设备</strong>部分参见虎书3.1笔记。</p><p>实际设备上每个像素由RGB三种感光元件组成。</p><p>光栅化方法：遍历像素，判断像素中心点是否在三角形内（叉积判断法）。可以用AABB（axisaligned bounding box）加速。</p><p>❓三角形公共边上的点属于哪个三角形：OpenGL和DirectX规定，如果有点落在三角形的上边和左边的话，认为这个点在三角形内，落在右边和下边，认为在三角形外。没有看懂。</p><h2 id="rasterization-2-antialiasing-and-z-buffering">06 Rasterization 2(Antialiasing and Z-Buffering)</h2><p>Sampling Artifacts的类型：</p><ul><li>Jaggies - sampling in space</li><li>Moire - undersampling images</li><li>Wagon wheel effect - sampling in time</li></ul><p>讲了傅里叶变换和滤波（数字图像处理的知识）。</p><p>Antialiasing方法：</p><ul><li>先Blurring再Sample，MSAA（Multisampling）。像素划分为更小的子像素后，像素颜色＝三角形颜色X三角形覆盖子像素数／总子像素数。</li><li>FXAA（Fast Approximate）。图像后处理，找到边界并处理。</li><li>TAA (Temporal)。复用上一帧的结果，相当于将MSAA对应的样本分布在时间上。</li></ul><p>超分和AA本质相似，因为超分也是在提高采样率。DLSS（Deep Learning SuperSampling）让AI来猜缺失的细节。</p><h2 id="shading-1-illumination-shading-and-graphics-pipeline">07 Shading1 (illumination, Shading and Graphics Pipeline)</h2><p>先讲上一节的<strong>Z-Buffer</strong>。</p><p>对每个像素存深度值z（正数），z越小越近（深度图中表现为越黑），z越大越远（深度图中表现为越白）。</p><p>每一帧对应一张深度图，深度值初始为无限大，遍历三角形更新深度图。复杂度为O(n)，n为三角形数量。由GPU硬件实现。</p><p>Shading</p><p>字典定义：The darkening or coloring of an ilustration or diagram withparallel lines or a block of color.</p><p>本课程定义：The process of applying a material to an object.</p><p>Shading部分讲了<strong>Blinn-Phong ReflectanceModel</strong>，参见虎书笔记5.2、5.3。</p><h2 id="shading-2-shading-pipeline-and-texture-mapping">08 Shading 2(Shading, Pipeline and Texture Mapping)</h2><p>Flat shading 每个面计算一次着色，一个三角形上所有点颜色相同。</p><p>Gouraud shading每个顶点计算一次着色，三角形内部点颜色由顶点颜色插值得到。</p><p>Phong shading每个像素计算一次着色，三角形内部点法线由顶点法线插值得到。</p><p>顶点法线由相邻面的法线求加权平均得到（权重为三角形面积）。</p><p>三角形插值时使用<strong>重心坐标</strong>。<imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-11-25-graphics-pipeline.png" /></p><p>图形管线详细参见DX12龙书笔记第五章笔记。</p><p>shadertoy：在线着色器编写与渲染网站。</p><p>纹理映射即将二维表面蒙在三维物体表面。</p><p>Wang tile：一种生成可密铺纹理的算法。</p><h2 id="shading-3-texture-mapping-cont.">09 Shading 3 (Texture MappingCont.)</h2><p>A、B、C为三角形顶点坐标，对三角形所在平面上任意一点<spanclass="math inline">\((x,y)\)</span>，<strong>重心坐标</strong><spanclass="math inline">\(\alpha、\beta、\gamma\)</span>代表： <spanclass="math display">\[(x,y)=\alpha A+\beta B+\gamma C \\\alpha+\beta+\gamma=1\]</span> 重心坐标可由面积求得。例如，对于点P，<spanclass="math inline">\(\alpha=\frac{S_{PBC}}{S_{ABC}}\)</span>。</p><p>透视投影是非线性的，因此透视投影或需要对重心坐标进行矫正。应从屏幕空间逆变换回三维空间，再用重心坐标插值。</p><p>纹理&lt;平面，纹理放大：</p><ul><li>Nearest</li><li>Bilinear</li><li>Bicubic</li></ul><p>纹理&gt;平面，缩小导致摩尔纹，可以通过超采样解决（增大平面上每个点在纹理上的采样数，与MSAA类似）。工程中用<strong>mipmap</strong>预存范围查询的平均结果进行加速。</p><p>普通的mipmap范围查询区域为正方形，而实际区域并不规则，导致过模糊。用AnisotropicFiltering可以解决：</p><ul><li>Ripmaps and summed area tables</li><li>EWA filtering</li></ul><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-11-25-irregular-pixel-footprint.png" /></p><h2 id="geometry-1-induction">10 Geometry 1 (Induction)</h2><p>先讲上一节的纹理应用。</p><p>环境贴图：</p><ul><li>Spherical Environment Map</li><li>Cube Map</li></ul><p>Bump/Normal mapping改变法线，不改变几何。</p><p>Displacementmapping改变几何。相比Bump/Normal边缘也可以看出变化，并且会产生自阴影。Displacement需要三角形网格足够细，DirectX的dynamictessellation可以动态决定。</p><p>纹理可以定义3D Procedural Noise用于地形建模。</p><p>预计算AO纹理。</p><p>3D纹理和体渲染。</p><p><strong>几何表示方法</strong></p><p>Implicit：</p><ul><li>algebraic surface</li><li>level sets</li><li>distance functions</li><li>Constructive Solid Geometry</li><li>Fractals（分形）</li></ul><p>Explicit：</p><ul><li>point cloud</li><li>polygon mesh</li><li>subdivision, NURBS</li></ul><h2 id="geometry-2-curves-and-surfaces">11 Geometry 2 (Curves andSurfaces)</h2><p>介绍了The Wavefront Object File (.obj) 的格式。</p><p><strong>Curves</strong></p><ul><li>Bezier curves<ul><li>De Casteljau’s algorithm 绘制</li><li>quadratic Bezier 三控制点</li><li>Cubic Bézier Curve 四控制点</li></ul></li><li>B-splines<ul><li>贝塞尔曲线的扩展，具有局部性</li></ul></li></ul><p><strong>Surfaces</strong></p><ul><li>Bezier surfaces</li><li>Triangles &amp; quads (subdivision, simplification, regularization)<ul><li>regularization指让三角形网格都接近正三角形。</li></ul></li></ul><h2 id="geometry-3">12 Geometry 3</h2><p><strong>Subdivision</strong></p><ol type="1"><li>拆分三角形</li><li>调整顶点位置</li></ol><p>Loop Subdivision（Loop是作者姓氏，无循环义）（仅适用三角形网格）</p><p>Catmull-Clark Subdivision（适用有四边形也有三角形的网格）</p><p><strong>Simplification</strong></p><p>edge collapsing，最小化Quadric ErrorMetrics（新的点到原本几个面的距离平方和达到最小）。</p><p><strong>Shadow Mapping</strong></p><p>An Image-spaceAlgorithm，不知道场景几何信息，需要处理走样。只能做硬阴影，有数值精度问题。</p><ol type="1"><li>在光源处用虚拟摄像机光栅化，对每一点得到深度a</li><li>在摄像机处光栅化，成像的点投影回光源处，得到深度b</li><li>摄像机光栅化得到的图像上a和b不同的点则有阴影</li></ol><p><strong>软阴影</strong>有过渡。物理上所称的半影（Penumbra）：</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-11-25-penumbra.png" /></p><p>软阴影的产生是因为光源有一定的大小，点光源无法产生软阴影。</p><h2 id="ray-tracing-1-whitted-style-ray-tracing">13 Ray Tracing 1(Whitted-Style Ray Tracing)</h2><p>光栅化的缺点：不能很好的处理全局效果（Soft shadows、Glossyreflection、Indirect illumination）。</p><p>光线追踪准确而且质量高，但是慢。</p><p><strong>Basic Ray-Tracing Algorithm</strong></p><p>从相机出发向世界中投射光线（RayCasting），判断是否对光源可见。（光路可逆）</p><p><strong>Whitted-Style Ray Tracing</strong></p><p>投射光线后多次弹射（反射或折射），像素值为多个弹射点的着色值之和。</p><ul><li>primary ray：投射的第一根光线</li><li>secondary rays：一次弹射之后的光线</li><li>shadow rays：和光源相连判断可见性的光线</li></ul><p>关键问题：Ray-Surface Intersection</p><h2 id="ray-tracing-2-acceleration-radiometry">14 Ray Tracing 2(Acceleration &amp; Radiometry)</h2><p>AABB：划分为均匀格子，需要考虑划分密度。（Heuristics：常数27乘以3D场景中物体的数量）</p><p>Oct-Tree：每次均八分，直到格子里为空或物体足够少。</p><p>KD-Tree：每次二分（不均分，但轴对齐）。</p><p>BSP-Tree： 每次二分（不均分，且不轴对齐）。</p><p>BVH（Bounding Volume Hierarchy ）：按物体划分。</p><p>BVH优点：</p><ol type="1"><li>一个几何只出现在一个叶子节点里</li><li>不用求几何和包围盒的交</li></ol><p><strong>辐射度量学（Radiometry）</strong></p><p>辐射能（radiant energy）<span class="math inline">\(Q\)</span>：<spanclass="math inline">\(J\)</span>。</p><p>辐射通量（radiant flux）<spanclass="math inline">\(\Phi\)</span>：<spanclass="math inline">\(W\)</span>（即<spanclass="math inline">\(J/s\)</span>）或<spanclass="math inline">\(lm\)</span>。</p><p>辐射强度（radiant Intensity）<spanclass="math inline">\(I\)</span>：<spanclass="math inline">\(W/sr\)</span>或<spanclass="math inline">\(cd\)</span>。<spanclass="math inline">\(cd\)</span>是七个SI单位之一。</p><p>辐照度（irradiance）<span class="math inline">\(E\)</span>：<spanclass="math inline">\(W/m^2\)</span>或<spanclass="math inline">\(lux\)</span></p><p>辐射率（radiance）<span class="math inline">\(L\)</span>：<spanclass="math inline">\(W/(m^2\cdot sr)\)</span>或<spanclass="math inline">\(nit\)</span></p><p>BRDF值<span class="math inline">\(f\)</span>：<spanclass="math inline">\(sr^{-1}\)</span> （<spanclass="math inline">\(L/E\)</span>）</p><h2 id="ray-tracing-3-light-transport-global-llumination">15 Ray Tracing3 (Light Transport &amp; Global llumination)</h2><p><strong>渲染方程</strong>（反射方程+自发光项）： <spanclass="math display">\[L_r(x,w_r)=L_e(x,w_r)+\int_{\Omega}L_i(x,w_i)f(x,w_i,w_r)\cos\theta_id\omega_i\]</span></p><p>reflected light = emission + integral of Incident light * BRDF *cosine of incident angle</p><p>简化： <span class="math display">\[L=E+KL \\L=(1-K)^{-1}E \\\]</span> 泰勒展开： <span class="math display">\[L=(1+K+K^2+K^3+...)E\]</span> 幂指数即弹射次数。</p><p>回顾了一下概率论。</p><h2 id="ray-tracing-4-monte-carlo-path-tracing">16 Ray Tracing 4 (MonteCarlo Path Tracing)</h2><p>介绍了蒙特卡洛积分。</p><p>Whitted-Style Ray Tracing缺陷：</p><ul><li>对于镜面反射正确，对于glossy反射错误（没有考虑粗糙度）。</li><li>在漫反射表面就停止了，不继续弹射，没有Color bleeding。</li></ul><p>用蒙特卡洛积分解渲染方程： <span class="math display">\[\int_{\Omega}L_i(x,w_i)f(x,w_i,w_r)\cos\theta_id\omega_i\approx\frac{1}{N}\sum_{i=1}^{N}\frac{L_i(x,w_i)f(x,w_i,w_r)\cos\theta_i}{p(w_i)}\]</span> <spanclass="math inline">\(p(w_i)\)</span>即PDF，若对半球均匀采样，<spanclass="math inline">\(p(w_i)=\frac{1}{2\pi}\)</span>。</p><p>取N=1，并随机停止追踪，避免计算量爆炸。</p><p>SPP（samples per pixel）：一个像素打出多少光线。</p><p>若光源小，SPP过低会出现大量噪点，打不到光源。在光源上采样PDF可以避免浪费光线：<span class="math display">\[dw=\frac{dAcos\theta&#39;}{\left \|x^{&#39;}-x\right \|^2}\]</span> <span class="math inline">\(A\)</span>是光源面积，<spanclass="math inline">\(x^{&#39;}\)</span>是光源位置，<spanclass="math inline">\(x\)</span>是着色点位置，<spanclass="math inline">\(\theta&#39;\)</span>是着色点与光源连线与光源法线的夹角。</p><p>Modern Concepts：</p><ul><li>(unidirectional &amp; bidirectional) path tracing</li><li>Photon mapping</li><li>Metropolis light transport</li><li>VCM/UPS (vertex connection merging/unified path sampling)</li><li>UPBP (unifying points, beams, and paths in volumetric lighttransport simulation)</li></ul><h2 id="materials-and-appearances">17 Materials and Appearances</h2><p>Material==BRDF</p><p><strong>Diffuse / Lambertian Material</strong>（BRDF）</p><p><spanclass="math inline">\(\rho\)</span>为albedo，对于理想漫发射，BRDF值<spanclass="math inline">\(f_r=\frac{\rho}{\pi}\)</span>，是因为能量守恒的要求：<span class="math display">\[\begin{align} &amp;\int_{\Omega} f_r \cos\theta_i \, \mathrm{d}\omega_i\\=&amp; f_r \int_{\Omega} \cos\theta_i \, \mathrm{d}\omega_i \\=&amp; f_r \int_{0}^{2\pi} \int_{0}^{\frac{\pi}{2}} \cos\theta\sin\theta\mathrm{d}\theta\mathrm{d}\phi \\=&amp; f_r \cdot \int_{0}^{2\pi} \mathrm{d}\phi \cdot\int_{0}^{\frac{\pi}{2}} \cos\theta \sin\theta\mathrm{d}\theta \\=&amp; f_r \times 2\pi \times \frac{1}{2} \\=&amp; f_r \times \pi \\\end{align} \\\]</span> <strong>Glossy material</strong>（BRDF）</p><p>Blinn–Phong model：</p><p><span class="math display">\[f_r=k_smax(0,n\cdot h)^p\]</span> <strong>Ideal reflective / refractive material</strong>(BSDF)</p><p>Caustics（焦散：不准确的翻译，因为成因是聚焦，和散射没关系）：海水表面凹凸不平，光线向不同方向折射，在海底聚焦。</p><p><strong>Snell’s Law</strong> <span class="math display">\[\eta_isin\theta_i=\eta_tsin\theta_t\]</span> index of refraction (IOR) for incident ray <spanclass="math inline">\(\eta_i\)</span></p><p>index of refraction (IOR) for exiting ray <spanclass="math inline">\(\eta_t\)</span></p><p><span class="math inline">\(\eta_i&gt;\eta_t\)</span>时没有折射。</p><p>Snell’sWindow：从水下看上去，180度的视角被压成97.2度的光锥。由光线进入水中的大角度折射引起的。</p><p><strong>Fresnel Reflection /Term</strong>：表示反射折射之比，Schlick’s approximation： <spanclass="math display">\[R_0=(\frac{n1-n2}{n1+n2})^2\]</span> <span class="math display">\[R(\theta)=R_0+(1-R_0)(1-cos\theta)^5\]</span> <strong>Torrance-Sparrow microfacet model</strong></p><p><span class="math display">\[f_r=\frac{F(l,h)G(l,v,h)D(h)}{4(n\cdot l)(n\cdot v)}\]</span> F是Fresnel Term。</p><p>G是Shadowing Masking，如果没有G，球的边界（grazingangle）会非常亮。</p><p>D是Distribution ofNormals，计算有多少微面元的法线m满足m=h（入射出射半向量）。</p><p><strong>Properties of BRDFs</strong></p><ul><li>Non-negativity</li><li>Linearity（拆分之后计算再相加，例如diffuse、specular、ambient）</li><li>Reciprocity principle</li><li>Energy conservation</li><li>Isotropic / Anisotropic（Isotropic BRDF少一个自由度，为3维）</li></ul><p><strong>Measuring BRDFs</strong></p><p>MERL BRDF Database</p><h2 id="advanced-topics-in-rendering">18 Advanced Topics inRendering</h2><h3 id="advanced-light-transport">Advanced Light Transport</h3><h4 id="unbiased-light-transport-methods">Unbiased light transportmethods</h4><p><strong>Bidirectional path tracing</strong> (BDPT)</p><p>从光源和相机都出发，生成半路径（lightsub-paths），连接成完整路径。</p><p>当光线传播在光源这半边比较容易算的时候（直接照亮场景中一小块区域，其它区域都是间接光照亮），BDPT的效果会更好，但速度相对慢。不能处理SDS。</p><blockquote><p>Caustics的路径SDS（specular-diffuse-specular）。</p></blockquote><p><strong>Metropolis light transport</strong> (MLT)</p><p>因为采样的PDF和要积分的函数形状一致时方差最小。使用MarkovChain的蒙特卡洛方法。</p><p>适合Caustics。积分复杂，难以理论上分析渲染速度。具有局部性，有些像素收敛快，有些像素收敛慢，图像看上去脏，并且每一帧间有抖动，不适合做动画。</p><h4 id="biased-light-transport-methods">Biased light transportmethods</h4><p><strong>Photon mapping</strong></p><ol type="1"><li>从光源出发发射光子，在diffuse表面停止。</li><li>从相机出发发射路径，在diffuse表面停止。</li><li>局部密度估计。对一个着色点，取周围最近的N个光子，用光子的数量N除以它们占的面积A。有偏是因为<spanclass="math inline">\(dN/dA!=\Delta N/\DeltaA\)</span>。虽然有偏（biased）但一致（consistent），指样本数量接近无限时期望收敛到正确结果。</li></ol><p><strong>Vertex connection and merging</strong> (VCM)</p><p>BDPT和Photonmapping的结合。前者不能处理SDS，后者处理diffuse不如前者，互补。</p><h4 id="instant-radiosity">Instant radiosity</h4><p>(IR) (many light methods)</p><p>Unbiased.</p><p>已经被照亮的地方都可以认为它们是光源，Virtual Point Light(VPL)。看到着色点后用所有VPL照亮。</p><p>窄的缝隙产生错误的发光，因为光源与着色点过近。不能做glossy。</p><h3 id="advanced-appearance-modeling">Advanced Appearance Modeling</h3><h4 id="non-surface-models">Non-surface models</h4><p><strong>Participating media</strong></p><p>散射介质，如云、雾。</p><p><strong>Hair / fur / fiber</strong></p><p>头发表面有两种高光，一种无色发白，一种有色。按照MarschnerModel，Reflection记作R、Transmission记作T，有R、TT、TRT三种光线。（BCSDF）</p><p>毛发有cuticle（表皮）、cortex（皮层）、Medulla（髓质）三层结构，，动物毛发结构和人的头发髓质大小不同。</p><p><strong>Granular material</strong></p><p>颗粒状，如盐、糖等。</p><h4 id="surface-models">Surface models</h4><p><strong>Translucent material (BSSRDF)</strong></p><p>translucent不应翻译为半透明（semitransparent）。</p><p>semitransparent：沿着一个方向传播并被吸收。</p><p>translucent：光线从一个面进入，从另一个面离开，可以被导到其它方向去。</p><p><strong>Cloth</strong></p><p>fiber缠绕成ply（股），ply缠绕成yarn（线），线编织成布。</p><ol type="1"><li>当成participating media渲染</li><li>渲染每一根fiber</li></ol><p><strong>Detailed material (non-statistical BRDF)</strong></p><p>若使用分辨率极高的法线贴图，渲染十分困难。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-11-26-high-resolution-normal-map.png" /></p><p>考虑一个像素会覆盖很多的微表面，将微表面的分布拿出来（在一个小范围内的微表面的法线分布NDF算出来），替代原本光滑的分布，用在微表面模型里。</p><p>引入波动光学：衍射和干涉现象。</p><h4 id="procedural-appearance">Procedural appearance</h4><p>不使用纹理，使用噪声函数，随用随取。</p><h2 id="cameras-lenses-and-light-fields">19 Cameras, Lenses and LightFields</h2><p>Imaging = Synthesis + Capture</p><h3 id="camera">Camera</h3><p>Sensor记录的是irradiance。</p><p>针孔相机拍不出景深。透镜相机才可以。光追用的针孔相机。</p><p>05节笔记记载了FOV的计算方法。人们通常以35mm格式的胶片（film）为基准，固定传感器的大小，再通过定义焦距的方式来定义FOV。比如，17mm焦距对应广角104度。手机的胶片小很多，显示的是等效焦距（若胶片为基准胶片）。</p><p>影响Exposure（曝光）：</p><ul><li>Aperture size 光圈的大小</li><li>Shutter speed 快门速度</li><li>ISO gain ISO 增益/感光度</li></ul><h3 id="lens">Lens</h3><p>现代成像使用透镜组。</p><p>Ideal Thin Lens：</p><ol type="1"><li>All parallel rays entering a lens pass through its focal point.</li><li>All rays through a focal point will be in parallel after passing thelens.</li><li>Focal length can be arbitrarily changed.</li></ol><p>The Thin Lens Equation： <span class="math display">\[\frac{1}{f}=\frac{1}{z_i}+\frac{1}{z_o}\]</span> 物距<span class="math inline">\(z_o\)</span>，像距<spanclass="math inline">\(z_i\)</span>，焦距<spanclass="math inline">\(f\)</span>。</p><p><strong>Defocus Blur</strong></p><p>可解释景深。</p><p>一个点穿过透镜后，若像距对应成像平面远离真实的成像平面，会形成Circleof Confusion (CoC)。</p><p>F数（F-Stop）<spanclass="math inline">\(N=f/D\)</span>，焦距/光圈直径。CoC大小和F数成反比。</p><p>光圈通过挡透镜动态改透镜的大小。</p><p><strong>Depth of Field</strong></p><p>景深。CoC很小的一段范围内对应的场景的一段是清晰的。</p><h2 id="color-and-perception">20 Color and Perception</h2><h3 id="light-field-lumigraph">Light Field / Lumigraph</h3><blockquote><p>SIGGRAPH 2012 course on light fields</p></blockquote><p><strong>The Plenoptic Function</strong> <span class="math display">\[P(\theta,\phi,\lambda,t,V_x,V_y,V_z)\]</span>光场是全光函数的一小部分，描述任何一个位置的一个方向的光强。</p><p>光场是四维函数，使用二维位置（<spanclass="math inline">\(uv\)</span>）和二维方向（<spanclass="math inline">\(\theta\phi\)</span>）。</p><p>光照相机每个像素对应一个微透镜，拍摄的照片实际上记录了光场，可以重新聚焦得到普通相机照的照片。</p><h3 id="color">Color</h3><p><strong>光谱</strong>：谱功率密度（SPD，Spectral PowerDistribution），不同的波长的强度，<spanclass="math inline">\(W/nm\)</span>。SPD满足加法定律。</p><p>颜色是human perception。</p><p>讲了人眼的结构。视网膜上的Rods（视杆细胞）感知光强，Cones（视锥细胞）感知颜色。Cones分为S、M、L三种，分别感知短波长、中间波长、长波长。</p><p><strong>同色异谱</strong>（Metamerism）：光谱不同看到的颜色相同。显示器利用此原理。</p><p><strong>Color Reproduction / Matching</strong></p><p>红黄蓝三原色<strong>减色混合</strong>得到其它的颜色。显示器使用红绿蓝的<strong>加色混合</strong>。</p><p>讲了sRGB、CIE XYZ、HSV、CIE LAB颜色空间。</p><p>印刷中使用<strong>CMYK</strong>（Cyan青、Magenta品红、Yellow黄、Key黑）减色系统。使用黑色是因为成本低。</p><h2 id="animation">21 Animation</h2><p>讲了动画的历史。</p><p>Keyframe Animation</p><p>Physical Simulation</p><ul><li>Newton’s Law</li><li>Mass Spring System</li><li>Particle Systems</li><li>Simulated Flocking as an ODE</li></ul><p>Kinematics</p><ul><li>Forward Kinematics</li><li>Inverse Kinematics</li></ul><p>Rigging</p><blockquote><p>对物体或角色的不同地方加一些控制点</p></blockquote><h2 id="animation-cont.">22 Animation Cont.</h2><p>Single particle simulation</p><ul><li>Explicit Euler method</li><li>Instability and improvements</li></ul><p>Rigid body simulation</p><p>Fluid simulation</p><ul><li>A Simple Position-Based Method</li><li>Eulerian vs. Lagrangian</li><li>Material Point Method</li></ul><h1 id="games104-现代游戏引擎入门必修课">GAMES104现代游戏引擎入门必修课</h1><p>王希老师</p><p><a href="https://games104.boomingtech.com/sc/">GAMES104</a></p><p><a href="https://github.com/BoomingTech/Piccolo">BoomingTech/Piccolo:Piccolo (formerly Pilot) – mini game engine for games104</a></p><h1 id="games202-高质量实时渲染">GAMES202 高质量实时渲染</h1><p>闫令琪老师</p><p><ahref="https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html">GAMES202</a></p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《故事的解剖》笔记</title>
      <link href="//posts/Notebook/STORY-note/"/>
      <url>//posts/Notebook/STORY-note/</url>
      
        <content type="html"><![CDATA[<p>STORY: Substance, Structure, Style and The Principles ofScreenwriting</p><span id="more"></span><p>Robert McKee 著</p><p>戴洛棻 黃政淵 蕭少嵫 译</p><p class="note note-primary">精炼整理。</p><p>这本书提到的电影集中于上个世纪且以西方电影为主，我基本没看过。</p><h1 id="第一部-作者与说故事的技艺">第一部 作者与说故事的技艺</h1><h2 id="引言-掌握内容与形式打造动人故事">引言掌握内容与形式，打造动人故事</h2><p>原型故事：发掘普世皆同的人生经验，并以某种特定文化的独特表现方式包装。</p><p>刻板而老套的故事：内容局限于某种文化当中的偏狭经验，包装形式陈腐、平凡且毫无特色。</p><p>原创是<strong>内容</strong>与<strong>形式</strong>的融合——独特的选题，搭配独特的说故事方式。内容指场景、角色、构想；形式指事件的选择与安排。</p><h2 id="故事面临的难题">01 故事面临的难题</h2><p>故事不是对现实的逃避，而是承载我们去追求现实的工具，让我们得以在混乱的生存当中努力发现真谛。</p><p>故事设计考验写作者的成熟程度、洞察能力，以及对社会、自然与人类内心的了解。</p><p>故事是生活的隐喻。</p><p>拥有感知与想象的能力并找到平衡。</p><h1 id="第二部-故事的要素">第二部 故事的要素</h1><h2 id="结构的光谱">02 结构的光谱</h2><p>大师之所以是大师，就是只选择某些片刻，却足以呈现角色的一生。</p><p>结构：从角色的人生故事当中选取某些事件，编写成有意义的场景段落，引发观众特定情绪，同时呈现某种特定的人生观点。</p><p>事件：故事事件为角色的人生处境带来有意义的改变。这样的改变是透过价值取向来加以呈现和体验的，并且透过冲突加以实现。</p><p><strong>架构</strong>：戏剧节拍 -&gt; 场景 -&gt; 场景段落 -&gt; 幕-&gt;故事</p><p>剧情：对各种事件的选择，以及对事件排列时序的规划。</p><p>故事三角：</p><ul><li>经典设计/原型剧情。因果关系，封闭式结局，线性时间，外在冲突，单一主角，连贯的单一真实，主动的主角。</li><li>极简主义/极简剧情。开放式结局，内在冲突，多重主角，被动的主角。</li><li>反结构/反剧情。巧合，非线性时间，不连续的复数真实。</li></ul><h2 id="结构与设定">03 结构与设定</h2><p><strong>故事设定四个面向</strong>：时代、持续时间、地点、冲突的层面。</p><p>故事必须遵循自己内在可能的规则。因此，作者对事件的选择，仅局限于他创造出来的世界内部的可能性与或然率。</p><h2 id="结构与类型">04 结构与类型</h2><p>每种类型都涉及人类重要的价值取向：爱/恨、和平/战争、正义/不公、成就/失败、善/恶等，每一种价值取向都是永恒的主题，从故事源起就启发了伟大的作品。</p><h2 id="结构与角色">05 结构与角色</h2><p>一个人在压力下作出的选择，相对也暴露了角色本色。压力越大，显露出的真相越深刻，这个选择也愈贴近角色的重要本质。</p><p>主要角色必须得有深度，换句话说，他们的内心不能与外表看起来的表相相同。</p><h2 id="结构与意义">06 结构与意义</h2><p>故事的意义必须在情感动人的故事高潮以戏剧方式呈现，而不是用解释性的对白来辅助。</p><p>让故事中面临重要考验的价值取向在正负两极之间动态移动，就能打造出剧情进展。</p><h1 id="第三部-故事设计的原则">第三部 故事设计的原则</h1><h2 id="故事的本质">07 故事的本质</h2><p>观众的情感投入是透过同理心来凝聚的。同理心绝对重要，好感却未必。</p><p>主角因为期待与结果之间的落差行动。创造场景的过程中，必须进入角色的内心，从他的观点来体验或感受。由内而外的创作。</p><p>故事的本质是落差，是一个人采取行动时期望发生和实际发生之间的落差，是期望与结果之间、可能发生与必然发生之间的分歧。</p><h2 id="触发事件">08 触发事件</h2><p><strong>故事设计组成</strong>：触发事件 -&gt; 渐进式困境 -&gt; 危机-&gt; 高潮 -&gt; 冲突解除</p><p>触发事件必须彻底颠覆主角生活中维持平衡的力量。</p><h2 id="幕的设计">09 幕的设计</h2><p>没有冲突，故事就无法往下发展。</p><p>剧情副线可制造与中心剧情主导意念之间的矛盾，藉由反讽让电影更显丰富。</p><h2 id="场景设计">10 场景设计</h2><p>场景设计的组成要素：转折点、铺陈/回馈结果、情绪动态、选择。</p><h2 id="场景分析">11 场景分析</h2><p>尽管角色可以说出和做出你想象得到的一切，但只要是人都不可能完全说出或做出绝对的真实，因为人们内心总是存在着不自觉的那一面。因此作者必需安排潜文本，只有当观众觉察到潜文本时，场景才能发挥功能。</p><h2 id="布局分场">12 布局分场</h2><p>布局分场是指为场景安排顺序并加以串联。</p><h2 id="危机高潮冲突解除">13 危机·高潮·冲突解除</h2><p>危机：危险/机会。危险指的是此时的错误决定将导致永远失去我们想要的东西；机会则是正确的选择能让我们如愿以偿。</p><h1 id="第四部-编剧实战篇">第四部 编剧实战篇</h1><h2 id="对立原则">14 对立原则</h2><p>对立原则：主角和主角的故事只有在对立力量迫使下，才能在理智面引人入胜，在感情面扣人心弦。</p><h2 id="铺叙">15 铺叙</h2><p>铺叙指关于背景、人物生平、角色塑造的咨询。铺叙的技巧在于将其化为无形，让观众随着故事的进展不知不觉知道这一切。</p><h2 id="问题与对策">16 问题与对策</h2><p>兴趣问题。如何让观众产生兴趣？</p><ul><li>推理：观众知道的比角色少。仅因好奇心产生兴趣。</li><li>悬疑：观众和角色知道同样的事。结合好奇心与关切。此时观众好奇的不是真相，而是结局。</li><li>戏剧反讽：观众知道的比角色多。一是因见到剧中角色发现我们已知的真相而不忍，二是眼睁睁看着剧中角色走向灾难而深感同情。</li></ul><p>惊奇问题。</p><ul><li>真实惊奇：期望与结果之间的误差。</li><li>低俗惊奇：强行制造惊奇，比如恐怖片常用的跳脸。</li></ul><p>巧合问题。</p><ul><li>尽早让巧合出现，给它充分的时间产生意义。</li><li>避免使用巧合逆转结局，这相当于天神解围法（机械降神）。</li></ul><p>喜剧问题</p><ul><li>在喜剧的世界里，有笑声就是老大。</li><li>喜剧的核心其实是愤怒而反社会的艺术。</li></ul><p>观点问题</p><ul><li>观点指把自己放在空间里的哪个位置来观察剧情。</li></ul><p>改编问题</p><p>通俗剧问题</p><p>漏洞问题</p><h2 id="角色">17 角色</h2><ol type="1"><li>为演员保留空间</li><li>爱上你笔下的角色</li><li>角色就是自知</li></ol><h2 id="文本">18 文本</h2><p>长话短说。</p><p>假如能用视觉的方式表现，一句对白也别写。</p><h2 id="编剧方法">19 编剧方法</h2><p>简单来说就是自上而下写。</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《概率导论（第2版）》笔记</title>
      <link href="//posts/Notebook/Introduction-to-Probability-note/"/>
      <url>//posts/Notebook/Introduction-to-Probability-note/</url>
      
        <content type="html"><![CDATA[<p>Introduction to Probability</p><span id="more"></span><p>Dimitri P. Bertsekas，John N. Tsitsiklis 著</p><p>郑忠国，童行伟 译</p><p class="note note-primary">精炼整理。</p><h1 id="第1章-样本空间与概率">第1章 样本空间与概率</h1><h2 id="集合">1.1集合</h2><p>概率论大量应用集合运算，引入集合相关的记号和术语。</p><p>集合 <span class="math inline">\(\{ x\in \Omega\mid x\notin S\}\)</span> 称为集合<span class="math inline">\(S\)</span>相对于<spanclass="math inline">\(\Omega\)</span>的补集，记作<spanclass="math inline">\(S^C\)</span>。 <spanclass="math inline">\(\Omega^C=\emptyset\)</span> 。</p><p><strong>德摩根定律</strong>：<span class="math inline">\((\bigcup_{n}S_{n} )^c=\bigcap_{n}S_{n}^c\)</span> <spanclass="math inline">\((\bigcap_{n} S_{n})^c=\bigcup_{n}S_{n}^c\)</span></p><h2 id="概率模型">1.2 概率模型</h2><p>概率模型是对不确定现象的数学描述，每个概率模型都关联一个试验。</p><p><strong>概率模型</strong>基本构成：</p><ul><li>样本空间<spanclass="math inline">\(\Omega\)</span>，这是一个试验的所有可能结果的集合。</li><li>概率律，概率律为试验结果的集合<spanclass="math inline">\(A\)</span>（称之为<strong>事件</strong>，即样本空间的子集）确定一个非负数<spanclass="math inline">\(P(A)\)</span>（称之为事件A的<strong>概率</strong>）。而这个非负数刻画了我们对事件<spanclass="math inline">\(A\)</span>的认识或所产生的信念的程度。</li></ul><p>许多实验本身具有序贯的特征，常用<strong>序贯树形图</strong>刻画样本空间中的试验结果。</p><p><strong>概率公理</strong>：</p><ol type="1"><li><p>非负性。对一切事件<spanclass="math inline">\(A\)</span>，满足<spanclass="math inline">\(P(A)\ge0\)</span>。</p></li><li><p>可加性。设<span class="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>为两个互补相交的集合（概率论中称为互不相容的事件），则它们的并满足：<spanclass="math inline">\(P(A\bigcupB)=P(A)+P(B)\)</span>。可以向一般情形推广。</p></li><li><p>归一性。整个样本空间<spanclass="math inline">\(\Omega\)</span>（称为必然事件）的概率为1，即<spanclass="math inline">\(P(\Omega)=1\)</span>。</p></li></ol><p><strong>离散概率律</strong>：</p><p>设样本空间由有限个可能的结果组成，则事件的概率可由组成这个事件的试验结果的概率所决定。<span class="math display">\[P(\{s_1,s_2,...,s_n\})=P(s_1)+P(s_2)+...+P(s_n)\]</span></p><h2 id="条件概率">1.3 条件概率</h2><p>给定<span class="math inline">\(B\)</span>发生之下事件<spanclass="math inline">\(A\)</span>的条件概率，记作<spanclass="math inline">\(P(A\mid B)\)</span>。</p><p>$P(AB)= $。</p><p><strong>乘法规则</strong>： <span class="math display">\[P( { \bigcap_{i=1}^{n}}A_i)=P(A_1)P(A_2\mid A_1)P(A_3\mid A_1\bigcapA_2)...P(A_n\mid {\bigcap^{n-1}_{i=1}}A_i)\]</span></p><h2 id="全概率定理和贝叶斯准则">1.4 全概率定理和贝叶斯准则</h2><p>设<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>是一组互不相容的事件，它形成样本空间的一个分割（每一个试验结果必使其中一个事件发生）。又假定对每一个<spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(P(A_i)&gt;0\)</span>。</p><p><strong>全概率定理</strong>：</p><p>则对于任意事件<spanclass="math inline">\(B\)</span>，下列公式成立：<spanclass="math inline">\(P(B)=P(A_1\bigcap B)+...+P(A_i\bigcapB)\)</span></p><p><strong>贝叶斯准则</strong>：</p><p>则对于任意满足<spanclass="math inline">\(P(B)&gt;0\)</span>的事件<spanclass="math inline">\(B\)</span>，下列公式成立：<spanclass="math inline">\(P(A_i\mid B)=\frac{P(A_i)P(B\midA_i)}{P(B)}\)</span></p><p>若<span class="math inline">\(P(A_i\midB)\)</span>代表新得到信息<span class="math inline">\(B\)</span>之后<spanclass="math inline">\(A_i\)</span>出现的概率，称之为<strong>后验概率</strong>，原来的<spanclass="math inline">\(P(A_i)\)</span>称为<strong>先验概率</strong>。</p><h2 id="独立性">1.5 独立性</h2><p>若<span class="math inline">\(P(A\mid B)=P(A)\)</span>，称事件<spanclass="math inline">\(A\)</span>是独立于事件<spanclass="math inline">\(B\)</span>的。上式等价于<spanclass="math inline">\(P(A\bigcap B)=P(A)P(B)\)</span>。</p><p>若<span class="math inline">\(P(A\bigcap B\mid C)=P(A\mid C)P(B\midC)\)</span>，则称<span class="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>在给定<spanclass="math inline">\(C\)</span>之下条件独立。</p><h2 id="计数法">1.6 计数法</h2><p><span class="math inline">\(n\)</span>个对象的排列数：<spanclass="math inline">\(n!\)</span></p><p><span class="math inline">\(n\)</span>个对象中取<spanclass="math inline">\(k\)</span>个对象的排列数：<spanclass="math inline">\(\frac{n!}{(n-k)!}\)</span></p><p><span class="math inline">\(n\)</span>个对象中取<spanclass="math inline">\(k\)</span>个对象的组合数：<spanclass="math inline">\(\begin{pmatrix} n\\k\end{pmatrix}=\frac{n!}{k!(n-k)!}\)</span></p><p>将<span class="math inline">\(n\)</span>个对象分成<spanclass="math inline">\(r\)</span>个组的分割数，其中第<spanclass="math inline">\(i\)</span>个组具有<spanclass="math inline">\(n_i\)</span>个对象：<spanclass="math inline">\(\begin{pmatrix} n\\n_1,n_2,...,n_r\end{pmatrix}=\frac{n!}{n_1!n_2!...n_r!}\)</span></p><h1 id="第2章-离散随机变量">第2章 离散随机变量</h1><h2 id="基本概念">2.1 基本概念</h2><p>在一个试验的概率模型之下：</p><ul><li><strong>随机变量</strong>是试验结果的实值函数</li><li>随机变量的函数定义了另一个随机变量</li><li>对于一个随机变量，我们可以定义一些平均量，例如均值和方差</li><li>可以在某事件或某随机变量的条件之下定义一个随机变量</li><li>存在一个随机变量与某事件或某随机变量项目独立的概念</li></ul><p>离散随机变量的取值范围智能是有限多个值或可数无限多个值。</p><p>一个离散随机变量有一个<strong>分布列</strong>，它对于随机变量的每一个取值给出一个概率。</p><p>离散随机变量的函数也是一个离散随机变量。</p><h2 id="分布列">2.2 分布列</h2><p><spanclass="math inline">\(p_X(x)=P(\{X=x\})\)</span>，<strong>大写字母表示随机变量，小写字母表示实数</strong>。</p><p><span class="math inline">\(\sum_{x}p_X(x)=1\)</span></p><p><strong>伯努利随机变量</strong>：</p><p>抛掷一枚硬币，正面出现概率为<spanclass="math inline">\(p\)</span>。<spanclass="math inline">\(X\)</span>取值为<spanclass="math inline">\(k\)</span>，<spanclass="math inline">\(k\)</span>正面为1，反面为0。</p><p><span class="math display">\[p_X(k)=\left\{ \begin{aligned}  p,k=1\\1-p,k=0  \end{aligned} \right.\]</span> <strong>二项随机变量</strong>：</p><p>将硬币抛掷<span class="math inline">\(n\)</span>次。<spanclass="math inline">\(X\)</span>取值为<spanclass="math inline">\(k\)</span>，<spanclass="math inline">\(k\)</span>为得到正面的次数。 <spanclass="math display">\[p_X(k)=\begin{pmatrix} n\\k \end{pmatrix}p^k(1-p)^{n-k},k=0,1,...,n.\]</span> <strong>几何随机变量</strong>：</p><p><span class="math inline">\(X\)</span>取值为<spanclass="math inline">\(k\)</span>，<spanclass="math inline">\(k\)</span>为连续抛掷硬币直到第一次出现正面所需的抛掷次数。<span class="math display">\[p_X(k)=(1-p)^{k-1}p,k=1,2,...\]</span> <strong>泊松随机变量</strong>：</p><p><span class="math inline">\(X\)</span>的分布列如下： <spanclass="math display">\[p_X(k)=e^{-\lambda}\frac{\lambda^k}{k!},k=0,1,2,...\]</span> 当二项随机变量<spanclass="math inline">\(n\)</span>很大、<spanclass="math inline">\(p\)</span>很小时，<spanclass="math inline">\(\lambda=np\)</span>，泊松随机变量的分布列是二项随机变量分布列很好的逼近：<span class="math display">\[e^{-\lambda}\frac{\lambda^k}{k!} \approx\frac{n!}{k!(n-k)!}p^k(1-p)^{n-k},k=0,1,...,n.\]</span></p><h2 id="随机变量的函数">2.3 随机变量的函数</h2><p>随机变量的函数也是随机变量。</p><h2 id="期望均值和方差">2.4 期望、均值和方差</h2><p><strong>期望</strong>：</p><p>设随机变量<span class="math inline">\(X\)</span>的分布列为<spanclass="math inline">\(p_X\)</span>。<spanclass="math inline">\(X\)</span>的期望值由下式给出： <spanclass="math display">\[E[X]=\sum_{x} xp_X(x)\]</span> 对于<span class="math inline">\(X\)</span>的函数<spanclass="math inline">\(g(X)\)</span>: <span class="math display">\[E[g(X)]=\sum_x g(x)p_X(x)\]</span> <strong>方差</strong>：</p><p>随机变量<span class="math inline">\(X\)</span>的方差为： <spanclass="math display">\[var(X)=E[(X-E[X])^2]\]</span> 其平方根记为标准差<spanclass="math inline">\(\sigma_X\)</span></p><p><strong>随机变量的线性函数的均值和方差</strong>：</p><p>若<span class="math inline">\(Y=aX+b\)</span>,则： <spanclass="math display">\[E[Y]=aE[X]+b,  var(Y)=a^2var(X)\]</span> <strong>用矩表达的方差公式</strong>： <spanclass="math display">\[var(X)=E[X^2]-(E[X])^2\]</span></p><h2 id="多个随机变量的联合分布列">2.5 多个随机变量的联合分布列</h2><p><span class="math display">\[p_{X,Y}(x,y)=P(X=x,Y=y)\]</span></p><p>可以通过联合分布列求单个随机变量的分布列： <spanclass="math display">\[p_X(x)= P(X=x) =\sum_y P(X=x,Y=y) = \sum_y P_{X,Y}(x,y)\]</span> 以上也称为边缘分布列。</p><h2 id="条件">2.6 条件</h2><p>在某个事件<spanclass="math inline">\(A(P(A)&gt;0)\)</span>发生的条件下，随机变量<spanclass="math inline">\(X\)</span>的<strong>条件分布列</strong>由下式定义：<span class="math display">\[p_{X\mid A}(x)=P(X=x\mid A)=\frac{P(\{X=x\}\bigcap A)}{P(A)}\]</span></p><h2 id="独立性-1">2.7 独立性</h2><p>设在某一试验中，<spanclass="math inline">\(A\)</span>是一个事件，满足条件<spanclass="math inline">\(P(A)&gt;0\)</span>，又设<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>是在同一个试验中的两个随机变量。</p><p>若对一切<span class="math inline">\(x\)</span>，<spanclass="math inline">\(p_{X\mid A}(x)=p_X(x)\)</span>，则称<spanclass="math inline">\(X\)</span>相对于事件<spanclass="math inline">\(A\)</span>独立。</p><p>若对一切<span class="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span>，<spanclass="math inline">\(p_{X,Y}(x,y)=p_X(x)p_Y(y)\)</span>，则称<spanclass="math inline">\(\{X=x\}\)</span> 和<spanclass="math inline">\(\{Y=y\}\)</span>相互独立。此时有<spanclass="math inline">\(E[XY]=E[X]E[Y]\)</span>、<spanclass="math inline">\(var(X+Y)=var(X)+var(Y)\)</span>。</p><h1 id="第3章-一般随机变量">第3章 一般随机变量</h1><h2 id="连续随机变量和概率密度函数">3.1 连续随机变量和概率密度函数</h2><p>对于随机变量<spanclass="math inline">\(X\)</span>，若存在一个非负函数<spanclass="math inline">\(f_X\)</span>，使得 <span class="math display">\[P(X\in B)=\int_B f_X(x)dx\]</span> 对每一个实数轴上的集合<spanclass="math inline">\(B\)</span>都成立，则称<spanclass="math inline">\(X\)</span>为连续的随机变量，函数<spanclass="math inline">\(f_X\)</span>就称为<spanclass="math inline">\(X\)</span>的概率密度函数(PDF)。 <spanclass="math display">\[E[X]=\int_{-\infty}^{\infty}xf_X(x)dx\]</span></p><h2 id="分布函数">3.2 分布函数</h2><p>之前分别用分布列（离散情况）和概率密度函数（连续情况）来刻画随机变量<spanclass="math inline">\(X\)</span>的取值规律。累计分布函数（CDF）可以同时刻画以上两者：<span class="math display">\[X\text{离散，}F_X(x)=P(X\le x)=\sum_{k\le x}p_X(k) \\X\text{连续，}F_X(x)=\int_{-\infty}^x f_X(t)dt\]</span></p><h2 id="正态随机变量">3.3 正态随机变量</h2><p>正态/高斯连续随机变量<spanclass="math inline">\(X\)</span>的密度函数如下： <spanclass="math display">\[f_X(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-(x-\mu)^2/(2\sigma^2)},E[X]=\mu,var(X)=\sigma^2\]</span> 线性变化之下随机变量的正态性保持不变。</p><p>期望为1方差为1的正态随机变量称为标准正态随机变量。</p><h2 id="多个随机变量的联合概率密度">3.4 多个随机变量的联合概率密度</h2><p><span class="math display">\[P((X,Y)\in B)=\int\int_{(x,y)\in B} f_{X,Y}(x,y)dxdy\]</span></p><h2 id="条件-1">3.5 条件</h2><p>对于给定的事件<spanclass="math inline">\(A(P(A)&gt;0)\)</span>，<spanclass="math inline">\(B\)</span>是实数轴上的任意集合，连续随机变量<spanclass="math inline">\(X\)</span>的条件概率密度<spanclass="math inline">\(f_{X\mid A}\)</span>是满足下列条件的函数： <spanclass="math display">\[P(X\in B\mid A)=\int_B f_{X\mid A}(x)dx\]</span> 设<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>为联合连续的随机变量，其联合、边缘、条件概率密度函数是相互关联的：<span class="math display">\[f_{X,Y}(x,y)=f_Y(y)f_{X\mid Y}(x\mid y)\]</span></p><h2 id="连续贝叶斯准则">3.6 连续贝叶斯准则</h2><p><span class="math display">\[f_{X\mid Y}(x\mid y)=\frac{f_X(x)f_{Y\mid X}(y\midx)}{f_Y(y)}=\frac{f_X(x)f_{Y\mid X}(y\midx)}{\int_{-\infty}^{\infty}f_X(t)f_(Y\mid X)(y\mid t)dt}\]</span></p><h1 id="第4章-随机变量的深入内容">第4章 随机变量的深入内容</h1><h2 id="随机变量函数的分布密度函数">4.1 随机变量函数的分布密度函数</h2><p>连续随机变量<span class="math inline">\(X\)</span>的函数<spanclass="math inline">\(Y=g(X)\)</span>的分布密度函数（CDF）： <spanclass="math display">\[F_Y(y)=P(g(x)\le y)=\int_{ \{x\mid g(x)\le y\} }f_X(x)dx\]</span></p><p>PDF可由求导得到： <span class="math display">\[f_Y(y)=\frac{dF_Y}{dy}(y)\]</span></p><h2 id="协方差和相关">4.2 协方差和相关</h2><p><span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>的协方差记为<spanclass="math inline">\(cov(X,Y)\)</span>，当其为0时<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>不相关： <span class="math display">\[cov(X,Y)=E[(X-E[X])(Y-E[Y])]\]</span></p><p><span class="math display">\[cov(X,Y)=E[XY]-E[X]E[Y]\]</span></p><p>如果<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>相互独立，则它们是不相关的，但逆命题不成立。</p><p><strong>相关系数</strong>定义为： <span class="math display">\[\rho(X,Y)=\frac{cov(X,Y)}{\sqrt{var(X)var(Y)}},\rho(X,Y)\in[-1,1]\]</span> 随机变量和的方差： <span class="math display">\[var(X_1+X_2)=var(X_1)+var(X_2)+2cov(X_1,X_2)\]</span></p><p><span class="math display">\[var(\sum_{i=1}^{n}X_i)=\sum_{i=1}^{n}var(X_i)+\sum_{ \{(i,j)\mid i\nej\} }cov(X_i,Y_j)\]</span></p><h2 id="再论条件期望和条件方差">4.3 再论条件期望和条件方差</h2><p><strong>重期望法则</strong>： <span class="math display">\[E[E[X\mid Y]]=E[X]\]</span> <strong>全方差法则</strong>： <span class="math display">\[var(X)=E[var(X\mid Y)]+var(E[X\mid Y])\]</span></p><h2 id="矩母函数">4.4 矩母函数</h2><p>一个与随机变量<spanclass="math inline">\(X\)</span>相关的矩母函数是一个参数<spanclass="math inline">\(s\)</span>的函数<spanclass="math inline">\(M_X(s)\)</span>，定义如下： <spanclass="math display">\[M_X(s)=E[e^{sX}]\]</span>数学期望和方差可以纳入到一个更一般的概念范畴中，那就是随机变量的矩。</p><p>设<span class="math inline">\(X\)</span>为随机变量，<spanclass="math inline">\(k\)</span>为正整数，如果<spanclass="math inline">\(E(X^k)\)</span>存在，则称<spanclass="math inline">\(E(X^k)\)</span>为<spanclass="math inline">\(X\)</span>的<spanclass="math inline">\(k\)</span>阶原点矩。如果<spanclass="math inline">\(E((X-E(X))^k)\)</span>存在，则称<spanclass="math inline">\(E((X-E(X))^k)\)</span>为<spanclass="math inline">\(X\)</span>的<spanclass="math inline">\(k\)</span>阶中心矩。</p><p>显然，一阶原点矩就是数学期望，二阶中心矩就是方差。</p><p>使用矩母函数可以方便地计算矩。</p><h2 id="随机数个相互独立的随机变量之和">4.5随机数个相互独立的随机变量之和</h2><p>记<span class="math inline">\(X_1,X_2,...\)</span>为均值<spanclass="math inline">\(\mu\)</span>、方差<spanclass="math inline">\(\sigma^2\)</span>的同分布随机变量。记<spanclass="math inline">\(N\)</span>为取值于正整数的随机变量。我们假定上述所有变量相互独立，下面考虑变量和<span class="math display">\[Y=X_1+...+X_N\]</span> 那么：</p><ul><li><span class="math inline">\(E[Y]=E[X]E[N]\)</span></li><li><spanclass="math inline">\(var(Y)=var(X)E[N]+(E[X])^2var(N)\)</span></li><li>矩母函数<spanclass="math inline">\(M_Y(s)\)</span>可由计算矩母函数<spanclass="math inline">\(M_N(s)\)</span>的公式得到，将其中的<spanclass="math inline">\(e^S\)</span>全部替换成<spanclass="math inline">\(M_X(s)\)</span>即可</li></ul><h1 id="第5章-极限理论">第5章 极限理论</h1><h2 id="马尔可夫和切比雪夫不等式">5.1 马尔可夫和切比雪夫不等式</h2><p><strong>马尔克夫不等式</strong>：</p><p>设随机变量<spanclass="math inline">\(X\)</span>只取非负值，则对任意<spanclass="math inline">\(a&gt;0\)</span>， <span class="math display">\[P(X\ge a)\le\frac{E[X]}{a}\]</span> 如果一个非负随机变量均值很小，它取大值的概率也很小。</p><p><strong>切比雪夫不等式</strong>：</p><p>设随机变量<span class="math inline">\(X\)</span>的均值为<spanclass="math inline">\(\mu\)</span>，方差为<spanclass="math inline">\(\sigma^2\)</span>，则对任意<spanclass="math inline">\(c&gt;0\)</span>， <span class="math display">\[P(\mid X-\mu \mid\ge c)\le \frac{\sigma^2}{c^2}\]</span> 如果一个随机变量的方差很小，它取远离均值<spanclass="math inline">\(\mu\)</span>的概率也很小。</p><h2 id="弱大数定律">5.2 弱大数定律</h2><p>设<spanclass="math inline">\(X_1,...,X_n,...\)</span>独立同分布，其公共分布的均值为<spanclass="math inline">\(\mu\)</span>，则对任意的<spanclass="math inline">\(\epsilon&gt;0\)</span>，当$n$时， <spanclass="math display">\[P(\mid M_n-\mu \ge \epsilon \mid)=P(\mid \frac{X_1+...+X_n}{n} - \mu\mid\ge\epsilon)\longrightarrow 0\]</span> 利用切比雪夫不等式可得： <span class="math display">\[P(\mid M_n-\mu\mid\ge\epsilon)\le\frac{\sigma^2}{n\epsilon^2},\forall\epsilon&gt;0\]</span> n越大，<spanclass="math inline">\(M_n\)</span>均值越接近公共分布均值，收敛于<spanclass="math inline">\(\mu\)</span>。</p><h2 id="依概率收敛">5.3 依概率收敛</h2><p>依概率收敛和数列收敛不同。</p><p>设<spanclass="math inline">\(Y_1,Y_2,...\)</span>是随机变量序列（不必相互独立），对任意的<spanclass="math inline">\(\epsilon&gt;0\)</span>和<spanclass="math inline">\(\delta&gt;0\)</span>，存在<spanclass="math inline">\(n_0\)</span>和实数a，使得对所有的<spanclass="math inline">\(n\ge n_0\)</span>，都有 <spanclass="math display">\[P(\mid Y_n-a\mid \ge \epsilon)\le\delta\]</span> <span class="math inline">\(\epsilon\)</span>为精度，<spanclass="math inline">\(\delta\)</span>为置信水平。</p><h2 id="中心极限定理">5.4 中心极限定理</h2><p>设<spanclass="math inline">\(X_1,X_2,...\)</span>是独立同分布的随机变量序列，序列的每一项的均值为<spanclass="math inline">\(\mu\)</span>，方差为<spanclass="math inline">\(\sigma^2\)</span>。记 <spanclass="math display">\[Z_n=\frac{X_1+...+X_n-n\mu}{\sqrt{n}\sigma}\]</span> 则<spanclass="math inline">\(Z_n\)</span>的分布函数的极限分布为标准正态分布<span class="math display">\[\Phi(x)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^xe^{-z^2/2}dz\]</span> 即 <span class="math display">\[\lim_{n\to\infty} P(Z_n\le x)=\Phi(x),\forall x\]</span> 二项分布的棣莫弗-拉普拉斯近似</p><p>设<spanclass="math inline">\(S_n\)</span>是服从参数为n和p的二项分布，n充分大，k和l是非负整数，则<span class="math display">\[P(k\le S_n \le l)\approx\Phi(\frac{l+\frac{1}{2}-np}{\sqrt{np(1-p)}})-\Phi(\frac{k-\frac{1}{2}-np}{\sqrt{(np(1-p))}})\]</span></p><h2 id="强大数定律">5.5 强大数定律</h2><p>设<span class="math inline">\(X_1,X_2,...,X_n\)</span>是均值为<spanclass="math inline">\(\mu\)</span>的独立同分布随机变量序列，则样本均值<spanclass="math inline">\(M_n=(X_1+X_2+...+X_n)/n\)</span>以概率1收敛于<spanclass="math inline">\(\mu\)</span>，即 <span class="math display">\[P(\lim_{n\to\infty}\frac{(X_1+X_2+...+X_n)}{n}=\mu)=1\]</span>强大数定律的收敛是“以概率1收敛”，与若大数定律的收敛不同。弱大数定律是指<spanclass="math inline">\(M_n\)</span>显著性偏离<spanclass="math inline">\(\mu\)</span>的事件的概率<spanclass="math inline">\(P(\mid M_n-\mu\mid\ge\epsilon)\)</span>，在<spanclass="math inline">\(n\to\infty\)</span>时，趋于0。但是对任意有限的n，这个概率可以是正的。弱大数定律不能提供到底有多少会显著性偏离<spanclass="math inline">\(\mu\)</span>，但是强大数定律可以。<spanclass="math inline">\(M_n\)</span>以概率1收敛于<spanclass="math inline">\(\mu\)</span>，这意味着对<spanclass="math inline">\(\forall\epsilon&gt;0\)</span>，偏离<spanclass="math inline">\(\mid M_n-\mu\mid\)</span>超过<spanclass="math inline">\(\epsilon\)</span>的，只能发生有限次。</p><h1 id="第6章-伯努利和泊松过程">第6章 伯努利和泊松过程</h1><p>随机过程就是一串随机变量序列，但是更倾向于强调过程中产生的数据序列之间的相关关系。</p><h2 id="伯努利过程">6.1 伯努利过程</h2><p><strong>与伯努利过程相关的随机变量</strong></p><p>服从参数n和p的二项分布。n次相继独立的试验成功的总次数<spanclass="math inline">\(S\)</span>的分布。 <span class="math display">\[p_S(k)==\begin{pmatrix} n\\k \end{pmatrix}p^k(1-p)^{n-k},k=0,1,...,n.\]</span></p><p><span class="math display">\[E[S]=np,var(S)=np(1-p)\]</span></p><p>服从参数为p的几何分布。相互独立重复的伯努利试验首次成功的总次数<spanclass="math inline">\(T\)</span>的分布。 <span class="math display">\[p_T(t)=p(1-p)^{t-1},t=1,2 ...,\]</span></p><p><span class="math display">\[E[T]=\frac{1}{p},var(T)=\frac{1-p}{p^2}\]</span></p><p>伯努利过程具有独立性和无记忆性。</p><h2 id="泊松过程">6.2 泊松过程</h2><p>泊松过程是伯努利过程的<strong>连续</strong>版本。两者都是到达过程。</p><p><strong>泊松过程相关的随机变量</strong></p><p>服从参数为<spanclass="math inline">\(\lambda\tau\)</span>的泊松分布。泊松过程的强度为<spanclass="math inline">\(\lambda\)</span>，在时间强度为<spanclass="math inline">\(\tau\)</span>的区间内到达的总次数<spanclass="math inline">\(N_\tau\)</span>的分布。 <spanclass="math display">\[p_{N_\tau}(k)=P(k,\tau)=e^{-\lambda\tau}\frac{(\lambda\tau)^k}{k!},k=0,1,...,\]</span></p><p><span class="math display">\[E[N_\tau]=var(N_\tau)=\lambda\tau\]</span></p><p>服从参数为<spanclass="math inline">\(\lambda\)</span>的指数分布。首次到达的时间<spanclass="math inline">\(T\)</span>的分布。 <span class="math display">\[f_T(t)=\lambda e^{-\lambda t},t\ge0,E[T]=\frac{1}{\lambda},var(T)=\frac{1}{\lambda^2}\]</span></p><h1 id="第7章-马尔可夫链">第7章 马尔可夫链</h1><h2 id="离散时间的马尔可夫链">7.1 离散时间的马尔可夫链</h2><p>用变量n表示时刻，在任意时刻n用<spanclass="math inline">\(X_n\)</span>表示链的状态，所有可能状态组成有限集合<spanclass="math inline">\(S\)</span>，称该集合为状态空间。</p><p>马尔可夫链由转移概率<spanclass="math inline">\(p_{ij}\)</span>所描述：即当状态是i时，下一个状态等于j的概率是<spanclass="math inline">\(p_{ij}\)</span>。 <span class="math display">\[p_{ij}=P(X_{n+1}=j\mid X_n=i),i,j\in S\]</span> 马尔可夫性质：下一个状态<spanclass="math inline">\(X_{n+1}\)</span>的概率分布只依赖于前一个状态<spanclass="math inline">\(X_n\)</span>。</p><p>转移概率一定是非负的，且其和为1。</p><p>马尔可夫链可以用转移概率矩阵或转移概率图刻画。</p><h2 id="状态的分类">7.2 状态的分类</h2><p>如果对于每个从<spanclass="math inline">\(i\)</span>出发可达的状态<spanclass="math inline">\(j\)</span>，相应地从<spanclass="math inline">\(j\)</span>出发也可达<spanclass="math inline">\(i\)</span>，则<spanclass="math inline">\(i\)</span>是<strong>常返</strong>的。</p><p>如果<span class="math inline">\(i\)</span>是常返态，那么从<spanclass="math inline">\(i\)</span>可达的状态集合<spanclass="math inline">\(A(i)\)</span>组成一个<strong>常返类</strong>。同一个常返类中所有状态都是相互可达的，但与常返类之外的状态不相互可达。</p><p>一个马尔可夫链的状态集合可以分解为一个或多个常返类，加上可能的一些非常返状态。</p><p>考虑一个常返类<span class="math inline">\(R\)</span></p><ul><li><p>如果一类中的状态能被分成<spanclass="math inline">\(d&gt;1\)</span>个互不相交的子集<spanclass="math inline">\(S_1,...,S_d\)</span>，满足所有的转移都是从子集<spanclass="math inline">\(S_k\)</span>到<spanclass="math inline">\(S_{k+1}\)</span>的（或到<spanclass="math inline">\(S_1\)</span>，当<spanclass="math inline">\(k=d\)</span>时）,则称该类为周期类。</p></li><li><p>一类<spanclass="math inline">\(R\)</span>称为非周期的，当且仅当存在时刻n，使得对于任何<spanclass="math inline">\(i,j\in R\)</span>，满足<spanclass="math inline">\(r_{ij}(n)&gt;0\)</span>。</p></li></ul><h2 id="稳态性质">7.3 稳态性质</h2><p>考虑一个非周期的，单个常返类的马尔可夫链。那么，状态<spanclass="math inline">\(j\)</span>和它对应的稳态概率<spanclass="math inline">\(\pi_j\)</span>有如下性质。</p><ol type="1"><li>对于每个<span class="math inline">\(j\)</span>，我们有：</li></ol><p><span class="math display">\[\lim_{n\to\infty}r_{ij}(n)=\pi_j,\text{对于所有的}i\]</span> 2. <spanclass="math inline">\(\pi_j\)</span>是下面方程组的唯一解：</p><p><span class="math display">\[\pi_j=\sum_{k=1}^{m}\pi_k p_{kj},j=1,...,m,\]</span></p><p><span class="math display">\[l=\sum_{k=1}^m\pi_k\]</span></p><ol start="3" type="1"><li>另外有：</li></ol><p><span class="math display">\[\pi_j=0,\text{对于所有的非常返状态}j,\]</span></p><p><span class="math display">\[\pi_j&gt;0,\text{对于所有的常返态}j.\]</span></p><h2 id="吸收概率和吸收的期望时间">7.4 吸收概率和吸收的期望时间</h2><p>一个常返态k是<strong>吸收</strong>的：<spanclass="math inline">\(p_{kk}=1,p_{kj}=0\)</span>对于所有的<spanclass="math inline">\(j\ne k\)</span>。</p><p>固定一个吸收态，设为s，令<spanclass="math inline">\(a_i\)</span>表示链从状态i开始，最终达到s的概率即为吸收概率：<span class="math display">\[a_i=P(X_n\text{最终等于吸收状态}s\mid X_0=i)\]</span> <strong>平均吸收时间方程组</strong>：</p><p>平均吸收时间<spanclass="math inline">\(\mu_1,...,\mu_m\)</span>是下列方程组的唯一解 <spanclass="math display">\[\mu_i=0,\text{对于所有的非常返状态}i,\]</span></p><p><span class="math display">\[\mu_i=1+\sum_{j=1}^m p_{ij}\mu_{j},\text{对于所有的非常返状态}i.\]</span></p><p><strong>平均首访时间和回访时间方程组</strong>：</p><p>考虑只有单个常返类的马尔可夫链，令s为特殊的常返状态。</p><ul><li><p>从状态i到状态s的平均首访时间<spanclass="math inline">\(t_i\)</span>，是下列方程组的唯一解 <spanclass="math display">\[t_s=0,t_i=1+\sum_{j=1}^m p_{ij}t_j,\text{对于所有的}i\ne s\]</span></p></li><li><p>状态s的平均回访时间<spanclass="math inline">\(t^*_s\)</span>为</p></li></ul><p><span class="math display">\[t^*_s=1+\sum_{j=1}^m p_{sj}t_j\]</span></p><h2 id="连续时间的马尔可夫链">7.5 连续时间的马尔可夫链</h2><p>连续性时间马尔可夫链的假设</p><ul><li>如果当前状态是i，到下一个转移的时间服从已知参数<spanclass="math inline">\(v_i\)</span>的指数分布，且独立于之前的历史过程和下一个状态</li><li>如果当前状态是i，按照给定的概率<spanclass="math inline">\(p_{ij}\)</span>到达下一个状态j,而且独立于之前的历史过程和转移到下一个状态的时间间隔</li></ul><p>考虑一个具有单个常返类的连续时间马尔可夫链。那么，状态<spanclass="math inline">\(j\)</span>和它对应的稳态概率<spanclass="math inline">\(\pi_j\)</span>有如下性质。q是转移速率。</p><ol type="a"><li>对于每个<span class="math inline">\(j\)</span>，我们有： <spanclass="math display">\[\lim_{t\to\infty}P(X(t)=j\mid X(0)=i)=\pi_j,\text{对于所有的}i\]</span></li><li><span class="math inline">\(\pi_j\)</span>是下面方程组的唯一解：<span class="math display">\[\pi_j\sum_{k\ne j}q_{jk}=\sum_{k\ne j}^{m}\pi_k q_{kj},j=1,...,m,\]</span></li></ol><p><span class="math display">\[l=\sum_{k=1}^m\pi_k\]</span></p><p>(c)另外有： <span class="math display">\[\pi_j=0,\text{对于所有的非常返状态}j,\]</span></p><p><span class="math display">\[\pi_j&gt;0,\text{对于所有的常返态}j.\]</span></p><h1 id="第8章-贝叶斯统计推断">第8章 贝叶斯统计推断</h1><p><strong>统计推断</strong>是从观测数据推断未知变量或未知模型的有关信息的过程，和概率理论不是一码事。</p><p>统计有两种学派：贝叶斯学派和经典（频率）学派。它们的重要区别在于如何看待未知模型或者变量。</p><ul><li>贝叶斯学派将其看成已知分布的随机变量。</li><li>经典学派将其看成未知的待估计的量。</li></ul><p>统计推断的应用主要分为两种类型：模型推断和变量推断。</p><p>统计推断问题可以简单分为估计问题和假设检验问题。在参数估计中对参数进行估计，使得在某种概率意义下估计接近真实值。在假设检验中，未知参数根据对应的假设可能取有限个值。人们去选择其中一个假设，目标是使犯错误的概率很小。</p><p>考虑具有形式<spanclass="math inline">\(Y=g(X)+W\)</span>的模型，该模型涉及两个随机变量<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>，其中<spanclass="math inline">\(W\)</span>是零均值噪声，<spanclass="math inline">\(g\)</span>是需要估计的未知函数。这类问题，未知目标（比如这里的函数g）是不能表述为固定数目的参数，称为<strong>非参数</strong>统计推断问题。不在此书考虑范围之内。</p><p><strong>共轭先验分布</strong>：</p><p>在贝叶斯统计中，如果后验分布与先验分布属于同类，则先验分布与后验分布被称为共轭分布，而<strong>先验分布被称为似然函数的共轭先验分布</strong>。</p><p>具体地说，就是给定贝叶斯公式<span class="math inline">\(p_{\Theta\midX}(\theta\mid x)=\frac{p_\Theta(\theta)p_{X\mid\Theta}(x\mid\theta)}{\sum_{\theta&#39;}p_{\Theta}(\theta&#39;)p_{X\mid\Theta}(x\mid\theta&#39;)}\)</span>（假设<spanclass="math inline">\(\Theta\)</span>离散，<spanclass="math inline">\(X\)</span>离散），假定似然函数<spanclass="math inline">\(p_{X\mid\Theta}(x\mid\theta)\)</span>是已知的，问题就是选取什么样的先验分布会让后验分布与先验分布具有相同的数学形式。</p><p>共轭先验分布是针对某一参数而言，如正态分布关于方差的共轭先验分布为倒Gamma分布、关于均值的共轭先验分布为正态分布。</p><p>所有指数家族的分布都有共轭先验。</p><h2 id="贝叶斯推断与后验分布">8.1 贝叶斯推断与后验分布</h2><p>推断过程：</p><ul><li>起点是未知随机变量<spanclass="math inline">\(\Theta\)</span>的先验分布<spanclass="math inline">\(p_{\Theta}\)</span>或者<spanclass="math inline">\(f_\Theta\)</span>。</li><li>得到观测向量<span class="math inline">\(X\)</span>的<spanclass="math inline">\(p_{X\mid\Theta}\)</span>或者<spanclass="math inline">\(f_{X\mid\Theta}\)</span>。</li><li>一旦<spanclass="math inline">\(X\)</span>的一个特定值x观测到后，运用贝叶斯法则计算<spanclass="math inline">\(\Theta\)</span>的后验分布。</li></ul><p>贝叶斯法则的4种形式：</p><ul><li><p><span class="math inline">\(\Theta\)</span>离散，<spanclass="math inline">\(X\)</span>离散： <span class="math display">\[p_{\Theta\mid X}(\theta\midx)=\frac{p_\Theta(\theta)p_{X\mid\Theta}(x\mid\theta)}{\sum_{\theta&#39;}p_{\Theta}(\theta&#39;)p_{X\mid\Theta}(x\mid\theta&#39;)}\]</span></p></li><li><p><span class="math inline">\(\Theta\)</span>离散，<spanclass="math inline">\(X\)</span>连续： <span class="math display">\[p_{\Theta\mid X}(\theta\midx)=\frac{p_\Theta(\theta)f_{X\mid\Theta}(x\mid\theta)}{\sum_{\theta&#39;}p_{\Theta}(\theta&#39;)f_{X\mid\Theta}(x\mid\theta&#39;)}\]</span></p></li><li><p><span class="math inline">\(\Theta\)</span>连续，<spanclass="math inline">\(X\)</span>离散： <span class="math display">\[f_{\Theta\mid X}(\theta\midx)=\frac{f_\Theta(\theta)p_{X\mid\Theta}(x\mid\theta)}{\sum_{\theta&#39;}f_{\Theta}(\theta&#39;)p_{X\mid\Theta}(x\mid\theta&#39;)}\]</span></p></li><li><p><span class="math inline">\(\Theta\)</span>连续，<spanclass="math inline">\(X\)</span>连续： <span class="math display">\[f_{\Theta\mid X}(\theta\midx)=\frac{f_\Theta(\theta)f_{X\mid\Theta}(x\mid\theta)}{\sum_{\theta&#39;}f_{\Theta}(\theta&#39;)f_{X\mid\Theta}(x\mid\theta&#39;)}\]</span></p></li></ul><h2 id="点估计假设检验最大后验概率准则">8.2点估计，假设检验，最大后验概率准则</h2><p>最大后验准则是指在所有的<spanclass="math inline">\(\theta\)</span>中寻找<spanclass="math inline">\(\hat{\theta}\)</span>，使得后验分布（见贝叶斯准则）达到最大值。</p><p><strong>点估计</strong>指的是在得到实际观察值x的基础上我们选择的<spanclass="math inline">\(\hat{\theta}\)</span>的数值。<spanclass="math inline">\(\hat{\theta}\)</span>是由观测值x的某些函数g决定的，即<spanclass="math inline">\(\hat{\theta}=g(x)\)</span>。随机变量<spanclass="math inline">\(\hat{\Theta}=g(X)\)</span>也称为估计，之所以说<spanclass="math inline">\(\hat{\Theta}\)</span>是随机变量是因为估计的结果由随机的观测值所决定。利用不同的函数g可以构造不同的估计量。</p><ul><li><p><strong>最大后验概率（MAP）估计量</strong>。观测到x，在所有<spanclass="math inline">\(\theta\)</span>中选<spanclass="math inline">\(\hat{\theta}\)</span>使得后验分布达到最大。当取值很多时任取其中一个。</p></li><li><p><strong>条件期望估计量</strong>。<spanclass="math inline">\(\hat{\theta}=E[\Theta\mid X=x]\)</span></p></li></ul><p><strong>假设检验</strong>一般使用最大后验概率准则。</p><h2 id="贝叶斯最小均方估计">8.3 贝叶斯最小均方估计</h2><p>条件期望估计量具有使可能的均方误差达到最小的性质。（最小均方简称为LMS）</p><h2 id="贝叶斯线性最小均方估计">8.4 贝叶斯线性最小均方估计</h2><p>在一个较小的统计量的集合类中寻找统计量使得均方误差最小：那些观测值的线性函数的集合类。虽然这种统计量会导致较高的均方误差，但是在实际中有明显的优势：对计算要求简单，只包括均值、方差以及观测与参数之间的协方差。在最大后验估计量和最小均方估计量难以计算的情况下，这是个很有用的替代估计量。</p><h1 id="第9章-经典统计推断">第9章 经典统计推断</h1><h2 id="经典参数估计">9.1 经典参数估计</h2><p>经典的方法将参数<spanclass="math inline">\(\theta\)</span>看作未知常数，而不是随机变量。</p><p><span class="math inline">\(\hat{\Theta}_n\)</span>是未知参数<spanclass="math inline">\(\theta\)</span>的一个<strong>估计量</strong>，也即关于n个的观测<spanclass="math inline">\(X_1,...,X_n\)</span> (服从依赖参数<spanclass="math inline">\(\theta\)</span>的分布)的一个函数。</p><ul><li><p>估计误差，记为<spanclass="math inline">\(\tilde{\Theta}_n\)</span>，定义为<spanclass="math inline">\(\tilde{\Theta}_n=\hat{\Theta}_n-\theta\)</span></p></li><li><p>估计量的偏差，记为<spanclass="math inline">\(b_\theta(\hat{\Theta}_n)\)</span>，是估计误差的期望值：<span class="math display">\[b_\theta(\hat{\Theta}_n)=E_\theta[\hat{\Theta}_n]-\theta\]</span></p></li><li><p><spanclass="math inline">\(\hat{\Theta}_n\)</span>的期望值、方差和偏差都依赖于<spanclass="math inline">\(\theta\)</span>，而估计误差同时还依赖于观测<spanclass="math inline">\(X_1,...,X_n\)</span></p></li><li><p>称<spanclass="math inline">\(\hat{\Theta}_n\)</span><strong>无偏</strong>，若<spanclass="math inline">\(E_\theta[\hat{\Theta}_n]=\theta\)</span>对于<spanclass="math inline">\(\theta\)</span>所有可能的取值都成立</p></li><li><p>称<spanclass="math inline">\(\hat{\Theta}_n\)</span><strong>渐进无偏</strong>，若<spanclass="math inline">\(\lim_{n\to\infty}E_\theta[\hat{\Theta}_n]=\theta\)</span>对于<spanclass="math inline">\(\theta\)</span>所有可能的取值都成立</p></li><li><p>称<span class="math inline">\(\hat{\Theta}_n\)</span>为<spanclass="math inline">\(\theta\)</span>的相合估计序列，如果对于参数所有可能的真值<spanclass="math inline">\(\theta\)</span>，序列<spanclass="math inline">\(\hat{\Theta}_n\)</span>依概率收敛到<spanclass="math inline">\(\theta\)</span></p></li></ul><p><strong>最大似然估计</strong>：</p><p>设观测向量<spanclass="math inline">\(X=(X_1,...,X_n)\)</span>的联合分布列为<spanclass="math inline">\(p_X(x;\theta)=p_X(x_1,....,x_n;\theta)\)</span>（<spanclass="math inline">\(\theta\)</span>可为向量或数量），其中<spanclass="math inline">\(x=(x_1,...x_n)\)</span>为<spanclass="math inline">\(X\)</span>的观察值。<strong>最大似然估计</strong>是使（<spanclass="math inline">\(\theta\)</span>的）数值函数<spanclass="math inline">\(p_X(x_1,...,x_n;\theta)\)</span>达到最大的参数值：<span class="math display">\[\hat{\theta}_n=\underset{\theta}{argmax} p_X(x_1,...,x_n;\theta)\]</span> 对于连续型随机变量： <span class="math display">\[\hat{\theta}_n=\underset{\theta}{argmax} f_X(x_1,...,x_n;\theta)\]</span> <span class="math inline">\(p_X(x;\theta)\)</span>和<spanclass="math inline">\(f_X(x;\theta)\)</span>称为似然函数。</p><p><strong>随机变量的均值和方差估计</strong>：</p><p>观察值<spanclass="math inline">\(X_1,...,X_n\)</span>是独立同分布的，均值<spanclass="math inline">\(\theta\)</span>和方差<spanclass="math inline">\(v\)</span>均未知。</p><ul><li><p>样本均值 <span class="math display">\[M_n=\frac{X_1,...,X_n}{n}\]</span> 是<spanclass="math inline">\(\theta\)</span>的一个无偏估计量，它的均方误差是<spanclass="math inline">\(v/n\)</span>。</p></li><li><p>方差的估计量有两个 <span class="math display">\[\bar{S}^2_n=\frac{1}{n}\sum^n_{i=1}(X_i-M_n)^2,\hat{S}^2_n=\frac{1}{n-1}\sum^n_{i=1}(X_i-M_n)^2\]</span></p></li><li><p>当<spanclass="math inline">\(X_i\)</span>服从正态分布，估计量<spanclass="math inline">\(\bar{S}^2_n\)</span>和最大似然估计量相等。它有偏但是渐进无偏。估计量<spanclass="math inline">\(\hat{S}^2_n\)</span>是无偏的。当n很大时，方差的两个估计量本质上一致。</p></li></ul><p><strong>置信区间</strong>：</p><ul><li><p>对于一维的未知参数<spanclass="math inline">\(\theta\)</span>，其置信区间是一个以很高概率包含<spanclass="math inline">\(\theta\)</span>的区间，端点为<spanclass="math inline">\(\hat{\Theta}_n^-\)</span>和<spanclass="math inline">\(\hat{\Theta}_n^+\)</span>。</p></li><li><p><span class="math inline">\(\hat{\Theta}_n^-\)</span>和<spanclass="math inline">\(\hat{\Theta}_n^+\)</span>是依赖于观测值<spanclass="math inline">\(X_1,...,X_n\)</span>的随机变量</p></li><li><p><span class="math inline">\((1-\alpha)\)</span>置信区间对于<spanclass="math inline">\(\theta\)</span>所有可能的取值满足 <spanclass="math display">\[P(\hat{\Theta}_n^-\le\theta\le\hat{\Theta}_n^+)\ge1-\alpha\]</span></p></li></ul><h2 id="线性回归">9.2 线性回归</h2><p>线性回归可以由最小二乘法完成操作，而不需要任何概率上的解释。它也可以在各种概率框架下解释。</p><h2 id="简单假设检验">9.3 简单假设检验</h2><p>略。</p><h2 id="显著性检验">9.4 显著性检验</h2><p>略。</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win32笔记</title>
      <link href="//posts/Notebook/Win32-note/"/>
      <url>//posts/Notebook/Win32-note/</url>
      
        <content type="html"><![CDATA[<p>使用 C++ 和 Win32 API 为Windows电脑生成桌面应用</p><span id="more"></span><p class="note note-primary">二次整理自网络教程。</p><h1 id="前言">0 前言</h1><p>由于需要用到windows窗口，参考以下文档:</p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/">使用 Win32API 生成桌面Windows应用 - Win32 apps</a></p><p>进入其中的：<ahref="https://docs.microsoft.com/zh-cn/windows/win32/learnwin32/learn-to-program-for-windows">Win32和 C++ 入门 - Win32 apps</a></p><p>都是机翻的，得看英文原版。</p><p>安装Windows SDK即可。注意其不支持硬件驱动程序开发。</p><p>匈牙利表示法虽然仍在文档中存在，但已经不再使用。</p><h1 id="第一个窗口程序">1 第一个窗口程序</h1><h2 id="窗口简介">窗口简介</h2><p>窗口之间有两种关系，拥有关系和亲子关系：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E7%AA%97%E5%8F%A3%E5%85%B3%E7%B3%BB.png"alt="窗口关系" /><figcaption aria-hidden="true">窗口关系</figcaption></figure><p>窗口句柄的数据类型是<strong>HWND</strong>，通过将其作为参数的函数来操作它。句柄不是指针。</p><p>原点始终在左上角：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E5%B1%8F%E5%B9%95%E5%92%8C%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87.png"alt="屏幕和窗口坐标" /><figcaption aria-hidden="true">屏幕和窗口坐标</figcaption></figure><p>每个窗口程序都包含一个名为 <strong>WinMain</strong> 或<strong>wWinMain</strong> 的入口点函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> WINAPI <span class="hljs-title">wWinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, <span class="hljs-type">int</span> nCmdShow)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><em>hInstance</em>称为“实例句柄”或“模块句柄”。操作系统使用此值在内存中加载可执行文件时标识可执行文件(EXE) 。 某些Windows函数需要实例句柄，例如加载图标或位图。</li><li><em>hPrevInstance</em> 没有意义。 它在 16位Windows中使用，但现在始终为零。</li><li><em>pCmdLine</em> 包含作为 Unicode 字符串的命令行参数。</li><li><em>nCmdShow</em>是一个标志，指示主应用程序窗口是最小化、最大化还是正常显示。</li></ul><p><strong>WinMain</strong> 函数与 <strong>wWinMain</strong>相同，但命令行参数作为 ANSI 字符串传递。</p><p><strong>WINAPI</strong> 是调用约定。<em>调用约定</em>定义函数如何从调用方接收参数。例如，它定义参数在堆栈上显示的顺序。</p><h2 id="程序示例">程序示例</h2><p>创建一个窗口。</p><p>代码来自<ahref="https://github.com/microsoft/Windows-classic-samples/">microsoft/Windows-classic-samples</a>中的<strong>Samples/Win7Samples/begin/LearnWin32/HelloWorld/cpp</strong>。此后的程序示例均位于LearnWin32中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UNICODE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNICODE</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowProc</span><span class="hljs-params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> WINAPI <span class="hljs-title">wWinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, <span class="hljs-type">int</span> nCmdShow)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//填写WNDCLASS结构，注册窗口类。此类不是 C++ 意义上的“类”。相反，它是操作系统在内部使用的数据结构。 </span><br>    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> CLASS_NAME[]  = <span class="hljs-string">L&quot;Sample Window Class&quot;</span>;<br>    <br>    WNDCLASS wc = &#123; &#125;;<br><br>    wc.lpfnWndProc   = WindowProc; <span class="hljs-comment">//窗口过程,定义窗口的大部分行为</span><br>    wc.hInstance     = hInstance;  <span class="hljs-comment">//应用程序实例的句柄</span><br>    wc.lpszClassName = CLASS_NAME; <span class="hljs-comment">//标识窗口类的字符串</span><br><span class="hljs-comment">//向操作系统注册窗口类</span><br>    <span class="hljs-built_in">RegisterClass</span>(&amp;wc);<br><br>    <span class="hljs-comment">//创建窗口类</span><br>    HWND hwnd = <span class="hljs-built_in">CreateWindowEx</span>(<br>        <span class="hljs-number">0</span>,                              <span class="hljs-comment">//可选窗口行为</span><br>        CLASS_NAME,                     <span class="hljs-comment">//窗口类名称</span><br>        <span class="hljs-string">L&quot;Learn to Program Windows&quot;</span>,    <span class="hljs-comment">//窗口文本</span><br>        WS_OVERLAPPEDWINDOW,            <span class="hljs-comment">//窗口样式</span><br><br>        <span class="hljs-comment">//位置和大小， CW_USEDEFAULT表示使用默认值。</span><br>        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,<br><br>        <span class="hljs-literal">NULL</span>,       <span class="hljs-comment">//父窗口或所有者窗口，NULL代表顶级窗口   </span><br>        <span class="hljs-literal">NULL</span>,       <span class="hljs-comment">// 定义菜单</span><br>        hInstance,  <span class="hljs-comment">// 应用程序实例的句柄</span><br>        <span class="hljs-literal">NULL</span>        <span class="hljs-comment">// 附加数据， void*</span><br>        );<br><br>    <span class="hljs-keyword">if</span> (hwnd == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//显示窗口。nCmdShow 参数可用于最小化或最大化窗口。</span><br>    <span class="hljs-built_in">ShowWindow</span>(hwnd, nCmdShow);<br><br>    <span class="hljs-comment">//程序将保留在此循环中，直到用户关闭窗口并退出应用程序。</span><br>    MSG msg = &#123; &#125;;<br>    <span class="hljs-comment">//GetMessage函数从队列的头中删除第一条消息。后三个参数用于筛选消息，几乎所有情况都默认为0。</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">GetMessage</span>(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//将击键转换为字符</span><br>        <span class="hljs-built_in">TranslateMessage</span>(&amp;msg);<br>        <span class="hljs-comment">//告知操作系统调用消息的目标窗口的窗口过程</span><br>        <span class="hljs-built_in">DispatchMessage</span>(&amp;msg);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//入参：窗口句柄，消息代码，附加数据（后两个参数）</span><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowProc</span><span class="hljs-params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (uMsg)<br>    &#123;<br>    <span class="hljs-keyword">case</span> WM_DESTROY:<br>        <span class="hljs-comment">//退出应用程序并中断消息循环。PostQuitMessage 函数在消息队列上放置WM_QUIT消息。 WM_QUIT 是一条特殊消息：它会导致 GetMessage 返回零，发出消息循环的结束信号。</span><br>        <span class="hljs-built_in">PostQuitMessage</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">case</span> WM_PAINT:<br>        &#123;<br>            PAINTSTRUCT ps;<br>            HDC hdc = <span class="hljs-built_in">BeginPaint</span>(hwnd, &amp;ps);<br><br>            <span class="hljs-comment">// 所有绘制发生在BeginPaint和EndPaint之间</span><br>            <span class="hljs-built_in">FillRect</span>(hdc, &amp;ps.rcPaint, (HBRUSH) (COLOR_WINDOW+<span class="hljs-number">1</span>));<br><br>            <span class="hljs-built_in">EndPaint</span>(hwnd, &amp;ps);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    &#125;<br>    <span class="hljs-comment">//执行默认操作。对于 WM_CLOSE，DefWindowProc 会自动调用 DestroyWindow。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);<br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://docs.microsoft.com/zh-CN/windows/win32/winmsg/about-messages-and-message-queues">关于消息和消息队列- Win32 apps</a></p><p>关闭窗口的消息流程：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E5%85%B3%E9%97%AD%E7%AA%97%E5%8F%A3%E6%B5%81%E7%A8%8B.png"alt="关闭窗口流程" /><figcaption aria-hidden="true">关闭窗口流程</figcaption></figure><p><ahref="https://docs.microsoft.com/zh-cn/windows/win32/learnwin32/managing-application-state-">管理应用程序状态- Win32 apps</a></p><h1 id="使用com">2 使用COM</h1><h2 id="com简介">COM简介</h2><p>COM 是<em>二进制标准</em>，而不是语言标准：它定义应用程序和软件组件之间的二进制接口。作为二进制标准，COM 是语言中立的，尽管它自然映射到某些 C++ 构造。</p><p>COM接口的概念与C#、Java中的接口和C#中的纯虚类类似。使用名为“接口定义语言”(IDL) 的语言定义 COM 接口。 IDL 文件由 IDL 编译器处理，该编译器生成 C++头文件。</p><h2 id="初始化">初始化</h2><p>使用 COM 的任何Windows程序都必须通过调用 <ahref="https://docs.microsoft.com/zh-CN/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex"><strong>CoInitializeEx</strong></a>函数来初始化 COM 库。 使用 COM 接口的每个线程都必须单独调用此函数。</p><p>对于 CoInitializeEx 的每个成功调用，必须在线程退出之前调用 <ahref="https://docs.microsoft.com/zh-CN/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize"><strong>CoUninitialize</strong></a>。 此函数不采用任何参数，并且没有返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HRESULT <span class="hljs-title">CoInitializeEx</span><span class="hljs-params">(LPVOID pvReserved, DWORD dwCoInit)</span></span>;<br><span class="hljs-built_in">CoUninitialize</span>();<br></code></pre></td></tr></table></figure><p>CoInitializeEx第一个参数是保留的，必须为 <strong>NULL</strong>。第二个参数指定程序将使用的线程模型。</p><table><thead><tr class="header"><th style="text-align: left;">标志</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: left;"><strong>COINIT_APARTMENTTHREADED</strong></td><td style="text-align: left;">单元线程。</td></tr><tr class="even"><td style="text-align: left;"><strong>COINIT_MULTITHREADED</strong></td><td style="text-align: left;">多线程。</td></tr></tbody></table><p>如果使用单元线程，你应该保证：</p><ul><li>你将从单个线程访问每个 COM 对象；不会在多个线程之间共享 COM接口指针。</li><li>线程将有一个消息循环。</li></ul><p>COM 方法和函数返回 <strong>HRESULT</strong>类型的值要指示成功或失败。 <strong>HRESULT</strong> 是一个 32位整数，高阶位表示成功或失败， 0表示成功，1 表示失败。少量 COM方法不返回 <strong>HRESULT</strong> 值。 例如， <ahref="https://docs.microsoft.com/zh-CN/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref"><strong>AddRef</strong></a>和 <ahref="https://docs.microsoft.com/zh-CN/windows/desktop/api/unknwn/nf-unknwn-iunknown-release"><strong>Release</strong></a>方法返回无符号长值。 Windows SDK 标头提供两个宏，<ahref="https://docs.microsoft.com/zh-CN/windows/desktop/api/winerror/nf-winerror-succeeded"><strong>SUCCEEDED</strong></a>宏和 <ahref="https://docs.microsoft.com/zh-CN/windows/desktop/api/winerror/nf-winerror-failed"><strong>FAILED</strong></a>宏，检查 COM 方法是否成功。</p><h2 id="创建对象">创建对象</h2><p><ahref="https://docs.microsoft.com/zh-cn/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance"><strong>CoCreateInstance</strong></a>函数提供用于创建对象的泛型机制。两个 COM对象可以实现相同的接口，一个对象可以实现两个或多个接口。因此，创建对象的泛型函数需要两段信息：</p><ul><li>要创建的对象。</li><li>要从对象中获取的接口。</li></ul><p>在 COM 中，通过为其分配 128位数字来标识对象或接口，该数字称为<em>全局唯一标识符</em> (GUID) 。GUID以有效唯一的方式生成。 GUID是解决如何在没有中央注册机构的情况下创建唯一标识符的问题。 GUID 有时称为<em>通用唯一标识符</em> (UUID) 。 在 COM 之前，它们用于 DCE/RPC(分布式计算环境/远程过程调用) 。 存在多个用于创建新 GUID的算法，并非所有算法都严格保证唯一性，但意外创建同一 GUID值的概率极小，实际上为零。</p><h2 id="程序示例-1">程序示例</h2><p>创建一个“打开”对话框。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shobjidl.h&gt;</span> </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> WINAPI <span class="hljs-title">wWinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE, PWSTR pCmdLine, <span class="hljs-type">int</span> nCmdShow)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化COM库</span><br>    HRESULT hr = <span class="hljs-built_in">CoInitializeEx</span>(<span class="hljs-literal">NULL</span>, COINIT_APARTMENTTHREADED | <br>        COINIT_DISABLE_OLE1DDE);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(hr))<br>    &#123;<br>        IFileOpenDialog *pFileOpen;<br><br>        <span class="hljs-comment">//创建FileOpenDialog对象。参数依次为：类标识符，NULL，执行上下文，接口标识符，指向接口的指针</span><br>        hr = <span class="hljs-built_in">CoCreateInstance</span>(CLSID_FileOpenDialog, <span class="hljs-literal">NULL</span>, CLSCTX_ALL, <br>                IID_IFileOpenDialog, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(&amp;pFileOpen));<br><span class="hljs-comment">//创建成功</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(hr))<br>        &#123;<br>            <span class="hljs-comment">//展示对话框</span><br>            hr = pFileOpen-&gt;<span class="hljs-built_in">Show</span>(<span class="hljs-literal">NULL</span>);<br><br>            <span class="hljs-comment">// 从对话框获取文件名</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(hr))<br>            &#123;<br>                <span class="hljs-comment">//实现 IShellItem 接口的 Shell 项表示用户选择的文件</span><br>                IShellItem *pItem;<br>                hr = pFileOpen-&gt;<span class="hljs-built_in">GetResult</span>(&amp;pItem);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(hr))<br>                &#123;<br>                    PWSTR pszFilePath;<br>                    <span class="hljs-comment">// 此方法以字符串的形式获取文件路径</span><br>                    hr = pItem-&gt;<span class="hljs-built_in">GetDisplayName</span>(SIGDN_FILESYSPATH, &amp;pszFilePath);<br><br>                    <span class="hljs-comment">// Display the file name to the user.</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(hr))<br>                    &#123;<br>                        <span class="hljs-comment">//显示显示文件路径的消息框</span><br>                        <span class="hljs-built_in">MessageBoxW</span>(<span class="hljs-literal">NULL</span>, pszFilePath, <span class="hljs-string">L&quot;File Path&quot;</span>, MB_OK);<br>                        <span class="hljs-built_in">CoTaskMemFree</span>(pszFilePath);<br>                    &#125;<br>                    pItem-&gt;<span class="hljs-built_in">Release</span>();<br>                &#125;<br>            &#125;<br>            pFileOpen-&gt;<span class="hljs-built_in">Release</span>();<br>        &#125;<br>        <span class="hljs-comment">//取消初始化COM库</span><br>        <span class="hljs-built_in">CoUninitialize</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管理对象的生存期">管理对象的生存期</h2><p>每个 COM 接口都必须直接或间接地从名为 <ahref="https://docs.microsoft.com/zh-CN/windows/desktop/api/unknwn/nn-unknwn-iunknown"><strong>IUnknown</strong></a>的接口继承。 此接口提供所有 COM对象必须支持的一些基线功能，它定义了三种方法：</p><ul><li><ahref="https://docs.microsoft.com/zh-CN/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)"><strong>QueryInterface</strong></a></li><li><ahref="https://docs.microsoft.com/zh-CN/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref"><strong>AddRef</strong></a></li><li><ahref="https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nf-unknwn-iunknown-release"><strong>Release</strong></a></li></ul><p>为了释放资源，C++ 使用自动析构函数，而 C# 和 Java 则使用垃圾回收。COM使用称为 <em>引用计数</em>的方法。</p><p>每个 COM 对象都维护内部计数。 这称为引用计数。引用计数跟踪对象当前处于活动状态的引用数。当引用数降至零时，对象将删除自身。 最后一部分值得重复：对象删除自身。程序永远不会显式删除对象。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-COM-manage.png"alt="COM管理过程" /><figcaption aria-hidden="true">COM管理过程</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">HRESULT <span class="hljs-title">QueryInterface</span><span class="hljs-params">(REFIID riid, <span class="hljs-type">void</span> **ppvObject)</span></span>;<br></code></pre></td></tr></table></figure><p>查询某个组件是否支持某个特定的接口。第一个参数标识客户所需的接口；第二个参数是指向接口的指针。</p><p><ahref="https://docs.microsoft.com/zh-cn/windows/win32/learnwin32/memory-allocation-in-com">COM中的内存分配 - Win32 apps</a></p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记</title>
      <link href="//posts/Notebook/Git-note/"/>
      <url>//posts/Notebook/Git-note/</url>
      
        <content type="html"><![CDATA[<p>一个开源的分布式版本控制系统</p><span id="more"></span><p class="note note-primary">二次整理自网络教程。</p><h1 id="一.基础概念">一.基础概念</h1><h2 id="工作区域">1.工作区域</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E5%8C%BA%E5%9F%9F%E6%9E%84%E6%88%901.png"alt="区域构成1" /><figcaption aria-hidden="true">区域构成1</figcaption></figure><p><strong>workspace</strong>: 工作区，电脑上当前可见的目录。</p><p><strong>Index/Stage</strong>:暂存区，临时存放变动。实际上是一个文件，保存即将提交到文件列表的信息。位于.git/index。</p><p><strong>Repository</strong>:版本库，即.git。其中HEAD指向最新放入版本库的版本。</p><p><strong>Remote</strong>: 远程仓库，托管代码的服务器。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E5%8C%BA%E5%9F%9F%E6%9E%84%E6%88%902.jpg"alt="区域构成2" /><figcaption aria-hidden="true">区域构成2</figcaption></figure><h2 id="文件状态">2.文件状态</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%811.png"alt="文件状态1" /><figcaption aria-hidden="true">文件状态1</figcaption></figure><p>GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用<strong>SHA-1算法</strong>计算文件的校验和。</p><p><strong>Untracked</strong>:文件未跟踪，位于工作区。没有加入到暂存区，不参与版本控制。通过git add变为Staged。</p><p><strong>Unmodify</strong>:文件位于版本库，未修改。即版本库中的文件快照内容与工作区中完全一致。这种文件有两个去处，如果它被修改，变为Modified；如果使用gitrm移出版本库，则成为Untracked文件。</p><p><strong>Modified</strong>:文件已修改，位于工作区。这种文件有两个去处，通过gitadd可进入暂存staged状态；使用git checkout则丢弃修改，返回unmodify或staged。</p><p><strong>Staged</strong>: 文件位于暂存区。执行gitcommit则将修改同步到版本中。执行git reset HEADfilename取消暂存,文件状态为Modified。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%812.png"alt="文件状态2" /><figcaption aria-hidden="true">文件状态2</figcaption></figure><h1 id="二.命令">二.命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init &lt;<span class="hljs-built_in">dir</span>&gt;    <span class="hljs-comment">#新建git仓库,如果带dirname，则新建目录</span><br>git <span class="hljs-built_in">clone</span> --recursive &lt;url&gt;   <span class="hljs-comment">#克隆远程仓库，带--recursive则克隆子仓库</span><br><br>git status &lt;file&gt;  <span class="hljs-comment">#查看文件状态，不带&lt;file&gt;默认查看所有文件</span><br><br>git add &lt;file&gt;      <span class="hljs-comment"># 将文件从工作区添加到暂存区</span><br>git restore &lt;file&gt;  <span class="hljs-comment"># 弃置工作区的变动</span><br><br>git <span class="hljs-built_in">rm</span> &lt;file&gt;  <span class="hljs-comment">#将文件从工作区、暂存区、版本库上均删除</span><br><br>git <span class="hljs-built_in">rm</span> --cached &lt;file&gt;  <span class="hljs-comment"># 将文件从暂存区和版本库上删除，但是本地工作区还有。再次add之后会重新添加，使用.gitignore可以避免。</span><br>git restore --staged &lt;file&gt;  <span class="hljs-comment"># 将文件的更改从暂存区撤销</span><br><br>git checkout .<br>git checkout -- &lt;file&gt;  <span class="hljs-comment">#撤销在工作区做的修改，使用暂存区或版本库的文件替换工作区的文件。如果自修改后还没有被放到暂存区，撤销修改就回到和版本库一模一样的状态。如果已经添加到暂存区后，又作了修改，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。</span><br>git checkout HEAD .<br>git checkout HEAD &lt;file&gt;  <span class="hljs-comment">#使用HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和工作区中的文件</span><br><br>git commit -m <span class="hljs-string">&quot;备注&quot;</span>    <span class="hljs-comment"># 一次提交暂存区的所有更改到版本库，并备注</span><br><br>git reset HEAD &lt;file&gt;  <span class="hljs-comment">#使用HEAD 指向的 master 分支替换暂存区，工作区不受影响</span><br><br><span class="hljs-comment"># 同步submodule</span><br>git submodule <span class="hljs-built_in">sync</span> --recursive<br>git submodule update --init --recursive<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清空一个分支的所有提交记录</span><br>git checkout --orphan lastest  <span class="hljs-comment"># 切换到全新的分支</span><br>git add .                     <span class="hljs-comment"># 缓存所有文件</span><br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span>  <span class="hljs-comment"># 提交</span><br>git branch -d main          <span class="hljs-comment"># 删除main分支</span><br>git branch -m main          <span class="hljs-comment"># 重命名当前分支为main</span><br>git push -f --set-upstream origin main      <span class="hljs-comment"># 强行推送到远程的main分支</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除某文件的所有提交记录，去除敏感信息</span><br><span class="hljs-comment"># 将 PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA 这个路径替换成要删除的文件的路径</span><br> git filter-branch --force --index-filter \<br> <span class="hljs-string">&quot;git rm --cached --ignore-unmatch PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA&quot;</span> \<br>--prune-empty --tag-name-filter <span class="hljs-built_in">cat</span> -- --all<br><span class="hljs-comment"># 强制推送</span><br>git push origin --force --all<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改上一次commit</span><br>git commit --amend<br><span class="hljs-comment"># 修改任意commit</span><br>git rebase -i HEAD<br><span class="hljs-comment"># 回退任意commit </span><br><span class="hljs-comment"># --soft 重置HEAD，不更改暂存区和工作区，回退的变更存在暂存区</span><br><span class="hljs-comment"># --hard 重置HEAD，更改暂存区和工作区，失去回退的变更</span><br><span class="hljs-comment"># --mixed 重置HEAD，更改暂存区，回退的变更存在工作区，默认参数</span><br>git reset HEAD<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启大文件存储</span><br>git lfs install<br><span class="hljs-comment"># 查看lfs追踪的文件</span><br>git lfs ls-files<br></code></pre></td></tr></table></figure><p>推荐一个动画演示的<ahref="https://learngitbranching.js.org/?locale=zh_CN">在线练习网站</a></p><h1 id="参考">参考</h1><p><ahref="https://www.runoob.com/git/git-workspace-index-repo.html">Git工作区、暂存区和版本库</a></p><p><ahref="https://www.cnblogs.com/qdhxhz/p/9757390.html">【Git】---工作区、暂存区、版本库、远程仓库</a></p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记</title>
      <link href="//posts/Notebook/Docker-note/"/>
      <url>//posts/Notebook/Docker-note/</url>
      
        <content type="html"><![CDATA[<p>一个开源的应用容器引擎</p><span id="more"></span><p class="note note-primary">二次整理自书籍和网络教程。</p><h1 id="概述">1 概述</h1><h2 id="容器生态系统">1.1 容器生态系统</h2><p>Docker现在几乎是容器的代名词。确实，是Docker将容器技术发扬光大。同时，大家也需要知道围绕Docker还有一个生态系统。Docker是这个生态系统的基石，但完善的生态系统才是保障Docker以及容器技术能够真正健康发展的决定因素。</p><p>容器生态系统：</p><ul><li><p>容器核心技术</p><p>容器核心技术是指能够让Container在host上运行起来的那些技术。</p><ul><li><p>容器规范</p><p>容器不光是Docker，还有其他容器，比如CoreOS的rkt。为了保证容器生态的健康发展，保证不同容器之间能够兼容，包含Docker、CoreOS、Google在内的若干公司共同成立了一个叫OpenContainerInitiative（OCI）的组织，其目的是制定开放的容器规范。目前OCI发布了两个规范：</p><ul><li>runtime spec</li><li>image format spec</li></ul></li><li><p>容器runtime</p><p>runtime是容器真正运行的地方。runtime需要跟操作系统kernel紧密协作，为容器提供运行环境。如果大家用过Java，可以这样来理解runtime与容器的关系：Java程序就好比是容器，JVM则好比是runtime,JVM为Java程序提供运行环境。同样的道理，容器只有在runtime中才能运行。lxc、runc和rkt是目前主流的三种容器runtime。</p><p>lxc是Linux上老牌的容器runtime。Docker最初也是用lxc作为runtime。runc是Docker自己开发的容器runtime，符合oci规范，也是现在Docker的默认runtime。rkt是CoreOS开发的容器runtime，符合OCI规范，因而能够运行Docker的容器。</p><ul><li>lxc</li><li>runc</li><li>rkt</li></ul></li><li><p>容器管理工具</p><p>容器管理工具对内与runtime交互，对外为用户提供interface，比如CLI。这就好比除了JVM，还得提供Java命令让用户能够启停应用。</p><p>runc的管理工具是docker engine。dockerengine包含后台deamon和cli两个部分。我们通常提到Docker，一般就是指的dockerengine。</p><ul><li><p>lxd</p></li><li><p>docker engine</p><ul><li><p>deamon</p></li><li><p>cli</p></li></ul></li><li><p>rkt cli</p></li></ul></li><li><p>容器定义工具</p><p>容器定义工具允许用户定义容器的内容和属性，这样容器就能够被保存、共享和重建。</p><p>docker image是Docker容器的模板，runtime依据dockerimage创建容器。dockerfile是包含若干命令的文本文件，可以通过这些命令创建出dockerimage。ACI(App Container Image)与dockerimage类似，只不过它是由CoreOS开发的rkt容器的image格式。</p><ul><li>docker image</li><li>dockerfile</li><li>ACI (App Container Image)</li></ul></li><li><p>Registries</p><p>容器是通过image创建的，需要有一个仓库来统一存放image，这个仓库就叫做Registry。</p><ul><li>Docker Registry</li><li>Docker Hub</li><li>Quay.io</li></ul></li><li><p>容器OS</p><p>由于有容器runtime，几乎所有的Linux、MACOS和Windows都可以运行容器，但这并没有妨碍容器OS的问世。容器OS是专门运行容器的操作系统。与常规OS相比，容器OS通常体积更小，启动更快。因为是为容器定制的OS，通常它们运行容器的效率会更高。目前已经存在不少容器OS,CoreOS、Atomic和Ubuntu Core是其中的杰出代表。</p><ul><li>CoreOS</li><li>Atomic</li><li>Ubuntu Core</li></ul></li></ul></li><li><p>容器平台技术</p><p>容器核心技术使得容器能够在单个host上运行，而容器平台技术能够让容器作为集群在分布式环境中运行。</p><ul><li><p>容器编排引擎</p><p>基于容器的应用一般会采用微服务架构。在这种架构下，应用被划分为不同的组件，并以服务的形式运行在各自的容器中，通过API对外提供服务。为了保证应用的高可用，每个组件都可能会运行多个相同的容器。这些容器会组成集群，集群中的容器会根据业务需要被动态地创建、迁移和销毁。</p><p>所谓编排（orchestration），通常包括容器管理、调度、集群定义和服务发现等。通过容器编排引擎，容器被有机地组合成微服务应用，实现业务需求。</p><ul><li>docker swarm</li><li>kubernetes</li><li>mesos+marathon</li></ul></li><li><p>容器管理平台</p><p>容器管理平台是架构在容器编排引擎之上的一个更为通用的平台。通常容器管理平台能够支持多种编排引擎，抽象了编排引擎的底层实现细节，为用户提供更方便的功能，比如applicationcatalog和一键应用部署等。</p><ul><li><p>Rancher</p></li><li><p>ContainerShip</p></li></ul></li><li><p>基于容器的PaaS</p><p>基于容器的PaaS为微服务应用开发人员和公司提供了开发、部署和管理应用的平台，使用户不必关心底层基础设施而专注于应用的开发。</p><ul><li>Deis</li><li>Flynn</li><li>Dokku</li></ul></li></ul></li><li><p>容器支持技术</p><ul><li><p>容器网络</p><p>容器的出现使网络拓扑变得更加动态和复杂。用户需要专门的解决方案来管理容器与容器、容器与其他实体之间的连通性和隔离性。dockernetwork是Docker原生的网络解决方案。</p><ul><li>docker network</li><li>flannel</li><li>weave</li><li>calico</li></ul></li><li><p>服务发现</p><p>动态变化是微服务应用的一大特点。当负载增加时，集群会自动创建新的容器；负载减小，多余的容器会被销毁。容器也会根据host的资源使用情况在不同host中迁移，容器的IP和端口也会随之发生变化。</p><p>在这种动态的环境下，必须要有一种机制让client能够知道如何访问容器提供的服务。这就是服务发现技术要完成的工作。</p><p>服务发现会保存容器集群中所有微服务最新的信息，比如IP和端口，并对外提供API，提供服务查询功能。</p><ul><li>etcd</li><li>consul</li><li>zookeeper</li></ul></li><li><p>监控</p><p>dockerps/top/stats是Docker原生的命令行监控工具。除了命令行，Docker也提供了statsAPI，用户可以通过HTTP请求获取容器的状态信息。</p><ul><li>docker ps/top/stats</li><li>docker stats API</li><li>sysdig</li><li>cAdvisor/Heapster</li><li>Weave Scope</li></ul></li><li><p>数据管理</p><p>容器经常会在不同的host之间迁移，如何保证持久化数据也能够动态迁移，是Rex-Ray这类数据管理工具提供的能力</p><ul><li>REX-Ray</li></ul></li><li><p>日志管理</p><p>日志为问题排查和事件管理提供了重要依据。</p><p>dockerlogs是Docker原生的日志工具。而logspout对日志提供了路由功能，它可以收集不同容器的日志并转发给其他工具进行后处理。</p><ul><li>docker logs</li><li>logspout</li></ul></li><li><p>安全性</p><p>OpenSCAP能够对容器镜像进行扫描，发现潜在的漏洞。</p><ul><li>OpenSCAP</li></ul></li></ul></li></ul><h2 id="容器核心知识">1.2 容器核心知识</h2><p>容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。开发人员在自己笔记本上创建并测试好的容器，无须任何修改就能够在生产系统的虚拟机、物理服务器或公有云主机上运行。</p><p>容器由两部分组成：</p><p>（1）应用程序本身；</p><p>（2）依赖：比如应用程序需要的库或其他软件容器在Host操作系统的用户空间中运行，与操作系统的其他进程隔离。这一点显著区别于的虚拟机。</p><p>传统的虚拟化技术，比如VMWare、KVM、Xen，目标是创建完整的虚拟机。为了运行应用，除了部署应用本身及其依赖（通常几十MB），还得安装整个操作系统（几十GB）。由于所有的容器共享同一个HostOS，这使得容器在体积上要比虚拟机小很多。另外，启动容器不需要启动整个操作系统，所以容器部署和启动速度更快、开销更小，也更容易迁移。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-VM%E4%B8%8EContainer.jpg"alt="VM与Container" /><figcaption aria-hidden="true">VM与Container</figcaption></figure><p>Docker将集装箱思想运用到软件打包上，为代码提供了一个基于容器的标准化运输系统。Docker可以将任何应用及其依赖打包成一个轻量级、可移植、自包含的容器。</p><p>只需要配置好标准的runtime环境，服务器就可以运行任何容器。这使得运维人员的工作变得更高效、一致和可重复。容器消除了开发、测试、生产环境的不一致性。</p><p>Docker的核心组件包括：</p><ul><li><p>Docker客户端：Client</p></li><li><p>Docker服务器：Docker daemon</p></li><li><p>Docker镜像：Image</p></li><li><p>Registry</p></li><li><p>Docker容器：Container</p></li></ul><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-Docker-framework.jpg"alt="Docker架构" /><figcaption aria-hidden="true">Docker架构</figcaption></figure><p>Docker采用的是Client/Server架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个Host上，客户端也可以通过socket或RESTAPI与远程的服务器通信。</p><h1 id="环境">2 环境</h1><p>容器需要管理工具、runtime和操作系统，我们的选择如下：</p><p>（1）管理工具：Docker Engine。因为Docker最流行使用最广泛。</p><p>（2）runtime :runc。Docker的默认runtime。</p><p>（3）操作系统：Ubuntu。虽然存在诸如CoreOS的容器OS，因考虑到我们目前处于初学阶段，选择大家熟悉的操作系统更为合适。等具备了扎实的容器基础知识后，再使用容器OS会更有利。</p><p>Docker分为开源免费的CE（Community Edition）版本和收费的EE（EnterpriseEdition）版本。</p><p>国内 daocloud 一键安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sSL https://get.daocloud.io/docker | sh<br></code></pre></td></tr></table></figure><h1 id="应用">3 应用</h1><h2 id="快速入门">3.1 快速入门</h2><p>运行容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 80:80 httpd<br></code></pre></td></tr></table></figure><p>访问http://localhost</p><p>上述命令执行过程如下：</p><p>（1）Docker客户端执行dockerrun命令。启动httpd容器，并将容器的80端口映射到host的80端口。</p><p>（2）Docker daemon发现本地没有httpd镜像。</p><p>（3）daemon从Docker Hub下载镜像。</p><p>（4）下载完成，镜像httpd被保存到本地。</p><p>（5）Docker daemon启动容器。</p><h2 id="使用镜像">3.2 使用镜像</h2><p>可将Docker镜像看成只读模板，通过它可以创建Docker容器。对于应用软件，镜像是软件生命周期的构建和打包阶段，而容器则是启动和运行阶段。</p><p>镜像名为REPOSITORY，完整格式为：[registry-host]:[port]/[username]/xxx。只有DockerHub上的镜像可以省略registry-host:[port]。不可以用 IMAGE ID代替。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取镜像</span><br>docker pull [镜像名]<br><span class="hljs-comment"># 查看镜像</span><br>docker images [镜像名]<br><span class="hljs-comment"># 运行容器</span><br>docker run [镜像名]<br><span class="hljs-comment"># 显示运行容器</span><br>docker ps<br>docker container <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 删除Docker host中的镜像</span><br>docker rmi [镜像名]<br><span class="hljs-comment"># 搜索Docker Hub中的镜像</span><br>docker search [镜像名]<br></code></pre></td></tr></table></figure><h2 id="dockerfile介绍">3.2.1 Dockerfile介绍</h2><p>Dockerfile是镜像的描述文件，定义了如何构建Docker镜像。</p><p>同样创建一个新镜像</p><ol type="1"><li>使用docker commit:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -it参数的作用是以交互模式进入容器，并打开终端。</span><br>docker run -it ubuntu<br><span class="hljs-comment"># 安装vi</span><br>apt-get install -y vim<br><span class="hljs-comment"># 保存为新镜像</span><br>docker commit [容器名] [新镜像命名]<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用Dockerfile:</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y vim</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -t将新镜像命名为ubuntu-with-vi-dockerfile，命令末尾的．指明build context为当前目录。Docker默认会从build context中查找Dockerfile文件，我们也可以通过-f参数指定Dockerfile的位置。</span><br>docker build -t [新镜像命名] .<br><span class="hljs-comment"># 显示镜像的构建历史，也就是Dockerfile的执行过程。</span><br>docker <span class="hljs-built_in">history</span> [镜像名]<br></code></pre></td></tr></table></figure><p>Docker会缓存已有镜像的镜像层，构建新镜像时，如果某镜像层已经存在，就直接使用，无须重新创建。如果我们希望在构建镜像时不使用缓存，可以在dockerbuild命令中加上--no-cache参数。</p><p><strong>通过Dockerfile构建镜像的过程</strong>：</p><ol type="1"><li><p>从base镜像运行一个容器。</p></li><li><p>执行一条指令，对容器做修改。</p></li><li><p>执行类似docker commit的操作，生成一个新的镜像层。</p></li><li><p>Docker再基于刚刚提交的镜像运行一个新容器。</p></li><li><p>重复2～4步，直到Dockerfile中的所有指令执行完毕。</p></li></ol><p>从这个过程可以看出，如果Dockerfile由于某种原因执行到某个指令失败了，我们也将能够得到前一个指令成功执行构建出的镜像，这对调试Dockerfile非常有帮助。我们可以运行最新的这个镜像定位指令失败的原因。</p><p><strong>Dockerfile语法</strong>：</p><ul><li><p>FROM 指定base镜像。</p></li><li><p>MAINTAINER 设置镜像的作者，可以是任意字符串。</p></li><li><p>COPY 将文件从build context复制到镜像。COPY支持两种形式： COPY srcdest与COPY ["src", "dest"]。注意：src只能指定buildcontext中的文件或目录。</p></li><li><p>ADD 与COPY类似，从buildcontext复制文件到镜像。不同的是，如果src是归档文件（tar、zip、tgz、xz等），文件会被自动解压到dest。</p></li><li><p>ENV 设置环境变量，环境变量可被后面的指令使用。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> MY_VERSION <span class="hljs-number">1.3</span> <br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y mypackage=<span class="hljs-variable">$MY_VERSION</span></span><br></code></pre></td></tr></table></figure></li><li><p>EXPOSE指定容器中的进程会监听某个端口，Docker可以将该端口暴露出来。我们会在容器网络部分详细讨论。</p></li><li><p>VOLUME将文件或目录声明为volume。我们会在容器存储部分详细讨论。</p></li><li><p>WORKDIR为后面的RUN、CMD、ENTRYPOINT、ADD或COPY指令设置镜像中的当前工作目录。</p></li><li><p>RUN 在容器中运行指定的命令。</p></li><li><p>CMD容器启动时运行指定的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效。CMD可以被dockerrun之后的参数替换。</p></li><li><p>ENTRYPOINT设置容器启动时运行的命令。Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或dockerrun之后的参数会被当作参数传递给ENTRYPOINT。</p></li></ul><h2 id="镜像示例">3.2.2 镜像示例</h2><p>hello-world是Docker官方提供的一个镜像，通常用来验证Docker是否安装成功。它还不到还不到2KB。hello-world的Dockerfile内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">COPY</span><span class="language-bash"> hello /</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/hello&quot;</span>]</span><br></code></pre></td></tr></table></figure><ol type="1"><li><p>FROM scratch 镜像是从白手起家，从0开始构建。</p></li><li><p>COPY hello / 将文件“hello”复制到镜像的根目录。</p></li><li><p>CMD ["/hello"] 容器启动时，执行/hello。</p></li></ol><p>base镜像有两层含义：（1）不依赖其他镜像，从scratch构建；（2）其他镜像可以以之为基础进行扩展。能称作base镜像的通常都是各种Linux发行版的Docker镜像，比如Ubuntu、Debian、CentOS等。一个CentOS镜像只有200MB。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-Linux-composition.jpg"alt="Linux操作系统组成" /><figcaption aria-hidden="true">Linux操作系统组成</figcaption></figure><p>Linux操作系统由内核空间和用户空间组成。内核空间是kernel,Linux刚启动时会加载bootfs文件系统，之后bootfs会被卸载掉。用户空间的文件系统是rootfs，包含我们熟悉的/dev、/proc、/bin等目录。对于base镜像来说，底层直接用Host的kernel，自己只需要提供rootfs就行了。而对于一个精简的OS,rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了。相比其他Linux发行版，CentOS的rootfs已经算臃肿的了，alpine还不到10MB。</p><p>CentOS镜像的Dockerfile的内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">ADD</span><span class="language-bash"> centos-7-docker.tar.xz /</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>不同Linux发行版的区别主要就是rootfs。比如Ubuntu14.04使用upstart管理服务，apt管理软件包；而CentOS7使用systemd和yum。这些都是用户空间上的区别，Linuxkernel差别不大。所以Docker可以同时支持多种Linux镜像，模拟出多种操作系统环境。</p><p>base镜像只是在用户空间与发行版一致，<strong>kernel版本与发行版是不同的</strong>。所有容器都共用host的kernel，在容器中没办法对kernel升级。如果容器对kernel版本有要求（比如应用只能在某个kernel版本下运行），则不建议用容器<strong>，这种场景虚拟机可能更合适</strong>。</p><p>DockerHub中99%的镜像都是通过在base镜像中安装和配置需要的软件构建出来的。比如我们现在构建一个新的镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> debian<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install emacs</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install apaches</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>]</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg"alt="构建过程" /><figcaption aria-hidden="true">构建过程</figcaption></figure><p>可以看到，新镜像是从base镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><h2 id="容器copy-on-write特性">3.2.3 容器Copy-on-Write特性</h2><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E5%AE%B9%E5%99%A8%E5%B1%82.jpg"alt="容器层" /><figcaption aria-hidden="true">容器层</figcaption></figure><p>所有对容器的改动，无论添加、删除，还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如/a，上层的/a会覆盖下层的 /a，也就是说用户只能访问到上层中的文件/a。<strong>在容器层中，用户看到的是一个叠加之后的文件系统。</strong></p><p>（1）添加文件。在容器中创建文件时，新文件被添加到容器层中。</p><p>（2）读取文件。在容器中读取某个文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。</p><p>（3）修改文件。在容器中修改已存在的文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</p><p>（4）删除文件。在容器中删除文件时，Docker也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</p><p>只有当需要修改时才复制一份数据，这种特性被称作Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，<strong>所以镜像可以被多个容器共享</strong>。</p><h2 id="run-vs-cmd-vs-entrypoint">3.2.4 RUN vs CMD vs ENTRYPOINT</h2><p>（1）RUN：执行命令并创建新的镜像层，RUN经常用于安装软件包。</p><p>（2）CMD：设置容器启动后默认执行的命令及其参数，但CMD能够被dockerrun后面跟的命令行参数替换。</p><p>（3）ENTRYPOINT：配置容器启动时运行的命令。ENTRYPOINT看上去与CMD很像，它们都可以指定要执行的命令及其参数。不同的地方在于ENTRYPOINT不会被忽略，一定会被执行，即使运行dockerrun时指定了其他命令。</p><p>我们可用两种方式指定RUN、CMD和ENTRYPOINT要运行的命令：Shell格式和Exec格式，二者在使用上有细微的区别。</p><p>Shell格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install python3    </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello world&quot;</span>    </span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello world&quot;</span></span><br></code></pre></td></tr></table></figure><p>Exec格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;apt-get&quot;</span>, <span class="hljs-string">&quot;install&quot;</span>, <span class="hljs-string">&quot;python3&quot;</span>]   </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/echo&quot;</span>, <span class="hljs-string">&quot;Hello world&quot;</span>]    </span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/echo&quot;</span>, <span class="hljs-string">&quot;Hello world&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>CMD和ENTRYPOINT推荐使用Exec格式，因为指令可读性更强，更容易理解。RUN则两种格式都可以。</p><p>实践经验：</p><p>（1）使用RUN指令安装应用和软件包，构建镜像。</p><p>（2）如果Docker镜像的用途是运行应用程序或服务，比如运行一个MySQL，应该优先使用Exec格式的ENTRYPOINT指令。CMD可为ENTRYPOINT提供额外的默认参数，同时可利用dockerrun命令行替换默认参数。</p><p>（3）如果想为容器设置默认的启动命令，可使用CMD指令。用户可在dockerrun命令行中替换此默认命令。 ## 3.2.5 分发镜像</p><p>如果执行dockerbuild时没有指定tag，会使用默认值latest。tag常用于描述镜像的版本信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag myimage-v1.9.2 myimage:1 <br>docker tag myimage-v1.9.2 myimage:1.9 <br>docker tag myimage-v1.9.2 myimage:1.9.2 <br>docker tag myimage-v1.9.2 myimage:latest<br></code></pre></td></tr></table></figure><p>打tag之后会生成新的镜像引用。用tag删除仅删除引用（只有当最后一个tag被删除时，镜像才被真正删除），用镜像ID删除会删除镜像。</p><p>DockerHub为了区分不同用户的同名镜像，镜像的registry中要包含用户名，完整格式为：[username]/xxx:tag。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登陆Docker Host</span><br>docker login -u [用户名]<br><span class="hljs-comment"># 通过docker push将镜像上传到Docker Hub</span><br>docker push [镜像名]<br></code></pre></td></tr></table></figure><p>如果想上传同一repository中所有镜像，省略tag部分就可以了。</p><h2 id="使用容器">3.4 使用容器</h2><p><strong>容器有三种名字</strong>：</p><p>CONTAINERID是容器的“短ID”，启动容器时返回的则是“长ID”。短ID是长ID的前12个字符。NAMES字段显示容器的名字，在启动容器时可以通过--name参数显式地为容器命名，如果不指定，docker会自动为容器分配名字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行容器</span><br>docker run [容器名]<br><span class="hljs-comment"># 显示容器列表,-a显示全部</span><br>docker ps<br>docker container <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 停止,发送SIGTERM信号</span><br>docker stop [容器名]<br><span class="hljs-comment"># 停止，发送SIGKILL信号</span><br>docker <span class="hljs-built_in">kill</span> [容器名]<br><span class="hljs-comment"># 启动停止状态的容器，保留容器的第一次启动时的所有参数</span><br>docker start [容器名]<br><span class="hljs-comment"># 依次执行docker stop和docker start</span><br>docker restart [容器名]<br><span class="hljs-comment"># docker run 添加参数 --restart=always意味着无论容器因何种原因退出（包括正常退出），都立即重启；该参数的形式还可以是 --restart=on-failure:3，意思是如果启动进程退出代码非0，则重启容器，最多重启3次。</span><br><span class="hljs-comment"># 处于暂停状态的容器不会占用CPU资源，直到通过docker unpause恢复运行</span><br>docker pause/unpause [容器名]<br><span class="hljs-comment"># 如果确认不会再重启此类容器，可以通过docker rm删除，一次可以指定多个</span><br>docker <span class="hljs-built_in">rm</span> [容器名]<br><span class="hljs-comment"># 如果希望批量删除所有已经退出的容器，可以执行如下命令</span><br>docker <span class="hljs-built_in">rm</span> -v $(docker ps -aq -f status=exited)<br></code></pre></td></tr></table></figure><p>可用三种方式指定容器启动时执行的命令：</p><p>（1）CMD指令。</p><p>（2）ENTRYPOINT指令。</p><p>（3）在docker run命令行中指定。</p><p><strong>容器分类</strong>：</p><p><strong>服务类容器</strong>以daemon的形式运行，对外提供服务，比如WebServer、数据库等。通过-d以后台方式启动这类容器是非常合适的。如果要排查问题，可以通过exec-it进入容器。<strong>工具类容器</strong>通常能给我们提供一个临时的工作环境，通常以run-it方式运行。</p><h2 id="attach-vs-exec">3.4.1 attach VS exec</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># attach到容器启动命令的终端</span><br>docker attach [容器名]<br><span class="hljs-comment"># 通过docker exec进入相同的容器</span><br>docker <span class="hljs-built_in">exec</span> -it [容器名] bash|sh<br></code></pre></td></tr></table></figure><p>（1）attach直接进入容器启动命令的终端，不会启动新的进程。（2）exec则是在容器中打开新的终端，并且可以启动新的进程。（3）如果想直接在终端中查看启动命令的输出，用attach；其他情况使用exec。当然，如果只是为了查看启动命令的输出，可以使用dockerlogs命令。</p><p>如果要退出，输入exit或使用ctrl+D。使用attach命令后从 stdin 中exit，会导致容器的停止；使用exec命令后从这个 stdin 中exit，不会导致容器的停止。</p><h2 id="容器状态机">3.4.2 容器状态机</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E5%AE%B9%E5%99%A8%E7%8A%B6%E6%80%81%E6%9C%BA.jpg"alt="容器状态机" /><figcaption aria-hidden="true">容器状态机</figcaption></figure><p>可以先创建容器，稍后再启动。docker start将以后台方式启动容器。dockerrun命令实际上是docker create和docker start的组合。</p><p>退出包括正常退出或者非正常退出。这里举了两个例子：启动进程正常退出或发生OOM，此时Docker会根据--restart的策略判断是否需要重启容器。但如果容器是因为执行dockerstop或docker kill退出，则不会自动重启。</p><h2 id="资源限制">3.4.3 资源限制</h2><p>与操作系统类似，容器可使用的内存包括两部分：物理内存和swap。Docker通过下面两组参数来控制容器内存的使用量。</p><p>（1）-m 或 --memory：设置内存的使用限额，例如100MB,2GB。</p><p>（2）--memory-swap：设置内存+swap的使用限额。</p><p>（3）-c 或--cpu-shares：设置容器使用CPU的权重。某个容器最终能分配到的CPU资源取决于它的cpushare占所有容器cpu share总和的比例。</p><p>（4）--cpu：设置工作线程的数量。</p><p>（5）--blkio-weight：设置容器读写磁盘的权重。</p><p>（6）bps是byte per second，每秒读写的数据量。iops是io persecond，每秒IO的次数。</p><ul><li>--device-read-bps：限制读某个设备的bps。</li><li>--device-write-bps：限制写某个设备的bps。</li><li>--device-read-iops：限制读某个设备的iops。</li><li>--device-write-iops：限制写某个设备的iops。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以下命令含义是允许该容器最多使用200MB的内存和100MB的swap。默认情况下，两组参数为 -1，即对容器内存和swap的使用没有限制。如果在启动容器时只指定 -m而不指定 --memory-swap，那么--memory-swap默认为 -m的两倍</span><br>docker run -m 200M --memory-swap=300M ubuntu<br><span class="hljs-comment"># 默认设置下，所有容器可以平等地使用host CPU资源并且没有限制。如果不指定，默认值为1024。</span><br>docker run --name <span class="hljs-string">&quot;container_A&quot;</span> -c 1024 ubuntu --cpu 1<br><span class="hljs-comment"># 限制容器写 /dev/sda的速率为30 MB/s</span><br>docker run -it --device-write-bps /dev/sda:30MB ubuntu<br></code></pre></td></tr></table></figure><h2 id="底层技术">3.4.4 底层技术</h2><p>cgroup和namespace是最重要的两种技术。cgroup实现资源限额，namespace实现资源隔离。</p><p>cgroup全称ControlGroup。Linux操作系统通过cgroup可以设置进程使用CPU、内存和IO资源的限额。--cpu-shares、-m、--device-write-bps实际上就是在配置cgroup。在/sys/fs/cgroup/cpu/docker目录中，Linux会为每个容器创建一个cgroup目录，以容器长ID命名。</p><p>namespace管理着host中全局唯一的资源，并可以让每个容器都觉得只有自己在使用它。换句话说，namespace实现了容器间资源的隔离。Linux使用了6种namespace，分别对应6种资源：</p><ul><li><p>Mount</p><p>Mountnamespace让容器看上去拥有整个文件系统。容器有自己的/目录，可以执行mount和umount命令。</p></li><li><p>UTS</p><p>UTSnamespace让容器有自己的hostname。默认情况下，容器的hostname是它的短ID，可以通过-h或--hostname参数设置</p></li><li><p>IPC</p><p>IPCnamespace让容器拥有自己的共享内存和信号量（semaphore）来实现进程间通信，而不会与host和其他容器的IPC混在一起。</p></li><li><p>PID</p><p>进程的PID不同于host中对应进程的PID，容器中PID=1的进程当然也不是host的init进程。也就是说：容器拥有自己独立的一套PID，这就是PIDnamespace提供的功能。</p></li><li><p>Network</p><p>Network namespace让容器拥有自己独立的网卡、IP、路由等资源。</p></li><li><p>User</p><p>Usernamespace让容器能够管理自己的用户，host不能看到容器中创建的用户</p></li></ul><h1 id="参考">参考</h1><p>《每天五分钟玩转Docker容器技术》--CloudMan 前四章</p><p><ahref="https://www.runoob.com/docker/docker-tutorial.html">Docker教程_菜鸟</a></p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学饮食与锻炼</title>
      <link href="//posts/Article/keep-healthy/"/>
      <url>//posts/Article/keep-healthy/</url>
      
        <content type="html"><![CDATA[<p>到底能活多久呢……</p><span id="more"></span><h1 id="基本知识">1 基本知识</h1><p>不能通过节食减肥，通过运动提高肌肉含量是关键。对男性来说，节食更是会导致其睾酮含量降至阉割水平。</p><p>食物<strong>GI</strong>，是指摄入含有100克碳水化合物（不包括纤维）的该食物后，身体2小时后的血糖上升水平。GI的缺陷在于以每百克碳水作为评估基准，但并没有综合考虑含有那么多碳水的食物实际分量有多少，这就会导致有些食物虽然GI很高，但你很难吃下去那么多。</p><p>食物<strong>GL</strong>是GI的升级版，是用来描述单位食物中可利用的碳水，在身体里的消化吸收速度和血糖应答的指标。</p><p>经常喝甜饮会引起血糖波动，让人饿得更快，进而吃得更多。含糖饮料、高糖，不仅会让人胖，而且还会影响日常行为，让人变得更懒和更不想动。</p><h1 id="平时吃">2 平时吃</h1><h2 id="中国居民膳食指南">2.1 中国居民膳食指南</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E4%B8%AD%E5%9B%BD%E5%B1%85%E6%B0%91%E8%86%B3%E9%A3%9F%E6%8C%87%E5%8D%97.PNG"alt="中国居民膳食指南" /><figcaption aria-hidden="true">中国居民膳食指南</figcaption></figure><p><strong>1）食物多样，谷类为主。</strong></p><p>每日膳食摄入应包括谷薯类、蔬菜水果类、畜禽鱼蛋奶类、大豆坚果类等食物。</p><p>平均每天建议摄入12种以上食物，每周25种以上。</p><p>每日建议摄入谷薯类食物250~400克，其中全谷物和杂豆类50~150克，薯类50~100克。</p><p>食物多样，谷类为主是平衡膳食模式的重要特征。</p><p>推荐谷物类：大米、小米、小麦、荞麦、藜麦</p><p>推荐蔬类：菠菜、西蓝花、苦瓜、丝瓜、番茄等富含维生素的蔬菜</p><p>推荐豆类：大豆、绿豆、黄豆、红豆、黑豆</p><p>推荐薯类：红薯、马铃薯、山药、芋头</p><p><strong>2）多吃蔬果、奶类、大豆</strong></p><p>蔬菜水果是平衡膳食的重要组成部分，奶类富含钙，大豆富含优质蛋白质。</p><p>餐餐有蔬菜，保证每天摄入300~500克蔬菜，深绿色蔬菜应占1/2。</p><p>天天吃水果，保证每天摄入200~350克新鲜水果，果汁不能代替鲜果。</p><p>吃各种各样的奶制品，相当于每天摄入液态奶300克。</p><p>经常吃豆制品，适量吃坚果。</p><p>“果汁不能代替鲜果”。市售的勾兑果味果汁就不说了，基本就是色素加糖加果味添加剂。不过即使是鲜榨果汁，也绝非水果的健康替代品。因为鲜榨果汁改变了水果的物理性状，某种程度上提升了水果的GI值，容易导致人们发胖或者代谢类疾病。此外，鲜榨果汁为了口感，也抛弃了一部分对健康有益的膳食纤维。</p><p><strong>3）适量吃鱼、禽、蛋、瘦肉</strong></p><p>鱼、禽、蛋和瘦肉摄入要适量。·每周吃鱼280~525克，畜禽肉280~525克，蛋类280~350克，平均每天摄入总量120~200克。</p><p>优先选择鱼和禽肉。</p><p>吃鸡蛋不弃蛋黄。2015年《美国居民膳食指南》里胆固醇限制被取消，因为目前的研究表示，通过饮食摄入的胆固醇，对血液中胆固醇的变化波动其实非常非常小，并不会最终导致心血管疾病的发生。但是蛋黄的脂肪含量仍然很高。</p><p>少吃肥肉、烟熏和腌制肉制品。</p><p><strong>4）少盐少油，控糖限酒</strong></p><p>培养清淡饮食习惯，少吃高盐和油炸食品。成人每天食盐量不超过6克，每天烹调油量控制在25~30克。</p><p>控制添加糖的摄入量，每天摄入不超过50克，最好控制在25克以下。</p><p>足量饮水，成年人每天7~8杯（1500~1700毫升），提倡饮用白开水和茶水；不喝或少喝含糖饮料。</p><p>儿童、少年、孕妇、乳母不应饮酒。成人如饮酒，男性一天饮用酒的酒精量不超过25克，女性不超过15克。</p><h2 id="dash饮食">2.2 DASH饮食</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-DASH-diet.png"alt="DASH饮食" /><figcaption aria-hidden="true">DASH饮食</figcaption></figure><p>DASH（Dietary Approaches to StopHypertension），直译就是“防治高血压饮食对策”，最早是根据1997年美国的一项大型高血压防治计划发展出来的饮食模式。</p><p>“杯”，欧美国家使用的非正式计量单位，1杯＝240毫升(美国），表格中“碗”与“杯”意义相同。“大勺”“小勺”，欧美国家使用的非正式计量单位，1大勺＝15毫升，1小勺＝5毫升(美国)。</p><p>当你喝牛奶的时候，<strong>要选择脱脂或者低脂的</strong>，并且不建议大家摄入饱和脂肪。虽然脂肪也是很重要的营养元素，但是牛奶中的脂肪较多，占总热量构成的25%以上，可以算是高脂食物了。此外，饱和脂肪算不上特别健康，而且现代都市人也真的不缺摄入饱和脂肪的机会。除了极端的饮食控制者，很少有人会摄入饱和脂肪不足，而更好的脂肪来源是鱼类、坚果等不饱和脂肪。</p><h2 id="规律睡眠">2.3 规律睡眠</h2><p>香港中文大学一项针对运动与睡眠的研究发现，虽然坚持运动可以明显降低超重和肥胖的概率，但对睡眠不足的人来说，活动水平就算比较高，也很难让人瘦——这一点，在男性身上尤其明显。</p><p>因为昼夜节律紊乱本身也会扰乱身体的相关激素分泌，导致身体往容易胖的激素水平调节。</p><h1 id="健身吃">3 健身吃</h1><h2 id="注意事项">3.1 注意事项</h2><p><strong>1）忌脂肪</strong></p><p>在运动期间，为了达到更好的训练效果，健身前后2小时，请尽量避免摄入脂肪！</p><p>训练后肌肉蛋白的合成速率大大提高，人体也会进行超量恢复，是最佳的进食时间，此时应该多摄入高GI碳水化合物和蛋白质来满足更多的胰岛素分泌和身体糖原合成储备。日常饮食中可以适量摄入脂肪，不过训练前后2小时，请大家尽可能少吃脂肪，巧克力、士力架、奶糖、全脂牛奶什么的，并不是运动期间的合适食物。</p><p><strong>2）吃饭时间</strong></p><p>同样一碗饭，运动后吃，会变成减肥的能源；平时吃，会变成肥肉！也就是说，如果你一天摄入的食物总量不变，你运动后吃，肯定会比其他时间吃要瘦得多。</p><p><strong>3）运动顺序</strong></p><p>对于增肌而言，先做无氧；对于减脂而言，先做有氧。</p><h2 id="健身前">3.2 健身前</h2><p>对于<strong>塑性健身</strong>，一般训练者在<strong>训前2小时摄入低GI的食物</strong>，可以增加训练中的耐力和脂肪燃烧。</p><p>对于<strong>减脂</strong>，<strong>空腹训练</strong>更有益于脂肪的消耗，并且能提高静息代谢率。空腹运动时多喝水，不仅更有利于减脂，还可以避免脂肪动员消耗过程中产生的过多酮体给身体带来的副作用。</p><p>对以<strong>增肌</strong>，<strong>训前即刻服用必需氨基酸+碳水化合物</strong>（实际上也就是蛋白粉+糖），比训练结束后再服用，更有利于肌肉蛋白的合成，能促进肌肉增长。力量训练后，身体的肌肉蛋白合成率会增长近300%，是肌肉合成最快的时候，此时目标肌群里的氨基酸含量越高，自然越有利于肌肉的合成。如果想极限增肌，在训练前摄入蛋白质+碳水化合物，最有利于刺激肌肉的生长。也就是说，训练前来一杯运动饮料冲服的蛋白粉，就非常不错。</p><p><strong>有氧运动前来1~2杯绿茶</strong>，不仅可以加速燃脂，对提高运动表现也很有好处。喝绿茶可以促进身体对脂肪的利用，让你的燃脂能力更高。不过训练后就不建议喝绿茶了，训练后一般需要即刻进食，来促进恢复与生长，还要好好补充蛋白质。而绿茶里面的鞣酸，会与食物中的蛋白质结合生成一种块状的、不易消化吸收的鞣酸蛋白，阻碍你的吸收，还让你便秘。</p><h2 id="健身后">3.3 健身后</h2><p>训后饮食最重要的有三点：多吃高GI碳水化合物；多吃蛋白质；尽量不吃脂肪。有氧运动和力量训练后饮食模式基本一样，只是力量训练后应多吃些蛋白质。</p><p><strong>有氧运动后</strong>，必须吃东西，不吃更胖。原因是有氧运动后及时补充碳水化合物和蛋白质，身体会把吃下去的食物变成下次运动的能源储备，帮你越吃越瘦；相反，你平时不运动时吃同等的食物则容易被身体储存为脂肪。</p><p><strong>力量训练后</strong>，立即补充碳水化合物和蛋白质→身体分泌更多胰岛素→更好地促进肌肉吸收氨基酸和恢复糖原→肌肉更好地合成、糖原储备更多→训练效果更好、下次运动更高效。因为运动后的胰岛素分泌，不会囤积脂肪，反而会优先促进肌肉吸收氨基酸和恢复糖原，增加肌肉合成，所以运动后是个比较特殊的时段，更推荐此时吃高GI食物。</p><p>运动后的那一餐，可以选择吃口感好的精米精面，搭配少油低脂肪的瘦肉、鸡蛋来补充必需的蛋白质就可以。</p><h2 id="简易饮食指南">3.4 简易饮食指南</h2><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E5%81%A5%E8%BA%AB%E9%A5%AE%E9%A3%9F%E6%8C%87%E5%8D%97.JPG"alt="健身饮食指南" /><figcaption aria-hidden="true">健身饮食指南</figcaption></figure><h1 id="食物推荐">4 食物推荐</h1><h2 id="原则">4.1 原则</h2><p>平时吃：热量适中，饱腹感强，营养搭配合理，GI值较低，有助于控制血糖波动，更扛饿；</p><p>训后吃：高GI碳水化合物、高蛋白、低脂肪，能更好地促进糖原、肌肉合成和身体恢复，横菜为主，可以大快朵颐；</p><p>随便吃：吃热量低，饱腹感强，解馋不怕胖的食物。</p><h2 id="技巧">4.2 技巧</h2><p>如果是真的全麦面包，那么食品配料表的第一位应该写的是全麦粉，而非小麦粉。</p><p>鸭脖是个好东西，从营养成分来看，基本不含脂肪和碳水化合物，而且高蛋白、低热量、低GI，具备了健康美食的所有标准，非常适合作为零食。</p><p>咖喱中的姜黄素，可以起到消毒、杀菌的作用，对于训练后的肌肉酸疼和炎症等也有很好的缓解效果。</p><p>牛板筋里面几乎都是蛋白质。</p><p>运动前适量摄入含有小苏打的食物，比如苏打饼干什么的，对提高运动表现会更有帮助。</p><h1 id="锻炼计划">5 锻炼计划</h1><h1 id="参考资料">6 参考资料</h1><p>硬派健身 / 斌卡</p><p>囚徒健身系列 / Paul Wade</p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>估计</title>
      <link href="//posts/Article/estimation/"/>
      <url>//posts/Article/estimation/</url>
      
        <content type="html"><![CDATA[<p>估计</p><span id="more"></span><p class="note note-primary">二次整理自课程学习。</p><h1 id="parameter-estimation">Parameter Estimation</h1><p>假定概率密度的特定形式（比如高斯分布），只需要估计参数（比如均值、方差）即可。比如Bayes和ML。</p><p>Criterion for Classification Decision Rule：</p><ul><li><p>MAP (Maximum A Posteriori) Criterion</p></li><li><p>ML (Maximum Likelihood) Criterion</p></li><li><p>Bayes Criterion</p></li><li><p>Other Criterion</p></li></ul><p>假定总体<span class="math inline">\(X\)</span>的PDF为<spanclass="math inline">\(f(x\mid\theta)\)</span>，观测到一组样本<spanclass="math inline">\((X_1,X_2,...,X_n)=(x_1,x_2,...,x_n)\)</span>，需要估计参数<spanclass="math inline">\(\theta\)</span>。</p><h2 id="bayes">Bayes</h2><p><strong>贝叶斯估计</strong>是贝叶斯学派观点。<spanclass="math inline">\(\theta\)</span>是随机的，只能估计其分布。 <spanclass="math display">\[\pi (\boldsymbol \theta|\boldsymbol x)=\frac {f(\boldsymbolx|\boldsymbol \theta)\pi (\boldsymbol \theta)}{m(\boldsymbol x)}=\frac{f(\boldsymbol x|\boldsymbol \theta)\pi (\boldsymbol \theta)}{\intf(\boldsymbol x|\boldsymbol \theta)\pi (\boldsymbol \theta)d(\boldsymbol\theta)}\]</span> $() <span class="math inline">\(为参数\)</span> $的先验分布（prior distribution），表示对参数$ <spanclass="math inline">\(的主观认识，是非样本信息。\)</span> (|x) <spanclass="math inline">\(为参数\)</span> <spanclass="math inline">\(的后验分布（posteriordistribution）。因此，贝叶斯估计可以看作是，在假定\)</span> $服从 <spanclass="math inline">\(\pi (\boldsymbol \theta)\)</span>的先验分布前提下，根据样本信息去校正先验分布，得到后验分布 <spanclass="math inline">\(\pi (\boldsymbol \theta|\boldsymbol x)\)</span>。由于后验分布是一个条件分布，通常我们取后验分布的期望作为参数的估计值。</p><p>使用<strong>贝叶斯风险</strong>用来度量一个估计量的好坏。对于待估参数<spanclass="math inline">\(\theta\)</span>和<spanclass="math inline">\(x\)</span>，参数<spanclass="math inline">\(\theta\)</span>的贝叶斯估计值为<spanclass="math inline">\(\hat{\theta}\)</span>，那么贝叶斯风险为： <spanclass="math display">\[\R=E_{\theta,x}[l(\theta,\hat{\theta})]\]</span> <spanclass="math inline">\(l\)</span>为评价风险的损失函数。</p><h2 id="map">MAP</h2><p>可以看作Bayes的特殊情况。</p><p>贝叶斯估计中后验分布的计算往往是非常棘手的。<strong>最大后验（MAP）估计</strong>利用了无法从观测样本获得的来自先验的信息，是贝叶斯估计的一种近似解。使后验分布<spanclass="math inline">\(\pi (\boldsymbol \theta|\boldsymbolx)\)</span>极大化的<spanclass="math inline">\(\hat{\theta}_{map}\)</span>是<spanclass="math inline">\(\theta\)</span>的MAP估计值。 <spanclass="math display">\[\boldsymbol {\hat \theta}_{map}=arg \underset {\boldsymbol \theta}{\max}\pi (\boldsymbol \theta|\boldsymbol x)=arg \underset {\boldsymbol\theta}{\max} \frac {f(\boldsymbol x|\boldsymbol \theta)\pi (\boldsymbol\theta)}{m(\boldsymbol x)}=arg \underset {\boldsymbol \theta}{\max}{f(\boldsymbol x|\boldsymbol \theta)\pi (\boldsymbol \theta)}=arg\underset {\boldsymbol \theta}{\max} (\log {f(\boldsymbol x|\boldsymbol\theta)+ \log \pi (\boldsymbol \theta))}\]</span> 如果将机器学习结构风险中的正则化项对应为上式的<spanclass="math inline">\(\log \pi (\boldsymbol\theta)\)</span>，那么带有这种正则化项的ML学习就可以被解释为MAP。</p><h2 id="ml">ML</h2><p>可以看作MAP的特殊情况。</p><p><strong>极大似然（ML）估计</strong>是频率学派观点。<spanclass="math inline">\(\theta\)</span>客观存在，只是未知。</p><p>使样本<spanclass="math inline">\((X_1,X_2,...,X_n)=(x_1,x_2,...,x_n)\)</span>更容易观测到（发生概率更大）的<spanclass="math inline">\(\hat{\theta}_{ml}\)</span>是<spanclass="math inline">\(\theta\)</span>的ML估计值。 <spanclass="math display">\[L(\boldsymbol \theta|\boldsymbol x)=f(\boldsymbol x|\boldsymbol\theta)=f(x_1,x_2,\dots,x_n|\boldsymbol\theta)=\prod^{n}_{i=1}f(x_i|\boldsymbol \theta)\]</span> <span class="math display">\[\boldsymbol {\hat \theta}_{mle}=arg\underset {\boldsymbol \theta}{\max}L(\boldsymbol \theta|\boldsymbol x)\]</span></p><h2 id="eg.-mapml">eg. MAP&amp;ML</h2><p>拿到一枚未知的硬币，估计其正面出现概率<spanclass="math inline">\(\theta\)</span>。</p><p>观测到样本<spanclass="math inline">\(X\)</span>：反正正正正反正正正反</p><p>似然函数：<spanclass="math inline">\(f(X\mid\theta)=(1-\theta)\times\theta\times\theta\times\theta\times\theta\times(1-\theta)\times\theta\times\theta\times\theta\times(1-\theta)=\theta^7(1-\theta)^3\)</span></p><p>求<spanclass="math inline">\(f(X\mid\theta)\)</span>图像和使其最大的<spanclass="math inline">\(\theta\)</span>值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br>y = x**<span class="hljs-number">7</span>*(<span class="hljs-number">1</span>-x)**<span class="hljs-number">3</span><br><br>plt.plot(x,y)<br>plt.show()<br><br><span class="hljs-built_in">print</span>(x[y.argmax()])<br></code></pre></td></tr></table></figure><blockquote><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-30-ML估计值.png" /></p><p>0.696969696969697</p></blockquote><p>得出使其最大的<spanclass="math inline">\(\theta\)</span>大约是0.7。此即ML估计。</p><p>引入<spanclass="math inline">\(\theta\)</span>的先验分布为高斯分布，即<spanclass="math inline">\(f(\theta)\)</span>为均值0.5，方差0.1的高斯函数。<span class="math display">\[f(\theta)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(\theta-\mu)^2}{2\sigma^2}},\mu=0.5,\sigma=0.1\]</span> 求<spanclass="math inline">\(f(X\mid\theta)f(\theta)\)</span>图像和使其最大的<spanclass="math inline">\(\theta\)</span>值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br>y = x**<span class="hljs-number">7</span>*(<span class="hljs-number">1</span>-x)**<span class="hljs-number">3</span><br><br>sigma = <span class="hljs-number">0.1</span><br>mu = <span class="hljs-number">0.5</span><br>gauss = <span class="hljs-number">1</span>/(sigma * np.sqrt(<span class="hljs-number">2</span>*np.pi)) * np.power(np.e,-((x-mu)**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*sigma**<span class="hljs-number">2</span>))<br>y *= gauss<br><br>plt.plot(x,y)<br>plt.show()<br><br><span class="hljs-built_in">print</span>(x[y.argmax()])<br></code></pre></td></tr></table></figure><blockquote><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-30-MAP估计值.png" /></p><p>0.5555555555555556</p></blockquote><p>得出使其最大的<spanclass="math inline">\(\theta\)</span>大约是0.56。此即MAP估计。</p><h2 id="mixture-models">Mixture models</h2><p>以Gaussian mixturemodel为例，一个复杂的曲线可以用若干个组合起来的高斯函数来逼近。</p><h2 id="em">EM</h2><p>当模型的变量都是观测变量时，可以直接通过前面的ML、MAP估计模型参数。但是当模型包含隐变量时，就不能简单的使用这些估计方法。比如K-means算法，除了给定的样本（也就是观测变量）<spanclass="math inline">\(X\)</span>以及参数<spanclass="math inline">\(\theta\)</span>（也就是那些聚类的中心）之外，还包含一个隐变量（记为<spanclass="math inline">\(Z\)</span>，每个样本的所属类别）。</p><p>Expectation-Maximum是最常见的<strong>隐变量</strong>估计方法，在机器学习中有极为广泛的用途，例如常被用来学习GMM的参数、隐式马尔科夫算法（HMM）、LDA主题模型的变分推断等等。</p><p>给定一组观测数据记为<spanclass="math inline">\(X=(x_1,x_2,\dots,x_n)\)</span> 及参数 <spanclass="math inline">\(\theta\)</span> 。因为 <spanclass="math inline">\(x_1,x_2,\dots,x_n\)</span>是独立同分布，所以有以下对数似然函数： <span class="math display">\[\begin{align} \ell(\theta|X)&amp;=\log{P\left(X|\theta\right)}=\log\left( \prod_{i=1}^n P\left(x_i|\theta\right) \right) =\sum_{i=1}^n\log P(x_i|\theta) \end{align}\]</span> 可以通过极大似然估计来求解最优参数，即： <spanclass="math display">\[\begin{align} \hat{\theta}&amp;=\arg \max_\theta\log{\ell\left(\theta|X\right)} =\arg \max_\theta \sum_{i=1}^n \logP(x_i|\theta) \end{align}\]</span> 但是由于隐变量的存在， <spanclass="math inline">\(\log{P\left(X|\theta\right)}\)</span> 变为 <spanclass="math display">\[\begin{align} \log{P\left(X\middle|\theta\right)}&amp;=\log{\sum_{Z}\P\left(X,Z|\theta\right)}\\&amp;=\log{\left(\sum_{Z}\P\left(X|\theta,Z\right)P\left(Z|\theta\right)\right)} \end{align}\]</span>下面构造一个容易优化的——关于对数似然函数的——下界函数，通过不断的优化这个下界，迭代逼近最优参数。</p><p>引入隐变量 <span class="math inline">\(Z\)</span> 的概率分布 <spanclass="math inline">\(q(Z)\)</span> ，满足 <span class="math display">\[\sum_Z q(Z)=1\]</span> 并且以下等式成立 <span class="math display">\[P\left(X|\theta\right)=\frac{P\left(X,Z|\theta\right)}{P\left(Z|X,\theta\right)}=\frac{P\left(X,Z|\theta\right)/q\left(Z\right)}{P\left(Z|X,\theta\right)/q\left(Z\right)}\]</span> 两边同时取对数 <span class="math display">\[\begin{align}\log{P\left(X|\theta\right)}&amp;=\log{\frac{P\left(X,Z|\theta\right)/q\left(Z\right)}{P\left(Z|X,\theta\right)/q\left(Z\right)}}\end{align}\]</span> 同时求两边在 Z 上的期望 <span class="math display">\[\mathbb{E}_Z\left[\log{P\left(X|\theta\right)}\right]=\mathbb{E}_Z\left[\log{\frac{P\left(X,Z|\theta\right)/q\left(Z\right)}{P\left(Z|X,\theta\right)/q\left(Z\right)}}\right]\]</span> 因为 <spanclass="math inline">\(\log{P\left(X|\theta\right)}\)</span> 与 Z无关，所以求期望仍然不变： <span class="math display">\[\begin{align}\mathbb{E}_Z\left[\log{P\left(X|\theta\right)}\right]&amp;=\sum_{Z}{q\left(Z\right)\log{P\left(X|\theta\right)}}\\&amp;=\log{P\left(X|\theta\right)}\sum_{Z} q\left(Z\right)\\&amp;=\log{P\left(X|\theta\right)} \end{align}\]</span> 然后将右边展开 <span class="math display">\[\begin{align}\mathbb{E}_Z\left[\log{\frac{P\left(X,Z|\theta\right)/q\left(Z\right)}{P\left(Z|X,\theta\right)/q\left(Z\right)}}\right]&amp;=\sum_{Z}{q\left(Z\right)\log{\frac{P\left(X,Z|\theta\right)/q\left(Z\right)}{P\left(Z|X,\theta\right)/q\left(Z\right)}}}\\&amp;=\sum_{Z}{q\left(Z\right)\log{\frac{P\left(X,Z|\theta\right)}{q\left(Z\right)}}}-\sum_{Z}{q\left(Z\right)\log{\frac{P\left(Z|X,\theta\right)}{q\left(Z\right)}}}\\&amp;=\sum_{Z}{q\left(Z\right)\log{\frac{P\left(X,Z|\theta\right)}{q\left(Z\right)}}}+\sum_{Z}{q\left(Z\right)\log{\frac{q\left(Z\right)}{P\left(Z|X,\theta\right)}}}\\&amp;=\sum_{Z}{q\left(Z\right)\log{\frac{P\left(X,Z|\theta\right)}{q\left(Z\right)}}}+KL\left(q\left(Z\right)||P\left(Z|X,\theta\right)\right)\\&amp;\geq\sum_{Z}{q\left(Z\right)\log{\frac{P\left(X,Z|\theta\right)}{q\left(Z\right)}}}\end{align}\]</span></p><blockquote><p>相对熵 <span class="math inline">\(KL\left(p||q\right)=\sum_{x\inX}{p\left(x\right)log{\frac{p\left(x\right)}{q\left(x\right)}}}\)</span></p></blockquote><p>由此得到对数似然函数的下界。并且当 <spanclass="math inline">\(KL\left(q\left(Z\right)||P\left(Z|X,\theta\right)\right)= 0\)</span>，上式可以取到等号，由相对熵的性质可知，相对熵为0，也就是<span class="math inline">\(q(Z)=P(Z|X,\theta)\)</span>。</p><p>其中 <span class="math inline">\(q(Z)\)</span> 是<spanclass="math inline">\(Z\)</span>的概率分布，但是因为无法观测<spanclass="math inline">\(Z\)</span> ，所以<spanclass="math inline">\(q(Z)\)</span>未知，可以假设其等于 <spanclass="math inline">\(P(Z|X,\theta)\)</span> ，也就是<spanclass="math inline">\(Z\)</span>关于给定<spanclass="math inline">\(X\)</span>与<spanclass="math inline">\(\theta\)</span>的后验，且<spanclass="math inline">\(\theta\)</span>是由初始值<spanclass="math inline">\(\theta^{(0)}\)</span>一次次迭代计算而来，所以此处的 <spanclass="math inline">\(\theta\)</span> 是迭代<spanclass="math inline">\(i\)</span>次后的值。 <span class="math display">\[q(Z) = P(Z|X,\theta^{(i)})\]</span> 以上，就是EM算法中E步的由来。</p><p>然后通过极大似然估计得到： <span class="math display">\[\begin{align}\hat{\theta}&amp;=\arg{\max_\theta{\sum_{Z}{q\left(Z\right)\log{\frac{P\left(X,Z|\theta\right)}{q\left(Z\right)}}}}}\\&amp;=\arg{\max_\theta{\sum_{Z}{P\left(Z|X,\theta^{\left(i\right)}\right)\log{\frac{P\left(X,Z|\theta\right)}{P\left(Z|X,\theta^{\left(i\right)}\right)}}}}}\\&amp;=\arg{\max_\theta{\sum_{Z}\P\left(Z|X,\theta^{\left(i\right)}\right)\left(\log{P\left(X,Z|\theta\right)}-\log{P\left(Z|X,\theta^{\left(i\right)}\right)}\right)}}\\&amp;=\arg{\max_\theta{\sum_{Z}{P\left(Z|X,\theta^{\left(i\right)}\right)\log{P\left(X,Z|\theta\right)}}}}\\&amp;=\arg{\max_\theta{\mathbb{E}_{Z|X,\theta^{\left(i\right)}}\left[\log{P\left(X,Z|\theta\right)}\right]}}\end{align}\]</span> 令<span class="math inline">\(\hat{\theta}=\theta^{(i+1)}\)</span>，就得到了M步的公式 <span class="math display">\[\theta^{(i+1)}=\arg{\max_\theta{\mathbb{E}_{Z|X,\theta^{\left(i\right)}}\left[\log{P\left(X,Z|\theta\right)}\right]}}\]</span>EM算法可以<strong>保证收敛</strong>到一个稳定点，但是却不能保证收敛到全局的极大值点，因此它是<strong>局部最优</strong>的算法。</p><h2 id="eg.-em">eg. EM</h2><p>假设我们有A，B两枚硬币，其中正面朝上的概率分别为<spanclass="math inline">\(\theta_{A},\theta_{B}\)</span>，这两个参数即为需要估计的参数。我们设计5组实验，每次实验投掷5次硬币，但是每次实验都不知道用哪一枚硬币进行的本次实验。投掷结束后，会得到一个数组<span class="math inline">\(x=(x_{1},x_{2},...,x_{5})\)</span>，表示每组实验有几次硬币正面朝上，因此 <span class="math inline">\(0\leqx_{i}\leq 5\)</span> 。</p><p>虽然我们不知道每组实验用的是哪一枚硬币，但如果我们用某种方法<strong>猜测每组实验是哪个硬币投掷的</strong>，我们就可以将数据缺失的估计问题转化成一个<strong>最大似然问题和完整参数估计问题</strong>。</p><p>实验结果：</p><table><thead><tr class="header"><th>实验编号</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>1</td><td>3正2反</td></tr><tr class="even"><td>2</td><td>2正3反</td></tr><tr class="odd"><td>3</td><td>1正4反</td></tr><tr class="even"><td>4</td><td>3正2反</td></tr><tr class="odd"><td>5</td><td>2正3反</td></tr></tbody></table><p>首先，随机选取 <spanclass="math inline">\(\theta_{A},\theta_{B}\)</span>的初始值，比如 <spanclass="math inline">\(\theta_{A}=0.2,\theta_{B}=0.7\)</span> 。</p><p><strong>E步</strong></p><p>计算在当前的预估参数下，隐变量（是A硬币还是B硬币）的每个值出现的概率。</p><p>对于第一组实验，3正面2反面。</p><ul><li>如果是A硬币得到这个结果的概率为： <spanclass="math inline">\(0.2^3\times0.8^2=0.00512\)</span></li><li>如果是B硬币得到这个结果的概率为： <spanclass="math inline">\(0.7^3\times0.3^2=0.03087\)</span></li></ul><p>因此，第一组实验结果是A硬币得到的概率为：<spanclass="math inline">\(0.00512 / (0.00512 +0.03087)=0.14\)</span>，第一组实验结果是B硬币得到的概率为：<spanclass="math inline">\(0.03087/ (0.00512 + 0.03087)=0.86\)</span>。</p><p>整个5组实验的A,B投掷概率如下：</p><table><thead><tr class="header"><th>实验编号</th><th>是A硬币的概率</th><th>是B硬币的概率</th></tr></thead><tbody><tr class="odd"><td>1</td><td>0.14</td><td>0.86</td></tr><tr class="even"><td>2</td><td>0.61</td><td>0.39</td></tr><tr class="odd"><td>3</td><td>0.94</td><td>0.06</td></tr><tr class="even"><td>4</td><td>0.14</td><td>0.86</td></tr><tr class="odd"><td>5</td><td>0.61</td><td>0.39</td></tr></tbody></table><p><strong>M步</strong></p><p>计算硬币投掷正反的期望：</p><table><thead><tr class="header"><th>实验编号</th><th>A硬币下正/反期望</th><th>B硬币下正/反期望</th></tr></thead><tbody><tr class="odd"><td>1</td><td>0.42 0.28</td><td>2.58 1.72</td></tr><tr class="even"><td>2</td><td>1.22 1.83</td><td>0.78 1.17</td></tr><tr class="odd"><td>3</td><td>0.94 3.76</td><td>0.06 0.24</td></tr><tr class="even"><td>4</td><td>0.42 0.28</td><td>2.58 1.72</td></tr><tr class="odd"><td>5</td><td>1.22 1.83</td><td>0.78 1.17</td></tr><tr class="even"><td>总计</td><td>4.22 7.98</td><td>6.78 6.02</td></tr></tbody></table><p>通过计算期望把隐变量（是A硬币还是B硬币）消除掉了。 <spanclass="math display">\[\theta_{A} =4.22/(4.22+7.98)=0.35\]</span> <span class="math display">\[\theta_{B} =6.78/(6.78+6.02)=0.5296875\]</span>这一步中，我们根据E步中求出的A硬币、B硬币概率分布，依据最大似然概率法则去估计<spanclass="math inline">\(\theta_{A},\theta_{B}\)</span>。</p><p>最后，一直循环迭代E步M步，直到<spanclass="math inline">\(\theta_{A},\theta_{B}\)</span>不更新为止。</p><h1 id="non-parametric-density-estimation">Non-parametric DensityEstimation</h1><p>不假定关于概率密度的任何知识。比如核密度估计和最近邻规则。</p><h1 id="参考资料">参考资料</h1><p><ahref="https://zhuanlan.zhihu.com/p/61593112">极大似然估计和贝叶斯估计</a></p><p><ahref="https://zhuanlan.zhihu.com/p/159189617">机器学习准则（期望风险、经验风险、结构风险）</a></p><p><a href="https://zhuanlan.zhihu.com/p/40991784">EM算法详解</a></p><p><ahref="https://zhuanlan.zhihu.com/p/85236423">EM算法原理及推导</a></p><p><ahref="https://blog.csdn.net/DD_PP_JJ/article/details/109722504">概率公式中的分号、逗号、竖线</a></p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非参数</title>
      <link href="//posts/Article/nonparametric/"/>
      <url>//posts/Article/nonparametric/</url>
      
        <content type="html"><![CDATA[<p>nonparametric</p><span id="more"></span><p>摘录<em>Invertible Neural BRDF for Object InverseRendering</em><sup><a class=n href="#ref1">[1]</a></sup>部分原文如下：</p><ol type="1"><li><em>即使我们假设物体的几何形状已知或已经估计，联合估计剩下的反射率和照明的困难仍然存在。关键挑战在于两者之间固有的模糊性，包括颜色和频率<sup><a class=n href="#ref3">[3]</a></sup>。过去的方法依赖于强约束表示，例如，通过采用基于物理或数据驱动的低维参数模型（例如，朗伯和球面谐波）。在这些紧凑的参数模型之上，通常需要强大分析但简单的约束，以更好地调节联合估计，例如真实世界反射率的变化上的高斯混合以及<strong>非参数</strong>照明上的梯度和熵先验<sup><a class=n href="#ref2">[2]</a></sup>。</em></li><li><em>理想情况下，我们希望对反射率和照明都使用高维表示，以便估计精度不受其参数形式的限制。挑战因此变为使用常见的高维表示来表达复杂的真实世界反射率，同时驯服真实世界反射率和照明的可变性，以便可以从单个图像中估计它们。<strong>非参数</strong>（即列表）BRDF表示和规则深度生成模型（如生成对抗网络和变分自动编码器）不适用于该任务，因为它们无法在BRDF的角度域中提供用于足够采样的直接方法。</em></li><li><em>在本文中，我们介绍了可逆神经BRDF模型（iBRDF），用于从物体外观的单个图像中联合估计反射率和照明。我们表明，将表达能力优于<strong>非参数</strong>表示的可逆可微模型与具有可微渲染的MAP公式相结合，可以实现高效、准确的真实对象逆渲染。我们通过将其双向反射分布函数（BRDF）建模为可逆神经网络，即基于归一化流的非线性变换参数分布<sup><a class=n href="#ref5">[5]</a></sup><sup><a class=n href="#ref6">[6]</a></sup><sup><a class=n href="#ref7">[7]</a></sup>，来利用反射的固有结构。与以往使用低维参数模型的方法形成鲜明对比的是，深度生成神经网络对底层分布不作任何假设，并通过对简单输入分布应用一系列非线性变换来表示BRDF的复杂角度分布。我们将证明，这为我们提供了与<strong>非参数</strong>表示相当或更高的表达能力。此外，模型的可逆性确保了亥姆霍兹相互作用和能量守恒，这对于物理合理性至关重要。此外，尽管我们在本文中没有讨论，但由于iBRDF的双向、可微双向单射，这种可逆性使其也适用于正向渲染应用。我们还表明，这种<strong>非参数</strong>BRDF模型的多个“波瓣”可以组合起来表达真实世界BRDF的复杂颜色和频率特性。此外，为了模拟真实材料反射率变化的内在结构，我们对该生成模型进行条件处理，以提取参数嵌入空间。在简单的参数分布中嵌入BRDF为我们估计反射率提供了强大的先验。</em></li><li><em>对于照明，我们采用<strong>非参数</strong>表示，将其建模为角度空间中的点源集合（即，等矩形环境地图）。过去的方法严重依赖于可以转化为分析约束的简单假设，以克服与这种<strong>非参数</strong>照明表示相关的高维复杂性。相反，我们通过利用深度神经网络（即深度图像先验<sup><a class=n href="#ref8">[8]</a></sup>）诱导的结构偏差来约束照明以表示真实的自然环境。我们通过将照明编码为编码器-解码器深度神经网络的输出，并在固定的随机图像输入上优化其参数，来预先设置深度照明。</em></li><li><em>综上所述，我们的技术贡献包括</em><ul><li><em>一个新型BRDF模型，具有<strong>非参数</strong>表示的表达能力和分析分布模型的计算简单性</em></li><li><em>一个反射先验，基于嵌入这种新型BRDF模型</em></li><li><em>一个照明先验，其利用神经网络结构偏差</em></li><li><em>以及基于这些新模型和先验的反射率和照明的完全可微联合估计框架</em></li></ul></li><li><em>为了描述表面点的局部光传输，Nicodemus<sup><a class=n href="#ref9">[9]</a></sup>引入了双向反射分布函数（BRDF），作为入射光和出射光方向的4D反射函数。此后，人们提出了许多参数反射模型，为这一抽象函数提供了解析表达式。Phong<sup><a class=n href="#ref10">[10]</a></sup>和Blinn模型<sup><a class=n href="#ref11">[11]</a></sup>等经验模型为正向渲染提供了极大的简单性，但无法捕捉真实材料的复杂反射率特性，因此不适合进行反射率估计。基于物理的反射模型，如TorranceSparrow<sup><a class=n href="#ref12">[12]</a></sup>、CookTorrance<sup><a class=n href="#ref13">[13]</a></sup>和Disney materialmodels<sup><a class=n href="#ref14">[14]</a></sup>严格模拟了光与微表面几何形状的相互作用。虽然这些模型捕捉了具有挑战性的反射特性，如非镜面反射，但其精度仅限于某些类型的材料。</em><em>相反，数据驱动的反射率模型通过拟合基函数（例如Zernike多项式<sup><a class=n href="#ref15">[15]</a></sup>和球谐函数<sup><a class=n href="#ref16">[16]</a></sup><sup><a class=n href="#ref3">[3]</a></sup>）或从测量数据中提取此类基<sup><a class=n href="#ref17">[17]</a></sup>来直接建模BRDF。Nishino等人基于新推导的半球指数功率分布介绍了方向统计BRDF模型<sup><a class=n href="#ref18">[18]</a></sup><sup><a class=n href="#ref19">[19]</a></sup>，以半程向量表示表示BRDF，并将其嵌入作为各种逆渲染任务的先验<sup><a class=n href="#ref20">[20]</a></sup><sup><a class=n href="#ref2">[2]</a></sup><sup><a class=n href="#ref21">[21]</a></sup>。Ashikhmin和Premoze<sup><a class=n href="#ref22">[22]</a></sup>使用改进的各向异性Phong拟合测量数据。这些模型的表达能力受到潜在分析分布的限制。Romeiro等人<sup><a class=n href="#ref23">[23]</a></sup>直接使用表格2D各向同性反射分布。尽管<strong>非参数</strong>且具有表达性，但由于其高维数和缺乏可微性，使用此类模型估计反射率仍然具有挑战性。我们表明，我们的可逆神经BRDF模型具有相当数量的参数，在可微和可逆的同时实现了更高的精度。</em></li><li><em>现实世界中的材料在反射率方面表现出很大的变化，很难用通用基（如Zernike多项式或Cook-Torrance模型中的解析分布）捕捉到这些变化。<strong>非参数</strong>表示，例如各向同性BRDF的简单3D表格，可以更好地捕捉广泛的变化，同时确保单个BRDF准确表示。另一方面，我们还需要区分关于反射率的误差函数等式1，并评估BRDF的准确可能性。因此，过去的方法倾向于低维参数反射模型，其表达能力有限。我们通过引入基于可逆深度生成神经网络的高维参数反射模型来解决这一基本难题。准确地说，BRDF表示为三维反射分布，该分布由简单的参数分布（例如均匀分布）转换而来。关键特性是，该变换是可逆线性变换的级联，共同导致复杂的<strong>非参数</strong>分布。由此产生的参数化是高维的，具有与<strong>非参数</strong>表格一样多的参数，因此具有极强的表达能力，但可微，也可以有效地进行采样和评估。</em></li></ol><p>对于1中提到的非参数照明，摘录原文<sup><a class=n href="#ref2">[2]</a></sup>如下：</p><blockquote><p>许多方法假设可以使用低阶参数模型（如球谐函数）或少量点光源对自然照明进行建模。当反射率模型不是朗伯模型时，这些模型无法准确预测场景辐照度。为了模拟真实场景，需要一个表示入射照明球体的全色<strong>非参数</strong>照明模型。</p><p>我们的照明模型是入射照明场的<strong>非参数</strong>表示。<strong>非参数</strong>模型允许很强的表达能力，为了减少解空间，这些表达能力必须受到约束。我们使用几个先验来实现这一点。首先，我们采用Lombardi和Nishino<sup><a class=n href="#ref4">[4]</a></sup>引入的熵先验，该先验建模了照明与物体反射率相互作用导致的熵损失。我们还利用自然图像统计先验，鼓励恢复合理的自然照明环境。</p></blockquote><p>以统计学中的非参数为例，考虑具有形式<spanclass="math inline">\(Y=g(X)+W\)</span>的模型，该模型涉及两个随机变量<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>，其中<spanclass="math inline">\(W\)</span>是零均值噪声，<spanclass="math inline">\(g\)</span>是需要估计的未知函数。这类问题，未知目标（比如这里的函数g）是不能表述为固定数目的参数，称为<strong>非参数</strong>统计推断问题。</p><p><ahref="https://zhuanlan.zhihu.com/p/350307389">参数模型与非参数模型</a></p><p><strong>参考文献</strong></p><p><a name="ref1">[1] Chen Z, Nobuhara S, Nishino K. Invertible neuralBRDF for object inverse rendering[J]. IEEE Transactions on PatternAnalysis and Machine Intelligence, 2021.</a></p><p><a name="ref2">[2] Lombardi S, Nishino K. Reflectance andillumination recovery in the wild[J]. IEEE transactions on patternanalysis and machine intelligence, 2015, 38(1): 129-141.</a></p><p><a name="ref3">[3] Ramamoorthi R, Hanrahan P. A signal-processingframework for inverse rendering[C]//Proceedings of the 28th annualconference on Computer graphics and interactive techniques. 2001:117-128.</a></p><p><a name="ref4">[4] Lombardi S, Nishino K. Reflectance and naturalillumination from a single image[C]//European Conference on ComputerVision. Springer, Berlin, Heidelberg, 2012: 582-595.</a></p><p><a name="ref5">[5] Müller T, McWilliams B, Rousselle F, et al. Neuralimportance sampling[J]. ACM Transactions on Graphics (TOG), 2019, 38(5):1-19.</a></p><p><a name="ref6">[6] Tabak E G, Turner C V. A family of nonparametricdensity estimation algorithms[J]. Communications on Pure and AppliedMathematics, 2013, 66(2): 145-164.</a></p><p><a name="ref7">[7] Tabak E G, Vanden-Eijnden E. Density estimation bydual ascent of the log-likelihood[J]. Communications in MathematicalSciences, 2010, 8(1): 217-233.</a></p><p><a name="ref8">[8] Ulyanov D, Vedaldi A, Lempitsky V. Deep imageprior[C]//Proceedings of the IEEE conference on computer vision andpattern recognition. 2018: 9446-9454.</a></p><p><a name="ref9">[9] Nicodemus F E, Richmond J C, Hsia J J, et al.Geometric Considerations and Nomenclaturefor Reflectance[J]. US Dept. ofCommerce, Washington, DC, NBS Monograph, 1977, 160</a></p><p><a name="ref10">[10] Phong B T. Illumination for computer generatedpictures[J]. Communications of the ACM, 1975, 18(6): 311-317.</a></p><p><a name="ref11">[11] Blinn J F. Models of light reflection forcomputer synthesized pictures[C]//Proceedings of the 4th annualconference on Computer graphics and interactive techniques. 1977:192-198.</a></p><p><a name="ref12">[12] Torrance K E, Sparrow E M. Theory foroff-specular reflection from roughened surfaces[J]. Josa, 1967, 57(9):1105-1114.</a></p><p><a name="ref13">[13] Cook R L, Torrance K E. A reflectance model forcomputer graphics[J]. ACM Transactions on Graphics (ToG), 1982, 1(1):7-24.</a></p><p><a name="ref14">[14] Burley B, Studios W D A. Physically-basedshading at disney[C]//ACM SIGGRAPH. vol. 2012, 2012, 2012: 1-7.</a></p><p><a name="ref15">[15] Koenderink J J, Doorn A J, Stavridi M.Bidirectional reflection distribution function expressed in terms ofsurface scattering modes[C]//European Conference on Computer Vision.Springer, Berlin, Heidelberg, 1996: 28-39. </a></p><p><a name="ref16">[16] Basri R, Jacobs D, Kemelmacher I. Photometricstereo with general, unknown lighting[J]. International Journal ofcomputer vision, 2007, 72(3): 239-257.</a></p><p><a name="ref17">[17] Matusik W. A data-driven reflectance model[D].Massachusetts Institute of Technology, 2003. </a></p><p><a name="ref18">[18] Nishino K. Directional statistics BRDFmodel[C]//2009 IEEE 12th International Conference on Computer Vision.IEEE, 2009: 476-483.</a></p><p><a name="ref19">[19] Nishino K, Lombardi S. Directionalstatistics-based reflectance model for isotropic bidirectionalreflectance distribution functions[J]. JOSA A, 2011, 28(1):8-18.</a></p><p><a name="ref20">[20] Lombardi S, Nishino K. Radiometric scenedecomposition: Scene reflectance, illumination, and geometry from rgb-dimages[C]//2016 fourth international conference on 3d vision (3dv).IEEE, 2016: 305-313.</a></p><p><a name="ref21">[21] Oxholm G, Nishino K. Shape and reflectanceestimation in the wild[J]. IEEE transactions on pattern analysis andmachine intelligence, 2015, 38(2): 376-389.</a></p><p><a name="ref22">[22] Ashikhmin M, Premoze S. Distribution-basedbrdfs[J]. Unpublished Technical Report, University of Utah, 2007, 2:6.</a></p><p><a name="ref23">[23] Romeiro F, Vasilyev Y, Zickler T. Passivereflectometry[C]//European Conference on Computer Vision. Springer,Berlin, Heidelberg, 2008: 859-872.</a></p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python编程经验</title>
      <link href="//posts/Article/python-experience/"/>
      <url>//posts/Article/python-experience/</url>
      
        <content type="html"><![CDATA[<p>python编程的经验和易错细节总结</p><span id="more"></span><p class="note note-primary">个人经验总结。</p><h1 id="数据复制">数据复制</h1><ol type="1"><li><p>直接赋值：相当于C++的引用，起别名</p></li><li><p>浅拷贝: 拷贝父对象，但是不会拷贝对象的内部的子对象。</p></li><li><p>深拷贝: 拷贝父对象. 以及其内部的子对象</p></li></ol><p>以可变对象list为例，上述三种赋值的操作依次为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br>b = a <span class="hljs-comment"># 直接赋值</span><br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">999</span><br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a)==<span class="hljs-built_in">id</span>(b))<br>b = copy.copy(a) <span class="hljs-comment"># 浅拷贝，等价于a.copy()</span><br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">888</span><br>b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">888</span><br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a)==<span class="hljs-built_in">id</span>(b))<br>b = copy.deepcopy(a) <span class="hljs-comment"># 深拷贝</span><br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">777</span><br>b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">777</span><br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a)==<span class="hljs-built_in">id</span>(b))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[999, 2, [3, 4]]</span><br><span class="hljs-string">[999, 2, [3, 4]]</span><br><span class="hljs-string">True</span><br><span class="hljs-string">[999, 2, [888, 4]]</span><br><span class="hljs-string">[888, 2, [888, 4]]</span><br><span class="hljs-string">False</span><br><span class="hljs-string">[999, 2, [888, 4]]</span><br><span class="hljs-string">[777, 2, [777, 4]]</span><br><span class="hljs-string">False</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="numpy">numpy</h1><h2 id="复制">复制</h2><p>默认浅复制，使用<code>.copy()</code>进行深复制。</p><h2 id="修改">修改</h2><p><code>resize()</code> 就地操作，可以修改尺寸。</p><p><code>reshape()</code> 非就地操作，只能修改形状。</p><p>入参都是一组数字或者元组。但前者入参不能有-1。</p><h2 id="切片">切片</h2><p>当使用数组切片切下<strong>一维切片</strong>（单行或单列）时，默认为一维数组，需用<code>reshape(-1, 1)</code>转换为二维数组，才可使用np.hstack等函数或同二维数组进行运算。</p><p>可以直接对切片赋值，如对<strong>一维切片</strong>进行赋值，需要将赋值对象拉平<code>reshape(-1)</code>。</p><p>还可以通过切片提升数组维度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># :等同于...</span><br>a = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(a[:, <span class="hljs-literal">None</span>])<br><span class="hljs-built_in">print</span>(a[<span class="hljs-literal">None</span>, ...])<br><span class="hljs-built_in">print</span>(a[<span class="hljs-literal">None</span>, :, <span class="hljs-literal">None</span>])<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[1 2 3]</span><br><span class="hljs-string">[[1]</span><br><span class="hljs-string"> [2]</span><br><span class="hljs-string"> [3]]</span><br><span class="hljs-string">[[1 2 3]]</span><br><span class="hljs-string">[[[1]</span><br><span class="hljs-string">  [2]</span><br><span class="hljs-string">  [3]]]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="生成">生成</h2><p><code>np.meshgrid()</code>生成网格，输出为网格的横坐标矩阵和纵坐标矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>y = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])<br>X, Y = np.meshgrid(x, y)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[[0 1 2]</span><br><span class="hljs-string"> [0 1 2]]</span><br><span class="hljs-string">[[0 0 0]</span><br><span class="hljs-string"> [1 1 1]]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="可视化">可视化</h1><h2 id="matplotlib">matplotlib</h2><p>常用例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 设置图像大小,像素为figsize*dpi</span><br>fig = plt.figure(figsize=(<span class="hljs-number">30</span>, <span class="hljs-number">10</span>), dpi=<span class="hljs-number">50</span>)  <br>ax1 = fig.add_subplot(<span class="hljs-number">121</span>)<br><br>X = np.arange(<span class="hljs-number">10</span>)<br>Y = np.square(X)<br>ax1.set_xlabel(<span class="hljs-string">&#x27;X&#x27;</span>)<br>ax1.set_ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>)<br>ax1.plot(X, Y,<br>         color=<span class="hljs-string">&#x27;grey&#x27;</span>,<br>         marker=<span class="hljs-string">&#x27;o&#x27;</span>,<br>         markersize=<span class="hljs-number">8</span>, <br>         linewidth=<span class="hljs-number">2</span>,<br>         markerfacecolor=<span class="hljs-string">&#x27;red&#x27;</span>,<br>         markeredgecolor=<span class="hljs-string">&#x27;grey&#x27;</span>,<br>         markeredgewidth=<span class="hljs-number">2</span>)<br><br>XX, YY = np.meshgrid(X, Y)<br>Z = np.full_like(XX, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.size):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(Y.size):<br>        <span class="hljs-comment"># 注意这里Z的shape是(Y.size,X.size)</span><br>        Z[j][i] = X[i] + Y[j]<br><br>ax2 = fig.add_subplot(<span class="hljs-number">122</span>, projection=<span class="hljs-string">&#x27;3d&#x27;</span>)<br>ax2.plot_surface(XX, YY, Z, cmap=<span class="hljs-string">&#x27;rainbow&#x27;</span>)<br>ax2.set_xlabel(<span class="hljs-string">&#x27;X&#x27;</span>)<br>ax2.set_ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>)<br>ax2.set_zlabel(<span class="hljs-string">&#x27;Z&#x27;</span>)<br><span class="hljs-comment"># visible：表示是否显示网格。若提供其他关键字参数，则b参数设为True。</span><br><span class="hljs-comment"># which：表示显示网格的类型，支持major、minor、both这3种类型，默认为major。</span><br><span class="hljs-comment"># axis：表示显示哪个方向的网格，该参数支持both、x和y这3个选项，默认为both。</span><br><span class="hljs-comment"># linewidth或lw：表示网格线的宽度。</span><br><span class="hljs-comment"># ax1.grid(visible=True,which=&#x27;both&#x27;, axis=&#x27;both&#x27;, linewidth=0.3)</span><br><span class="hljs-comment"># 在show之前调用</span><br>plt.savefig(<span class="hljs-string">&#x27;loss_image.jpg&#x27;</span>)<br>plt.show()<br>plt.close()<br></code></pre></td></tr></table></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%93%E6%9E%9C.png"alt="可视化结果" /><figcaption aria-hidden="true">可视化结果</figcaption></figure><h1 id="解包操作">解包操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>d1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>d2 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">4</span>&#125;<br><br><span class="hljs-built_in">print</span>(add(*d1))<br><span class="hljs-built_in">print</span>(add(*d2))<br><span class="hljs-built_in">print</span>(add(**d2)) <span class="hljs-comment"># key与形参名需对应</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">3</span><br><span class="hljs-string">ab</span><br><span class="hljs-string">7 </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅行</title>
      <link href="//posts/Log/travel/"/>
      <url>//posts/Log/travel/</url>
      
        <content type="html"><![CDATA[<p>纪要</p><span id="more"></span><table><thead><tr class="header"><th>时间</th><th>地点</th></tr></thead><tbody><tr class="odd"><td>2017夏</td><td>广东韶关、广州、佛山，重庆，北京</td></tr><tr class="even"><td>2017冬</td><td>吉林长春</td></tr><tr class="odd"><td>2018夏</td><td>浙江杭州，江西兴国，广东深圳</td></tr><tr class="even"><td>2018中秋</td><td>陕西西安</td></tr><tr class="odd"><td>2018国庆</td><td>天津</td></tr><tr class="even"><td>2018冬</td><td>法国奥尔良、图尔，湖南张家界</td></tr><tr class="odd"><td>2019五一</td><td>辽宁大连</td></tr><tr class="even"><td>2019夏</td><td>内蒙古呼和浩特</td></tr><tr class="odd"><td>2019中秋</td><td>上海</td></tr><tr class="even"><td>2019国庆</td><td>山西太原</td></tr><tr class="odd"><td>2021国庆</td><td>湖北宜昌</td></tr><tr class="even"><td>2022夏</td><td>湖北武汉、荆门</td></tr><tr class="odd"><td>2023春</td><td>山东烟台</td></tr><tr class="even"><td>2023夏</td><td>河北保定</td></tr><tr class="odd"><td>2023国庆</td><td>山东青岛</td></tr></tbody></table><p><em>季节按中国二十四节气划分，大约公历2~4月为春，以此类推。</em></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子游戏🎮</title>
      <link href="//posts/Log/video-game/"/>
      <url>//posts/Log/video-game/</url>
      
        <content type="html"><![CDATA[<p>大致记录玩过的电子游戏</p><span id="more"></span><p>电子游戏可以按照不同维度进行分类，众说纷纭，这里仅列出一种说法。</p><p>按<strong>玩法</strong>分类，不同类别并不互斥，可以相互融合：</p><p><strong>ACT</strong>（ActionGame）：动作导向。故事较薄弱，以战斗为主的是<strong>H&amp;S</strong>（Hackand Slash），如鬼泣。以1V1格斗为主的是<strong>FTG</strong>（FightingGame），如拳皇、死或生。地图设计以平台为主的是<strong>PlatformGame</strong>，如马里奥系列，其中一个子类别称为<strong>Metroidvania</strong>（类银河战士恶魔城）。采用卷轴（Scroller）地图的是<strong>Beat'emup</strong>（清版动作游戏），如城堡破坏者。以射击为主的是<strong>STG</strong>（ShooterGame），第一人称是<strong>FPS</strong>（FirstPerson），第三人称是<strong>TPS</strong>（ThirdPerson），无法自由移动顺轨道前进的是<strong>LightGun</strong>（光枪），如死亡之屋（多见于街机），弹幕射击玩法的是<strong>Shoot'Em Up</strong>（清版射击游戏），如雷电。以迷宫为主的是<strong>MazeGame</strong>，如吃豆人。</p><p><strong>AVG</strong>（AdventureGame）：探索导向。与ACT结合的是<strong>AAVG</strong>（Action），如生化危机，相较于ACT以数值成长为主。以文字为主图像为辅的是<strong>TAVG</strong>（Text），也称<strong>VN</strong>（VisualNovel），如逆转裁判，其中以恋爱为主的是<strong>Galgame</strong>，如白色相簿。以电影式演绎为主的是<strong>IM</strong>（InteractiveMovie），如超凡双生。以解谜玩法为主的是<strong>PAVG</strong>（Puzzle），如机械迷城。</p><p><strong>RPG</strong>（Role-playingGame）：数值导向。按设计风格分有<strong>日式RPG</strong>和<strong>美式RPG</strong>，前者倾向预设角色和线性剧情，如最终幻想、女神异闻录，后者倾向自定角色和高自由度，如上古卷轴、辐射。与ACT结合的是<strong>ARPG</strong>（Action），如黑暗之魂，相较于ACT以数值成长为主。还原线下RPG体验、强调属性加点和分支选择的是<strong>CRPG</strong>（Computer），如极乐迪斯科。以迷宫地下城为核心玩法的是<strong>DRPG</strong>（Dungeon），如世界树迷宫。可以大型多人在线的是<strong>MMORPG</strong>（MassivelyMultiplayerOnline），如魔兽世界。以文字为主多人在线的是<strong>MUD</strong>（MultiuserDungeon），如北大侠客行。符合柏林准则的是<strong>Roguelike</strong>，如Rogue，不完全符合柏林准则的是<strong>Roguelite</strong>，如哈迪斯：杀出地狱。与SLG结合的是<strong>SRPG</strong>（Strategy），如火焰之纹章。</p><p><strong>SLG</strong>（SimulationGame）：策略。回合制玩法有经营的是<strong>TBS</strong>（Turn-BasedStrategy），如文明系列，无经营的是<strong>TBT</strong>（Turn-basedTactics），如高级战争。即时玩法有经营的是<strong>RTS</strong>（Real-TimeStrategy），如红色警戒，无经营的是<strong>RTT</strong>（Real-TimeTactics），如影子战术：将军之刃。多人在线竞技的是<strong>MOBA</strong>（MultiplayerOnline Battle Arena），如英雄联盟。<strong>TD</strong>（TowerDenfense，塔防）如植物大战僵尸。<strong>AC</strong>（AutoChess）如刀塔自走棋。</p><p><strong>SIM</strong>（SimulationGame）：模拟。模拟生活如模拟人生，模拟体育如FIFA23，模拟驾驶载具如极限竞速:地平线、微软模拟飞行，模拟建造如坎巴拉太空计划。</p><p><strong>CasualGame</strong>：休闲。有解谜、棋牌、音乐、派对、益智等类型。</p><p>按<strong>题材</strong>：</p><p>恐怖、仙侠、奇幻、战争等。</p><p>按<strong>地图探索方式</strong>：</p><p>开放世界、半开放世界、线性、沙盒。</p><p>按<strong>游玩人数</strong>：</p><p>单人、多人。多人有联机、同屏/分屏。</p><p>按<strong>玩家所处视角</strong>：</p><p>第一人称、第三人称。</p><p>按<strong>画面表现方式</strong>：</p><p>3D、2.5D、2D。</p><p>2D可分为卷轴、平台、侧视角、俯视角、顶视角。</p><p>卷轴：城堡破坏者。</p><p>平台：洞窟物语。</p><p>侧视角：泰拉瑞亚、The Captain。</p><p>俯视角：逃脱者2。</p><p>顶视角：Hell is Others、Darkwood、阿瑞斯病毒。</p><p>按<strong>付费方式</strong>：</p><p>买断、内购、抽卡（ガチャ，gacha）。</p><p>按<strong>目的</strong>：</p><p>娱乐、严肃。</p><p>按<strong>平台</strong>：</p><p>PC、街机、主机、掌机、手机、VR等。</p><p style="color:red;"><strong>个人最喜欢的游戏：</strong></p><p>Shadow Tactics: Blades of the Shogun</p><p>Ring of Pain</p><p>Terraria</p><p>Prey</p><p>Hades: Battle Out of Hell</p><p>This War of Mine</p><p>三国志II 霸王的大陆</p><p>合战忍者村物语</p><p>Forza Horizon 4/5</p><p>Orwell: Keeping an Eye on You</p><p>A Way Out</p><p>It takes two</p><p>GTA V</p><h1 id="游玩清单">游玩清单</h1><h2 id="pc">PC</h2><h3 id="metro-exodus">Metro Exodus</h3><blockquote><p>地铁离去</p><p>FPS，开放世界</p></blockquote><p><strong>剧情</strong></p><p>阿尔乔姆在后末日世界乘火车穿越俄罗斯的故事。</p><p>为系列游戏的第三作，改编自小说《地铁》三部曲，对主要剧情做了取舍和改动。本作相当于续写了三部曲结尾的剧情，故事主要发生在地面上而不是地铁里。</p><p><strong>玩法</strong></p><p>潜行或者大杀四方。潜行需要在黑夜进行。是否杀戮会影响战友及自己的结局。</p><p>捡垃圾获取资源制作弹药和道具、修复武器和防毒面具，游戏节奏比较紧张，不乏跳脸。</p><p><strong>特色</strong></p><p>演出十分精彩，场景制作细腻。</p><p>打火机点蛛网。</p><p><strong>备注</strong></p><p>原作小说同样出色，推荐阅读。先读小说再玩游戏会有一种遗憾被弥补的感觉。</p><h3 id="prey">Prey</h3><blockquote><p>掠食</p><p>AAVG，第一人称，恐怖</p></blockquote><p><strong>剧情</strong></p><p>摩根·余需要在意外被外星怪物占据的太空站找出一切背后的秘密。</p><p>真正的结局和设定完全出人意料，最后一刻反转。</p><p><strong>玩法</strong></p><p>以紧张的探索/战斗为主。支线非常多，往往需要做拷问人性的道德选择（对结局有影响）。跳脸拟态怪物太多以至于让人麻木。需要躲避或击杀定时出现的巨大梦魇。</p><p>技能树分为人类侧的工程师/科学家/保安和风暴异魔侧的能量/变形/心电感应，需要神经调整仪解锁。风暴异魔侧的技能还需要用心电感应仪扫描风暴异魔。资源比较稀缺，需要到处捡垃圾以制造装备。</p><p><strong>特色</strong></p><p>整个太空站地图设计的很不错，站外太空漫游也很有意思，但是对没有方向感的人不友好。</p><p>凝胶枪gloo不仅可以凝固怪物，而且丰富了探索地图的方式。往往有不止一种方式到达目的地。</p><p>NPC可以杀。</p><p><del>大量厕所分布和可交互冲水马桶。（不少游戏都有）</del></p><p><strong>备注</strong></p><p>主角哥哥艾力克斯·余办公室茶几上的毛笔写的唐诗选节录《登鹳雀楼》让人影响深刻。主角一家姓余，应该有华裔血统吧？</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-02-17-Prey%20(2017)%20.png"alt="Prey (2017)" /><figcaption aria-hidden="true">Prey (2017)</figcaption></figure><h3 id="shadow-of-the-tomb-raider">Shadow of the Tomb Raider</h3><blockquote><p>古墓丽影：暗影</p><p>AAVG ，半开放世界，第三人称</p></blockquote><p><strong>剧情</strong></p><p>考古学家劳拉前往南美秘鲁的传说城市帕伊提提对抗反派组织圣三一，阻止反派头目多米格斯使用神器重塑世界。劳拉作为一个杀人不眨眼的女战士刻画的比较温情。</p><p>主线没有伏笔和反转，比较平铺直叙。支线很多，没有耐心的话玩不完。</p><p><strong>玩法</strong></p><p>以解密为主（在低难度下有白漆作提示），总体来说设计得不错，特别是“鹰之试炼”。</p><p>主角经常需要利用登山镐攀爬、索降、移动。</p><p>在水底、丛林伏击敌人的暗杀系统很有趣。</p><p>有单独的古墓挑战，并且有联机模式。</p><p>技能树分为探索/战斗/制作。可收集资源很多，背包容易满。武器种类丰富，弓箭用处很大。</p><p><strong>特色</strong></p><p>地图不小，收集品很多，充斥关于美洲古文明的知识。</p><p>通过背景设定巧妙地把本不在同一地的中南美三大文明阿兹特克、玛雅、印加都带进了帕伊提提。</p><p>第三人称利于暗杀等需要观察环境的玩法。</p><p><strong>备注</strong></p><p>该作是古墓丽影系列第11部（重启系列第3部）。</p><h3 id="dying-light">Dying Light</h3><blockquote><p>消逝的光芒</p><p>AAVG，开放世界，恐怖，第一人称</p></blockquote><p><strong>剧情</strong></p><p>国际组织“全球救援计划”的特工凯尔·克兰奉命进入丧尸横行的隔离城市哈兰寻找卡迪尔·苏莱曼，找回组织被盗的机密文件。故事精彩。</p><p><strong>玩法</strong></p><p>以战斗和跑酷为主，地图上有大量丧尸，需要尽量避免正面冲突。</p><p>有昼夜变化，晚上丧尸攻击性更强，并且需要躲避夜魔。</p><p>技能树分为生存/敏捷/力量。武器可以制作和强化。以免惊扰丧尸，一般使用冷兵器战斗。</p><p><strong>特色</strong></p><p>几乎可以使用钩爪攀登所有建筑物。</p><h3 id="amnesia-rebirth">Amnesia: rebirth</h3><blockquote><p>失忆症：重生</p><p>恐怖，线性，无战斗，第一人称</p></blockquote><p><strong>剧情</strong></p><p>普通人Tasi Trianon飞机失事坠入阿尔及利亚的沙漠，一路求生。</p><p>故事复杂，时间线多，并且没玩过前作的话理解设定有点困难。</p><p><strong>玩法</strong></p><p>在无所不在的黑暗中探索，寻找并用火柴点亮光源获得短暂的光明（一直待在黑暗中会累计恐惧值，导致看见黑暗女王以至于死亡）。面对怪物食尸鬼，没有武器只能躲避和逃生。</p><p>利用谜题推进游戏进程，但解谜比较单调。</p><p><strong>特色</strong></p><p>能感受到开发者通过在黑暗中引导玩家自己的想象力来塑造恐怖氛围。</p><p><strong>备注</strong></p><p>该作是失忆症系列第3部。</p><p>玩到第8章堡垒末尾处（大概整个游戏的一半），玩不下去了。心理承受不了。</p><h3 id="cyberpunk-2077">Cyberpunk 2077</h3><blockquote><p>赛博朋克2077</p><p>AAVG，开放世界，第一人称</p></blockquote><p><strong>剧情</strong></p><p>开局可以选流浪者、街头小子、公司员工之一的角色，认识兄弟杰克，然后探索赛博朋克世界。</p><p>主角自己的背景故事不多，主线较短，主要通过支线撑起世界观。</p><p><strong>备注</strong></p><p>可以捏脸，但由于只有第一人称所以除了开局平时几乎看不到……</p><h3 id="breathedge">Breathedge</h3><blockquote><p>呼吸边缘</p><p>AVG，生存，第一人称</p></blockquote><p>太空生存，阻止机器人的阴谋。主角全程不说话，宇航服充当旁白。剧情偏喜剧风格。</p><p>太空环境体验不错，但资源采集过程过于冗长无聊。</p><h3 id="dishonored">Dishonored</h3><blockquote><p>耻辱</p><p>AAVG，第一人称</p></blockquote><p>前保镖科尔沃为了给女王报仇、拯救国家而成为刺客。</p><p>非常好玩和经典的潜行玩法，魔法系统有趣。不知为何，是唯一一款让我有眩晕感的3D游戏。</p><h3 id="call-of-the-sea">Call of the Sea</h3><blockquote><p>海之呼唤</p><p>AVG，解谜</p></blockquote><p>克苏鲁类型的故事。没有制造和战斗，中规中矩的线性剧情。</p><h3 id="in-sound-mind">In Sound Mind</h3><blockquote><p>神志清醒</p><p>AVG，解谜，恐怖</p></blockquote><p>说是恐怖游戏，但隔近了之后怪物不怎么吓人，有点花里胡哨。玩到镜中女鬼就卡关了。</p><h3 id="elder-ring">Elder Ring</h3><blockquote><p>艾尔登法环</p><p>魂系</p></blockquote><p>第一次玩魂系游戏，实在是太难了。</p><h3 id="暗影火炬城">暗影火炬城</h3><blockquote><p>F.I.S.T.: Forged In Shadow Torch</p><p>2D平台，AAVG</p></blockquote><p>主角是兔子，场景中有很多中国元素，背景是柴油朋克的动物世界。故事中规中矩。</p><h3 id="orwell-keeping-an-eye-on-you">Orwell: Keeping an Eye on You</h3><blockquote><p>奥威尔：老大哥在看着你</p><p>AVG，叙事，解谜</p></blockquote><p>操作名为奥威尔的监控系统监控互联网上的一切，抓捕有反国家行为的公民。</p><p>玩法别具一格，剧情不错。</p><p>建议阅读乔治奥威尔的《1984》。</p><h3 id="adios">Adios</h3><blockquote><p>再见（西班牙语）</p><p>AVG，叙事</p></blockquote><p>短篇小说式的游戏，一个小时的时长。叙事平淡，娓娓道来。</p><p>英文对话没有字幕。</p><h3 id="the-silent-age">The Silent Age</h3><blockquote><p>沉默年代</p><p>AVG，2D侧视角，解谜</p></blockquote><p>讲述了一个小人物穿越时间拯救世界的故事。</p><h3 id="the-room">The Room</h3><blockquote><p>未上锁的房间</p><p>解谜</p></blockquote><p>对着盒子解谜。</p><h3 id="to-the-moon">To the Moon</h3><blockquote><p>去月球</p><p>AVG，像素，2D</p></blockquote><p>讲述了一个非常不错的故事。RPGMaker制作的游戏见过不少，大多是恐怖类型的，如此感人的还是头一个。</p><h3 id="brothers-a-tale-of-two-sons">Brothers: A Tale of two sons</h3><blockquote><p>兄弟：双子传说</p><p>AVG，解谜，2.5D，线性</p></blockquote><p>一个手柄控制两个角色，哥哥和弟弟。玩的过程有一种听西方童话故事的感觉。</p><h3 id="sable">Sable</h3><blockquote><p>沙贝</p><p>AVG，3D</p></blockquote><p>非常惊艳的美术和三渲二技术。跑图很休闲。</p><h3 id="this-war-of-mine">This War of Mine</h3><blockquote><p>这是我的战争</p><p>AVG</p></blockquote><p>因为战争被困，为了生存不得不杀人，亦是战争爆发原因的折射。冲突不可能从世界上消失。</p><p>生存模式容易无聊，DLC剧情模式更有趣。</p><h3 id="turnip-boy-commits-tax-evasion">Turnip Boy Commits TaxEvasion</h3><blockquote><p>大头菜小子偷税了</p><p>AAVG，休闲，2D</p></blockquote><p>美术音乐战斗都不错，但是挺无聊的。任务驱动太不自然了。</p><h3 id="unturned">Unturned</h3><blockquote><p>未转变者</p><p>AVG，开放世界</p></blockquote><p>建模简单的3D生存游戏，但意外地有趣。</p><p>联机服务器里神仙太多了。</p><h3 id="disco-elysium">Disco Elysium</h3><blockquote><p>极乐迪斯科</p><p>CRPG，解谜，2.5D</p></blockquote><p>主线剧情其实不长，但支线多，文本量极大，世界观描述详细。</p><p>玩了一段时间感觉精神污染，有点头晕，还是云了。</p><h3 id="gamedec">Gamedec</h3><blockquote><p>骇游侠探</p><p>CRPG，解谜，2.5D</p></blockquote><p>不用投骰子。在不同虚拟世界中冒险还是很有趣的。后面侦探玩法会越来越复杂。</p><h3 id="evoland-12">Evoland 1/2</h3><blockquote><p>进化之地 1/2</p><p>RPG</p></blockquote><p>游戏不断升级（画面、音乐、操控等）的点子很有趣。</p><h3 id="gta-v">GTA V</h3><blockquote><p>RPG</p></blockquote><p>最喜欢的开放世界游戏。</p><h3 id="final-fantasy-vii-remake-intergrade">FINAL FANTASY VII REMAKEINTERGRADE</h3><blockquote><p>最终幻想7重制版</p><p>RPG</p></blockquote><p>半即时制的战斗系统对我来说很新鲜，不是很习惯。</p><h3 id="marvals-avengers">Marval's Avengers</h3><blockquote><p>漫威复仇者</p><p>ARPG</p></blockquote><p>童年最喜欢的IP之一。游戏还是做的很还原的，很酷。</p><h3 id="hades-battle-out-of-hell">Hades: Battle Out of Hell</h3><blockquote><p>哈迪斯：杀出地狱</p><p>Roguelite，ACT</p></blockquote><p>冥王哈迪斯之子扎格瑞斯决心离开地狱寻找真正的生母珀耳塞福涅，在奥林匹斯的众神的帮助下一次次试图杀出地狱。</p><p>将希腊神话完美融入故事剧情，利用剧情和背景设定使其作为Roguelite游戏的特性毫不违和。</p><p>战斗非常畅快。带有收集要素。</p><h3 id="cursed-to-golf">Cursed to Golf</h3><blockquote><p>诅咒高尔夫</p><p>Roguelite，ACT</p></blockquote><p>同样是杀出地狱，不过是高尔夫地狱。玩法很丰富。</p><h3 id="rising-hell">Rising Hell</h3><blockquote><p>杀戮之源</p><p>Roguelite，2D平台，竖版</p></blockquote><p>复古像素风格，打斗畅快。</p><h3 id="ring-of-pain">Ring of Pain</h3><blockquote><p>苦痛之环</p><p>Roguelite，卡牌</p></blockquote><p>简洁的战斗机制，在环状卡牌中移动，选择性随探索轮数增加，容易上瘾。</p><h3 id="warpips">Warpips</h3><blockquote><p>小兵大战</p><p>RTS，Roguelite</p></blockquote><p>RTS和Roguelite结合的游戏，很有趣。对兵种强弱没有直观的感觉，需要在战斗中熟悉。</p><h3 id="loop-hero">Loop Hero</h3><blockquote><p>循环英雄</p><p>Roguelite，策略</p></blockquote><p>游戏机制非常特别，将勇者放上闭路地图自动探险，地图中的所有建筑自己放置，有增益类建筑也有刷怪类建筑。</p><h3 id="godlike-burger">Godlike Burger</h3><blockquote><p>宇宙汉堡王</p><p>Roguelite，策略，ACT</p></blockquote><p>买汉堡给顾客挣钱，杀顾客做成汉堡，物尽其用……</p><h3 id="terraria">Terraria</h3><blockquote><p>泰拉瑞亚</p><p>沙盒，ARPG</p></blockquote><p>人生最早接触的电子游戏之一，初中经常玩。</p><h3 id="rimworld">RimWorld</h3><blockquote><p>环世界</p><p>沙盒，策略</p></blockquote><p>买了之后发现云比自己玩更有意思。</p><p>该游戏作者西尔韦斯特写了《体验引擎》一书。</p><h3 id="ark-survival-evolved">ARK: Survival Evolved</h3><blockquote><p>方舟：生存进化</p><p>沙盒，ARPG</p></blockquote><p><del>能吃屎活下去真是太自由了。</del></p><h3 id="besiege">Besiege</h3><blockquote><p>围攻</p><p>沙盒</p></blockquote><p>用零件组装千奇百怪的载具，攻克各种别出心裁的关卡。自由度非常高。</p><h3 id="戴森球计划">戴森球计划</h3><blockquote><p>Dyson Sphere Program</p><p>建造，策略</p></blockquote><p>规划生产运输，需要机器人辅助进行工作。</p><h3 id="train-valley-2">Train Valley 2</h3><blockquote><p>火车山谷2</p><p>建造，策略</p></blockquote><p>设计交通路线来运输物资，供给生产线。列车需要手动派出，避免碰撞。难度适中，比较有趣。</p><h3 id="rise-of-industry">Rise of Industry</h3><blockquote><p>工业崛起</p><p>建造，策略</p></blockquote><p>规划生产运输，并购其他公司。</p><h3 id="kerbal-space-program">Kerbal Space Program</h3><blockquote><p>坎巴拉太空计划</p><p>建造，模拟</p></blockquote><p>建造和发射宇航器探索太空。</p><h3 id="operator">911 Operator</h3><blockquote><p>模拟，策略</p></blockquote><p>扮演接线员指挥消防警察急救出任务。接电话让人火大。</p><h3 id="shadow-tactics-blades-of-the-shogun">Shadow Tactics: Blades ofthe Shogun</h3><blockquote><p>影子战术：将军之刃</p><p>RTT，闯关</p></blockquote><p><strong>剧情</strong></p><p>逐步引出所有五个可操作角色忍者（隼人）、陷阱师（友希）、武士（无垠）、伪装者（爱子）、狙击手（琢磨），帮助幕府将军对抗反派“影子”。每个角色都刻画得有血有肉。</p><p><strong>玩法</strong></p><p>玩家即时操作具有不同技能和特性的角色完成任务。</p><p><strong>特色</strong></p><p>美术精美，每一关的地图都设计的很出色，通关方式多样化。可以清图或速通。</p><p><strong>备注</strong></p><p>这款含有武士道精神的日式风格游戏由德国公司MimimiGames开发。后续还有一个爱子的DLC，也非常不错。</p><h3 id="risk-global-domination">RISK: Global Domination</h3><blockquote><p>TBT</p></blockquote><p>简洁有趣，和Hex Empire类似。我喜欢这种不需要经营的战棋类游戏。</p><h3 id="plants-vs.-zombies">PLANTS vs. ZOMBIES</h3><blockquote><p>植物大战僵尸</p><p>塔防</p></blockquote><p>塔防游戏中的绝对经典。</p><h3 id="neighbours-from-hell">Neighbours from Hell</h3><blockquote><p>整蛊邻居</p><p>策略</p></blockquote><p>很早接触的游戏，非常好玩。2020年出了重制版。</p><h3 id="duskers">Duskers</h3><blockquote><p>策略</p></blockquote><p>操作无人机探索宇宙飞船。DOS风格的界面及命令行操作方式极具特色。</p><h3 id="fallout-a-post-nuclear-role-playing-game">Fallout: A PostNuclear Role Playing Game</h3><blockquote><p>辐射1</p><p>RPG，TBS</p></blockquote><p>核辐射废土，主角被派出避难所找净水芯片。结局雷人。</p><p>1997年发行的游戏，系统非常完善。</p><h3 id="encased-a-sci-fi-post-apocalyptic-rpg">Encased: A Sci-FiPost-Apocalyptic RPG</h3><blockquote><p>穹顶</p><p>RPG，TBS</p></blockquote><p>UI有种塑料感，游戏场景没有后末世的世界的感觉，并不有趣。</p><h3 id="the-dungeon-of-naheulbeuk-the-amulet-of-chaos">The Dungeon OfNaheulbeuk: The Amulet Of Chaos</h3><blockquote><p>纳赫鲁博王国地下城：混沌护符</p><p>RPG，TBS</p></blockquote><p>新手教程很好，故事有趣。队伍里角色性格鲜明，不同角色的对话和说书人旁白都设计的很好。个人认为比神界原罪2好玩。</p><h3 id="sid-meiers-civilization-vi">Sid Meier's Civilization VI</h3><blockquote><p>文明6</p><p>TBS</p></blockquote><p>一局的时间太长了，消磨时间神器。</p><h3 id="ancient-enemy">Ancient Enemy</h3><blockquote><p>古代敌人</p><p>TBS，卡牌，RPG</p></blockquote><p>玩法有趣，通过消牌（纸牌接龙）充能，然后用战斗牌战斗。</p><h3 id="black-book">Black Book</h3><blockquote><p>黑书</p><p>TBS，卡牌，AVG，RPG</p></blockquote><p>主角是沙俄时期的女巫（万事通）。人物刻画栩栩如生，可以了解很多俄国词语（如雠特）和民间故事。</p><p>愚人牌很有意思。一副牌36张，4种花色和9种点数（Ace、King、Queen、Jack、10、9、8、7、6）。<ahref="https://zhuanlan.zhihu.com/p/404728516">《黑书》愚人牌规则以及简易攻略</a></p><p>移动时固定视角镜头，地形中的物品没有做碰撞检测。</p><h3 id="city-of-gangsters">City of Gangsters</h3><blockquote><p>黑帮之城</p><p>TBS</p></blockquote><p>现在是1920年，镀金时代的开始……</p><p>在美国的黄金年代经营黑帮，贩卖私酒积累财富，逐步扩张势力。</p><h3 id="left-4-dead-2">Left 4 Dead 2</h3><blockquote><p>求生之路2</p><p>FPS</p></blockquote><p>过于经典。和室友一起通关很有趣。</p><h3 id="battlefield">Battlefield</h3><blockquote><p>战地系列</p><p>FPS</p></blockquote><p>战争场面非常震撼，特别是1和5的剧情模式。</p><h3 id="zombie-army-4-dead-war">Zombie Army 4: Dead War</h3><blockquote><p>僵尸部队4：死亡战争</p><p>TPS</p></blockquote><p>X光击杀镜头非常有趣。</p><h3 id="デモンエクスマキナ">デモンエクスマキナ</h3><blockquote><p>DAEMON X MACHINA / 机甲战魔</p><p>ARPG，TPS</p></blockquote><p>适合喜欢机甲战斗的人。</p><h3 id="蛇行武装">蛇行武装</h3><blockquote><p>射击，2.5D</p></blockquote><p>类似贪吃蛇的队列设定很有趣。</p><h3 id="doom64">DOOM64</h3><blockquote><p>FPS，恐怖</p></blockquote><p>1997年发行的经典游戏毁灭战士64。</p><h3 id="wolfenstein-the-new-order">Wolfenstein: The New Order</h3><blockquote><p>德军总部：新秩序</p><p>FPS，AVG</p></blockquote><p>美国大兵消灭纳粹。畅快。可以潜行。</p><h3 id="forza-horizon-45">Forza Horizon 4/5</h3><blockquote><p>极限竞速：地平线 4/5</p></blockquote><p>非常棒的赛车（观光）游戏。5和4的主要区别就是背景从英国换成墨西哥了，地图更大了。</p><h3 id="the-hunter-call-of-the-wild">the Hunter: Call of the Wild</h3><blockquote><p>猎人：荒野的呼唤</p><p>模拟</p></blockquote><p>打猎游戏。非常有趣。</p><p>寻找足迹，一击毙命或者追踪血迹。</p><h3 id="lawn-mowing-simulator">Lawn Mowing Simulator</h3><blockquote><p>除草模拟器</p><p>模拟</p></blockquote><p>竟然有这种游戏，真是有钱有闲。</p><p>开割草机帮人割草赚钱。割草很慢，还得维护机器，需要耐心。</p><p>适合有强迫症（享受把草割干净的过程）的人玩。</p><h3 id="digital-combat-simulator-world">Digital Combat SimulatorWorld</h3><blockquote><p>数字作战模拟世界</p><p>模拟</p></blockquote><p>战争模拟，非常逼真，也很不好操作。</p><h3 id="arma-3">Arma 3</h3><blockquote><p>武装突袭3</p><p>模拟</p></blockquote><p>够真实。和一战游戏坦能堡一样，能让我体验到作为炮灰的无力感。</p><h3 id="world-of-warships">World of Warships</h3><blockquote><p>战舰世界</p><p>模拟，多人竞技</p></blockquote><p>闲的时候打打船。同系列的Tanks、Warplanes也不错。</p><h3 id="war-thunder">War Thunder</h3><blockquote><p>战争雷霆</p><p>模拟，多人竞技</p></blockquote><p>大杂烩。</p><h3 id="hacknet">Hacknet</h3><blockquote><p>黑客网络</p><p>解谜，模拟</p></blockquote><p>扮演黑客解开Bit死亡之谜。需要一点linux基础。</p><h3 id="filament">Filament</h3><blockquote><p>钨丝</p><p>解谜</p></blockquote><p>音乐不错，解谜很硬核（又多又难），但挺无聊的。不是非常非常喜欢解谜还是不要玩。</p><h3 id="poly-bridge">Poly bridge</h3><blockquote><p>建造，解谜</p></blockquote><p>建桥游戏。</p><h3 id="lego-builders-journey">LEGO Builder's Journey</h3><blockquote><p>乐高建造者之旅</p><p>建造，解谜</p></blockquote><p>美术和音乐非常棒，适合喜欢乐高的人。</p><h3 id="peaky-blinders-mastermind">Peaky Blinders: Mastermind</h3><blockquote><p>浴血黑帮：傀儡师</p><p>策略</p></blockquote><p>无聊，解法单一。</p><p>通过倒转时间线的方式安排多人同时行动很独特。</p><h3 id="reigns">Reigns</h3><blockquote><p>王权</p><p>策略</p></blockquote><p>伪装成卡牌游戏的文字AVG。很有创意。</p><h3 id="mordhau">MORDHAU</h3><blockquote><p>雷霆一击</p><p>ACT，3D，多人</p></blockquote><p>西方中世纪骑士对战游戏，战斗表现力很强，可以砍下敌人任何部位。</p><h3 id="gigabash">GigaBash</h3><blockquote><p>巨击大乱斗</p><p>ACT，3D</p></blockquote><p>俯视角特摄角色格斗。</p><h3 id="slain-back-from-hell">Slain: Back from Hell</h3><blockquote><p>弑杀：地狱归来</p><p>2D侧视角，AAVG</p></blockquote><p>复古像素风格，难度很高。</p><h3 id="cave-story">Cave Story+</h3><blockquote><p>洞窟物语</p><p>ACT，2D平台</p></blockquote><p>非常经典的平台游戏。</p><h3 id="divine-knockout">Divine Knockout</h3><blockquote><p>神圣一击</p><p>ACT，3D，多人</p></blockquote><p>将对手击出地图外以获胜。战斗时卡顿感很明显。</p><h3 id="let-it-die">LET IT DIE</h3><blockquote><p>ACT，3D</p></blockquote><p>爬塔冒险。战斗还不错，但是各类加载太慢了，退出到标题画面都要很久。</p><h3 id="仙侠道1">仙侠道1</h3><p>心动游戏开发，2013年发行的回合制MMORPG。</p><p>初中接触的。玩的第一款页游，也是唯一一款页游。</p><p>美术和音乐都很出色，和其它的粗制滥造的页游完全不同。可惜2020年关服了。</p><h3 id="hell-is-others">Hell is Others</h3><blockquote><p>他人即地狱</p><p>PVPVE，恐怖，2D顶视角，像素</p></blockquote><p>克苏鲁风格的游戏，非常刺激。美中不足的是匹配机制不行，新手进去很容易死。</p><p>最后的结局就是删档重开？</p><h2 id="pc本地同乐">PC本地同乐</h2><p>可以一台电脑多人同屏/分屏玩的游戏。</p><h3 id="it-takes-two">It takes two</h3><blockquote><p>双人成行</p><p>AAVG</p></blockquote><p>2人。双人小游戏集大成者，充满创意和趣味。</p><h3 id="a-way-out">A Way Out</h3><blockquote><p>逃出生天</p><p>AAVG</p></blockquote><p>2人。关卡直观流畅，叙事有感染力，玩法丰富多彩，追逐部分尤其精彩。</p><h3 id="human-fall-flat">Human: Fall Flat</h3><blockquote><p>人类一败涂地</p><p>解谜，3D</p></blockquote><p>1~8人。适合很多人一起合作，非常欢乐。</p><h3 id="door-kickers-action-squad">Door Kickers: Action Squad</h3><blockquote><p>破门而入：行动小队</p><p>2D平台，射击</p></blockquote><p>1~2人。畅快刺激的射击游戏，尤其是两人一起玩。</p><h3 id="castle-crashers">Castle Crashers</h3><blockquote><p>城堡破坏者</p><p>卷轴，ARPG</p></blockquote><p>1~4人。算是童年回忆了，游戏相当精彩。这个公司的美术风格很有特色，国内很有名的flash小游戏《狂扁小朋友》就是这个游戏的开发者做的。</p><h3 id="riverbond">Riverbond</h3><blockquote><p>河畔之乡</p><p>AAVG，2.5D，像素</p></blockquote><p>1~4人。美术精美，动画很舒服。接入多个手柄即自动创建多个角色。</p><h3 id="ibb-obb">ibb &amp; obb</h3><blockquote><p>艾波与欧波</p><p>2D平台，解密</p></blockquote><p>2人。设计精巧，需要动脑子但又不太难，出色的双人游戏。</p><p>没有游戏说明，玩了一段时间才发现长按跳跳的更高，没弄懂右摇杆画出的彩色痕迹是干嘛的。</p><h3 id="overcooked-2">Overcooked! 2</h3><blockquote><p>胡闹厨房</p><p>休闲，厨房模拟</p></blockquote><p>1~4人（1人玩得控制两个角色）。考验合作和规划，需要耐心和条理。</p><h3 id="untitled-goose-game">Untitled Goose Game</h3><blockquote><p>鹅作剧</p><p>休闲</p></blockquote><p>1~2人。双人同屏合作时两只大鹅不能离太远，视点调整有点难受，要是能分屏就好了。这本来是单人游戏，后来出的双人模式。</p><h3 id="guacamelee-super-turbo-championship-edition">Guacamelee! SuperTurbo Championship Edition</h3><blockquote><p>墨西哥英雄大混战！超级漩涡冠军版</p><p>2D平台，ARPG，解谜</p></blockquote><p>1~4人。主角是牛战士，墨西哥背景。非常畅快。</p><p>还有第二部。</p><h3 id="unrailed">Unrailed</h3><blockquote><p>建造</p></blockquote><p>1~4人。一起修铁路。</p><h3 id="runbow">Runbow</h3><blockquote><p>2D平台，闯关</p></blockquote><p>1~9人。有竞速、占点等模式。</p><h3 id="horizon-chase-turbo">Horizon Chase Turbo</h3><blockquote><p>竞速，模拟</p></blockquote><p>1~8人。复古街机赛车游戏，适合朋友一起玩。</p><h3 id="never-alone">Never Alone</h3><blockquote><p>永不孤单</p><p>2D平台，AVG，解谜</p></blockquote><p>1~2人。主角是小女孩和狐狸，可两个手柄分开控制也可一个手柄控制。</p><p>有大量的关于阿拉斯加原住民的科普，富有文化底蕴。</p><h3 id="the-escapists-2">The Escapists 2</h3><blockquote><p>逃脱者2</p><p>策略，2D</p></blockquote><p>1~4人。非常好玩的越狱游戏，但套路也很明显，制作物品比较枯燥。</p><h3 id="tunche">Tunche</h3><blockquote><p>密林传奇</p><p>2D卷轴，ARPG，Roguelite</p></blockquote><p>1~4人。亚马逊丛林探险。</p><h3 id="black-widow-recharged">Black Widow: Recharged</h3><h3 id="centipede-recharged">Centipede: Recharged</h3><blockquote><p>射击，2D</p></blockquote><p>1~2人。畅快的街机玩法。</p><h3 id="super-bunny-man">Super Bunny Man</h3><blockquote><p>超级兔子人</p><p>2D平台</p></blockquote><p>1~4人。需要利用弹跳和抓取过关，难度较高。</p><h3 id="biped">Biped</h3><blockquote><p>只只大冒险</p><p>3D平台</p></blockquote><p>2人。难度适中，比较有趣。</p><h3 id="beyond-two-souls">Beyond: Two Souls</h3><blockquote><p>超凡双生</p><p>AVG</p></blockquote><p>1~2人。操作有点无聊，选择取向。</p><h3 id="失落城堡">失落城堡</h3><blockquote><p>Roguelite，2D卷轴</p></blockquote><p>1~4人。联机体验不好，经常有一方极其卡顿。</p><h3 id="unravel-2">Unravel 2</h3><blockquote><p>毛线小精灵2</p><p>2D平台</p></blockquote><p>1~2人。画面精美，故事为默片。</p><h2 id="pc其它">PC其它</h2><h3 id="视觉小说">视觉小说</h3><p>三色绘恋</p><p>第七号列车</p><p>我和她的世界末日</p><p>daydream 白日梦</p><p>Find Love or Die Trying / 寻爱或赴死</p><p>U-ena -空焰火少女</p><p>真恋~寄语枫秋~</p><blockquote><p>过于抒情，但毕竟是经典。</p></blockquote><p>Phoenix Wright: Ace Attorney Trilogy</p><blockquote><p>逆转裁判1-3合集，架空律师冒险游戏。讯问与指证，非常有趣的玩法。</p></blockquote><h3 id="浅尝辄止">浅尝辄止</h3><p>Sail Forth</p><blockquote><p>卡通风格海战AVG。</p></blockquote><p>Melvor Idle</p><blockquote><p>挂机RPG。</p></blockquote><p>Human Resource Machine</p><blockquote><p>编程模拟器。</p></blockquote><p>Snakebird Complete</p><blockquote><p>非常有创意的贪吃蛇。</p></blockquote><p>Cat Quest</p><blockquote><p>2D俯视角。典型的RPG游戏。</p></blockquote><p>GhostWire Tokyo</p><blockquote><p>FPS为主，恐怖为辅。</p></blockquote><p>Slay the Spire</p><blockquote><p>杀戮尖塔。朋友推荐的，但我对卡牌类Roguelite无感。苦痛之环除外。</p></blockquote><p>PUBG</p><p>Predecessor</p><blockquote><p>3D的MOBA</p></blockquote><p>Apex Legends</p><p>Fortnite</p><p>Second Extinction</p><p>Rising Storm 2: Vietnam</p><p>Borderlands 3</p><p>Eximius: Seize the Frontline</p><p>Hood: Outlaws &amp; Legends</p><p>KARDS</p><blockquote><p>二战版炉石传说，前线的设定很有趣。</p></blockquote><p>Recipe for Disaster</p><blockquote><p>餐厅经营，设计太多了反而无聊，这类型还是开罗游戏更好玩。</p></blockquote><p>Cook, Serve, Delicious! 3?!</p><blockquote><p>想起了小学玩过的金山系列打字游戏。</p></blockquote><p>Epistory Typing Chronicles</p><blockquote><p>本质是打字游戏，美术非常精美。</p></blockquote><p>CrocoMars</p><blockquote><p>一个小游戏，2D顶视角射击。音效很魔性。</p></blockquote><p>Divinity: Original Sin 2 神界原罪2</p><blockquote><p>自由度确实高，新手引导比较差，故事看不懂，不太想玩下去。</p></blockquote><p>Soda Dungeon 1/2</p><blockquote><p>挂机+策略游戏，玩了几个维度就撑不下去了，太无聊。</p></blockquote><p>Midnight Ghost hunt</p><blockquote><p>躲猫猫，4V4</p></blockquote><p>GRIME</p><blockquote><p>2D平台，ACT，探索。主角的头是个黑洞。跑图挺无聊的。</p></blockquote><p>Against All Odds</p><blockquote><p>类似电视节目男生女生向前冲</p></blockquote><p>永劫无间</p><p>Kao the Kangaroo</p><blockquote><p>AAVG，3D。感觉适合小朋友玩。这游戏竟然有9个G。</p></blockquote><p>The Sims 4 模拟人生4</p><p>PAYDAY 2</p><blockquote><p>扮演劫匪的游戏，但不怎么刺激。</p></blockquote><p>Beyond Blue</p><blockquote><p>海洋潜水探险游戏，包含很多专业知识。</p></blockquote><p>Murder by Numbers</p><blockquote><p>AAVG和数独式解谜结合的侦探游戏。</p></blockquote><p>The Elder Scrolls Online 上古卷轴OL</p><blockquote><p>MMORPG。玩法很好，但我对西幻剧情提不起兴趣。</p></blockquote><p>Albion Online</p><blockquote><p>MMORPG。入门容易，故事简单，画面舒服，组队可玩性很高。可惜没有时间……</p></blockquote><p>Homeworld Remastered Collection</p><blockquote><p>太空RTS，重制版画面精美，但我不是很习惯3D操作。</p></blockquote><p>Figment</p><blockquote><p>美术和音乐很不错，游戏性不强。</p></blockquote><p>shapez</p><blockquote><p>建造，策略。直观的流水线游戏，不太感兴趣。</p></blockquote><p>Warhammer 40000: Gladius - Relics of War</p><blockquote><p>TBS策略游戏，本身很完善。战锤40k本身设定庞大，看了好久，需要感兴趣。</p></blockquote><p>Heroes &amp; Generals WWII</p><blockquote><p>多人竞技。</p></blockquote><p>Gods will Fall</p><blockquote><p>Roguelite。玩法很有特色，但随机性太强。</p></blockquote><p>Tannenberg</p><blockquote><p>一战游戏。比较真实。</p></blockquote><p>Fall Guys</p><blockquote><p>网易的蛋仔派对和这好像。</p></blockquote><p>Redout: Enhanced Edition</p><blockquote><p>赛车游戏。</p></blockquote><p>Insurmountable</p><blockquote><p>Roguelite，策略。以登雪山为背景，有点意思。</p></blockquote><p>Cities Skylines</p><blockquote><p>建造，策略。</p></blockquote><p>Windbound</p><blockquote><p>AVG，生存。</p></blockquote><p>First Class Trouble</p><blockquote><p>狼人杀规则的游戏，以仿生人以背景。</p></blockquote><p>METAL SLUG</p><blockquote><p>合金弹头。和魂斗罗等街机游戏一并是童年回忆。可惜现在steam上买不到魂斗罗。</p></blockquote><p>Dodo Peak</p><blockquote><p>渡渡鸟峰。2.5D平台。街机玩法。</p></blockquote><p>Mortal Shell</p><blockquote><p>致命躯壳。魂系游戏。石化和附身的玩法很有趣。</p></blockquote><p>Severed Steel</p><blockquote><p>跑酷射击游戏。让人晕3D。</p></blockquote><p>Death Stranding</p><blockquote><p>死亡搁浅。AVG。</p></blockquote><p>Them's Fightin' Herds</p><blockquote><p>群马乱斗。FTG。</p></blockquote><p>Costume Quest 2</p><blockquote><p>万圣节大作战2。TBS和动作结合，有趣。</p></blockquote><p>Star Wars Squadrons</p><blockquote><p>星球大战战机中队。太空中开战机，不好操作。</p></blockquote><p>Saints Row IV: Re-Elected</p><blockquote><p>黑道圣徒 IV：改选。游戏风格特别狂放。</p></blockquote><p>Wildcat Gun Machine</p><blockquote><p>地牢探索。挺无聊的。</p></blockquote><p>Fort Triumph</p><blockquote><p>TBS，2.5D。西幻卡通风格，比较有趣。</p></blockquote><p>Evil Dead The Game</p><blockquote><p>鬼玩人。PVP。特别血腥，特别是各种处决动画。</p></blockquote><p>Dark Deity</p><blockquote><p>黑暗神祇。TBS，2.5D。明显的JRPG风格。</p></blockquote><p>Saturnalia</p><blockquote><p>农神节。Roguelite，恐怖。美术风格让我感到不适，特别是人物身上运动的纹理。</p></blockquote><p>ToeJam &amp; Earl: Back in the Groove!</p><blockquote><p>Roguelite。卡通风格，很无厘头。</p></blockquote><p>Darkwood</p><blockquote><p>黑暗森林。恐怖。波兰游戏，2D顶视角，美术很独特。</p></blockquote><p>The Drone Racing League Simulator</p><blockquote><p>无人机竞速联盟模拟器。模拟。</p></blockquote><p>Shop Titans</p><blockquote><p>传奇商店。经营。</p></blockquote><p>Gloomhaven</p><blockquote><p>幽港迷城。TBS，2.5D，桌游改。</p></blockquote><p>Terraforming Mars</p><blockquote><p>火星改造。TBS，桌游改。</p></blockquote><p>The Captain</p><blockquote><p>舰长。AVG，2D侧视角，像素。讲述了一个舰长拯救文明的故事。</p></blockquote><p>Spirit of the North</p><blockquote><p>北方之灵。AVG，3D。滑雪挺有意思的。</p></blockquote><p>Killing Floor 2</p><blockquote><p>杀戮空间2。FPS。重音乐杀僵尸。</p></blockquote><p>Iratus</p><blockquote><p>伊拉图斯。Roguelike，TBS。美术精美，作为死神收割凡人。</p></blockquote><p>Wonder Boy: The Dragon's Trap</p><blockquote><p>神奇小子：龙之陷阱。AAVG，2D平台。1989年的游戏的复刻版，非常精美，可以随时切换复古美术和音乐。</p></blockquote><p>Hundred Days Winemaking Simulator</p><blockquote><p>百日：葡萄酒酿造模拟器。</p></blockquote><p>Submerged: Hidden Depths</p><blockquote><p>淹没之城：深境。AVG。场景精美，但不太好玩。</p></blockquote><p>Paradigm</p><blockquote><p>解谜，点击。非常抽象的游戏，玩不懂。</p></blockquote><p>Just Die Already</p><blockquote><p>模拟老大爷。AVG，开放世界。搞笑游戏。</p></blockquote><p>Jotun: Valhalla Edition</p><blockquote><p>巨人约顿。AAVG，2.5D。手绘风格的美术。</p></blockquote><p>Maneater</p><blockquote><p>食人鲨。AAVG。扮演大鲨鱼，动作畅快。</p></blockquote><p>Supraland</p><blockquote><p>超大陆。AVG，解谜。卡通风格。</p></blockquote><p>Stardew Valley</p><blockquote><p>星露谷。RPG，2D。</p></blockquote><p>Rogue Legacy</p><blockquote><p>盗贼遗产。Roguelite，2D平台。难度很高。</p></blockquote><p>City of Brass</p><blockquote><p>黄铜之城。Roguelite，3D。不是很好玩。</p></blockquote><p>Alba: A Wildlife Adventure</p><blockquote><p>阿尔芭：野生动物冒险。AVG，休闲。以环境保护为主题的游戏。收集各类动物的图鉴（以鸟为主）。</p></blockquote><p>Spelldrifter</p><blockquote><p>咒语浪人。TBT，卡牌。</p></blockquote><p>BioShock</p><blockquote><p>生化奇兵。FPS，AVG。主角因空难进入海底城市冒险，比较恐怖。</p></blockquote><p>The Vanishing of Ethan Carter</p><blockquote><p>伊森卡特的消失。AVG，解谜，3D。一个很新奇的小故事。</p></blockquote><p>The Forest Quarter</p><blockquote><p>森林四重奏。AVG，解谜，2.5D。美术音乐不错。</p></blockquote><p>Out of Line</p><blockquote><p>边界之外。2D平台。像金箍棒的棒子有点意思，总体不是很好玩。</p></blockquote><p>Warhaven</p><blockquote><p>ACT，多人在线PVP。</p></blockquote><p>Model Builder</p><blockquote><p>模拟。制作手办。</p></blockquote><p>Soulstice</p><blockquote><p>ACT。画质一般，视角难受，机制复杂。</p></blockquote><p>Blazing Sail</p><blockquote><p>ACT。帆船PVP，挺有意思的。</p></blockquote><p>Q.U.B.E</p><blockquote><p>AVG，解谜。解谜经典，剧情老套。</p></blockquote><p>Portal 1/2</p><blockquote><p>传送门玩法。</p></blockquote><p>Bridge Constructor Portal</p><blockquote><p>传送门和造桥游戏的结合。</p></blockquote><h2 id="mobile">Mobile</h2><p>雀姬，雀魂</p><blockquote><p>日本麻将</p></blockquote><p>Cookeis Must Die</p><p>合战忍者村物语</p><blockquote><p>经典耐玩，日本开罗游戏的作品，其开发过很多类似的模拟经营手游。</p></blockquote><p>三国杀</p><blockquote><p>一个游戏，三个版本……</p></blockquote><p>炉石传说</p><p>元气骑士</p><p>光遇</p><p>原神</p><p>崩坏3</p><p>Pathos</p><blockquote><p>地牢Roguelite。</p></blockquote><p>世界弹射物语</p><blockquote><p>战斗版弹球游戏。</p></blockquote><p>伊洛纳（Elona）</p><blockquote><p>极高自由度的RPG。</p></blockquote><p>驻留（stay）</p><blockquote><p>即使离开游戏，游戏主角的时间依然流动。有点绑架人一次性玩完的意思。</p><p>通过与主角对话的形式推进游戏，让我想起了另一个游戏声之寄托（コエヲタヨリニ）。</p></blockquote><p>荒野乱斗</p><p>和平精英</p><p>世界征服者4</p><p>三国志战略版</p><p>文明与征服</p><p>小小五千年</p><p>梦幻花园</p><blockquote><p>这个游戏的小游戏太魔性了。很多游戏广告来自它。</p></blockquote><p>阿瑞斯病毒</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术书籍</title>
      <link href="//posts/Log/technical-book/"/>
      <url>//posts/Log/technical-book/</url>
      
        <content type="html"><![CDATA[<p>计算机相关技术书籍阅读记录</p><span id="more"></span><h1 id="编程语言">编程语言</h1><p>C Primer Plus 第六版 / Stephen Prata</p><ul><li>入门语言</li></ul><p>C++程序设计教程 / 钱能</p><p>C++ Primer 第五版 / Stanley B. Lippman, Josée Lajoie, Barbara E.Moo</p><ul><li>经典全面。</li></ul><p>C++ Primer Plus 第六版 / Stephen Prata</p><ul><li>同样经典全面。最后专门讨论了C++11。</li></ul><p><a href="https://google.github.io/styleguide/cppguide.html">GoogleC++ Style Guide</a> <spanclass="math inline">\(\stackrel{中文版}{\longrightarrow}\)</span> <ahref="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">GoogleC++ 风格指南</a></p><p>深度探索C++对象模型 / Stanley B. Lippman</p><ul><li>站在编译器开发者的角度分析C++。</li></ul><p>Effective C++ 第三版 / Scott Meyers</p><p>More Effective C++ / Scott Meyers</p><p>Effective STL / Scott Meyers</p><p>Effective Modern C++ / Scott Meyers</p><p><a href="https://changkun.de/modern-cpp/">现代 C++ 教程: 高速上手 C++11/14/17/20</a> / 欧长坤</p><p>STL源码剖析 / 侯捷</p><p>C++并发编程实战 第二版 / Anthony Williams</p><p>⬜Linux多线程服务端编程——使用muduo C++网络库 / 陈硕</p><p>⬜x86汇编语言：从实模式道保护模式 第二版 / 李忠，王晓波，余洁</p><p>⬜C++反汇编与逆向分析技术解谜 第二版 / 钱林松，张延清</p><p>⬜老“码”识途 / 韩宏，李林</p><p>流畅的Python / Luciano Ramalho</p><ul><li>适合python精进。</li></ul><p>Lua程序设计 第4版 / Roberto Ierusalimschy</p><ul><li>Lua语言的主要设计者所作。</li></ul><p>C# 7.0核心技术指南 / Joseph Albahari, Ben Albahari</p><p>Java程序设计基础 / 陈国君</p><p>Java编程逻辑 / 马俊昌</p><ul><li>并发部分讲的很好。</li></ul><p>阿里巴巴Java开发手册</p><h1 id="cg">CG</h1><p>Unity Shader 入门精要 / 冯乐乐</p><ul><li>少有的讲shaderlab的书。</li></ul><p>Fundamentals of Computer Graphics 第五版 / Steve Marschner, PeterShirley etc.</p><ul><li>GAMS101的参考书。</li></ul><p>DirectX 11 高级图形开发技术实战 / 韩元利，王汉东</p><ul><li>好看懂。</li></ul><p>Computer Graphics with OpenGL 第四版 / Donald Hearn etc.</p><ul><li>基于GLUT库，原理讲得细致。LearnOpenGL基于GLFW库。</li></ul><p>⬜DirectX 12 3D 游戏开发实战 / Frank D. Luna</p><ul><li>初学者不好看懂，建议从DX11入门后再看。</li></ul><p>⬜Physically Based Rendering 第三版 / Matt Pharr etc.</p><p>⬜Real-Time Rendering 第四版 / Tomas Akenine-Moller etc.</p><h1 id="游戏设计与开发">游戏设计与开发</h1><p>游戏设计梦工厂 <em>以游玩体验为核心，创造开创性的游戏</em> 第四版 /Tracy Fullerton</p><ul><li><p>游戏设计完整入门</p></li><li><p>原名 Game Design Workshop <em>A Playcentric Approach to CreatingInnovative Games</em></p></li></ul><p>体验引擎：游戏设计全景探秘 / 西尔韦斯特</p><ul><li>作者为Rimworld游戏的开发者。非常专业，结合现实案例高度总结了游戏设计理念和游戏开发流程。</li><li>侧重于从心理学角度分析。</li><li>原名 Designing Games: A Guide to Engineering Experiences。</li></ul><p>游戏设计的236个技巧：游戏机制、关卡设计和镜头窍门 / 大野宫二</p><ul><li>结合具体游戏细致分析了使游戏有趣的详细设计技巧。</li></ul><p>屠龙记：创造游戏世界的艺术 / 罗伯特·丹顿·布莱恩特</p><ul><li>主要讲叙事设计。</li></ul><p>平衡掌控者 游戏数值战斗设计 / 似水无痕</p><p>平衡掌控者 游戏数值经济设计 / 似水无痕</p><p>游戏概论 / 李瑞森，焦锟</p><ul><li>系统整理了历史、行业、策划、美术、引擎等。</li></ul><p>⬜游戏设计、原型与开发：基于unity与C#从构思到实现 第二版 / JeremyGibson Bond</p><ul><li>介绍了三种经典游戏设计框架，提出了新框架分层四元法。</li><li>MDA：机制（mechanics）、动态（dynamic）、美学（aesthetics）。</li><li>形式（formal）、戏剧（dramatic）、动态元素（dynamicelements）：《游戏设计梦工厂》提出。</li><li>四元法（elementaltetrad）：机制、美学、技术、剧情，《全景探秘游戏设计艺术》提出。</li><li>分层四元法：内嵌层、动态层、文化层三层，每层包括机制、美学、技术、叙事（narrative），本书基于前人提出。</li><li>原名 Introduction to Game Design, Prototyping, and Development: FromConcept to Playable Game with Unity and C#。</li></ul><p>⬜游戏引擎原理与实践 / 程东哲</p><h1 id="ai">AI</h1><p>深度学习之模型设计：核心算法与案例实践 / 言有三</p><ul><li>主要了解深度学习思想。</li></ul><p>深度学习之Tensorflow：入门、原理与进阶实战 / 李金洪</p><ul><li>这本书2018年出版，基于tensorflow1.4。</li></ul><p>从零开始学Tensorflow 2.0 / 赵铭，欧铁军</p><ul><li>大部分是代码，类似官方文档，对入门不好，但实用性不错。</li></ul><p>pytorch深度学习实战 / Eli Stevens, Luca Antiga, Thomas Viehmann</p><ul><li>非常适合pytorch入门。</li></ul><h1 id="计算机基础">计算机基础</h1><p>计算机科学导论 / Behrouz Forouzan, Firouz Mosharraf</p><p>⬜深入理解计算机系统 / Randal E.Bryant , David O'Hallaron</p><p>现代操作系统 / Andrew S. Tanenbaum</p><p>计算机网络：自顶向下方法 / James F. Kurose，Keith W. Ross</p><p>设计模式：可复用面向对象软件的基础 / Erich Gamma, Richard Helm, RalphJohnson, John Vlissides</p><blockquote><p>学校的专业课主要包括数据结构、算法、计算机组成原理、操作系统、计算机网络、数据库、编译原理、软件工程、电路、具体编程语言、具体应用开发，以及细分方向的课（如网安、大数据、AI、云计算等）。教材何其多。</p></blockquote><h1 id="其它">其它</h1><p>Python爬虫开发：从入门到实战 / 谢乾坤</p><ul><li>自己玩玩。</li></ul><p>深入理解BootLoader / 胡尔佳</p><ul><li>铺垫了一堆基础。对ELF文件的介绍也不全面，只提Section不讲Segment。</li></ul><p>树莓派开始，玩转Linux / Vamei，周昕梓</p><p>Hadoop大数据技术开发实战 / 张伟洋</p><p>Kafka入门与实践 / 牟大恩</p><p>Spark编程基础 / 林子雨，赖永炫，陶继平</p><p>Spark Streaming实时流式大数据处理实战 / 肖力涛</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人菜谱</title>
      <link href="//posts/Log/personal-recipe/"/>
      <url>//posts/Log/personal-recipe/</url>
      
        <content type="html"><![CDATA[<p>下厨与化学实验类似</p><span id="more"></span><p class="note note-warning">2023/11/18停止更新。</p><h1 id="基本操作">1 基本操作</h1><h2 id="肉类腌制">肉类腌制</h2><p>加入生粉（玉米淀粉）、蛋清（可选）、葱姜水、料酒、蒜末、耗油、生抽、植物油、香辛料抓匀放置15分钟。</p><p>不放盐、醋。盐会逼出水分（高渗透压）使肉柴，并且料酒、生抽等已含有盐；醋影响味道。</p><p>料酒作用是去腥，放少了无去腥作用，放多了有料酒味。若用的是<strong>葱姜料酒</strong>则无需葱姜水。</p><h2 id="焯水">焯水</h2><p>沸焯：沸水加入食材，水重新沸腾再捞出。多用于轻型蔬菜。肉类不能沸焯，表面会立刻变熟，阻碍血水的释放。</p><p>冷焯：冷水加入食材，水沸腾后捞出。多用于重型蔬菜及肉类。肉类需要加料酒去腥。</p><p>肉类若是做炒菜只需腌制，做焖炖菜只需焯水，不需要既腌制又焯水。</p><h2 id="使用料酒">使用料酒</h2><p>料酒去腥的原理是溶解腥味物质并挥发带走。</p><p>素菜不需要使用料酒。</p><p>炒肉时中途加入料酒，沿锅边加入不可直接倒在菜上，大火爆炒使其快速挥发，避免菜带有料酒味。</p><p>炖肉在焯水时加入料酒。</p><p>肉类腌制时可以加入料酒。</p><h2 id="香辛料">香辛料</h2><p>香辛料是主要用于给食物调味或着色的种子、果实、根、树皮或其他植物成分。有葱姜蒜、辣椒、花椒、黑白胡椒、洋葱、韭菜、八角、山奈、肉桂、小茴香、桂皮、陈皮、丁香、云木香、砂仁桂等。</p><p>可以直接使用香辛料，也可以使用加工后的单香辛料制品，如孜然粉、花椒粉、辣椒粉、黑胡椒粉、白胡椒粉等；或复合香辛料制品，如王守义十三香、欧芹大蒜盐等。</p><p>香辛料可以爆香时加入，也可以烹饪时加入，或者最后加入做好的菜品中。</p><h2 id="爆香">爆香</h2><p>确保锅内没有水，锅烧热后倒入冷油，立马倒入葱姜蒜等香辛料，中小火快速翻炒后即可倒入食材。</p><p>要确保香辛料不焦黑。</p><h2 id="炒糖色">炒糖色</h2><p>糖+清水+少许植物油。</p><p>大火化糖，变粘稠时改开中小火，水分蒸发完糖液变冒泡乳白色，称为<strong>挂霜</strong>，可做挂霜花生；继续熬制变香油色、大泡变小泡，称为<strong>拔丝</strong>，可做拔丝苹果；继续熬制颜色更深，称为<strong>琉璃</strong>，可做糖葫芦；继续熬制变枣红色，小泡变大泡称为<strong>嫩汁</strong>，可做红烧排骨，此时顺着锅边加入温水，再煮两三分钟，熬好的糖色是微苦微甜的。</p><p>冰糖做的糖色比白糖更亮。</p><h1 id="荤">2 荤</h1><h2 id="红烧排骨">红烧排骨</h2><ol type="1"><li>排骨清洗，冷焯</li><li>炒糖色，排骨翻炒上色</li><li>加入小米辣段、姜蒜、盐、香辛料，翻炒</li><li>加入温水没过排骨，水沸后加入盐小火慢煮</li><li>大火收汁，翻炒出锅</li></ol><h2 id="香干炒肉丝">香干炒肉丝</h2><ol type="1"><li>肉丝清洗，腌制，香干切丝</li><li>小米辣段和蒜末爆香，倒入肉丝翻炒</li><li>倒入香干继续翻炒</li><li>加入盐、生抽，翻炒出锅</li></ol><h2 id="麻辣鸡丝">麻辣鸡丝</h2><ol type="1"><li>鸡胸肉清洗，冷焯，撕成丝</li><li>干辣椒温水泡开，切丝</li><li>鸡丝用生抽、盐、鸡精、白糖、蚝油、香辛料拌匀，油锅煸炒</li><li>鸡丝微干时加入辣椒丝继续煸炒干</li></ol><h2 id="五花肉炒豆角">五花肉炒豆角</h2><ol type="1"><li>五花肉切片冷焯，豆角沸焯</li><li>小米辣段和蒜末爆香，倒入五花肉片和豆角翻炒</li><li>加入盐、鸡精、生抽，翻炒出锅</li></ol><h2 id="辣子鸡丁">辣子鸡丁</h2><ol type="1"><li><p>鸡腿肉切丁，腌制，干辣椒切段，空锅炒芝麻至微黄</p></li><li><p>油锅倒入鸡丁，炸至金黄捞出</p></li><li><p>蒜末和干辣椒爆香，倒入鸡丁翻炒</p></li><li><p>加入盐、鸡精、生抽，翻炒出锅，撒上芝麻</p></li></ol><h2 id="玉米虾仁">玉米虾仁</h2><ol type="1"><li>虾仁去虾线，腌制</li><li>油锅下甜玉米粒，炒出水分</li><li>下虾仁爆炒，撒上香辛料出锅</li></ol><h2 id="香菜牛肉">香菜牛肉</h2><ol type="1"><li>牛肉切丝，腌制，香菜洗净切段</li><li>蒜末和小米辣段爆香，倒入牛肉翻炒</li><li>牛肉变色后倒入香菜，加入盐、鸡精、生抽、香辛料，快速翻炒出锅</li></ol><h2 id="火腿肠炒玉米粒">火腿肠炒玉米粒</h2><ol type="1"><li>火腿肠切丁，玉米粒吸干水（若从罐头中取出）</li><li>油锅倒入玉米粒，炒至五分熟，倒入火腿肠翻炒</li><li>加入盐、鸡精、生抽，翻炒出锅</li></ol><h2 id="尖椒牛柳">尖椒牛柳</h2><ol type="1"><li><p>牛里脊肉切条，腌制，线椒切段</p></li><li><p>倒入线椒，炒出水分</p></li><li><p>葱姜蒜爆香，倒入牛里脊翻炒</p></li><li><p>炒至线椒出现虎皮，加入生抽、蚝油、盐、鸡精、糖翻炒出锅</p></li></ol><h2 id="火腿炒菌菇">火腿炒菌菇</h2><ol type="1"><li>火腿切片，白玉菇和蟹味菇沸焯</li><li>小米辣段和蒜末爆香，倒入菌菇和火腿翻炒</li><li>加入盐、鸡精、生抽、蚝油，翻炒出锅</li></ol><h2 id="煎牛排">煎牛排</h2><p>牛排按<strong>切割部位</strong>分为西冷（后腰肉）、眼肉（肋眼肉）、菲力（里脊肉）等；按<strong>牛种</strong>分为和牛、安格斯牛等。</p><p>牛排<strong>熟度</strong>分为全生（BlueRare）、一成熟（Rare）、三成熟（MediumRare）、五成熟（Medium）、七成熟（Medium Well）、全熟（WellDone）。不同种类的牛排适合不同的熟度，西冷、眼肉适合五成熟、七成熟；菲力适合三成熟、五成熟。</p><p>牛肉分级按国家不同，日本A5、澳大利亚M9、美国PRIME为最高品质。</p><ol type="1"><li>将冷冻牛排放至冷藏自然解冻12-24小时，然后室温放置2小时，用厨房纸吸去表面血水（若是现杀牛肉需要静置排酸）</li><li>牛排表面涂抹少量色拉油，锅烧热后下锅煎（厚切牛排需要先低温烹饪）</li><li>两面煎至想要的熟度（厚切牛排或边上有筋膜的牛排需要煎边）后换小火，牛排边放入黄油块和迷迭香，将融化的黄油和迷迭香汁水淋在牛排上</li><li>切开牛排，撒上黑胡椒、盐等香辛料</li><li>牛排在盘中醒5-10分钟（冷却使牛肉纤维收缩，将肉汁锁在牛排内）</li></ol><h2 id="葱油帝王蟹腿">葱油帝王蟹腿</h2><ol type="1"><li>熟冻帝王蟹腿解冻并切开分段，清水浸泡5分钟并冲洗，除去海水咸味</li><li>底部垫葱花和小米辣段，放蟹腿清蒸3分钟</li><li>蟹腿摆盘，淋入热油和蒸鱼豉油，佐鱼子酱</li></ol><h1 id="素">3 素</h1><h2 id="醋溜包菜">醋溜包菜</h2><ol type="1"><li>包菜清洗，撕碎</li><li>空碗加入生抽、盐、鸡精、白糖、蚝油</li><li>小米辣段和蒜末爆香，倒入包菜翻炒</li><li>包菜炒出水分后加入碗中作料，翻炒后淋上醋出锅</li></ol><h2 id="清炒菠菜">清炒菠菜</h2><ol type="1"><li>蒜末爆香</li><li>倒入菠菜，加入盐和鸡精，翻炒出锅</li></ol><h2 id="蚝油生菜">蚝油生菜</h2><ol type="1"><li>生菜沸焯出锅</li><li>小米辣段和蒜末爆香，放入蚝油、生抽烧开，淋入生菜</li></ol><h2 id="脆皮豆腐">脆皮豆腐</h2><ol type="1"><li>老豆腐切片，依次裹上生粉和鸡蛋液</li><li>油锅倒入豆腐片煎至金黄，加入蒜末、小米辣段爆香，捞出</li><li>淋上生抽、蚝油、盐、鸡精、香辛料</li></ol><h2 id="咸蛋黄焗玉米粒">咸蛋黄焗玉米粒</h2><ol type="1"><li>玉米粒用生粉拌匀</li><li>油锅倒入玉米粒炸指表面干脆，捞出</li><li>空锅倒入玉米粒，加入碾开的咸蛋黄，拌匀翻炒出锅</li></ol><h2 id="干煸豆角">干煸豆角</h2><ol type="1"><li>豆角洗净切段，沸焯，干辣椒切段</li><li>葱姜蒜爆香，倒入豆角和干辣椒翻炒</li><li>加入盐、鸡精、蚝油翻炒出锅</li></ol><h2 id="番茄炒蛋">番茄炒蛋</h2><ol type="1"><li>鸡蛋打匀，下锅打散煎熟</li><li>开水烫番茄，撕掉表皮后切块</li><li>葱蒜爆香，倒入番茄翻炒，加入生抽、盐、鸡精、糖</li><li>倒入鸡蛋，翻炒均匀出锅</li></ol><h2 id="炸土豆片">炸土豆片</h2><ol type="1"><li>土豆去皮，清洗切片，浸泡去除多余淀粉</li><li>冷焯</li><li>油锅炸至两面金黄，加入盐、香辛料翻炒出锅</li></ol><h2 id="酸辣土豆丝">酸辣土豆丝</h2><ol type="1"><li>土豆去皮，清洗切丝后放入盐水中泡10分钟泡出淀粉，沸焯15秒</li><li>蒜末和干辣椒爆香，倒入土豆丝翻炒</li><li>加入泡椒、陈醋、生抽、盐，翻炒出锅</li></ol><h2 id="烧椒皮蛋">烧椒皮蛋</h2><ol type="1"><li>线椒切段，皮蛋切四半</li><li>蒜末和干辣椒爆香，下线椒炒出虎皮</li><li>放入皮蛋翻炒出锅</li></ol><h1 id="汤">4 汤</h1><h2 id="紫菜口蘑汤">紫菜口蘑汤</h2><ol type="1"><li>汤碗放葱花、紫菜（若购买免洗品种则无需清洗）、虾皮、生抽、香油、盐、白胡椒粉</li><li>口蘑改十字刀</li><li>油锅将口蘑煎至半熟</li><li>汤碗加开水，然后倒入锅中同口蘑煮两分钟，盛入汤碗</li></ol><h2 id="番茄紫菜蛋汤">番茄紫菜蛋汤</h2><ol type="1"><li>汤碗放葱花、紫菜（若购买免洗品种则无需清洗）、虾皮、生抽、香油、盐、白胡椒粉</li><li>开水烫番茄，撕掉表皮后切块，鸡蛋打匀</li><li>油锅下番茄翻炒，然后加开水煮至沸腾，加入鸡蛋液，等待凝固后盛入汤碗</li></ol><h2 id="冬瓜肉丸汤">冬瓜肉丸汤</h2><ol type="1"><li>肉剁馅，加适当香辛料，和上淀粉和鸡蛋捏成丸子，冬瓜切片</li><li>煮肉丸至漂浮，撇去浮沫，然后下冬瓜</li><li>煮熟后盛入汤碗</li></ol><h1 id="凉菜">5 凉菜</h1><h2 id="凉拌皮蛋">凉拌皮蛋</h2><ol type="1"><li>每个皮蛋切四半</li><li>碗中加入葱花、蒜末、小米辣、生抽、醋、糖、盐、辣椒油、香油，搅匀淋在皮蛋上</li></ol><h1 id="附录">附录</h1><h2 id="特殊食物记录">特殊食物记录</h2><p>炸毛豆腐（味道难以形容）、臭鳜鱼 / 安徽</p><p>豆汁（味道独特）、炒肝（做法独特）、炸灌肠（没肉）、豌豆黄、干炸松肉、麻酱烧饼、门钉肉饼/ 北京</p><p>馅筋（肉打成馅上串烤，中东也有这种烤法）/ 北京门头沟</p><p>焖子火烧 / 河北保定</p><p>莜面栲【kǎo】栳【lǎo】栳、碗托（吃法独特）/ 山西</p><p>三不沾 / 河南安阳</p><p>乱炖 / 东北</p><p>藠【jiào】头（酱菜） / 中南及西南</p><p>渣/榨/鲊+广椒/海椒/辣椒 / 湖北</p><p>腌橄榄（味道难以形容） / 法国</p><p>酸嘢【yě】（酱菜）/ 广西</p><p>土笋冻（食材独特，用可口革囊星虫做的）/ 福建泉州</p><p>籺【hé】 / 广东</p><p>片儿川（面食）/ 浙江杭州</p><p>钵仔糕 / 广东</p><p>温州香酥肉、青岛脂渣（两者产地不同但很相似，后者更硬更油）</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些说明</title>
      <link href="//posts/Article/additional/"/>
      <url>//posts/Article/additional/</url>
      
        <content type="html"><![CDATA[<p>关于博客文章的一些说明</p><span id="more"></span><p><strong>文章中使用的emoji</strong></p><p>指示未完成内容</p><p>⬜</p><p>指示重点内容</p><p>🔺</p><p>指示疑问</p><p>❓</p><p>指示已解答疑问</p><p>❔</p><p>参考网站：<a href="https://emojixd.com/">🤣 Emoji表情大全，颜文字百科💌 - EmojiXD</a></p><p><strong>文章中使用的便签</strong></p><p>指示文章性质</p><p class="note note-primary">primary 紫</p><p>指示警告</p><p class="note note-warning">warning 黄</p><p>指示说明</p><p class="note note-info">info 蓝</p><p>其它</p><p class="note note-success">success 绿</p><p class="note note-secondary">secondary 灰</p><p class="note note-danger">danger 红</p><p class="note note-light">light 黑</p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF全流程代码解析</title>
      <link href="//posts/Research/NeRF-analysis/"/>
      <url>//posts/Research/NeRF-analysis/</url>
      
        <content type="html"><![CDATA[<p>Mildenhall B , Srinivasan P P , Tancik M , et al. NeRF: RepresentingScenes as Neural Radiance Fields for View Synthesis[J]. Springer, Cham,2020.</p><span id="more"></span><h1 id="相机参数生成">1.相机参数生成</h1><p>作者原代码见<a href="https://github.com/Fyusion/LLFF">Fyusion/LLFF:Code release for Local Light Field Fusion at SIGGRAPH 2019(github.com)</a></p><p>可以参考<a href="./相机参数相关脚本.md">相机参数相关脚本</a></p><p>进入LLFF-master，运行指令python imgs2pose.py./fern/，即可生成./fern/images/中照片的相机参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs flow">start=&gt;start: gen_poses<br>cond1=&gt;condition: 是否已经存在相机参数?<br>op1=&gt;operation: run_colmap<br>op2=&gt;operation: load_colmap_data<br>op3=&gt;operation: 调用系统中安装好的colmap生成cameras.bin、images.bin、points3D.bin<br>op4=&gt;operation: 加载colmap生成的bin文件,返回poses, pts3d, perm<br>op5=&gt;operation: save_poses<br>end=&gt;end: Done<br>start-&gt;cond1<br>cond1(no)-&gt;op1-&gt;op3(left)-&gt;op2<br>cond1(yes)-&gt;op2-&gt;op4-&gt;op5-&gt;end<br></code></pre></td></tr></table></figure><h2 id="入口函数.imgs2pose.py">1.1 入口函数(./imgs2pose.py)</h2><p>它接受两个参数，必选参数是scenedir，照片必须放在./scenedir/images/下（此例中是./fern/）；可选参数是match_type，有exhaustive_matcher（默认）和sequential_matcher两种。然后调用gen_poses函数。</p><h2 id="gen_poses函数.llffposespose_utils.py">1.2gen_poses函数(./llff/poses/pose_utils.py)</h2><p>它首先判断是否已有相机参数。没有的话调用<strong>run_colmap函数</strong>(./llff/poses/colmap_wrapper.py)生成相机参数。</p><p>run_colmap函数通过开启子进程的方式调用系统中安装好的colmap，令其在./fern/文件夹下依次执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">特征提取<br>colmap feature_extractor --database_path ./fern/database.db --image_path ./fern/images --ImageReader.single_camera 1<br>特征点匹配<br>colmap exhaustive_matcher --database_path ./fern/database.db<br>稀疏重建<br>colmap mapper --database_path  ./fern/database.db  --image_path  ./fern/images <br>  --output_path  ./fern/sparse  <span class="hljs-comment"># --export_path changed to --output_path in colmap 3.6</span><br>  --Mapper.num_threads 16<br>  --Mapper.init_min_tri_angle 4<br>  --Mapper.multiple_models 0<br>  --Mapper.extract_colors 0<br></code></pre></td></tr></table></figure><p>colmap运行日志打印到./fern/colmap_output.txt。</p><h2 id="load_colmap_data函数.llffposespose_utils.py">1.3load_colmap_data函数(./llff/poses/pose_utils.py)</h2><p>它调用./llff/poses/colmap_read_model.py下的函数加载colmap生成的相机参数（./fern/sparse/0/下的cameras.bin、images.bin、points3D.bin），返回poses,pts3d, perm。</p><p>加载cameras.bin得到<strong>相机内参</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-number">1</span><span class="hljs-punctuation">:</span> Camera(id=<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> model=&#x27;SIMPLE_RADIAL&#x27;<span class="hljs-punctuation">,</span> width=<span class="hljs-number">4032</span><span class="hljs-punctuation">,</span> height=<span class="hljs-number">3024</span><span class="hljs-punctuation">,</span> params=array(<span class="hljs-punctuation">[</span><span class="hljs-number">3.32041042e+03</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2.01600000e+03</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1.51200000e+03</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1.39666458e-02</span><span class="hljs-punctuation">]</span>))<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>以上参数对应相机编号, 相机模型, 宽, 高,<del>params[fx,fy,cx,cy]（fx、fy是焦距，cx、cy是光心）</del>这个网上的解释是错误的，我翻了colmap的源码，应该是params[f,cx,cy,k]，f是焦距，cx、cy是光心，k是畸变参数。这个相机模型SIMPLE_RADIAL是opencv相机模型的简化。</p><p>可以参考：<ahref="https://www.cnblogs.com/xiaohuidi/p/15767477.html">colmap相机模型及参数 - 小小灰迪 - 博客园 (cnblogs.com)</a></p><p>最终取hwf（高、宽、焦距）。</p><p>加载images.bin得到<strong>相机外参</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">Image(id=<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> qvec=array(<span class="hljs-punctuation">[</span> <span class="hljs-number">0.9977913</span> <span class="hljs-punctuation">,</span>  <span class="hljs-number">0.01760456</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0.06277221</span><span class="hljs-punctuation">,</span>  <span class="hljs-number">0.01273779</span><span class="hljs-punctuation">]</span>)<span class="hljs-punctuation">,</span> tvec=array(<span class="hljs-punctuation">[</span><span class="hljs-number">3.56130391</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1.68425</span>   <span class="hljs-punctuation">,</span> <span class="hljs-number">0.85253793</span><span class="hljs-punctuation">]</span>)<span class="hljs-punctuation">,</span> camera_id=<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> name=&#x27;IMG_4026.JPG&#x27;<span class="hljs-punctuation">,</span> xys=array(<span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span> <span class="hljs-number">157.9755249</span> <span class="hljs-punctuation">,</span>    <span class="hljs-number">6.25280905</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-punctuation">[</span>  <span class="hljs-number">37.46022034</span><span class="hljs-punctuation">,</span>    <span class="hljs-number">8.62553501</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-punctuation">[</span> <span class="hljs-number">493.85971069</span><span class="hljs-punctuation">,</span>    <span class="hljs-number">8.32364368</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>       ...<span class="hljs-punctuation">,</span><br>       <span class="hljs-punctuation">[</span><span class="hljs-number">1982.91186523</span><span class="hljs-punctuation">,</span>  <span class="hljs-number">725.0369873</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-punctuation">[</span><span class="hljs-number">1232.66833496</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2057.39038086</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-punctuation">[</span> <span class="hljs-number">981.81091309</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2577.60693359</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span>)<span class="hljs-punctuation">,</span> point3D_ids=array(<span class="hljs-punctuation">[</span>   <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span>    <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span>    <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span> ...<span class="hljs-punctuation">,</span>    <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span>    <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">10720</span><span class="hljs-punctuation">]</span>))<br><br></code></pre></td></tr></table></figure><p>qvec为四元数表示的相机旋转信息，tvec为平移向量。相机编号对应上面相机内参中的相机编号。名字是照片名。xys是该照片中找到的特征点，point3D_ids对应每个特征点的3D索引，如果其为-1则代表该点在重建过程中没有被观测为3D点。</p><p>qvec2rotmath函数将四元数qvec转化为3*3旋转矩阵。将3*3旋转矩阵和3*1平移向量和bottom位移向量[0,0,0,1]一起组装成<strong>4*4相机外参矩阵</strong>。</p><p>所有照片的相机外参矩阵一起堆叠成w2c_mats，对其求逆矩阵得c2w_mats。（假设有20张照片，则shape为(20,4, 4)）</p><p>(世界坐标系到相机坐标系的转换为w2c，相机坐标系到世界坐标系的转换为c2w）</p><p>对c2w_mats去掉第四行得到shape为(20, 3, 4)，再转置为(3, 4,20)，得到poses。</p><p>将加载相机内参得到的hwf变形为(3, 1,1),再沿axis=2复制扩张20倍（即poses.shape[-1]）得到hwf(3, 1, 20)。</p><p>将poses(3, 4, 20)和hwf(3, 1, 20)组装得到新的poses(3, 5,20)。对新poses的axis=1(第二个轴（列）)还要进行重排。</p><p>[1,2,3,4,5]的列顺序<strong>重排</strong>为[2,1,-3,4,5]。实际上就是旋转了一下坐标系，左手系还是右手系不变。</p><p>(代码里的解释是must switch to [-u, r, -t] from [r, -u, t], NOT [r, u,-t])</p><p>加载points3D.bin得到<strong>稀疏3D点</strong>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">Point3D(id=<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> xyz=array(<span class="hljs-punctuation">[</span> <span class="hljs-number">-1.95661541</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-14.04277513</span><span class="hljs-punctuation">,</span>  <span class="hljs-number">31.71051775</span><span class="hljs-punctuation">]</span>)<span class="hljs-punctuation">,</span> rgb=array(<span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">]</span>)<span class="hljs-punctuation">,</span> error=array(<span class="hljs-number">1.21389677</span>)<span class="hljs-punctuation">,</span> image_ids=array(<span class="hljs-punctuation">[</span><span class="hljs-number">7</span><span class="hljs-punctuation">,</span> <span class="hljs-number">6</span><span class="hljs-punctuation">]</span>)<span class="hljs-punctuation">,</span> point2D_idxs=array(<span class="hljs-punctuation">[</span><span class="hljs-number">63</span><span class="hljs-punctuation">,</span> <span class="hljs-number">63</span><span class="hljs-punctuation">]</span>))<br></code></pre></td></tr></table></figure><p>image_ids是该点存在于哪些照片之中（照片从1开始被编号，参见上面的相机外参）。point2D_idxs是该点在相应照片（image_ids）中对应的特征点的3D索引（即上面的相机外参中的point3D_ids）。</p><p>最后返回的perm是照片名数组的排序索引，poses是相机变换矩阵，pts3d是稀疏3D点。</p><h2 id="save_poses函数.llffposespose_utils.py">1.4save_poses函数(./llff/poses/pose_utils.py)</h2><p>输入是load_colmap_data函数得到的poses, pts3d, perm。</p><p>经过处理，pts_arr存放所有点的xyz坐标，vis_arr存放所有点在每张照片中的存在情况（1：存在，0：不存在），zvals是计算得到的深度信息。对于perm中的每张照片，取出在其上可见的所有点的深度信息，按百分比0.1和99.9取最小深度和最大深度，将其和这张照片的poses数组展开拼接为一维数组（3*5+2=17）。假设有20张照片的情况下，最终得到(20,17)的save_arr数组，将其保存到poses_bounds.npy供NeRF使用。</p><h1 id="nerf代码解析">2.NeRF代码解析</h1><p>作者原代码见<a href="https://github.com/bmild/nerf">bmild/nerf: Coderelease for NeRF (Neural Radiance Fields) (github.com)</a></p><p>进入nerf-dev, 运行指令python run_nerf_RE.py --config./configs/config_fern.txt开启训练fern模型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs flow">start=&gt;start: train<br>op1=&gt;operation: load_llff_data/load_blender_data/load_dv_data<br>sub1=&gt;subroutine: create_nerf<br>op2=&gt;operation: run the model<br>end=&gt;end: Done<br>start-&gt;op1-&gt;sub1-&gt;op2-&gt;end<br></code></pre></td></tr></table></figure><h2 id="入口函数train.run_nerf.py">2.1 入口函数train(./run_nerf.py)</h2><p>读取设定好的参数，输入参数列表见《复现NeRF》。</p><p>首先根据不同的数据类型读入数据，这里以load_llff_data为例。</p><p>选取训练集i_train和测试集i_test、i_val。</p><h2 id="load_llff_data部分.load_llff.py">2.2load_llff_data部分(./load_llff.py)</h2><p>读取生成相机参数代码生成的poses_bounds.npy，得到poses和bds；读照片文件夹，得到images。设照片数量为num，读取的poses、bds、imgs的shape为(num,3,5)(num,2) (num,768,1024,3)。</p><p>其中对poses矩阵的第二个轴（列）进行重排。[1,2,3,4,5]的列顺序<strong>重排</strong>为[2,1,-3,4,5]，实际上就是旋转了一下坐标系，左手系还是右手系不变。</p><p>生成render_poses:对于前向图片，得到螺旋渲染姿态；对于环视图片，得到旋转渲染姿态。</p><blockquote><p>recenter_poses函数：</p><p>可视化之后大概知道是把全部相机的位置（以原点为中心）绕x轴旋转了一个角度。但是不知道是为了什么。</p></blockquote><blockquote><p>spherify_poses函数：</p><p>可视化效果是把poses聚拢之后又转了一个小角度。</p></blockquote><blockquote><p>render_path_spiral函数：</p><p>返回一组密集的环绕视角用于生成视频。环绕视角的中心轴垂直于xy平面。</p></blockquote><p>求dists然后选i_test是为了选择居中的一张图片作为测试集。</p><p>其中有一些不是很理解：</p><p><font color=red>bd_factor的用处是什么？</font></p><p><font color=red>path_zflat有什么作用？</font></p><h2 id="create_nerf部分.run_nerf.py">2.3create_nerf部分(./run_nerf.py)</h2><p>创建NeRF的MLP模型</p><blockquote><p>get_embedder函数(./run_nerf_helpers.py)：入参是位置编码的最大频率的log2对数multires和位置编码方式i_embed，出参是一个函数embed_fn和输入维度input_ch。</p><p>embed_fn：操作一个1+multires*2长度的函数列表对输入数进行计算，返回一个拼接的tensor。这个函数列表第一个函数是y=x,此后每两个函数分别是y=sin(x*freq)和y=cos(x*freq)。freq是从<spanclass="math inline">\(2^0\)</span>到<spanclass="math inline">\(2^{(multires-1)}\)</span>按对数采样的multires个数。</p><p>input_ch为(1+multires*2)*input_dims。input_dims在程序里是常数3。</p><p>对于3D方向输入，multires默认是10，因此input_ch=63；对于2D方向输入，multires默认是4，因此input_ch_views=27。</p></blockquote><p>首先，调用get_embedder函数获得针对3D位置的embed_fn,input_ch，和针对2D方向的embeddirs_fn,input_ch_views（如果采用5D输入）。</p><p>设定output_ch = 4，skips =[4]，调用init_nerf_model函数生成模型model。</p><blockquote><p>init_nerf_model函数(./run_nerf_helpers.py)：入参是深度（默认8）、宽度（默认256）、input_ch、input_ch_views、output_ch、skips、use_viewdirs（是否采用5D输入），出参是model。</p><p>model使用ReLU作为激活函数，输入层inputs的shape为(input_ch +input_ch_views)，然后再分割为inputs_pts [None, input_ch] 和inputs_views[None, input_ch_views]，分别针对3D位置和2D方向。输出层为outputs。</p><p>广度为全连接层的输出数量，深度为全连接层的数目。skips对应的第五层将[inputs_pts,outputs]连接起来做一次跳跃。</p><p>如果采用5D输入，还要再增加alpha_out层和bottleneck层，同样在中间做跳跃连接。</p></blockquote><p>如果N_importance大于0，说明还要进行细采样，还要再生成一个模型model_fine。</p><p>将所有训练变量装入grad_vars。</p><p>定义函数<strong>network_query_fn</strong>，它调用<strong>run_network</strong>函数为网络准备输入。<strong>这个函数很关键，它是体渲染代码调用神经网络的入口。</strong></p><blockquote><p>run_network函数(./run_nerf.py)：</p><p>对输入调用embed_fn映射到高维空间，然后调用fn(也就是MLP模型)依据配置的args.netchunk每次选择指定数目的<strong>点</strong>进行并行计算。</p></blockquote><p>最后检查是否有已经训练好的参数可供加载，设置开始步数。</p><p>返回 render_kwargs_train, render_kwargs_test, start, grad_vars,models。分别是训练渲染参数，测试渲染参数，开始步数，训练变量，模型。</p><p>render_kwargs_train, render_kwargs_test的区别就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">render_kwargs_test[<span class="hljs-string">&#x27;perturb&#x27;</span>] = <span class="hljs-literal">False</span><br>render_kwargs_test[<span class="hljs-string">&#x27;raw_noise_std&#x27;</span>] = <span class="hljs-number">0.</span><br></code></pre></td></tr></table></figure><h2 id="run-the-model部分.run_nerf.py">2.4 run themodel部分(./run_nerf.py)</h2><p>如果只是渲染的话，直接调用render_path函数渲染出结果，然后返回。</p><blockquote><p>render_path函数(./run_nerf.py)：</p><p>入参gt_imgs函数是真实图像的意思</p><p>调用render函数依据配置的args.chunk每次选择指定数目的<strong>光线</strong>进行并行渲染。输入render_kwargs_test。</p><p>返回rgbs和disps，分别代表颜色和视差</p></blockquote><p>设置好优化器和全局训练步数。</p><p>如果使用随机光线批（即每次从所有图片中选取随机光线而不是只从一张图片选取随机光线），对于每张照片的pose，调用get_rays_np函数得到光线信息，和图片拼接在一起，得到所有图片所有像素的光线rays_rgb，shape是(N*H*W,3(即ro+rd+rgb),3)，其中ro是光线原点，rd是光线方向，rgb对应的像素颜色。（只取i_train对应的训练图片，并对所有光线做shuffle打乱）。</p><blockquote><p>get_rays_np函数(./run_nerf_helpers.py)：入参是H、W、focal、c2w，出参是rays_d、rays_o（shape是(H,W,3)）。代表一张图片上每处光线的方向和起点。</p><p>和get_rays函数应该是一摸一样。</p></blockquote><p>对于每一次训练，如果使用随机光线批，一次从rays_rgb中取N_rand条光线（默认是32* 32 * 4）batch，切分为batch_rays (ro、rd)和 target_s（rgb）。</p><blockquote><p>render函数(./run_nerf.py)：输入参数是H, W, focal,chunk（一次处理的光线数量。默认1024*32）, rays（batch_rays),render_kwargs_train（训练渲染参数）等，输出是rgb, disp, acc,extras。具体参数含义程序中有详细注释。</p><p>将rays分成rays_o和rays_d，rays_d除以二范数得到viewdirs。</p><p>对于forward facingscenes，调用ndc_rays函数将rays_o和rays_d转化为NDC坐标。</p><p>重新组装得到rays(ray origin(3), ray direction(3), min dist(1), maxdist(1), normalized viewingdirection(3))。为了防止OOM,调用batchify_rays函数按照chunk大小调用render_rays函数分批渲染得到结果。</p><p>render_rays函数：</p><p>进行体积渲染，在每条光线上选取一定数量的点采样，用MLP计算点的颜色和密度，积分得到光线的颜色。</p><p>首先在粗模型上采样，获得输出；然后在精细模型上调用sample_pdf函数根据概率密度函数进行层次采样。</p></blockquote><p>核心步骤：<strong>通过render函数渲染得到结果rgb与target_s对比，得到loss，输入优化器。</strong></p><p>之后的操作就是根据训练步数记录训练结果，输出图片和视频。训练直到指定步数结束。</p><h1 id="nerf思想">3.NeRF思想</h1><p><ahref="https://blog.csdn.net/Vpn_zc/article/details/115729297">NeRF:Representing Scenes as Neural Radiance Fields for View Synthesis</a></p>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机参数相关脚本</title>
      <link href="//posts/Research/script-on-camera-parameters/"/>
      <url>//posts/Research/script-on-camera-parameters/</url>
      
        <content type="html"><![CDATA[<p>相机参数</p><span id="more"></span><p>部分结合我的<ahref="https://github.com/bit704/visual-poses">代码仓库</a></p><h1 id="利用colmap的相机外参可视化">1.利用colmap的相机外参可视化</h1><p>利用colmap，算出每张照片的相机外参的四元数和位移向量。</p><p>根据四元数求得旋转矩阵。（旋转矩阵每一个列向量都是单位向量，且两两正交）</p><p>将旋转矩阵(3*3)与位移向量(3*1)还有底部齐次向量（1*4[0,0,0,1]）<strong>拼接</strong>得到世界到相机矩阵w2c(4*4)。</p><p>世界到相机矩阵w2c<strong>求逆</strong>到得到相机到世界矩阵c2w。</p><p>从相机到世界矩阵c2w中<strong>分割</strong>出相机到世界的旋转矩阵和位移向量。</p><p>把上述求出的旋转矩阵，与世界坐标系xyz轴的单位向量（列向量）分别相乘，即得到相机坐标系的xyz轴的单位向量。上述求出的位移向量，以世界坐标系的原点为起点，终点即为相机坐标系的原点。</p><p>如此便可绘出每张照片对应的相机坐标系的<strong>原点与xyz轴</strong>。</p><p><font color="red">注意：</font></p><p>绘制之后可以发现，colmap的世界坐标系里，各个相机视角的中心轴并不垂直于xy平面。</p><p>NeRF对于相机参数的预处理中没有解决这个问题，使用的世界坐标系各个相机视角的中心轴仍然不垂直于xy平面，但是渲染演示视频时使用的一圈新视角中心轴垂直于xy平面。因此使用环视数据集时，会出现演示视频的相机移动轨迹与采样的环视轨迹不一致。</p><p>instant-ngp对于相机参数的预处理解决了这个问题。</p><h1 id="llffnerf对于相机参数的处理">2.LLFF、NeRF对于相机参数的处理</h1><p>结合我写的<a href="NeRF全流程代码解析.md">NeRF全流程代码解析</a></p><p><strong>LLFF</strong>也是利用colmap，算出每张照片的相机外参的四元数和位移向量。</p><p>求出相机到世界矩阵c2w的步骤<strong>与第一部分相同</strong>。</p><p>将c2w(4*4)去掉底部齐次向量(1*4)，再与hwf向量(3*1，即宽高焦距，相机内参)拼接得到单个pose矩阵(3*5)。</p><p>poses矩阵的形状为(3*5*num)，num是照片的数量。</p><p>对poses矩阵的第二个轴（列）进行重排。[1,2,3,4,5]的列顺序<strong>重排</strong>为[2,1,-3,4,5]，实际上就是旋转了一下坐标系，左手系还是右手系不变。</p><p>poses数组最后被拉平拼接保存到poses_bounds.npy中。</p><p><strong>NeRF</strong>从poses_bounds.npy中加载得到poses矩阵。</p><p>将poses矩阵中的第四列（即hwf）<strong>根据实际输入图像的高宽进行修改</strong>。例如输入图像为原图1/4大小的图像，高宽均缩小为原图的1/4，焦距缩小为1/4。</p><p>对poses矩阵的第二个轴（列）进行重排。[1,2,3,4,5]的列顺序重排为[2,-1,3,4,5]，也是旋转了一下坐标系，左手系还是右手系不变。<strong>这并不是逆转了LLFF做的重排。</strong>因此，在对NeRF读取得poses进行可视化的时候，需要对z轴和y轴做反向，来逆转LLFF、NeRF对colmap求出的poses的重排造成的坐标系旋转。对instant-ngp也是一样的。</p><h1 id="新视角生成">3.新视角生成</h1><p>见 <ahref="https://github.com/bit704/visual-poses#%E4%BA%8C%E7%94%9F%E6%88%90%E6%96%B0%E8%A7%86%E8%A7%92">新视角生成</a></p>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复现纪要</title>
      <link href="//posts/Research/reproduction/"/>
      <url>//posts/Research/reproduction/</url>
      
        <content type="html"><![CDATA[<p>初学时记录一些简单的复现，后不再更新。</p><span id="more"></span><h1 id="复现nerf">复现NeRF</h1><p>Mildenhall B , Srinivasan P P , Tancik M , et al. NeRF: RepresentingScenes as Neural Radiance Fields for View Synthesis[J]. Springer, Cham,2020.</p><h2 id="运行环境">1. 运行环境</h2><h3 id="ubuntu">1.1 ubuntu</h3><h4 id="软硬件">1.1.1 软硬件</h4><p>设备：华硕魔霸新锐2021</p><p>系统：Ubuntu 21.10</p><p>显卡：NVIDIA GeForce RTX 3060 Laptop GPU</p><p>python环境：（与项目原环境不同）</p><p>conda</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 运行 conda env create -f environment.yml</span><br><span class="hljs-comment"># 以下是environment.yml中的内容</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">nerf2</span><br><span class="hljs-attr">channels:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">conda-forge</span><br><span class="hljs-attr">dependencies:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">python=3.7</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">pip</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">numpy</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">matplotlib</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">imageio</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">imageio-ffmpeg</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">configargparse</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">imagemagick</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">pip:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">tensorflow-gpu==2.5.0</span><br></code></pre></td></tr></table></figure><p>tensorflow-gpu==2.5.0也可以通过<em>pip install tensorflow-gpu==2.5.0(-i https://pypi.doubanio.com/simple</em> ,指定安装渠道) 安装。</p><h4 id="备注">1.1.2 备注</h4><ol type="1"><li><p>该项目的依赖imagemagick仅有linux和osx版本，没有windows版本，因此使用ubuntu。</p></li><li><p>Ubuntu 21.10之前的LTS版本没有合适此设备的键盘驱动和WIFI驱动。</p></li><li><p>3060只支持cuda11.1版本及以上，不兼容tensorflow1及相应cuda，运行项目会报错误（<ahref="https://github.com/bmild/nerf/issues/127">类似问题</a>），因此使用tensorflow2（<ahref="https://zhuanlan.zhihu.com/p/357652959">参考</a>)。</p></li><li><p>由于使用tensorflow2，以脚本为主、手工为辅的方式（<ahref="https://zhuanlan.zhihu.com/p/248557773">参考</a>）将原代码由tensorflow1改造升级到tensorflow2。</p></li><li><p>发现在conda中安装cudatoolkit和cudnn会找不到3060，因此手动安装（<ahref="https://zhuanlan.zhihu.com/p/393023811">参考</a>）。采用cudnn8.1+cuda11.2。nvdia-smi显示cuda版本大于等于nvcc显示的cuda版本即可。</p></li><li><p>tensorflow-gpu==2.5.0不可使用conda安装，单独安装（<ahref="https://blog.csdn.net/QAQIknow/article/details/118858870">参考</a>）</p></li><li><p>测试gpu</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Num GPUs Available: &quot;</span>, <span class="hljs-built_in">len</span>(tf.config.experimental.list_physical_devices(<span class="hljs-string">&#x27;GPU&#x27;</span>)))<br></code></pre></td></tr></table></figure></li><li><p>关闭ubuntu的合盖挂起。在使用GPU训练的时候如果挂机会导致nvidia驱动损坏，无法使用nvidia-smi，需要重装nvidia驱动（但不影响nvcc）。如果使用nvidia官方的驱动重装非常麻烦，并且可能会导致开机黑屏的bug，此刻需要进入ubuntu高级选项-恢复模式，通过root进入命令行，卸载nvidia驱动（直接使用命令卸载可能卸载不掉，需要使用nvidia驱动的安装文件卸载）。所以推荐使用标准ubuntu仓库进行驱动的自动安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ubuntu-drivers devices<br>sudo ubuntu-drivers autoinstall<br>sudo reboot<br></code></pre></td></tr></table></figure></li></ol><h3 id="windows">1.2 windows</h3><h4 id="软硬件-1">1.2.1 软硬件</h4><p>设备：华硕魔霸新锐2021</p><p>系统：windows 10</p><p>显卡：NVIDIA GeForce RTX 3060 Laptop GPU</p><p>python环境：（与项目原环境不同）</p><p>conda</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 运行 conda env create -f environment_win.yml</span><br><span class="hljs-comment"># 以下是environment_win.yml中的内容</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">nerf2</span><br><span class="hljs-attr">channels:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">conda-forge</span><br><span class="hljs-attr">dependencies:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">python=3.7</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">pip</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">numpy</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">matplotlib</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">imageio</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">imageio-ffmpeg</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">configargparse</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">pip:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">tensorflow-gpu==2.5.0</span><br></code></pre></td></tr></table></figure><h4 id="备注-1">1.2.2 备注</h4><ol type="1"><li>windows10中需安装好cudnn 8.1+cuda 11.2。</li><li>代码需要升级到tensorflow2。</li><li>相比在ubuntu中配置环境时去掉了原作者的imagemagick依赖。可以正常训练。</li><li>在conda中激活建立好的nerf2环境后，使用命令python run_nerf_RE.py--config ./configs/config_fern.txt开启训练fern模型。</li></ol><h2 id="实际运行">2.实际运行</h2><h3 id="本地验证">2.1 本地验证</h3><p>复现使用作者的<ahref="https://github.com/bmild/nerf">原代码</a>，在这里使用pythonrun_nerf.py --config config_fern.txt 运行ferndemo。（没有使用paper_configs里的llff_config，使用的作者提供的简化版config_fern.txt）</p><p>如果直接使用原来的参数运行，由于训练规模过大，在训练一定轮次后，会报<strong>显存不够</strong>的错误：</p><p>tensorflow.python.framework.errors_impl.ResourceExhaustedError: OOMwhen allocating tensor with shape[4194304,90] and type float on/job:localhost/replica:0/task:0/device:GPU:0 by allocator GPU_0_bfc[Op:ConcatV2] name: concat</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-%E6%98%BE%E5%AD%98%E4%B8%8D%E8%B6%B3.png"alt="显存不足" /><figcaption aria-hidden="true">显存不足</figcaption></figure><p>应该是因为我的3060的6G显存不如作者使用的nvidia v100。</p><p>因此，将config_fern.txt中的参数由：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">N_samples</span> = <span class="hljs-number">64</span><br><span class="hljs-attr">N_importance</span> = <span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>降低为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">N_samples</span> = <span class="hljs-number">16</span><br><span class="hljs-attr">N_importance</span> = <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>以减小训练规模，然后可以正常训练。</p><p>实际运行中的GPU情况：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-GPU-usage.png"alt="GPU使用情况" /><figcaption aria-hidden="true">GPU使用情况</figcaption></figure><p><strong>Terminal输出：</strong></p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-Terminal-output.png"alt="Terminal输出" /><figcaption aria-hidden="true">Terminal输出</figcaption></figure><p><strong>tesnorboard输出：</strong></p><p>使用命令tensorboard --logdir=logs/summaries --port=6006，查看网页</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-tensorboard1.png"alt="tensorboard1" /><figcaption aria-hidden="true">tensorboard1</figcaption></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-tensorboard2.png"alt="tensorboard2" /><figcaption aria-hidden="true">tensorboard2</figcaption></figure><p>最后输出的视频位于logs/fern_test文件夹中</p><p>完成整个训练过程大概需要34个小时（跑完1000kiterations，没有收敛）。因此减小训练参数效果不好。</p><h3 id="复现论文">2.2 复现论文</h3><p>因为在本地6G显存的3060上无法复现论文，所以采用24G的3090进行复现。</p><p><strong>3060与3090可以使用完全相同的环境。</strong></p><p>实际复现时使用了17G显存，迭代了200k次，大概24个小时。PSNR达到了论文的效果。</p><h3 id="训练细节">2.3 训练细节</h3><p>llff类型数据：</p><p>使用手机拍摄20张以上的照片，使用colmap自动生成相机参数。</p><p>我使用的是和作者一个型号的手机，因此拍照照片大小一样，均为4096*3024。拍完后分别做四分之一降采样和八分之一降采样的照片备用。作者在论文中使用的是四分之一降采样的照片做训练。</p><p>要求图片的长宽是16的整数倍，否则网络会做裁剪处理，可能会导致损失增大。</p><p>手动拍摄的照片之间基线不能太宽，角度变化不能太大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># render_rays函数的以下语句在处理360度环视场景时会报错</span><br>tf.debugging.check_numerics(ret[k], <span class="hljs-string">&#x27;output &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(k))<br></code></pre></td></tr></table></figure><h2 id="代码分析">3.代码分析</h2><p>以实际运行的fern demo为例子</p><h3 id="输入参数列表">3.1 输入参数列表</h3><table><thead><tr class="header"><th style="text-align: left;">参数名</th><th>默认值</th><th style="text-align: left;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">config</td><td></td><td style="text-align: left;">配置文件路径</td></tr><tr class="even"><td style="text-align: left;">expname</td><td></td><td style="text-align: left;">实验名</td></tr><tr class="odd"><td style="text-align: left;">basedir</td><td>./logs/</td><td style="text-align: left;">存放ckpts和logs的路径</td></tr><tr class="even"><td style="text-align: left;">datadir</td><td>./data/llff/fern</td><td style="text-align: left;">输入数据路径</td></tr><tr class="odd"><td style="text-align: left;">netdepth</td><td>8</td><td style="text-align: left;">网络层数</td></tr><tr class="even"><td style="text-align: left;">netwidth</td><td>256</td><td style="text-align: left;">每层的通道数</td></tr><tr class="odd"><td style="text-align: left;">N_rand</td><td>32*32*4</td><td style="text-align: left;">批大小 (每一梯度步的随即光线数)</td></tr><tr class="even"><td style="text-align: left;">lrate</td><td>5e-4</td><td style="text-align: left;">学习率</td></tr><tr class="odd"><td style="text-align: left;">lrate_decay</td><td>250</td><td style="text-align: left;">指数学习率下降(1000s内)</td></tr><tr class="even"><td style="text-align: left;">chunk</td><td>1024*32</td><td style="text-align: left;">平行处理的光线数(内存不足时应减小)</td></tr><tr class="odd"><td style="text-align: left;">netchunk</td><td>1024*64</td><tdstyle="text-align: left;">网络里平行发送的pts数(内存不足时应减小)</td></tr><tr class="even"><td style="text-align: left;">no_batching</td><td>False</td><td style="text-align: left;">一次只从一张图片获取随机光线</td></tr><tr class="odd"><td style="text-align: left;">no_reload</td><td>False</td><td style="text-align: left;">不从保存的模型中重载权重</td></tr><tr class="even"><td style="text-align: left;">ft_path</td><td>None</td><td style="text-align: left;">专为coarse网络重载的权重npy文件</td></tr><tr class="odd"><td style="text-align: left;">random_seed</td><td>None</td><td style="text-align: left;">确保结果可以复现的固定随机种子</td></tr><tr class="even"><td style="text-align: left;">precrop_iters</td><td>0</td><td style="text-align: left;">在central crops训练的步数</td></tr><tr class="odd"><td style="text-align: left;">precrop_frac</td><td>0.5</td><td style="text-align: left;">为central crops拿的图片部分</td></tr><tr class="even"><td style="text-align: left;">N_samples</td><td>64</td><td style="text-align: left;">每道光线的粗采样数</td></tr><tr class="odd"><td style="text-align: left;">N_importance</td><td>0</td><td style="text-align: left;">每道光线的附加细采样数</td></tr><tr class="even"><td style="text-align: left;">perturb</td><td>1.</td><td style="text-align: left;">0. for no jitter, 1. for jitter</td></tr><tr class="odd"><td style="text-align: left;">use_viewdirs</td><td>False</td><td style="text-align: left;">使用5D而不是3D输入</td></tr><tr class="even"><td style="text-align: left;">i_embed</td><td>0</td><td style="text-align: left;">0对应默认位置编码，1对应None</td></tr><tr class="odd"><td style="text-align: left;">multires</td><td>10</td><td style="text-align: left;">位置编码的最大频率对数（3D位置）</td></tr><tr class="even"><td style="text-align: left;">multires_views</td><td>4</td><td style="text-align: left;">位置编码的最大频率对数（2D方向）</td></tr><tr class="odd"><td style="text-align: left;">raw_noise_std</td><td>0.</td><td style="text-align: left;">std dev of noise added to regularizesigma_a output, 1e0 recommended</td></tr><tr class="even"><td style="text-align: left;">render_only</td><td>False</td><td style="text-align: left;">do not optimize, reload weights and renderout render_poses path</td></tr><tr class="odd"><td style="text-align: left;">render_test</td><td>False</td><td style="text-align: left;">render the test set instead ofrender_poses path</td></tr><tr class="even"><td style="text-align: left;">render_factor</td><td>0</td><td style="text-align: left;">downsampling factor to speed up rendering,set 4 or 8 for fast preview</td></tr><tr class="odd"><td style="text-align: left;">dataset_type</td><td>llff</td><td style="text-align: left;">三个选项：llff / blender / deepvoxels</td></tr><tr class="even"><td style="text-align: left;">testskip</td><td>8</td><td style="text-align: left;">will load 1/N images from test/val sets,useful for large datasets like deepvoxels</td></tr><tr class="odd"><td style="text-align: left;">shape</td><td>greek</td><td style="text-align: left;">四个选项：armchair / cube / greek /vase</td></tr><tr class="even"><td style="text-align: left;">white_bkgd</td><td>False</td><td style="text-align: left;">set to render synthetic data on a whitebkgd (always use for dvoxels)</td></tr><tr class="odd"><td style="text-align: left;">half_res</td><td>False</td><td style="text-align: left;">load blender synthetic data at 400x400instead of 800x800</td></tr><tr class="even"><td style="text-align: left;">factor</td><td>8</td><td style="text-align: left;">LLFF图片的降采样因子</td></tr><tr class="odd"><td style="text-align: left;">no_ndc</td><td>False</td><td style="text-align: left;">do not use normalized device coordinates(set for non-forward facing scenes)</td></tr><tr class="even"><td style="text-align: left;">lindisp</td><td>False</td><td style="text-align: left;">sampling linearly in disparity rather thandepth</td></tr><tr class="odd"><td style="text-align: left;">spherify</td><td>False</td><td style="text-align: left;">set for spherical 360 scenes</td></tr><tr class="even"><td style="text-align: left;">llffhold</td><td>8</td><td style="text-align: left;">will take every 1/N images as LLFF testset, paper uses 8</td></tr><tr class="odd"><td style="text-align: left;">i_print</td><td>100</td><td style="text-align: left;">控制台打印频率</td></tr><tr class="even"><td style="text-align: left;">i_img</td><td>500</td><td style="text-align: left;">tesnorboard图片注册频率</td></tr><tr class="odd"><td style="text-align: left;">i_weights</td><td>1000</td><td style="text-align: left;">权重模型保存频率</td></tr><tr class="even"><td style="text-align: left;">i_testset</td><td>5000</td><td style="text-align: left;">测试集保存频率</td></tr><tr class="odd"><td style="text-align: left;">i_video</td><td>5000</td><td style="text-align: left;">渲染姿态视频保存频率</td></tr></tbody></table><h3 id="训练过程">3.2 训练过程</h3><p>输入数据位于data/nerf_llff_data/fern</p><p>输出数据位于logs/fern_test</p><ul><li>调用run_nerf.py train()函数<ul><li>调用config_parser()函数，获取外部参数args</li><li>确定random_seed</li><li>确定数据类型，llff / blender / deepvoxels其中之一。</li><li>复现使用数据类型为llff，因此调用load_llff.pyload_llff_data()加载数据。<ul><li>load_llff_data()传入数据路径（./data/nerf_llff_data/fern）、降采样因子（8）、recenter(True)，bd_factor(0.75)，spherify（False）</li><li>根据根据降采样因子处理图片得到新图片（如果不存在）</li><li>从poses_bounds.npy读取poses和bds，从图片文件夹读取imgs</li></ul></li><li>将使用的配置写入args.txt和config.txt</li><li>使用create_nerf()建立模型</li><li>如果render_only参数为真，从训练好的模型渲染出结果</li><li>开启训练</li><li>输出的视频为螺旋视角移动的视频</li></ul></li></ul><h3 id="pose生成">3.3 Pose生成</h3><p>论文作者推荐使用LLFF code<sup><a class=n href="#ref3">[3]</a></sup>里的脚本imgs2poses.py来生成Pose，然后将数据以llff类型传入模型。于是我先采用一下这个方法。</p><p>（以下过程是在ubuntu上编译安装colmap，比较麻烦。在windows上直接安装很简单，下载好之后配上环境变量就行了。）</p><p>我一开始使用conda直接安装colmap，但是运行时会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Shader not supported by your hardware!<br>ERROR: SiftGPU not fully supported.<br></code></pre></td></tr></table></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-SiftGPU.png"alt="SiftGPU" /><figcaption aria-hidden="true">SiftGPU</figcaption></figure><p>这个问题我完全不知道怎么解决，可能3060及其驱动又和程序出现了兼容性问题。</p><p>可以从github的相关issue中看到<ahref="https://github.com/colmap/colmap/issues/971">有人提到</a> SiftGPUis rather old and not optimized with the latest GPU architecture, so itis very inefficient.</p><p><del>但是我的驱动已经是为了在3060上训练模型专门选择过了的，我不想再次更换。</del></p><p>于是我手动编译<ahref="https://colmap.github.io/install.html">安装colmap</a>，遇到了以下问题：</p><ol type="1"><li>编译 <a href="http://ceres-solver.org/">CeresSolver</a>这一步会把16G的内存跑满，导致编译失败甚至电脑重启。最好的解决办法是把交换区扩大。我是参考<ahref="https://www.linuxidc.com/Linux/2019-07/159580.htm">这篇文章</a>把交换区从2G扩大到10G。</li><li>编译colmap过程中，因为安装了anaconda导致系统库的路径被覆盖掉。进行到这里时，把~/.bashrc里的conda的环境变量注释掉。</li><li>ubuntu21.10自带的gcc (Ubuntu 11.2.0-7ubuntu2) 11.2.0和g++ (Ubuntu11.2.0-7ubuntu2)11.2.0版本太高，无法正确编译colmap中的一些模块，因此安装9版本代替11版本（<ahref="https://blog.csdn.net/Cxiazaiyu/article/details/106731687">参考</a>）。</li></ol><p>手动安装的colmap终于可用了，但我遇到了一个全新的问题。（<ahref="https://github.com/Fyusion/LLFF/issues/36">相同的issue</a>）</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-error1.png"alt="error1" /><figcaption aria-hidden="true">error1</figcaption></figure><p>根据我自己的实验，colmap在作者提供的数据集上运行的很完美，说明只是我只是拍的照片不够“好”，不足以让colmap匹配这些图片。（这种情况是，如果我对自己拍摄的照片进行降采样，就会使colmap无法匹配）</p><p>我自己用手机拍摄的一个数据集：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-toyset.png"alt="toyset" /><figcaption aria-hidden="true">toyset</figcaption></figure><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-toy.JPG"alt="toy" /><figcaption aria-hidden="true">toy</figcaption></figure><p>​ 实验证明可以用colmap生成相机参数并输入nerf或grf训练。</p><h2 id="评价标准">4.评价标准</h2><h3 id="psnr">4.1 PSNR</h3><p>Peak Signal to Noise Ratio 峰值信躁比</p><p>它是基于对应像素点间误差的图像质量评价。</p><blockquote><p>由于并未考虑到人眼的视觉特性（人眼对空间频率较低的对比差异敏感度较高，人眼对亮度对比差异的敏感度较色度高，人眼对一个区域的感知结果会受到其周围邻近区域的影响等），因而经常出现评价结果与人的主观感觉不一致的情况。</p></blockquote><p><span class="math display">\[MSE=\frac{1}{H\times W} \sum_{i=1}^{H} \sum_{j=1}^{W}(X(i,j)-Y(i,j))^2\]</span></p><p><span class="math display">\[PSNR=10\log_{10}{(\frac{(2^{n}-1)^2}{MSE} )}\]</span></p><p>其中，MSE表示当前图像X和参考图像Y的均方误差（Mean SquareError)，H、W分别为图像的高度和宽度；n为每像素的比特数，一般取8，即像素灰阶数为256。</p><p><spanclass="math inline">\(PSNR\)</span>的单位是dB，数值越大表示失真越小。</p><p>一般来说，<spanclass="math inline">\(PSNR\)</span>高于40dB说明图像质量几乎与原图一样好；在30-40dB之间通常表示图像质量的失真损失在可接受范围内；在20-30dB之间说明图像质量比较差；低于20dB说明图像失真严重。</p><h3 id="ssim">4.2 SSIM</h3><p>Structural Similarity 结构相似性</p><p>它分别从照明度(luminance)、对比度 (contrast) 和结构(structure)三方面度量图像相似性。 <span class="math display">\[l(X,Y)=\frac{2\mu_{x}\mu_{y}+C_{1}}{\mu_{x}^2+\mu_{y}^2+C_{1}}\]</span></p><p><span class="math display">\[c(X,Y)=\frac{2\sigma_{x}\sigma_{y}+C_{2}}{\sigma_{x}^2+\sigma_{y}^2+C_{2}}\]</span></p><p><span class="math display">\[s(X,Y)=\frac{\sigma_{xy}+C_{3}}{\sigma_{x}\sigma_{y}+C_{3}}\]</span></p><p>其中<span class="math inline">\(\mu_{x}\)</span>、<spanclass="math inline">\(\mu_{y}\)</span>分别表示图像X和Y的均值，<spanclass="math inline">\(\sigma_{x}\)</span>、<spanclass="math inline">\(\sigma_{y}\)</span>分别表示图像X和Y的方差，<spanclass="math inline">\(\sigma_{xy}\)</span>表示图像X和Y的协方差。</p><p><span class="math inline">\(C_{1}\)</span>、<spanclass="math inline">\(C_{1}\)</span>、<spanclass="math inline">\(C_{3}\)</span>为常数，为了避免分母为0的情况，通常取<spanclass="math inline">\(C_{1}=(K_{1}*L)^2\)</span>, <spanclass="math inline">\(C_{2}=(K_{2}*L)^2\)</span>, <spanclass="math inline">\(C_{3}=C_{2}/2\)</span>，一般地<spanclass="math inline">\(K_{1}=0.01\)</span>, <spanclass="math inline">\(K_{2}=0.03\)</span>, <spanclass="math inline">\(L=255\)</span>。 <span class="math display">\[SSIM(X,Y)=l(X,Y)c(X,Y)s(X,Y)\sim[0,1]\]</span> <span class="math inline">\(SSIM\)</span>取值范围<spanclass="math inline">\([0,1]\)</span>，值越大，表示图像失真越小。</p><h3 id="lpips">4.3 LPIPS</h3><p>Learned Perceptual Image Patch Similarity 学习感知图像块相似度</p><p>它也称为“感知损失”(perceptualloss)，用于度量两张图像之间的差别。<sup><a class=n href="#ref2">[2]</a></sup></p><p><spanclass="math inline">\(LPIPS\)</span>的值越低表示两张图像越相似，反之，则差异越大。</p><h2 id="参考文献">参考文献</h2><p><a name="ref1">[1] Mildenhall B , Srinivasan P P , Tancik M , et al.NeRF: Representing Scenes as Neural Radiance Fields for ViewSynthesis[J]. Springer, Cham, 2020.</a></p><p><a name="ref2">[2] Zhang R , Isola P , Efros A A , et al. TheUnreasonable Effectiveness of Deep Features as a Perceptual Metric[J].IEEE, 2018.</a></p><p><a name="ref3">[3]  Mildenhall B , Srinivasan P P , Ortiz-Cayon R ,et al. Local Light Field Fusion: Practical View Synthesis withPrescriptive Sampling Guidelines[J]. ACM Transactions on Graphics, 2019,38(4):1-14.</a></p><h1 id="复现extracting">复现Extracting</h1><p>Munkberg J, Hasselgren J, Shen T, et al. Extracting Triangular 3DModels, Materials, and Lighting From Images[C]//Proceedings of theIEEE/CVF Conference on Computer Vision and Pattern Recognition. 2022:8280-8290.</p><p><a href="https://github.com/NVlabs/nvdiffrec">代码仓库</a></p><p>装环境的时候使用国内源不要使用-c pytorch</p><p>驱动要求：</p><p>https://github.com/NVlabs/nvdiffrec/issues/46</p><p>安装 CUDA Toolkit 11.7 <ahref="https://developer.nvidia.com/cuda-downloads?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_network">link</a></p><p>安装 Vulkan SDK (someone mentioned to do this in a linux post) NOTE!Make sure that the Vulkan SDK is in your PATH environment variables: <ahref="https://vulkan.lunarg.com/doc/view/1.2.148.1/windows/getting_started.html">VulkanSDK Install Instructions</a></p><h1 id="复现grf">复现GRF</h1><p>Trevithick A , Yang B . GRF: Learning a General Radiance Field for 3DScene Representation and Rendering[J]. 2020.</p><h2 id="运行环境-1">1.运行环境</h2><p>可以使用与《复现NeRF》完全相同的环境。GRF的代码一部分基于NeRF。</p><h2 id="实验内容">2.实验内容</h2><p>参考论文中的实验部分。一共四个实验，前三个实验分别验证在不同物体、不同类别、不同场景的泛化能力，最后一个实验验证其在单个场景上的表现也胜过以往。</p><h3 id="不同物体泛化">2.1 不同物体泛化</h3><p>使用<ahref="https://drive.google.com/drive/folders/1OkYgeRcIcLOFu1ft5mRODWNQaPJ0ps90">SRNcars and chairsdatasets</a>，在cars和chairs这两个数据集上分别训练单独的模型。对每个训练好的模型：</p><ol type="1"><li>喂入一个新物体的2个视角的图片，然后推断其他251个视角的图片。</li><li>同上，但只喂入一个视角的图片。</li></ol><h3 id="不同类别泛化">2.2 不同类别泛化</h3><p>使用<ahref="https://github.com/Xharlie/ShapenetRender_more_variation">DISNMultiShapenet dataset</a>,在 {chair,bench,car,airplane,table,speaker}6个类别的数据集上训练，在{cabinet,display,lamp,phone,rifle,sofa,watercraft}7个新类别上验证。对于训练好模型：</p><ol type="1"><li>喂入属于新类别的一个新物体的2个视角的图片，然后推断全部36个视角的图片。</li><li>同上，喂入6个视角的图片。</li></ol><h3 id="不同场景泛化">2.3 不同场景泛化</h3><p>使用<ahref="https://drive.google.com/drive/folders/128yBriW1IG_3NJ5Rp7APSTZsJqdJdfc1">NeRFdataset</a>，对于其中的8个合成场景，随机选取4个场景进行训练。对于训练好的模型：</p><ol type="1"><li>将它直接在其它4个新场景上进行验证。</li><li>将它分别在其他4个新场景上进行微调（分别训练100,1k,10k次）,这样就得到3*4=12个新模型。使用NeRF分别在这4个新场景上训练（分别训练100,1k,10k次），然后与之对比。</li></ol><h3 id="单个场景表现">2.4 单个场景表现</h3><p>使用<ahref="https://drive.google.com/drive/folders/128yBriW1IG_3NJ5Rp7APSTZsJqdJdfc1">NeRFdataset</a>，在单个场景上进行训练，与NeRF对比。</p><h2 id="实际运行-1">3. 实际运行</h2><h3 id="不同物体泛化-1">3.1 不同物体泛化</h3><p>因为chairs数据集太大了，这里只使用cars数据集。将cars_test.zip，cars_train.zip，cars_train_test.zip，cars_train_val.zip，cars_val.zip五个压缩包下载下来，解压并把文件夹名字<strong>去掉“cars_”前缀</strong>。</p><p>使用python run.py --configconfig_shapenet_cars.txt运行程序。这里使用和作者一摸一样的配置。</p><p><strong>注意事项：</strong></p><ol type="1"><li><p>如果在windows下运行，config文件中数据路径写的windows路径，记得将load_shapenet_rewrite_lowmem.py里的load_shapenet_data函数中对文件路径操作时用的分隔符从'/'换成'//'。</p></li><li><p>数据集中有部分数据不合法，不满足load_shapenet_rewrite_lowmem.py里的read_scene函数中的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(rgb_files) == <span class="hljs-built_in">len</span>(pose_files), scene_path<br></code></pre></td></tr></table></figure><p>因此加上if判定忽视掉不合法数据使程序正常运行。</p></li><li><p>run.py中的render_rays函数最后的检查语句会报错，因此将其注释掉：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tf.debugging.check_numerics(ret[k], <span class="hljs-string">&#x27;output &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(k))<br></code></pre></td></tr></table></figure><p>这很奇怪，因为我采用与作者一摸一样的配置。</p><p>备注：GRF的render_rays函数与NeRF中的render_rays函数基本相同。NeRF中这个检查语句在我训练forward-facing场景时不会报错，训练360度场景时则会报错，但训练结果都是正常的。</p></li><li><p>第一次训练后发现没有tensorboard输出。后续有空给代码加上。</p></li></ol><p><strong>训练情况：</strong></p><p>使用24G的3090，显存基本占满。根据作者的说法他将32G的V100占满了。</p><p>GRF开始的训练是正常的，过了一段时间之后acm_loss全部变成nan。</p><p>根据作者在GithubIssue中的说法，训练400k次应该是足够的，因此我训练了30个小时完成400次。</p><h1 id="复现ibrdf">复现iBRDF</h1><p>Chen Z, Nobuhara S, Nishino K. Invertible neural BRDF for objectinverse rendering[J]. IEEE Transactions on Pattern Analysis and MachineIntelligence, 2021.</p><h2 id="环境">1 环境</h2><p><strong>操作系统</strong></p><p>Distributor ID: Ubuntu</p><p>Description: Ubuntu 22.04.1 LTS</p><p>Release: 22.04</p><p>Codename: jammy</p><p><strong>Docker</strong></p><p>Client: Docker Engine - Community</p><p>​ Version: 20.10.17</p><p>​ API version: 1.41</p><p>​ Go version: go1.17.11</p><p>​ Git commit: 100c701</p><p>​ Built: Mon Jun 6 23:02:46 2022</p><p>​ OS/Arch: linux/amd64</p><p>​ Context: default</p><p>​ Experimental: true</p><p>Server: Docker Engine - Community</p><p>​ Engine:</p><p>​ Version: 20.10.17</p><p>​ API version: 1.41 (minimum version 1.12)</p><p>​ Go version: go1.17.11</p><p>​ Git commit: a89b842</p><p>​ Built: Mon Jun 6 23:00:51 2022</p><p>​ OS/Arch: linux/amd64</p><p>​ Experimental: false</p><p>​ containerd:</p><p>​ Version: 1.6.7</p><p>​ GitCommit: 0197261a30bf81f1ee8e6a4dd2dea0ef95d67ccb</p><p>​ runc:</p><p>​ Version: 1.1.3</p><p>​ GitCommit: v1.1.3-0-g6724737</p><p>​ docker-init:</p><p>​ Version: 0.19.0</p><p>​ GitCommit: de40ad0</p><p><strong>依赖</strong>：</p><ol type="1"><li>A C++ 17-compatible compiler</li><li>CUDA 10.2</li><li>CMake</li><li>LibTorch 1.6.0</li><li>OptiX 7.0.0</li><li>TinyEXR (bundled)</li></ol><h2 id="实验过程">2 实验过程</h2><p>使用docker/下的脚本构建容器ranix。</p><p>如果运行容器时报错<ahref="https://github.com/NVIDIA/nvidia-docker/issues/1243">找不到设备驱动</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker: Error response from daemon: could not select device driver <span class="hljs-string">&quot;&quot;</span> with capabilities: [[gpu]].<br></code></pre></td></tr></table></figure><p>可以按照<ahref="https://collabnix.com/introducing-new-docker-cli-api-support-for-nvidia-gpus-under-docker-engine-19-03-0-beta-release/">教程</a>安装NVIDIAContainerRuntime，使用<code>systemctl restart  docker</code>重启服务，解决这个问题。</p><p>下载<a href="https://cdfg.csail.mit.edu/wojciech/brdfdatabase">MERLBRDF</a>，将二进制文件放到./datasets/merl目录下。挂vpn无法一次性下载全部，只能逐部下载。</p><figure><img src="https://cdfg.csail.mit.edu/assets/images/brdf.jpg"alt="MERL BRDF数据库包含一百种不同材质的反射函数" /><figcaption aria-hidden="true">MERLBRDF数据库包含一百种不同材质的反射函数</figcaption></figure><p>下载<ahref="https://github.com/chenzhekl/iBRDF">代码</a>到iBRDF-main。</p><p>下载指定版本<ahref="https://blog.csdn.net/weixin_43742643/article/details/114156298#cxx11_ABI_168">libtorch</a>和<ahref="https://developer.nvidia.com/designworks/optix/download">optix</a>到./iBRDF-main/third_party/下。</p><p>运行容器ranix，将iBRDF-main和datasets复制到ranix:/root/workspace中。</p><p>进入iBRDF-main，使用cmake编译项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake ..<br>make<br></code></pre></td></tr></table></figure><p>建立文件夹../datasets/merl_processed，进入iBRDF-main运行脚本转换BRDF数据格式适合训练：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python ./scripts/preprocess_merl.py ../datasets/merl ../datasets/merl_processed<br></code></pre></td></tr></table></figure><p>训练iBRDF</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: ./build/bin/ibrdf_train [MERL root] [Number of BRDFs per batch] [Number of samples per BRDF] [Number of epochs] [Output]<br><br>Example: ./build/bin/ibrdf_train ../datasets/merl_processed 50 10000 10000 ./run/ibrdf<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">terminate called after throwing an instance of <span class="hljs-string">&#x27;c10::Error&#x27;</span><br>  what():  CUDA error: no kernel image is available <span class="hljs-keyword">for</span> execution on the device<br>Exception raised from distribution_nullary_kernel at /pytorch/aten/src/ATen/native/cuda/DistributionTemplates.h:169 (most recent call first):<br>frame <span class="hljs-comment">#0: c10::Error::Error(c10::SourceLocation, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) + 0x69 (0x7ff957bdeeb9 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libc10.so)</span><br>frame <span class="hljs-comment">#1: void at::native::(anonymous namespace)::distribution_nullary_kernel&lt;float, float, 4, at::CUDAGeneratorImpl*, __nv_dl_wrapper_t&lt;__nv_dl_tag&lt;void (*)(at::TensorIterator&amp;, at::CUDAGeneratorImpl*, __nv_dl_wrapper_t&lt;__nv_dl_tag&lt;void (*)(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*), &amp;(void at::native::templates::cuda::normal_kernel&lt;at::CUDAGeneratorImpl*&gt;(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*)), 2u&gt;, float, float&gt;), &amp;(void at::native::templates::cuda::normal_and_transform&lt;float, float, 4ul, at::CUDAGeneratorImpl*, __nv_dl_wrapper_t&lt;__nv_dl_tag&lt;void (*)(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*), &amp;(void at::native::templates::cuda::normal_kernel&lt;at::CUDAGeneratorImpl*&gt;(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*)), 2u&gt;, float, float&gt; &gt;(at::TensorIterator&amp;, at::CUDAGeneratorImpl*, __nv_dl_wrapper_t&lt;__nv_dl_tag&lt;void (*)(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*), &amp;(void at::native::templates::cuda::normal_kernel&lt;at::CUDAGeneratorImpl*&gt;(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*)), 2u&gt;, float, float&gt;)), 2u&gt;&gt;, __nv_dl_wrapper_t&lt;__nv_dl_tag&lt;void (*)(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*), &amp;(void at::native::templates::cuda::normal_kernel&lt;at::CUDAGeneratorImpl*&gt;(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*)), 2u&gt;, float, float&gt; &gt;(at::TensorIterator&amp;, at::CUDAGeneratorImpl*, __nv_dl_wrapper_t&lt;__nv_dl_tag&lt;void (*)(at::TensorIterator&amp;, at::CUDAGeneratorImpl*, __nv_dl_wrapper_t&lt;__nv_dl_tag&lt;void (*)(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*), &amp;(void at::native::templates::cuda::normal_kernel&lt;at::CUDAGeneratorImpl*&gt;(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*)), 2u&gt;, float, float&gt;), &amp;(void at::native::templates::cuda::normal_and_transform&lt;float, float, 4ul, at::CUDAGeneratorImpl*, __nv_dl_wrapper_t&lt;__nv_dl_tag&lt;void (*)(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*), &amp;(void at::native::templates::cuda::normal_kernel&lt;at::CUDAGeneratorImpl*&gt;(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*)), 2u&gt;, float, float&gt; &gt;(at::TensorIterator&amp;, at::CUDAGeneratorImpl*, __nv_dl_wrapper_t&lt;__nv_dl_tag&lt;void (*)(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*), &amp;(void at::native::templates::cuda::normal_kernel&lt;at::CUDAGeneratorImpl*&gt;(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*)), 2u&gt;, float, float&gt;)), 2u&gt;&gt; const&amp;, __nv_dl_wrapper_t&lt;__nv_dl_tag&lt;void (*)(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*), &amp;(void at::native::templates::cuda::normal_kernel&lt;at::CUDAGeneratorImpl*&gt;(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*)), 2u&gt;, float, float&gt;) + 0x2e6 (0x7ff959f7bc76 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cuda.so)</span><br>frame <span class="hljs-comment">#2: void at::native::templates::cuda::normal_kernel&lt;at::CUDAGeneratorImpl*&gt;(at::Tensor&amp;, double, double, at::CUDAGeneratorImpl*) + 0x3af (0x7ff959f7db9f in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cuda.so)</span><br>frame <span class="hljs-comment">#3: at::native::normal_kernel(at::Tensor&amp;, double, double, c10::optional&lt;at::Generator&gt;) + 0x89 (0x7ff959f79d49 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cuda.so)</span><br>frame <span class="hljs-comment">#4: &lt;unknown function&gt; + 0xcc0a84 (0x7ff997ac9a84 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#5: &lt;unknown function&gt; + 0xcc11b0 (0x7ff997aca1b0 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#6: at::native::normal_(at::Tensor&amp;, double, double, c10::optional&lt;at::Generator&gt;) + 0x32 (0x7ff997aac6a2 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#7: &lt;unknown function&gt; + 0x1383085 (0x7ff99818c085 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#8: &lt;unknown function&gt; + 0x13a940b (0x7ff9981b240b in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#9: &lt;unknown function&gt; + 0x142c851 (0x7ff998235851 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#10: at::Tensor::normal_(double, double, c10::optional&lt;at::Generator&gt;) const + 0x67 (0x7ff998208c07 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#11: at::native::randn(c10::ArrayRef&lt;long&gt;, c10::optional&lt;at::Generator&gt;, c10::TensorOptions const&amp;) + 0x6c (0x7ff997cf9a6c in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#12: at::native::randn(c10::ArrayRef&lt;long&gt;, c10::TensorOptions const&amp;) + 0x30 (0x7ff997cf9b70 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#13: &lt;unknown function&gt; + 0x138095f (0x7ff99818995f in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#14: &lt;unknown function&gt; + 0x11ab07d (0x7ff997fb407d in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#15: &lt;unknown function&gt; + 0x11a5a98 (0x7ff997faea98 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#16: &lt;unknown function&gt; + 0x11ab07d (0x7ff997fb407d in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#17: at::randn(c10::ArrayRef&lt;long&gt;, c10::TensorOptions const&amp;) + 0xe7 (0x7ff9980b7557 in /root/workspace/iBRDF-main/third_party/libtorch/lib/libtorch_cpu.so)</span><br>frame <span class="hljs-comment">#18: &lt;unknown function&gt; + 0x18f1f (0x55a212218f1f in ./build/bin/ibrdf_train)</span><br>frame <span class="hljs-comment">#19: &lt;unknown function&gt; + 0x18fbc (0x55a212218fbc in ./build/bin/ibrdf_train)</span><br>frame <span class="hljs-comment">#20: &lt;unknown function&gt; + 0x14278 (0x55a212214278 in ./build/bin/ibrdf_train)</span><br>frame <span class="hljs-comment">#21: __libc_start_main + 0xe7 (0x7ff9563aec87 in /lib/x86_64-linux-gnu/libc.so.6)</span><br>frame <span class="hljs-comment">#22: &lt;unknown function&gt; + 0x1212a (0x55a21221212a in ./build/bin/ibrdf_train)</span><br><br>Aborted (core dumped)<br></code></pre></td></tr></table></figure><p>可能是libtorch版本并不能用1.6.0</p><h1 id="复现ingp">复现ingp</h1><p>Müller T, Evans A, Schied C, et al. Instant neural graphicsprimitives with a multiresolution hash encoding[J]. arXiv preprintarXiv:2201.05989, 2022.</p><p><a href="https://github.com/NVlabs/instant-ngp">代码仓库</a></p><h2 id="实验环境">1.实验环境</h2><p>RTX3090</p><p>CUDA 11.4</p><p>VS2019</p><p>编译过程中可能会遇到很多问题，具体参考github里的issue</p><p>远程控制主机，若主机不连接显示器，opengl渲染会出现白屏。</p><p>经过一次更新之后（https://github.com/NVlabs/instant-ngp/issues/36#issuecomment-1036198048），ingp对显存的需求量大大降低。</p><h2id="使用即时神经图形基元训练nerf模型的技巧">2.使用即时神经图形基元训练NeRF模型的技巧</h2><p><ahref="https://github.com/NVlabs/instant-ngp/blob/master/docs/nerf_dataset_tips.md">link</a></p><p>我们的NeRF实现期望初始相机参数以 transforms.json的格式提供，和原始的NeRF代码库兼容。我们提供了一个方便的脚本，scripts/colmap2nerf.py，它可以用来处理视频文件或图像序列，使用开源的COLMAP（structure from motion，SFM软件）来提取必要的摄像机数据。</p><p>训练过程可能对数据集非常挑剔。例如，重要的是数据集要有良好的覆盖率，不要包含错误标记的相机数据，不要包含模糊的帧(运动模糊和离焦模糊都是有问题的)。这篇问题试图给出一些技巧。一个很好的经验法则是，如果你的NeRF模型在20秒左右没有收敛，那么在长时间的训练之后，它就不太可能变得更好。因此，我们建议调整数据，以在培训的早期阶段获得明确的结果。对于大型的真实世界场景，可以通过最多几分钟的训练获得一点额外的清晰度。几乎所有的收敛都发生在最初的几秒钟。</p><p>数据集最常见的问题是相机位置的不正确比例或偏移（更多细节见下面）。第二个最常见的问题是图像太少，或者图像的相机参数不准确(例如，如果COLMAP失败)。在这种情况下，您可能需要获取更多的图像，或者调整计算相机位置的过程。这超出了instant-npg实现的范围。</p><h3 id="已有数据集">2.1 已有数据集</h3><p>默认情况下，instant-ngp的NeRF实现只将射线通过从[0,0,0]到[1,1,1]的单元边界框。默认情况下，数据加载器在输入JSON文件中接受摄像机转换，并将位置缩放0.33，偏移量[0.5,0.5,0.5]，以便将输入数据的原点映射到立方体的中心。缩放因子的选择是为了适应原始NeRF论文中的合成数据集，以及我们的脚本/colmap2nerf.py脚本的输出。</p><p>通过在UI的 "Debug visualization"中选择 "Debug visualization"和"Visualize unit cube"来检查你的摄像机与这个包围框的对齐方式是值得的，如下图所示:</p><p><imgsrc="https://github.com/NVlabs/instant-ngp/blob/master/docs/assets/nerfbox.jpg" /></p><p>对于单位立方体外有可见背景的自然场景，需要在transforms.json文件中把参数aabb_scale设置为2次幂(即1、2、4、8或16)，在最外层的作用域(与现有的camera_angle_x参数相同的嵌套)。data/nerf/fox/transforms.json是个例子。</p><p>效果如下图所示:</p><p><imgsrc="https://github.com/NVlabs/instant-ngp/blob/master/docs/assets/nerfboxrobot.jpg" /></p><p>摄像机仍然以单位立方体中的“感兴趣的对象”为中心;然而，aabb_scale参数，在这里设置为16，导致NeRF实现跟踪射线到一个更大的边界框(边长16)，包含背景元素，中心在[0.5,0.5,0.5]。</p><h3 id="扩展现有的数据集">2.2 扩展现有的数据集</h3><p>如果你有一个transform.json格式的数据集，它应该以原点为中心，并和原始的NeRFsyntheticdatasets规模近似。当你把它加载到NGP中时，如果你发现它没有收敛，首先要检查的是相机相对于立方体单元的位置，使用上面描述的调试功能。如果数据集不在单元立方体中占主导地位，则值得将其移到那里。你可以通过调整转换本身来做到这一点，或者你可以在json的外部范围中添加全局参数。</p><p>您可以设置以下任何参数，其中列出的值为默认值。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;aabb_scale&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">16</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;scale&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.33</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;offset&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0.5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0.5</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>实现细节和附加选项参见nerf_loader. cu。</p><h3 id="准备新的nerf数据集">2.3 准备新的NeRF数据集</h3><p>确保您已经安装了COLMAP，并且它在您的PATH中可用。如果您使用一个视频文件作为输入，也要确保安装FFmpeg，并确保它在您的PATH中可用。要检查这种情况，从一个终端窗口，您应该能够运行colmap和ffmpeg-?并从中看到一些帮助文本。</p><p>如果您正在从视频文件中进行训练，请在包含视频的文件夹中运行scripts/colmap2nerf.py脚本，并使用以下推荐参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">data-folder$ python [path-to-instant-ngp]/scripts/colmap2nerf.py --video_in &lt;filename of video&gt; --video_fps 2 --run_colmap --aabb_scale 16<br></code></pre></td></tr></table></figure><p>上面假设输入一个视频文件，然后按指定的帧率(2)提取帧。建议选择帧率在50-150左右的图像。对于一分钟的视频，——video_fps2是理想的。</p><p>如果从图像中进行训练，将它们放在名为images的子文件夹中，然后使用合适的选项，如下面的选项:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">data-folder$ python [path-to-instant-ngp]/scripts/colmap2nerf.py --colmap_matcher exhaustive --run_colmap --aabb_scale 16<br></code></pre></td></tr></table></figure><p>脚本将根据需要运行FFmpeg和/或COLMAP，然后执行转换到所需transforms.json格式的步骤，该步骤将写入当前目录。</p><p>默认情况下，脚本使用“顺序匹配器”调用colmap，它适用于从平滑变化的摄像机路径中拍摄的图像，比如视频。如果图像没有特定的顺序，则穷举匹配器更合适，如上面的图像示例所示。要了解更多选项，可以使用——help运行脚本。有关COLMAP更高级的使用或具有挑战性的场景，请参阅COLMAP文档;您可能需要修改脚本/colmap2nerf.py脚本本身。</p><p>aabb_scale参数是最重要的instant-ngp特定参数。它指定场景的范围，默认值为1;也就是说，场景被缩放，使得摄像机位置距离原点的平均距离为1个单位。对于小型的合成场景，如原始NeRF数据集，默认的aabb_scale为1是理想的，可以获得最快的训练。NeRF模型假设训练图像可以完全被包含在这个边界框中的场景所解释。然而，在自然场景中，背景超出了这个边界框，NeRF模型会在框的边界出现“飞蚊”。通过将aabb_scale设置为2的更大的幂(最高为16)，NeRF模型将射线扩展到一个更大的边界框。注意，这可能会轻微影响训练速度。如果有疑问，对于自然场景，首先将aabb_scale设置为16，然后如果可能的话将其缩小。值可以在transforms.json输出文件直接编辑，无需重新运行scripts/colmap2nerf.py脚本。</p><p>假设成功，你现在可以训练你的NeRF模型如下，从instant-ngp文件夹开始:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">instant-ngp$ ./build/testbed --mode nerf --scene [path to training data folder containing transforms.json]<br></code></pre></td></tr></table></figure><h3 id="nerf训练数据的技巧">2.4 NeRF训练数据的技巧</h3><p>NeRF模型在50-150张图像之间训练得最好，这些图像需要表现出最小的场景移动，运动模糊或其他人为模糊。COLMAP能够从图像中提取准确的相机参数，从而保证了重建的质量。有关如何验证这一点的信息，请参阅前面的部分。</p><p>colmap2nerf.py脚本假设所有训练图像都大约指向一个共享的兴趣点，它将这个点放置在原点。这个点是通过所有对训练图像的中心像素对光线之间最近的接近点取加权平均来找到的。在实践中，这意味着当训练图像指向感兴趣的对象时，脚本工作得最好，尽管它们不需要完成该对象的360度全景。如果将aabb_scale设置为大于1的数值，则感兴趣对象后面的任何可见背景仍然会被重建，如上所述。</p><h1 id="复现mip-nerf">复现Mip-NeRF</h1><p>Barron J T, Mildenhall B, Tancik M, et al. Mip-NeRF: A MultiscaleRepresentation for Anti-Aliasing Neural Radiance Fields[J]. arXivpreprint arXiv:2103.13415, 2021.</p><h2 id="运行环境-2">1. 运行环境</h2><h3 id="ubuntu-1">1.1 ubuntu</h3><p>系统版本：21.10</p><p>显卡：NVIDIA GeForce RTX 3060 Laptop GPU</p><p>python环境：按照作者github的原环境安装即可，记得使用国内源加速 -ihttps://pypi.doubanio.com/simple。建议手动安装，直接pip install -rrequirements.txt会下载很多多余的包，并且手动安装可以选择适配自己环境的。我安装的是tensorflow-gpu==2.5.0。</p><p>tensorflow2.x不再区分是否gpu，当检测到gpu并安装cuda后，自动调用gpu。</p><h2 id="实验内容-1">2.实验内容</h2><p>作者使用<ahref="https://drive.google.com/drive/folders/128yBriW1IG_3NJ5Rp7APSTZsJqdJdfc1">NeRF官方数据集</a>。使用以下命令从nerf_synthetic生成multiscale数据集:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python scripts/convert_blender_data.py --blenderdir /nerf_synthetic --outdir /multiscale<br></code></pre></td></tr></table></figure><p>batch_size默认4096 ，我的显存6G，将batch_size调小为512。</p><p>直接运行，会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">E external/org_tensorflow/tensorflow/stream_executor/cuda/cuda_dnn.cc:364] Could not create cudnn handle: CUDNN_STATUS_INTERNAL_ERROR<br></code></pre></td></tr></table></figure><p>这个怀疑是因为显存分配有问题。</p><p>并且，偶尔进程会被系统kill，怀疑是因为16G内存不够用。</p><h1 id="复现neutex">复现NeuTex</h1><p>Xiang F , Xu Z , Haan M , et al. NeuTex: Neural Texture Mapping forVolumetric Neural Rendering[J]. 2021.</p><p><a href="https://github.com/fbxiang/NeuTex">代码仓库</a></p><h2 id="运行环境-3">1. 运行环境</h2><h3 id="ubuntu-2">1.1 ubuntu</h3><p>系统版本：21.10</p><p>显卡：NVIDIA GeForce RTX 3060 Laptop GPU</p><p>python环境：pytorch gpu版本加上trimesh、hdf5、h5py</p><p>备注：直接pip installtorch的话会装成cpu版本，特别是添加了其他channel的情况下。另外，系统中安装了cuda就不需要按照官网的安装命令在conda中安装cudatoolkit,会发生冲突。我的显卡环境是cuda11.2+cudnn8.1，我的pytorch安装命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install torch==1.9.0+cu111 torchvision==0.10.0+cu111 torchaudio===0.9.0 -f https://download.pytorch.org/whl/torch_stable.html<br></code></pre></td></tr></table></figure><h3 id="windows-1">1.2 windows</h3><p>系统版本：windows10</p><p>显卡：NVIDIA GeForce RTX 3060 Laptop GPU</p><p>python环境：和ubuntu一摸一样</p><p>将原工程里的dtu.sh重写为dtu.bat即可在windows下运行。在Anacondaprompt中在配好的环境下执行 ..bat 114即可。</p><h2 id="实验内容-2">2.实验内容</h2><h3 id="运行作者提供的dtu-scene">2.1 运行作者提供的DTU scene</h3><p>首先，程序根据入参的dataset_name（“dtu”）加载实现写好的dtu_dataset.py类，用这个类从入参的data_root（"DTU/scan%1%/trainData"，%1%为入参114）下加载训练数据。它加载的就是存在hdf5里的图片数据和一些相机参数以及点云，还有用来分离图片背景的mask。</p><p>运行没有问题。</p><p>要使用自己的输入数据的话，需要根据作者的要求写一个自己的数据加载类，加载指定需要的数据即可（而类中的加载方式怎么写都行，所以源数据格式不重要）。</p><h1 id="复现nlt">复现NLT</h1><p>Zhang X , Fanello S , Tsai Y T , et al. Neural Light Transport forRelighting and View Synthesis[J]. 2020.</p><h2 id="运行环境-4">1.运行环境</h2><p>原工程在ubuntu下测试，并且作者自己写的第三方库不兼容windows，因此其不能在windows上运行。</p><p>为了使其在3060、cuda11.2.0、cudnn8.1.1下运行，将原conda环境更改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">nlt</span><br><span class="hljs-attr">channels:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">conda-forge</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">anaconda</span><br><span class="hljs-attr">dependencies:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">python=3.6</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">pip</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">numpy</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ipython</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">pillow</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">opencv</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tqdm</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">pip:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">tensorflow==2.5.0</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">tensorflow-addons==0.13.0</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">tensorflow-probability==0.13.0</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mpmath</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">matplotlib</span><br></code></pre></td></tr></table></figure><h2 id="实验内容-3">2.实验内容</h2><h3 id="使用作者的数据复现">2.1 使用作者的数据复现</h3><p>在作者的<ahref="http://nlt.csail.mit.edu/">项目主页</a>下载dragon_specular.zip，dragon_sss.zip。</p><p>可以在环境变量中添加作者自己的第三方库，也可以在pycharm的configurations中添加运行时的环境变量，注意ubuntu中的环境变量用:隔开。</p><p>原代码是在ubuntu上运行的，因此配置文件里在文件名中使用:，而这在windows下是不允许的，可以将其修改为$。</p><p>但是作者的自己写的第三方库并没有兼容windows，运行会报错:</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-windows%E4%B8%8D%E5%85%BC%E5%AE%B9.png"alt="windows不兼容" /><figcaption aria-hidden="true">windows不兼容</figcaption></figure><p><font color=red>非常坑的一点就是中断之后重新运行，不会加载原来保存的checkpoint而是直接覆盖输出目录重新从0开始训练，记得把配置文件里的overwrite改为False。</font></p><p>作者配置文件里的bs对应batch_size，值是4。直接跑的话可能会因为显存不够进程挂掉（有时候不会），改为2进行训练。大概需要30个小时完成训练（3060,6G显存）。</p><p>dragon_specular.zip训练结果：</p><figure><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-dragon_specular_ckpt-100_pred_2fps.gif"alt="dragon_specular_ckpt-100_pred_2fps" /><figcaptionaria-hidden="true">dragon_specular_ckpt-100_pred_2fps</figcaption></figure><p>dragon_sss.zip训练所需的神经网络学习率是前者的1/4，且深度是前者的4倍，可能会慢很多。并且将其batchsize减半依然超出6G显存，暂时没有训练。</p><h1 id="复现plenoxel">复现plenoxel</h1><p>Fridovich-Keil S, Yu A, Tancik M, et al. Plenoxels: Radiance FieldsWithout Neural Networks[C]//Proceedings of the IEEE/CVF Conference onComputer Vision and Pattern Recognition. 2022: 5501-5510.</p><p><a href="https://github.com/sxyu/svox2">代码仓库</a></p><h2 id="运行环境-5">1.运行环境</h2><p>注释掉原environment.yml中的pytorch、torchvision、cudatoolkit。直接pipinstall torch的话会装成cpu版本。应使用如下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install torch==1.9.0+cu111 torchvision==0.10.0+cu111 -f https://download.pytorch.org/whl/torch_stable.html<br></code></pre></td></tr></table></figure><p>使用以下命令安装库(svox2)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install .<br></code></pre></td></tr></table></figure><h2 id="运行">2.运行</h2><p>下载作者训练好的模型，直接进行评估。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python .\opt\render_imgs_circle.py .\ckpt\ckpt.npz .\data\fern\<br></code></pre></td></tr></table></figure><p>在RTX3060上，渲染一个40秒、30帧的视频需要20分钟左右的时间和4-5G显存。</p>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tiny-cuda-nn使用</title>
      <link href="//posts/Research/tiny-cuda-nn-usage/"/>
      <url>//posts/Research/tiny-cuda-nn-usage/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/NVlabs/tiny-cuda-nn">tiny-cuda-nn</a></p><span id="more"></span><h1 id="一.概括">一.概括</h1><p>这是一个用于训练和查询神经网络的小型自包含框架。值得一提的是，它包含一个闪电般的快速“完全融合”多层感知器，一个通用的多分辨率哈希编码，以及对各种其他输入编码、损失和优化器的支持。</p><h2 id="完全融合多层感知器">1. “完全融合”多层感知器</h2><p>图来自<ahref="https://tom94.net/data/publications/mueller21realtime/mueller21realtime.pdf">Real-timeNeural Radiance Caching for Path Tracing (tom94.net)</a></p><p><imgsrc="https://raw.githubusercontent.com/NVlabs/tiny-cuda-nn/master/data/readme/fully-fused-mlp-diagram.png" /></p><p>(a)对于大批量输入(例如对于1920 × 1080帧，N≈<spanclass="math inline">\(2^{21}\)</span>)，评估多层感知器(MLP)相当于交替使用“权矩阵乘法”和“激活函数的按元素应用”。</p><p>(b)在我们的完全融合MLP中，我们通过将批划分为128个元素宽的块来并行化这个工作负载，每个块由各自的线程块处理。由于我们的MLP很窄(<spanclass="math inline">\(M_{hidden}\)</span> = <spanclass="math inline">\(M_{in}\)</span> =64个神经元宽)，它的权重矩阵适合寄存器，中间的64 ×128个神经元激活适合共享内存。这是完全融合方法的卓越性能的关键。</p><p>(c)每个线程块进行矩阵乘法运算，将第i层<spanclass="math inline">\(H_{i}\)</span>转换为预先激活的下一层<spanclass="math inline">\(H^{&#39;}_{i+1}\)</span>。它被切成16 ×16个元素的块，以匹配我们的硬件加速的半精度矩阵乘法器(TensorCore)的大小。每个线程块的组计算一个16× 128块行<spanclass="math inline">\(H^{&#39;}_{i+1}\)</span>(例如条带区域)，首先从<spanclass="math inline">\(W_i\)</span>加载相应的16 ×64条带权重到寄存器，然后将它们乘以<spanclass="math inline">\(H_{i}\)</span>的所有64 ×16块列。因此，每个线程块只从全局内存加载一次权值矩阵(尽可能少的量)，只在位于快速共享内存中的Hi上进行多次传递。</p><h2 id="多分辨率哈希编码">2. 多分辨率哈希编码</h2><p>图来自<ahref="https://nvlabs.github.io/instant-ngp/assets/mueller2022instant.pdf">InstantNeural Graphics Primitives with a Multiresolution Hash Encoding(nvlabs.github.io)</a></p><p><imgsrc="https://raw.githubusercontent.com/NVlabs/tiny-cuda-nn/master/data/readme/multiresolution-hash-encoding-diagram.png" /></p><p>（算法流程序号和图中序号无关）</p><p>1）L是分辨率级数（一般取16，即有16个不同级别分辨率的哈希表作为辅助结构）。对于输入坐标x，我们在每一个分辨率级别上找到它周围的体素，并通过哈希它们的整数坐标为它们的角指定索引。</p><p>2）对于得到的角索引，我们从哈希表查询相关的F维（一般取F=2）特征向量，根据坐标x和体素的相对位置进行线性插值，得到x的特征向量。</p><p>3）将每一个分辨率级别上得出的x特征向量进行拼接，同时拼接入辅助输入ξ（维度为E）。此时得到的输出的维度一共是L·F+E。</p><p>4）将输入进行编码后输入MLP进行训练。损失梯度会通过MLP、向量拼接、线性插值传播，然后累计到查找的特征向量上。</p><h1 id="二.表现">二.表现</h1><p><imgsrc="https://github.com/NVlabs/tiny-cuda-nn/blob/master/data/readme/fully-fused-vs-tensorflow.png" /></p><p><em>Fully fused networks</em> vs. TensorFlow v2.5.0 w/ XLA。</p><p>在RTX3090上测量64个(实线)和128个(虚线)神经元宽的多层感知器。由benchmarks/bench_ours.cu和使用data/config_oneblob.json的benchmarks/bench_tensorflow.py生成。</p><h1 id="三.用法">三.用法</h1><p>简单的C++/CUDA API:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tiny-cuda-nn/common.h&gt;</span></span><br><br><span class="hljs-comment">// Configure the model</span><br>nlohmann::json config = &#123;<br>&#123;<span class="hljs-string">&quot;loss&quot;</span>, &#123;<br>&#123;<span class="hljs-string">&quot;otype&quot;</span>, <span class="hljs-string">&quot;L2&quot;</span>&#125;<br>&#125;&#125;,<br>&#123;<span class="hljs-string">&quot;optimizer&quot;</span>, &#123;<br>&#123;<span class="hljs-string">&quot;otype&quot;</span>, <span class="hljs-string">&quot;Adam&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;learning_rate&quot;</span>, <span class="hljs-number">1e-3</span>&#125;,<br>&#125;&#125;,<br>&#123;<span class="hljs-string">&quot;encoding&quot;</span>, &#123;<br>&#123;<span class="hljs-string">&quot;otype&quot;</span>, <span class="hljs-string">&quot;HashGrid&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;n_levels&quot;</span>, <span class="hljs-number">16</span>&#125;,<br>&#123;<span class="hljs-string">&quot;n_features_per_level&quot;</span>, <span class="hljs-number">2</span>&#125;,<br>&#123;<span class="hljs-string">&quot;log2_hashmap_size&quot;</span>, <span class="hljs-number">19</span>&#125;,<br>&#123;<span class="hljs-string">&quot;base_resolution&quot;</span>, <span class="hljs-number">16</span>&#125;,<br>&#123;<span class="hljs-string">&quot;per_level_scale&quot;</span>, <span class="hljs-number">2.0</span>&#125;,<br>&#125;&#125;,<br>&#123;<span class="hljs-string">&quot;network&quot;</span>, &#123;<br>&#123;<span class="hljs-string">&quot;otype&quot;</span>, <span class="hljs-string">&quot;FullyFusedMLP&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;activation&quot;</span>, <span class="hljs-string">&quot;ReLU&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;output_activation&quot;</span>, <span class="hljs-string">&quot;None&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;n_neurons&quot;</span>, <span class="hljs-number">64</span>&#125;,<br>&#123;<span class="hljs-string">&quot;n_hidden_layers&quot;</span>, <span class="hljs-number">2</span>&#125;,<br>&#125;&#125;,<br>&#125;;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> tcnn;<br><br><span class="hljs-keyword">auto</span> model = <span class="hljs-built_in">create_from_config</span>(n_input_dims, n_output_dims, config);<br><br><span class="hljs-comment">// Train the model</span><br><span class="hljs-function">GPUMatrix&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">training_batch_inputs</span><span class="hljs-params">(n_input_dims, batch_size)</span></span>;<br><span class="hljs-function">GPUMatrix&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">training_batch_targets</span><span class="hljs-params">(n_output_dims, batch_size)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n_training_steps; ++i) &#123;<br><span class="hljs-built_in">generate_training_batch</span>(&amp;training_batch_inputs, &amp;training_batch_targets); <span class="hljs-comment">// &lt;-- your code</span><br><br><span class="hljs-type">float</span> loss;<br>model.trainer-&gt;<span class="hljs-built_in">training_step</span>(training_batch_inputs, training_batch_targets, &amp;loss);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;iteration=&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; loss=&quot;</span> &lt;&lt; loss &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// Use the model</span><br><span class="hljs-function">GPUMatrix&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">inference_inputs</span><span class="hljs-params">(n_input_dims, batch_size)</span></span>;<br><span class="hljs-built_in">generate_inputs</span>(&amp;inference_inputs); <span class="hljs-comment">// &lt;-- your code</span><br><br><span class="hljs-function">GPUMatrix&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">inference_outputs</span><span class="hljs-params">(n_output_dims, batch_size)</span></span>;<br>model.network-&gt;<span class="hljs-built_in">inference</span>(inference_inputs, inference_outputs);<br></code></pre></td></tr></table></figure><p>也可以直接在pytorch里使用。</p>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑天鹅：如何应对不可预知的未来》笔记</title>
      <link href="//posts/Notebook/THE-BLACK-SWAN-note/"/>
      <url>//posts/Notebook/THE-BLACK-SWAN-note/</url>
      
        <content type="html"><![CDATA[<p>纳西姆·尼古拉斯·塔勒布 著</p><span id="more"></span><h1 id="序言">序言</h1><p>黑天鹅事件三<strong>特性</strong>：稀有性、极大的冲击性和事后（而不是事前）可预测性。</p><p>黑天鹅<strong>逻辑</strong>：你不知道的事比你知道的事更有意义，因为许多黑天鹅事件正是在不可预知的情况下发生和加剧的。</p><p><strong>本书的目的</strong>：揭示我们对随机事件的无视，尤其是具有很大差异的随机事件：为什么我们（不管是不是科学家，是不是社会精英）会倾向于本末倒置？为什么我们看到的总是细枝末节，而不是可能发生的重大事件，即使它们的巨大影响是显而易见的？而且，如果你赞同我的观点，为什么读报实际上削弱了你对世界的认识呢？</p><p><strong>专家的局限</strong>：尽管专家有经验和数据，但他们并不比普通大众更了解相关问题，只是更善于阐述而已，甚至只是更善于用复杂的数学模型把你弄晕而已。</p><p>你可以通过最大限度地置身于<strong>正面的黑天鹅事件</strong>的影响下，来享受黑天鹅现象的好处。实际上，在某些领域，比如科学发现和风险投资领域，未知事件能够为你带来大得不成比例的回报，因为通常你没什么可损失的，却可以从一桩稀有事件中获得巨大回报。</p><p>我不同意亚当·斯密等经济学家的观点：<strong>自由市场之所以能够运转，是因为它允许人们走好运</strong>，不论他们是拼命努力还是犯错，而不是对技能予以奖励或“激励”。所以，正确的策略应该是尽可能多地尝试和尽可能多地把握黑天鹅机会。</p><blockquote><p>作者认为所有人都知道预防比治疗更重要，但预防只得到很少的奖赏。这点与《扁鹊见蔡桓公》异曲同工。</p></blockquote><p><strong>作者的观点</strong>：我们的世界是由极端、未知和非常不可能发生的（以我们现有的知识而言非常不可能发生的）事物所主导的，而我们却一直把时间花在讨论琐碎的事情上，只关注已知和重复发生的事物。更进一步，即使我们取得了知识上的进步和成长（或者正因为这种进步和成长），未来仍会越来越不可预测，而人性和社会“科学”合谋起来向我们隐藏了这一点。</p><p><strong>全书概括</strong>：本书章节的顺序遵循非常简单的逻辑：从纯粹的文学（课题和方法）到纯粹的科学（课题，但不是方法）。心理学大部分在第一部分和第二部分开头，商业和自然科学主要在第二部分末尾和第三部分。第一部分主要讲述我们如何看待历史和当前事件，以及存在哪些偏差。第二部分讲述我们对待未来所犯的错误和某些“科学”不为人知的局限，以及我们对自身预测能力的局限性能够做什么。第三部分更深入地探讨了极端事件，讲解了钟形曲线（那个智力大骗局）是如何产生的，并审视了一些自然和社会科学中被置于“复杂”标签下的观点。</p><h1 id="第一部分-极端斯坦与黑天鹅现象">第一部分极端斯坦与黑天鹅现象</h1><blockquote><p>“斯坦”源自于古波斯语，而波斯语中的大半词汇都来自于阿拉伯语。它是个音译的地名，大概的意思是“……之地”或者是“某物或某人聚集之处”。本书种可以理解为“国度”的意思。</p></blockquote><p>历史和社会不是缓慢爬行的，而是在一步步地跳跃。它们从一个断层跃上另一个断层，其间极少有波折。</p><p>我们只是一台巨大的回头看的机器，人类总爱自欺欺人。每一年过去，我的这一认识都会加强。</p><p>在理想的<strong>平均斯坦</strong>，特定事件的单独影响很小，只有群体影响才大；在<strong>极端斯坦</strong>，个体能够对整体产生不成比例的影响。极端斯坦能够制造黑天鹅现象，少数事件已经对历史产生了巨大影响。</p><ul><li>平均斯坦：当你的样本量足够大时，任何个例都不会对整体产生重大影响。最大的观察值虽然令人吃惊，但对整体而言最终微不足道。</li><li>极端斯坦：个体能够对整体产生不成比例的影响。</li></ul><p><strong>职业分类</strong>：按报酬是否受时间或付出劳动数量的限制，分为体力劳动和脑力劳动。</p><blockquote><p>并不是用脑子就是脑力劳动，要看工作性质。作家的收入并不取决于作家投入写作的时间或作品字数，而取决于作者的写作水平，这是脑力劳动。</p><p>脑力劳动通常赢家通吃，当某个被认为比别人优秀一点的人拿走整块蛋糕时，不公平便产生了。</p></blockquote><p>事情就是这样，美国人比这些经常去博物馆而且会解方程式的国家的人们具有大得多的创造力，他们对自下而上的改良和无序的反复尝试也更为包容。</p><blockquote><p>以上是作者眼中美国特有的优点。</p></blockquote><p>我们从过去获得的知识实际上顶多是无关痛痒或虚假的知识，甚至是危险的误导。</p><blockquote><p>作者认为归纳思维具有局限性，就好比罗素提出的火鸡问题。</p></blockquote><p>我们对黑天鹅事件的无知产生的<strong>五个问题</strong>：</p><ol type="1"><li><p><strong>我们只关注从已观察到的事物中预先挑选出来的那部分，从它推及未观察到的部分：证实谬误。</strong></p><p><strong>避免证实谬误</strong>的方法是使用消极经验主义：通过负面例子而不是正面证据接近真相！对观察到的事实制定通用法则是具有误导性的。</p><p>投机家乔治·索罗斯在进行金融赌博时，会不断寻找证明他最初看法错误的事例。这大概才是真正的自信：冷眼看世界而不需要找理由满足自我膨胀的欲望。</p></li><li><p><strong>我们用那些符合我们对明显模式的偏好的故事欺骗自己：叙述谬误。</strong></p><p>我们习惯于过度解释，偏好简洁的故事，而不是原始真相。它严重扭曲了我们对世界的思维反应，在稀有事件上尤为严重。</p><p>更高的多巴胺聚集量似乎能够降低人的怀疑态度，使他更容易出现模式辨认行为；注射左旋多巴（一种用于治疗帕金森氏病的药物）似乎能够增强模式辨认行为，降低人们对信念的怀疑。接受注射的人变得易于接受各种各样的风潮，比如占星术、迷信、经济学和塔罗纸牌。</p><p>我们的思维在很大程度上是我们的物质机体的受害者。思维就像身体里的一个居住者，受到生物性的拘禁，除非我们找到聪明的逃脱办法。</p><p>人有许多脑细胞——1000亿个，因此处理和提取信息的困难大概不在于存储空间受到限制，而在于索引。</p><p>我们试图强制性地理解事物的习惯——叙述和寻找因果关系是同一种疾病的征候——谋求降低复杂性。</p><p><strong>避免叙述谬误</strong>的办法就是强调实验而非讲故事，强调体验而非历史，强调客观知识而非理论。</p></li><li><p><strong>我们假装黑天鹅现象不存在：人类的本性不习惯黑天鹅现象。</strong></p><p>许多人在生活中忙忙碌碌，相信自己在做正确的事，但很长时间都无法拿出实实在在的成绩。</p><p>让我们把世界分为两类。有的人就像火鸡，面临巨大的灾难却不知情；有的人正好相反，他们等待着让别人大吃一惊的黑天鹅事件的发生。</p></li><li><p><strong>我们所看到的并不一定是全部。历史把黑天鹅现象隐藏起来，使我们对这些事件发生的概率产生错误的观念：沉默的证据造成的认知扭曲。</strong></p><p>我们理解事件的方式中还存在另一个缺陷——沉默的证据。历史既向我们隐藏了黑天鹅现象，又隐藏了它制造黑天鹅现象的能力。</p><p>（其实就是幸存者偏差）</p><p>在我们进行天分比较时，经常忽略沉默的证据，尤其在那些受赢家通吃效应影响的行业。我们也许很喜欢那些成功故事，但太把它们当回事是不应该的，因为我们并没有看到全部事实。</p><p>自传的全部意义就在于武断地把某些品质与事件连成因果关系。现在来讨论失败者。躺在失败者坟墓里的人有如下共同点：勇气、冒险精神、乐观等等，同那些百万富翁一样。或许具体的技能不同，但真正使两者不同的最主要因素只有一个：运气，只是运气。</p><p>我<strong>并不是说因果关系不存在</strong>，不要以这个论点为借口而不去从历史中学习。我要说的只是因果关系没那么简单。请对“所以”保持怀疑态度，并小心对待它，尤其在你怀疑存在沉默的证据时。</p></li><li><p><strong>我们“犯过滤性错误”：我们只关注一些有明确定义的不确定性现象，一些特定的黑天鹅现象（而不关注那些不太容易想到的）。</strong></p><p>愚人只是指按照条条框框思考的人。</p><p>你有没有奇怪过，为什么那么多在校成绩好的人最后一事无成，而那些学业落后的人却在赚大钱、买钻石，甚至获得某个真正学科（比如医学）的诺贝尔奖？</p><p><strong>游戏谬误</strong>——我们在现实生活中面临的不确定性与我们在考试和游戏中遇到的简化情况之间几乎没有相同之处。</p></li></ol><h1 id="第二部分-我们难以预测">第二部分 我们难以预测</h1><p>事件发生的可能性越低，估计错误就越严重。</p><p>想一想有多少家庭对未来进行筛选性假设，他们把自己锁在牢固的房产中，以为会在那里生活一辈子，而不知道人们过稳定生活的记录很糟糕。</p><p>我知道历史将被低概率事件主宰，但我不知道到底是什么事件。</p><p>人们常说智者能够预测未来，或许真正的智者是那些知道自己不能预测未来的人。</p><p>预测的固有局限性，与人性没有多大关系，而是来源于信息本身的特性。我已经说过，黑天鹅现象有三个特点：不可预测，影响重大，事后可解释。</p><blockquote><p>作者举了一堆科学发现的例子，以下取其一。</p></blockquote><p>彭加莱的理论很简单：在预测未来的过程中，你所模型化的过程需要越来越精确，因为你的错误率会迅速上升。而仅仅达到近似的精确是不行的，因为你的预测会突然失效，最终需要对过去进行无穷精确的解释。彭加莱以一个非常简单的例子演示了这一点，即著名的“<strong>三体问题</strong>”。如果在一个类似太阳系的系统中只有两颗行星，并且没有其他因素影响它们的运行，你将能够毫不费力地预测它们的运行。但在两颗行星之间再加入第三个天体，比如一颗小小的彗星。最初第三个天体不会导致行星运行偏离轨道，对它没有影响；然后，随着时间的推移，它对另两个天体的影响可能是爆炸性的。这个微小天体的位置将最终决定这两个庞大行星的命运。</p><p>假如你相信自由意志，你就不可能真正相信社会科学和经济预测。你不可能预测人们会怎样行动。</p><p>认知自大程度较低的人不一定缺乏自信，只是他对自己的知识持怀疑态度。我将这种人称为“认知者”，将念念不忘人类认识错误的境界称为“认知斯坦”。</p><p>每个人都有心目中的乌托邦。对许多人而言，它意味着平等、公平、没有压迫、不用工作（对有些人而言，要求可能更低，但并不一定更容易达到）。对我而言，乌托邦就是认知斯坦，一个所有人都是认知者的社会，一个认知者能够当选的社会。它将是一个以承认无知而不是承认有知为基础的社会。</p><p><strong>假如你不会预测怎么办</strong></p><p>学会根据观点可能造成的损害而不是好听的程度来辨别它们。</p><p><strong>杠铃策略</strong></p><p>如果你知道容易犯预测错误，并且承认由于有黑天鹅事件的影响，大部分“风险管理方法”是有缺陷的，那么你的策略应该极度保守或极度冒险，而不是一般保守或一般冒险。<strong>不要把钱投入“中等风险”的投资（你怎么知道它是中等风险的？听某个谋求终身教职的“专家”的吗），而应该把一定比例的钱，比如85%～90%，投入极为安全的投资工具，比如国债，总之投入你能找到的最安全的投资工具。余下的10%～15%投入极具投机性的赌博中，用尽可能多的财务杠杆（比如期权），最好是类似风险资本的投资组合。</strong>这样一来，你就不受错误的风险管理的影响。没有黑天鹅事件能够超越你的“底线”伤害你了，因为你的储备金最大限度地投入了安全的投资工具。或者，同理，你可以拥有一个投机性投资组合，并确保（如果可能的话）它的损失不超过15%。这样，你就“剪掉”了对你有害的不可计算的风险。<strong>你不是承担中等风险，而是一边承担高风险，一边不承担风险。二者的平均值是中等风险，但能使你从黑天鹅事件中获益。用更为专业的术语，可以称之为“凸性”组合。</strong></p><p><strong>保持谨慎的技巧</strong></p><ol type="1"><li>区分正面意外和负面意外。在将正面黑天鹅事件的影响最大化的同时，保持对负面黑天鹅事件的警惕。</li><li>不要寻找精确和局部的东西。把精力放在作准备而不是预测上。</li><li>抓住一切机会，或者任何像机会的东西。努力工作，不是做无聊的工作，而是搜寻这些机会，并尽可能扩大它们对你的影响。</li><li>当心政府的精确计划。这些公仆的利益在于生存和自保，而不是接近真理。这并不意味着政府是无用的，只是你需要对它们的副作用保持警惕。</li><li>不要浪费时间与预测者、证券分析师、经济学家和社会学家争论，除非是拿他们取笑。</li></ol><p>所有这些建议有一个共同点：<strong>不对称性</strong>。请把你自己放入一个好结果比坏结果大得多的条件下。实际上，不对称结果是本书的核心思想：我永远不可能知道未知，因为从定义上讲，它是未知的。但是，我总是可以猜测它会怎样影响我，并且我应该基于这一点做出自己的决策。</p><h1 id="第三部分-极端斯坦的灰天鹅">第三部分 极端斯坦的灰天鹅</h1><blockquote><p><strong>灰天鹅</strong>是可以模型化的极端事件，而黑天鹅是未知的未知。</p></blockquote><p>我已说过，随机性是不好的，但并非总是如此。运气甚至比智慧更公平。如果人们严格根据能力获得报酬，有可能仍然不公平，因为人们无法选择自己的能力。随机性能够对社会进行重新洗牌，把那些大人物拉下马。</p><p>我已说过，在极端斯坦，没人是安全的。反过来也一样：没人受到完全失败的威胁。我们现在的环境允许小人物在成功的希望前等待时机——活着就有希望。</p><p>长尾是极端斯坦的副产品，它在某种程度上减少了不公平：世界对小人物而言没有变得更不公平，但对大人物而言变得极为不公平。没有谁的地位是牢固不破的，小人物非常具有颠覆性。</p><blockquote><p><strong>长尾理论</strong>是网络时代兴起的一种新理论，由美国人克里斯·安德森提出。长尾理论认为，由于成本和效率的因素，当商品储存流通展示的场地和渠道足够宽广，商品生产成本急剧下降以至于个人都可以进行生产，并且商品的销售成本急剧降低时，几乎任何以前看似需求极低的产品，只要有卖，都会有人买。</p></blockquote><p>高斯钟形曲线都受到一种阻力，使偏离平均值的概率下降得越来越快，突破性分布或者曼德尔布罗特分布则不受这种限制。这基本上就是你需要知道的。</p><p>你听说过80/20法则吗？它是一种标志性的<strong>幂律</strong>，实际上幂律的发现正是从它开始的。当时维尔弗雷多·帕累托观察到意大利80%的土地被20%的人占有。有人运用这一法则指出，80%的工作由20%的人完成；或者80%的工作只产生20%的结果，反之亦然。</p><p>我花了近15年时间才找到另一位思想家，他把许多天鹅变成了灰色：<strong>曼德尔布罗特</strong>——伟大的贝诺特·曼德尔布罗特。“分形”（fractal）一词是曼德尔布罗特创造的，用来描述不规则和支离破碎的几何图形，它来自拉丁语的fractus一词。</p><blockquote><p>作者就分形随机性做出了解释，具体见第十六章后半部分。作者认为分形分布比高斯分布更合理。</p></blockquote><blockquote><p>作者认为"现代"金融理论是危险的垃圾科学。参见十七章的叙述。</p></blockquote><p>我对黑天鹅的应对办法是在思维中避免从众。但在避免上当之外，这种态度受制于一种行为方式，不是思维方式，而是如何将知识转化为行动，并从中找出那些有价值的知识。</p><p>当我受到正面黑天鹅事件的影响时，我会非常冒险，这时失败只有很小的影响；当我有可能受到负面黑天鹅事件的袭击时，我会非常保守。</p><p>我们很容易忘记我们活着本身就是极大的运气，一个可能性微小的事件，一个极大的偶然。想象一个10亿倍于地球的行星边上的一粒尘埃。这粒尘埃就代表你出生的概率，庞大的行星则代表相反的概率。所以不要再为小事烦恼了。不要再像一个忘恩负义者，得到一座城堡，还要介意浴室里的霉菌。不要再检查别人赠与你的马匹的牙齿，请记住，你就是黑天鹅。最后，谢谢你读我的书。</p><h1 id="读后感">读后感</h1><p>塔勒布的书除了这本《黑天鹅》，还有《反脆弱》、《随机漫步的傻瓜》、《非对称性风险》等，他行文风格口语化（稍显啰嗦），爱好讲故事，对反对的名人批评严厉。摘录原文如下：</p><blockquote><p>现在简单看一下“诺贝尔”经济学奖，……在股市崩盘之后，他们授奖给两名理论学家哈里·马克威茨和威廉·夏普，他们以高斯方法为基础，建立了漂亮的柏拉图化模型，对所谓的现代投资组合理论作出贡献。很简单，假如你去掉他们的高斯假设，把价格当做突破性变量，你就只剩下吹牛。</p></blockquote><p>我个人以为他的黑天鹅思想可以总结为<strong>世界的复杂度远高于人类的建模能力</strong>，任何对未来的精准预测都不准确（回顾历史事实也是如此），因此绝不能想当然，对负面黑天鹅要保持怀疑和谨慎，对正面黑天鹅要大胆出手。</p><p>不要从众、不要盲信、注意幸存者偏差、运气影响巨大等等其实都是老生常谈的东西了，他最犀利的观点是对基于高斯模型的现代金融理论的严厉批评和其主张的杠铃策略，即没有真正意义上的中风险投资（无人可以保证），而是采用一比九的极高/极低风险组合，从黑天鹅中获益。</p><p>同时，塔勒布借用黑天鹅反映了一种积极的生活态度，珍惜生命、保持希望。</p>]]></content>
      
      
      <categories>
          
          <category> Notebook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学资源</title>
      <link href="//posts/Research/CG-resource/"/>
      <url>//posts/Research/CG-resource/</url>
      
        <content type="html"><![CDATA[<p>常识记录</p><span id="more"></span><h1 id="汇总">汇总</h1><p><a href="https://kesen.realtimerendering.com/">Resource for ComputerGraphics - Ke-Sen Huang's Home Page</a>（计算机图形学资源汇总）</p><p><ahref="https://www.siggraph.org/siggraph-events/conferences/">Conferences- ACM SIGGRAPH</a>（SIGGRAPH）</p><p><a href="https://advances.realtimerendering.com/">Advances inReal-Time Rendering in 3D Graphics and Games</a>（SIGGRAPH courses）</p><p><ahref="https://games-cn.org/gamescoursescollection/">GAMES在线课程合集 –计算机图形学与混合现实在线平台</a>（GAMES）</p><p><ahref="https://research.adobe.com/publications/?research-area=2d-3d-graphics">AdobeResearch » Publications</a>（Adobe Research）</p><h1 id="研究者工程师">研究者/工程师</h1><p><a href="http://www.cs.cornell.edu/~srm/">Steve Marschner</a></p><p><a href="https://cseweb.ucsd.edu/~ravir/">RAVI RAMAMOORTHI'S HOMEPAGE (ucsd.edu)</a></p><p><a href="https://cg.cs.tsinghua.edu.cn/people/~kun/">Kun Xu -Homepage (tsinghua.edu.cn)</a></p><p><a href="https://www.microsoft.com/en-us/research/people/xtong/">XinTong (microsoft.com)</a></p><p><a href="https://people.engr.tamu.edu/nimak/index.html">NimaKalantari (tamu.edu)</a></p><p><a href="https://xilongzhou.github.io/">Xilong Zhou</a></p><p><ahref="https://sites.google.com/a/eng.ucsd.edu/zhengqinli/">Zhengqin Li(李正钦) (google.com)</a></p><p><a href="https://gao-duan.github.io/">Duan Gao - Homepage(gao-duan.github.io)</a></p><p><a href="http://yuedong.shading.me/">Yue Dong's Home Page(shading.me)</a></p><p><a href="https://sites.cs.ucsb.edu/~lingqi/">Lingqi Yan: ResearchHomepage (ucsb.edu)</a></p><p><a href="https://valentin.deschaintre.fr/">ValentinDeschaintre</a></p><p><a href="https://shenyujun.github.io/">Yujun Shen (Damon)(shenyujun.github.io)</a></p><p><a href="https://tflsguoyu.github.io/">GuoYu's Homepage</a></p><p><a href="https://boksajak.github.io/">GFX Caffeinist Blog</a></p><h1 id="材质">材质</h1><h2 id="常用概念">常用概念</h2><p>切线空间的法线贴图标准有DirectX和OpenGL两种。OpenGL标准用于Blender、Maya、Unity；DirectX标准用于Unreal、3dsMax。需要反转法线贴图的RGB通道中的Green通道（切线空间TBN三轴中的B）（法线贴图的值域为[0,1]，法线的值域为[1,-1]，需要映射）。</p><p><span class="math inline">\(F_0\)</span>：0度菲涅尔反射值。</p><p>菲涅尔反射值代表材质的镜面反射颜色与强度，是真实世界材质的核心测量数值。其中非金属具有非彩色的镜面反射颜色，而金属具有彩色的镜面反射颜色，即非金属的<spanclass="math inline">\(F_0\)</span>是一个float，金属的<spanclass="math inline">\(F_0\)</span>是一个float3。</p><p>ORM（ARM）贴图：Occlusion（Ambient）、Roughness、Metallic三合一。</p><p>常用SVBRDF四张贴图：漫反射、法向、高光、粗糙度（单通道）。</p><p>菲涅尔效应：当入射光方向接近平行表面时，大部分的能量会被反射；当入射光方向接近垂直表面时，大部分的能量会被折射。所以水面远处的倒影更清楚。</p><p>IOR（Index ofrefraction）仅影响非金属材质。用它来控制材料的折射率和反射强度，可以用于折射（透射）材质或非折射材质。当用于非折射材质，它相当于设置反射率的替代方法（因为利用菲涅尔方程，可以用IOR计算反射率）。IOR在物理上描述了介质中的光速。数值越大，光速越慢。</p><p>Metallic/Roughness工作流中可能有个可调节的reflectance（例如UE、Filament）。这个属性可以用来控制材料的高光强度和折射率。该值定义在0到1之间，表示反射率百分比的重映射。例如，<strong>默认值0.5</strong>对应于0.04的反射率。应避免低于0.35（0.02反射率）的值，因为现实世界中没有任何材质具有如此低的反射率。</p><p>albedo并不指漫反射，实际上它指漫发射与高光的总和，分别有diffusealbedo、specular albedo。</p><h2 id="两种工作流">两种工作流</h2><table><thead><tr class="header"><th>Metallic/Roughness工作流</th><th>Specular/Glossiness工作流</th></tr></thead><tbody><tr class="odd"><td>Base Color贴图<br/>（三通道）<br/>（对于金属存<spanclass="math inline">\(F_0\)</span>，对于电介质存漫反射颜色（此时<spanclass="math inline">\(F_0\)</span>设为0.04），混合材质可以认为同时存了这两种数据）<br/>（除了微观遮蔽信息外不该含有任何光照信息）</td><td>Diffuse贴图<br/>（三通道）<br/>（对于金属存0，对于电介质存漫反射颜色）<br/>（除了微观遮蔽信息外不该含有任何光照信息）</td></tr><tr class="even"><td>Metallic贴图<br/>（单通道，相当于图层遮罩）<br/>（0代表非金属，1代表纯金属，中间值代表锈蚀等中间状态）</td><td>Specular贴图<br/>（三通道）<br/>（存<spanclass="math inline">\(F_0\)</span>）</td></tr><tr class="odd"><td>Roughness<br/>（单通道）<br/>（0代表平滑，1代表粗糙）</td><td>Glossiness贴图<br/>（单通道）<br/>（0代表粗糙，1代表光滑）</td></tr></tbody></table><p>当贴图分辨率与纹素密度过小时，在金属与电介质交界产生白边（金属工作流）/黑边（高光工作流）。</p><table><thead><tr class="header"><th></th><th>Metallic/Roughness工作流</th><th>Specular/Glossiness工作流</th></tr></thead><tbody><tr class="odd"><td>优点</td><td>由于电介质的<spanclass="math inline">\(F_0\)</span>规定为0.04，所以设计师在对其赋值时不易出错。如需调整，在大多实现流程中有控制器可以直接覆写这个值。<br/>内存需求小。<br/>兼容性广。</td><td>边缘效应不明显。<br/>可以在Specular贴图中自由调整电介质的<spanclass="math inline">\(F_0\)</span>。</td></tr><tr class="even"><td>缺点</td><td>边缘效应较明显。</td><td>自由调整电介质的<spanclass="math inline">\(F_0\)</span>可能导致错误，打破能量守恒，渲染不正确。<br/>内存需求大。<br/>需要设计师了解PBR。</td></tr></tbody></table><p><strong>工作流的转换</strong></p><p>Base color + Metallic→Diffuse</p><blockquote><p>去掉base color中的金属和混合材质的<spanclass="math inline">\(F_0\)</span>。</p></blockquote><p>打开base color和metallic, RGB模式。</p><p>新建Diffuse图层，纯黑填充。</p><p>单独显示metallic，在通道里ctrl+左键点选任意通道，选中选区。</p><p>Diffuse图层添加蒙版，自动将选区粘贴进蒙版。</p><p>不需要改变图层类型。</p><p>Base color + Metallic→Specular</p><blockquote><p>去掉base color中的漫反射数据，并加上非导体和混合材质的<spanclass="math inline">\(F_0\)</span>（0.04）。</p></blockquote><p>打开base color和metallic, RGB模式。</p><p>新建Specular图层，填充#383838。（0.04的linear对应约22的灰度，对应约56的RGB，对应代码#383838)（如果有specular level贴图，转换成对应的RGB颜色）</p><p>选中metallic,ctrl+i反相。单独显示，在通道里ctrl+左键点选任意通道，选中选区。</p><p>Specular图层添加蒙版，自动将选区粘贴进蒙版。</p><p>Roughness → Glossiness</p><blockquote><p>反相。</p></blockquote><p>ctrl+i 反相</p><h1 id="论文阅读">论文阅读</h1><p>如果想快速判断一篇文章来自的期刊或会议的级别，大体可以参考：</p><p><ahref="https://zhuanlan.zhihu.com/p/85770755">学术期刊的级别、种类、等级，这篇文章全讲清楚了</a></p><p><ahref="https://www.ccf.org.cn/Academic_Evaluation/CGAndMT/">计算机图形学与多媒体-中国计算机学会(ccf.org.cn)</a></p><p>存在期刊收录会议上的论文的情况，比如TOG (SG), CGF(EG)。TOG每一年有六期，第四期收录SIGGRAPH，第六期收录SIGGRAPHAsia（仅Technical Papers，不包括Conference Proceedings，见<ahref="https://www.siggraph.org/siggraph-events/conferences/">Conferences- ACM SIGGRAPH</a>）。</p><blockquote><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-06-25-siggraph_synergy_scaled.png" /></p><p>——摘自<a href="https://dl.acm.org/journal/tog/about">ACM TRANSACTIONSON GRAPHICS About</a></p><p>SIGGRAPH今年的一个新变化是，开始引入一个新的投稿方式，即投到ConferenceTrack，而不是投到JournalTrack，这两个是相对的。以前SIGGRAPH是一一对应的性质，就是在SIGGRAPH上的所有论文，都会被一期《AcmTransaction onGraphics》的期刊、所谓的TOG所收录，那么反过来也一样，所有被TPOG收录的文章也都会在SIGGRAPH上做报告。</p><p>以前的SIGGRAPH的论文可以认为是Journaltrack，其中文章会被期刊journal收录，那么今年ConferenceTrack的就只是SIGGRAPH文章，并不会被期刊收录，是否收录还需要专业的评定，但作为SIGGRAPH文章，国内还是相当认可ConferenceTrack的。</p><p>——摘自<a href="https://www.bilibili.com/read/cv18732536">与闫令琪畅聊SIGGRAPH 图形学前沿及一手求职经验【前沿技术篇】</a></p></blockquote><h1 id="颜色科学">颜色科学</h1><h2 id="cie色彩空间">CIE色彩空间</h2><p>人眼有三种视锥细胞，分别称为L、M、S，能够感知不同波长的光，使用它们接收到的三刺激值来描述任一颜色的色彩空间被称作LMS空间。</p><p>1931年，CIE（国际照明委员会）制定了最先采用数学方式来定义的色彩空间标准，即<strong>CIE1931 XYZ</strong>色彩空间。</p><blockquote><p>色域和色彩空间的区别是，色域必须在可见光范围内。在仅涉及可见光的领域（如摄影）两者相同。</p></blockquote><p>三刺激值XYZ不单纯只是人眼对不同波长的感知，而是一组再经过数学变换的函数。</p><blockquote><p>XYZ空间所采用的xyz坐标不等于三刺激值函数XYZ。</p></blockquote><p>因为无法只靠xyz坐标回推函数XYZ，并且XYZ无法诠释色彩三要素，所以产生了经过数学变换后的<strong>CIE1931Yxy</strong>色彩空间。在此基础上拿掉代表明度的函数Y，就是<strong>马蹄图</strong>，即平面的CIExy色度图。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-06-04-gamut.webp" /></p><blockquote><p>CIE 1931有两个缺点：</p><ol type="1"><li>无法识别同色异谱颜色。</li><li>并非等量均值。马蹄图上，两色的直线距离并不等于实际色差，无法进行数学计算。</li></ol></blockquote><p><strong>CIE 1976LAB</strong>中两色的直线距离公式求出的数值称为<strong>DeltaE</strong>，只要小于2，肉眼便难以分辨荧幕颜色和真实颜色差异。</p><p><strong>CIE 1976 LCH</strong>更为直观。</p><h2 id="gamma校正">Gamma校正</h2><p>显示器输出亮度和电压不为线性关系，<spanclass="math inline">\(y=x^{2.2}\)</span>，gamma值为2.2。</p><p>因此，数字图像中RGB值和实际亮度不为线性关系，<spanclass="math inline">\(y=x^{0.45}\)</span>，gamma值为0.45。</p><p>输出亮度和实际亮度的关系：<spanclass="math inline">\(y=({x^{0.45}})^{2.2}\approx x\)</span>。</p><p>如上所述，数字图像中RGB值存了更多偏暗的信息（画<spanclass="math inline">\(y=x^{0.45}\)</span>，看对应关系即知）。人眼也是这样的，人认知中的白色和黑色中间的50度灰，实际亮度是白色的0.21（<spanclass="math inline">\(0.21^{0.45}\approx 0.5\)</span>）。</p><h2 id="色温">色温</h2><p>某一光源发出的光，与某一温度下黑体发出的光所含的光谱成分相同，就称为某K色温。如100W灯泡发出的光的颜色，与绝对黑体在2527℃时的颜色相同，那么这只灯泡发出的光的色温就是：（2527+273）K=2800K。</p><h1 id="常用术语缩写">常用术语缩写</h1><p>PDF: Probability Density Function 概率密度函数</p><p>CDF: Cumulative Distribution Function 累积密度函数</p><p>MAP: Maximum a posteriori 最大后验估计</p><p>MLE: Maximum Likelihood Estimate 极大似然估计</p><p>ELBO: Evidence Lower Bound 证据下界</p><p>MIS: Multiple Importance Sampling 多重重要性采样</p><p>MSAA: MultiSample Anti-Aliasing 多重采样反走样</p><p>FXAA: Fast Approximate Anti-Aliasing 快速近似反走样</p>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相对的历史</title>
      <link href="//posts/Article/history-is-relative/"/>
      <url>//posts/Article/history-is-relative/</url>
      
        <content type="html"><![CDATA[<p>《发现东亚》一书的读后感</p><span id="more"></span><p>“历史从来不只是过去发生的事情，而是今天对过去的解读。”宋念申关于东亚史，提供了一个全新的叙述角度。对于“东亚”的许多刻板理解，是以欧洲殖民现代观为参照的；一些所谓的历史常识，竟有一些是有失偏颇的误解；一些在当时并未引起重大反响的事件，在后世被诠释为某种标志，比如福泽谕吉的脱亚论；在当时的历史情境下发生的事件，被后世加上了新的理解，比如马戛尔尼访华。而这些叙述，都是服务于以西方为中心的现代。</p><p>亚洲被当作欧洲的反题，成为文明的反面，一方面体现在对其“浪漫”的幻想中。亚洲停滞落后了，因此没有被“现代”荼毒，被西方人寄托上怀旧和乡愁。从《最后的武士》（TheLastSamurai）对于传统武士拒绝使用火枪、保持高贵的荣誉感的香格里拉式的幻想，可见一斑。实际上从日本战国时代起，火枪就被批量生产用以装备军队，并被日本人不断改进，发明出许多战法。在丰臣秀吉于1592年发动侵朝战争初期，就是因为武器上的优势势如破竹。至于后来日本火器落后，则是因为德川治下的日本承平两百多年，一为国家稳定，二无战争需求，逐渐限制火器的制造。这让我联想到了如今的都市青年对于西藏的香格里拉式的幻想，西藏因为它的落后、神秘，被赋予了净化心灵的圣地地位。</p><p>亚洲反题，另一方面体现在对于其“落后”的描述上。举个给我印象最深的例子，本书对于马戛尔尼访华前因后果的深入挖掘，完全推翻了我之前接触的主流叙述带给我的认知。正如原文所说，“马戛尔尼使团，逐渐脱离实际的历史情境，成为一个为特定意识形态提供素材的象征和神话。”1793年英方使团的失败被单方面归咎于清朝的狂妄自大、忽视商业、闭关自守，并由此延伸出47年后的鸦片战争。直到我看到这本书为止，我也是这么认为的。但实际上，当时的中国并不拒绝贸易，中欧贸易实际上不断增长。中英贸易已经持续多年，马戛尔尼使团所代表的英方的要求，不是普遍的通商权力，而是对英国的特殊待遇，近乎于殖民。其中包括开放宁波、舟山等地为口岸；在北京常设使馆；划舟山附近一岛供英商居住、仓储；允许英商常住广州；英船出入广州、澳门水道并减免课税；允许英国教士传教。英国不是想建立平等的外交贸易关系，对于这些近乎放肆的要求，皇帝当然不会答应。因为中国早将外贸规范管理，因此不能给英国提供他们想要攫取的特权。而在后世的论述中，马戛尔尼的具体要求被忽略，乾隆皇帝给英王的回信被截取出来、反复提及，以证明中国的狂妄和愚昧，这样看来，后来的鸦片战争，简直是为中国带去文明曙光的义举。“天朝无所不有……一点儿不需要你们的制品”在后世才被重新“发现”，实际上乾隆皇帝说的是马戛尔尼带的礼物，而不是中英贸易。在我的知识产权法课本里（《现代知识产权法概论（第三版）-曲三强主编-北京大学出版社》第4页下），就引用了马戛尔尼使团，用以描述乾隆皇帝的傲慢。而事实上，百年前中国的落后，并不能简单地归咎于中国所谓的“闭关锁国”上。如果真的“闭关锁国”，中国为何是当时世界最大的白银流入地？这么解释波士顿倾茶事件所倒掉的茶叶，全部来自中国南方？清朝夜郎自大的形象被无限放大，为当年西方国家的殖民扩张提供理论支持。</p><p>这本书的时间线索从丰臣秀吉侵略朝鲜开始到现代，讲解了东亚政治格局和外交关系的变化以及与西方的交流。中国缘何成为现代意义上的多民族国家，日本缘何发动建立“大东亚共荣圈”的战争，朝鲜半岛又为什么被拦腰斩断，都得到了一一解释。作者站在全球史的视角上，提供了一个对东亚的全新的理解角度。</p><p>有学者认为，丰臣秀吉侵略朝鲜，是为消耗过剩武力、巩固国内地位。实际上，若不是秀吉这样一个出身农民，在“下克上”时代一步步位列公卿的逆袭者，很难想象日本会发起蛇吞东亚的战争。当时日本游离于以中原王朝为中心的天下体系边缘，明和朝鲜对内乱多年的日本的近况都不甚了解，且因为内部党争对外界信息并不重视。日军突袭釜山，攻城拔寨，朝鲜君臣出逃，直到加藤清正率领的日军第二军团渡过图们江边界，明才确认日军的战略意图是中原。1592-1599年在朝鲜发生的三国大战，最后以丰臣秀吉病亡、日军撤退落幕，近代东亚国家间的基本权力格局基本奠定。这场战争有两点值得琢磨，一是鸣梁海战后世在韩国被加上新的解读、用作借古讽今，让我对历史的当代意义有了更深的认识。历史事件若在后世被拿到台前，必然有其当代意义的功能或目的在，也可从中窥见当下的国际关系或民众思维模式。就好比书中写的《鸣梁海战》在韩国大卖映衬中日韩关系黯淡，2014年国务院批复将每年12月13日设为南京大屠杀死难者国家公祭日，体现了中国人民要求日本认真反思战争的呼声。二是沈惟敬这样一个小人物成为了游走于战争方之间的大忽悠，让我对东亚的宗藩关系有了更深的理解。战争服务于政治，而沈惟敬能够忽悠各方，就在于他能把握东亚各国的政治需求。</p><p>明日渐衰落，清能够入主中原，有各方面的因素，地缘因素是一个方面。摆脱地图和现代的国界的概念带给我的认知，中原王朝在大多数时间内并不直接统治东北地区，而是通过建立宗藩关系或实施羁縻管理。东北地区作为沟通东亚的文化、经济、交通枢纽，它的崛起有得天独厚的条件。努尔哈赤统一女真，联合蒙古，将分裂的力量聚集了起来。皇太极参照明朝建立政法制度，以汉治汉，征服漠南蒙古、逼迫朝鲜屈服，一个容纳满、蒙、汉的“天下国家”雏形被他建立了起来。在此之后，清军入关，定鼎中原，初步奠定了今天的中国版图。</p><p>明清时期的外交，以宗藩制度为原则。说到这，就不得不谈谈《尼布楚条约》这一“异类”。《尼布楚条约》算是最早的现代条约之一，清俄双方力求平等，以条约形式确定边界。“现代”条约体系能够被容纳在清朝的“天下”制度之下，说明“现代”和“非现代”之间，并不存在一条清晰的边界。后来西方各国入侵清朝，逼迫清朝签署各种不平等条约，有人说其为落后的中国带了了“国际法”精神，以先进的主权国家之间按公法原则互相平等的“国际”代替清朝为中心的“天下”，难以让人信服。这大概也是为殖民寻找的、将中国与“现代”对立的借口之一。</p><p>“闭关锁国所以该打”是为欧洲中心主义服务的殖民逻辑。中国未能跟上工业革命的脚步，归咎于“闭关锁国”是不可的。海禁政策最早开始于明朝，在整个明朝海禁和开海的比例是3：1，清朝是3：17，可以看出明朝的海禁更长，但明朝却未能被后人扣上闭关锁国的帽子。我私以为，未能把科学技术转化为生产力是落后的主要原因。至于对思想、文化的包容，清朝倒要比西方更为“现代”。</p><p>清帝身兼数种宗教礼法，包括满人的萨满、蒙藏的佛教、中原儒道等。而天主教进入中国传教时，极端排斥佛道和民间信仰，尚能被清帝包容。康熙派遣多位使者向罗马教廷说明中国国情，在沟通失败不得已的情况下才禁教，且并未捕杀教士教徒，不少教士继续任用。</p><p>在东方，天主教在中国为传教寻求容忍；而在西方，天主教大力血洗异端。孰高孰低，高下立判。</p><p>在早期近代化时，东亚扮演了重要角色。“锁国”论以欧洲条约体系到来为分水岭，把东亚历史分为“封闭”、“开放”两部分，是殖民主义话语的一部分，服务于西方所要求的“自由”——宗教“自由”和贸易“自由”。西方列强的入侵，不是为了给中国带来先进的生产方式、促进中国进步，他们只是想把中国纳入殖民体系。在客观上，西方在经济上的入侵加速了封建自然经济的瓦解、一定程度上推动了民族资本主义。而在主观上，西方倒希望中国永远落后于世界。</p><p>接受了西方的论述，认定西方便是“现代”，使一代革命者陷入极端，连大文豪鲁迅都曾言“汉字不亡，中国必亡。”中国并非没有“现代”思想，可以例证的著作有《明夷待访录》、《天下郡国利病书》。整个东亚在17-19世纪的学术和思维都不缺新鲜的迸发，认为其为一潭死水的想法过于偏颇。而认为全盘西化才可救国的思想，在现在的我们看来可能有点荒谬，在当时却并不缺乏拥趸，都是因为接受了西方对于“现代”的话语权。</p><p>说到这，就不得不提起种族主义。一个世纪前，不同民族、种族被看做是人类发展的不同阶段。清末，一批知识分子力主以种族革命理论动员群众，将清朝视作落后的满族文明破坏了先进的汉族文明。实则不然，这种说法一是无视了清朝这个多元政权在各个领域的成就，二是将近代的“民族”、“进化”概念强行套到过去的历史上。满清中后期族裔界限日渐模糊，“旗”与“民”的对立，才是阶级矛盾的主线。而八旗不止有满人，到了近代，不管八旗满洲、蒙古还是汉人，大都只认定自己是“旗人”。华夷之辨是儒家思想塑造的一种身份认同，不仅中原，日韩也受其影响。而清入主中原以后，中华的概念发生了畸变，产生了“华夷变态”。所谓华和夷，固然包含一部分种族主义，但它突出的是两者在地域、文化、礼教、政体、文明等方面的相对性差异。近代，革命者拿种族主义来反抗清帝国和殖民者，将种族优劣嫁接到“华夷变态”上，是把民族主义生搬硬套到了中华这一概念复杂的演变过程中。</p><p>而殖民主义和民族主义实则是一个硬币的两面，用民族主义反抗殖民主义，很难保证强大起来之后不会把殖民主义施加给弱者。日本就是很好的例证，它一方面反对欧美以种族主义、文明开化论为主基调的历史观，另一方面却以标榜日本的种族优越、文明独特来对抗这种历史观。它一方面强调抵制欧美帝国、资本与殖民势力的扩张，另一方面以“共荣”为名，大肆在中国、朝鲜和东南亚扩张自己的帝国、殖民和资本。以殖民对抗殖民、以帝国主义对抗帝国主义，便是日本的知识精英群体“超克近代”的内核。</p><p>日本最终战败，但其是以美国的战胜来定义的，日本没能超克现代，被现代超克。这场战争最根本的殖民性被掩盖了，更多需要反思的东西被模糊了。日本的错误到底是什么？把战争浪漫化、拒绝反省的日本右翼往往认为日本的错误不过是战败了，而且日本对它国的伤害与本国受到的轰炸、核爆并无差别。以麦克阿瑟为代表的美国人认为日本的错误是它拒斥了以西方为主导的“现代”。这套殖民主义、霸权主义逻辑一直影响至今。</p><p>解放战争中，共产党把国民党逐出大陆，建立了中华人民共和国，这使美国猝不及防。出于对共产主义的恐惧，麦卡锡主义大行其道，“谁丢失中国”成为声浪高涨的论点。美国显然没有意识到，抗日战争及解放战争是一脉相承的中国人民对于殖民主义和帝国主义的抵抗，而不是为了美国的“文明”和“世界秩序”。同样吊诡的是，作为轴心国的日本战败后保全了领土（后来甚至获得了琉球），而作为受害国的朝鲜被一分为二。这都是为了美国在东亚的战略。朝鲜战争，被美国视作共产主义对自由世界的进攻，美国在三年内于朝鲜本土上投下了比二战更多的炸弹、使用了比二战杀伤力更大的常规武器。越南战争，美国制造了多起震惊世界的大屠杀、大量使用化学武器橙剂。美国还扶持苏哈托建立独裁军政府、血洗印尼共产党和无辜华人。这些罪行的背后是极度扩张的帝国主义。越战失败后美国陷入军事、政治和道义上的困境，不得不对华接触。了解了曾经美国为了自己的霸权不惜发动战争、搅乱东亚的行为，现在的贸易战看起来也就不再奇怪。</p><p>现在的许多问题，也是上个世纪帝国主义和殖民主义的产物。中印、印巴争端，源于英国殖民者留下来的问题。这些遗留问题被包上民族主义，成为新独立的国家之间的冲突。我们要跳出殖民史的范畴，才能找到解决方案。</p><p>如今的东亚，区域合作相当地艰难。东亚每个国家之间，都存在着历史问题，这些问题之上，还有着美国的阴影。要改变这些历史遗留问题，应该从历史认知入手，其中最关键的，就是对于“现代”的话语逻辑的认知。我们应该打破欧洲中心主义，避免单一线性史观，用多元的时间观看待世界、以各种不同的视角审视过去和现在，这样殖民主义借由工业革命带来的单一的“现代”叙述就会不攻自破。“现代”之于亚洲是内在的，而不单单只是西方世界带来的冲击。</p><p>“从一个区域视角出发，探讨世界历史时间如何在这个空间展开”很好的概括了这本书。“现代”是多元性的，“中国”、“东亚”是动态的，历史不是“向前”的线性过程，时间和空间都不是绝对的。</p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目存档</title>
      <link href="//posts/Log/project-archive/"/>
      <url>//posts/Log/project-archive/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/bit704">Github</a></p><span id="more"></span><p><ahref="https://github.com/bit704/BitSTL">BitSTL</a>：C++标准模板库。</p><p><ahref="https://github.com/bit704/BitRenderer">BitRenderer</a>：C++渲染器，支持光栅化实时预览和光线追踪离线渲染。</p><p><ahref="https://github.com/bit704/Analytical-SDF-DX">Analytical-SDF-DX</a>:基于DirectX的解析SDF渲染实验。</p><p><a href="https://github.com/bit704/MsEditor">MsEditor</a>: 自制C++IDE。</p><p><a href="https://github.com/bit704/PicPro">PicPro</a>:自制数字图像处理软件。</p><p><a href="https://github.com/bit704/Adonis">Adonis</a>:Adonis私密聊天软件开发。</p><p><a href="https://github.com/bit704/OChat">OChat</a>:自制即时聊天桌面软件。</p><p><a href="https://github.com/bit704/fishpond">fishpond:</a>自制即时聊天app的后端。</p><p><a href="https://github.com/bit704/visual-poses">visual-poses</a>:相机参数相关脚本。</p><p><a href="https://github.com/bit704/DX11-Practice">DX11-Practice</a>:DX11练习。</p><p><ahref="https://github.com/bit704/OpenGL-Practice">OpenGL-Practice</a>:OpenGL练习。</p><p><ahref="https://github.com/bit704/Information-System-of-Second-hand-House">Information-System-of-Second-hand-House</a>：二手房信息系统网站开发。</p><p><a href="https://github.com/bit704/FunSnake">FunSnake</a>:pygame开发的贪吃蛇。</p><p><a href="https://github.com/bit704/jsfbjzd">jsfbjzd</a>:自制大学生竞赛发布及组队系统。</p><p><a href="https://github.com/bit704/MiniTarget">MiniTarget</a>:用于目标规划的手机app。</p><p><ahref="https://github.com/bit704/Fetal_heart">Fetal_heart</a>：胎心监护神经网络。</p><p><ahref="https://github.com/bit704/software-project-management">software-project-management</a>:软件项目管理课作业。</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Burning Chrome译名考证</title>
      <link href="//posts/Article/thoughts-on-burning-chrome/"/>
      <url>//posts/Article/thoughts-on-burning-chrome/</url>
      
        <content type="html"><![CDATA[<p>William Ford Gibson创作并于1982年出版的科幻小说Burning Chrome</p><span id="more"></span><p>在一门与信息安全有关的课上，老师提到第一次提出“赛博空间”的小说《燃烧的铬》。出于对铬如何燃烧的好奇和对科幻小说的喜爱，我便搜索该小说来阅读，发现很多文章和论文里都提到了该小说，但并没有找到原文。</p><p><imgsrc="https://bit704.oss-cn-beijing.aliyuncs.com/image/2023-04-19-screenshot.png" /></p><p>于是我将其翻译为英文进行搜索，找到了其正确译名《整垮珂萝米》，曾被《科幻世界》杂志2005年7月刊转载。其实只要看过维基百科上该小说的剧情简介，就可以推断其不能译为《燃烧的铬》。</p><p>有趣的是，那个年代就有年龄危机这个说法了。</p><blockquote><p>二十八岁，我是说博比。在敲键盘、摆弄控制面板的人里，这个岁数已经是老头儿了。</p></blockquote><p>由于资源不好找，将小说全文贴在下面，以飨读者。</p><hr /><p>热得很。我们整垮珂萝米那一晚，真热。大商场里，购物广场里，蛾子拼命朝霓虹灯上撞，朝死里撞。但博比的厂房式大开间阁楼上只有显示器发出的光，还有就是矩阵模拟器上发光二极管的绿光红光。博比这台模拟器上的每块芯片我都熟到家了。表面上看，它跟大家每天上班都能见到的仙台小野Ⅶ型没什么区别，就是那种叫“赛伯①七型”的。可我把它翻修改造了无数次，里面那么多芯片，你连一平方毫米的工厂标准线路都甭想找到。</p><p>【①即网络虚拟空间，又称赛伯空间。】</p><p>我们俩肩并肩守在模拟器控制面板前，等着，看着屏幕左下角显示的时间。</p><p>时间到。“上吧。”我说，但博比已经动手了。身子向前一探，掌根一抵，把那张俄国程序卡塞进卡槽。动作麻利自如，跟小孩往游戏机里塞硬币似的。小孩做这个动作时，全都满心觉得自个儿这回铁定赢，只等认输的游戏机提供一连串免费游戏了。</p><p>矩阵在我意识中展开，我的视域里出现了一片银光，不断蒸腾起伏。这片光其实并不存在，它只出现在我的脑海里，一个三维棋盘，无穷无尽，完全透明。我们跨进棋盘格时，那个俄国程序似乎也跟着我们偷偷溜了进去。如果有谁接入这部分矩阵，他或许能看见一个淡淡的影子一晃，从代表我们计算机的那座黄色微型金字塔滚出来，涌进矩阵。这个程序是一件具有伪装功能的武器，它能改变自己的色彩，让自己的颜色和周遭一模一样，而且具备抢先优先级，一路上碰到的所有进程都得给它让路。</p><p>“太好了。”我听见博比说，“我们刚刚成为东海岸原子能管理委员会的检查程序……”也就是说，我们从此可以在光纤路网中畅行无阻，相当于赛伯空间里的消防车，一路拉响警报极速飞驰。但从我们这个矩阵模拟器这儿看，我们好像根本没耽搁时间乔装改扮，而是径直扑向珂萝米的数据库。我这会儿还看不见那个数据库，但我知道，那边的防火墙正等着我们。影子构成的墙，冰墙。</p><p>珂萝米——她那张脸蛋倒是漂漂亮亮，光滑得像钢铁。但那双眼睛却肯定来自大西洋海沟最深处，冰冷的灰眼睛，活在可怕的压力中。他们说，她用她独家炮制的癌症对付那些跟她过不去的人，最复杂最精细的癌症变种，潜伏好多年才最后要你的老命。道上流传着不少珂萝米的故事，没一个是让人心里踏实的。</p><p>所以我把她赶出脑海，代之以律姬的形象：一道阳光透过带铁窗格的玻璃窗射进阁楼，律姬跪在灰蒙蒙的光柱里，褪色的迷彩裤，玫瑰色透明凉鞋，弯腰翻着尼龙包时赤裸后背的迷人线条。她抬起头，一缕近似金色的鬈发散落下来，拂着她的鼻梁。她微笑着，穿上博比的一件旧衬衣，系着扣子，黄褐色棉布衬衣覆过双乳。</p><p>她笑了。</p><p>“婊子养的，”博比说，“我们刚刚告诉珂萝米，说我们是一个税务局的审计程序，三个最高法院的传唤程序……坐稳了，杰克……”</p><p>再见了，律姬，也许这次再见就是永别。</p><p>黑，一片黑暗。进入珂萝米冰墙的入口。</p><p>博比是赛伯空间的浪子，他摆弄的就是冰。冰是个缩写，指“网络侵袭电子反制措施”②。所谓矩阵，就是以抽象形式代表的各数据库之间的关联。遵纪守法的程序员们只能接入矩阵中的一部分，代表他们所在公司的那部分。进去之后，他们四周都是明亮的几何形体，代表公司数据。</p><p>【②Intrusion CountermeasuresElectronics，这几个词的首字母缩写是ICE，即“冰”。】</p><p>代表数据的几何形体高高低低，错落起伏，弥漫在矩阵模拟器形成的虚拟空间中。这个空间是一种交感幻象，方便人们处理、移动海量数据。合法程序员们看不到围绕着他们工作区的冰墙，但正是这些看不见的影子一样的墙将他们彼此隔开，避免互相干扰，同时阻挡那些商业间谍领域的艺术家和像博比·奎因这样的玩家。</p><p>博比是个浪子，博比是个贼，是个破门而入的强盗，闯荡在人类为自己延伸出来的电子神经系统中。他的工作是盗窃数据和金钱，他的活动天地就是这片色彩单一、并不存在的虚幻空间，这里的星宿是密集数据，它们之上是璀璨的大公司数据星系，还有军方系统冷冰冰的银河旋臂。</p><p>博比长着一张既年轻又苍老的面孔，在输家酒吧的客人中，你随处都能看到这种脸。输家是个时尚酒吧，是计算机浪子、赛伯空间盗匪和二道贩子的大本营。</p><p>博比和我是搭档。</p><p>博比·奎因和自动臂杰克，博比就是那个戴副墨镜、脸色苍白的瘦子，而杰克是那个样子狠巴巴、一只胳膊是肌电自动臂的家伙：博比是玩软件的，杰克搞硬件；博比敲键盘，杰克负责所有那些能让你胜过别人一头的小玩意儿。在整垮珂萝米之前，输家酒吧的客人准会这么跟你说。他们没准儿还会告诉你，博比正在走下坡路，已经没原先那么棒了。二十八岁，我是说博比。在敲键盘、摆弄控制面板的人里，这个岁数已经是老头儿了。</p><p>我们俩对各自的行当都挺在行，但就是没碰上好运气。我知道上哪儿能搞到合适的设备，而博比玩他那一套也是轻车熟路。大干起来时，他会在脑袋上扎一根白色绒布汗带，坐在那儿双手击键，动作如飞，快得你的眼睛都跟不上。一路敲击，攻破赛伯空间最厉害的冰墙。问题是，只有碰上能彻底把他调动起来的事，他才会有这么大劲头。可这种事很难碰上。打不起精神时，博比和我就成了那种得过且过型的，只要有钱付房租、身上能穿件干净衬衣就行。</p><p>博比对姑娘最感兴趣。对他来说，她们就跟胡萝卜似的，是他的动力。我们不大谈这方面的事，但那个夏天，就是他似乎开始走下坡路的那段时间，他在输家酒吧待得越来越久。坐在敞开的门边的一张桌子前，盯着进进出出的人流。整晚整晚这么待着，夏天的晚上，虫子朝霓虹灯上扑腾，空气中一股香水味儿、快餐食品味儿。你能看出他那副墨镜正扫视着一张张来来往往的脸。他一定认准了，律姬就是他等待的人儿，那张大牌，可以带来好运，一举扭转牌局——一个新姑娘。</p><p>我去纽约瞧瞧市场情况，看那儿有没有什么能弄到手的劲爆软件。</p><p>芬兰佬的铺子橱窗里有幅不怎么样的全息图像，写着“大都会全息图像技术”，下面是一片死苍蝇，个个披着一身毛茸茸的灰尘大衣。从里面看，这幅破烂货的光都散了，射在墙壁上。其实墙壁基本上看不见，挡在墙壁前的是一大堆说不出名目的垃圾货，还有一架架压合板货架，板子已经被上面堆着的色情杂志和年久发黄的《国家地理杂志》压弯了。</p><p>“你需要弄把枪。”芬兰佬说。瞧他的模样，好像接受了某种为了让人高速打洞专门搞的基因重组疗法似的，“你运气真好，我这儿有把新式史密斯&amp;韦森，408战术型。枪管下有氙气战术灯，瞧见没有，电池在枪把上。五十码外，一束光，直径十二英寸，照得雪亮。光源处直径更小，几乎看不到光是打哪儿来的。夜战的时候，这东西简直神了。”</p><p>我让我的自动臂“当”的一声落在柜台上，用手指敲击着台面。这只手的侍服电机吱吱叫起来，声音像力气使过了头的蚊子。芬兰佬最恨这种声音，我知道。</p><p>“你想典当这玩意儿？”他用一枝毡头笔的末端戳了戳硬铝合金制作的腕关节，“或者，换个更安静的家什？”</p><p>我让手向上一抬，“我用不着枪，芬兰佬。”</p><p>“行啊，”他说，“行啊。”我这才停止敲击，“我手头只有一件新货，至于这东西究竟是什么，我一点儿也不知道。”他满脸不高兴，“从泽西区桥洞的一帮小混混那儿弄的，上周才到手。”</p><p>“你不知道是什么？芬兰佬，你什么时候买过不知底细的货？”</p><p>“嘴皮子挺机灵嘛。”他递给我一个透明邮包。透过防撞气泡看进去，里面的东西像盒磁带，“他们同时还弄到了一本护照，”他说，“加上信用卡、表。就这些。”</p><p>“就是说，把谁口袋里的东西一股脑儿全弄来了。”</p><p>他点点头，“护照是比利时的。照我看是本假照，所以扔炉子里一把火烧了。信用卡也一块儿烧了，那块表还行，保时捷汽车表，不错。”</p><p>显然是军队里用的一种插入式程序卡。从邮包里掏出来以后，它看上去像微型冲锋枪的弹夹，上面还涂了一层防反光黑色塑胶，但边边角角处已经磨出了亮晶晶的金属底子：这东西被人狠狠敲打过一阵子。</p><p>“看在老交情份上，杰克，我便宜卖给你。”</p><p>我被逗乐了。便宜卖？芬兰佬？这就像上帝废除了重力，仅仅因为你拎了个很沉的箱子从机场出来走了十个街口。</p><p>“我看像俄国货。”我说，“说不定是列宁格勒远郊哪个下水道的紧急排污程序。我要这玩意儿干吗？”</p><p>“你要知道，”芬兰佬说，“我穿的鞋比你的岁数都大③。有时候，我觉得你的教育程度比泽西区那些痞子强不到哪儿去。我要怎么说你才高兴？这是克里姆林宫的秘钥？自个儿弄明白这该死的东西是他妈的什么。我？我只管卖。”</p><p>【③相当于吃的盐比你吃的饭还多，指比对方见多识广。】</p><p>我买了。</p><p>我们没有躯体，我们一个急转切进珂萝米冰城环绕的城堡中。我们快，太快了。感觉好像踏着这个入侵程序冲浪板，破坏子程序在我们脚下翻腾涌动，不断变化，以适应变化的环境。我们像一块智能化的油渍，转眼间便渗入幢幢鬼影般的系统甬道。</p><p>躯体还是有的，在很远很远的某个地方，挤在一间堆满东西的阁楼上，阁楼是钢铁加玻璃。在系统里，我们的时间只能以微秒计算，或许足够我们撤出来。</p><p>我们冲进她设下的关卡。我们把自己打扮成一个审计程序，三个传唤程序，但她的防御系统非同小可，经过改造，专门对付这种官方侵入。她有些最复杂的冰墙，可以化解传票、文书和传唤程序的攻势。我们冲破第一道关卡后，她的大块数据全都消失了，藏在由核心命令构成的冰墙后。在我们眼里，这些冰墙形成一道道走廊，长得看不到尽头。一个幻影迷宫。五条独立线路拼命向律师事务所发出求救信号，但我们的病毒已经攻克了外围冰墙，我们的程序扫描一切没有被核心命令屏蔽的东西，破坏子程序则大口吞噬，将求救信号扫荡尽净。</p><p>俄国程序从未屏蔽数据中挑选了一个东京电话号码，选择依据是来电频率、每次通话的时间、珂萝米回电的速度。</p><p>“成了。”博比说，“我们现在成了一个打进来的加密电话信号，她的日本朋友打来的。肯定管用。”</p><p>甩开膀子大干吧，哥们。</p><p>博比用女人给自己算卦。他的姑娘们就是显示吉凶的卦相，每季更换。他会整晚整晚守在输家酒吧，等着当下的季节将一张新脸蛋送到他面前，像翻开一张算命的扑克牌。</p><p>一天晚上，我在阁楼修改一块芯片，工作到很晚。我的胳膊卸下来了，一具小型自动机械臂直接插在残肢上。</p><p>博比和一个以前我没见过的姑娘走进来。一般说来，如果让陌生人看见我这副样子——电线电缆之类露在外头，卡在残肢的碳基上——我总会觉得有点不自在。她走过来，先看看屏幕上显示的放大图像，又望着我的机械臂在真空封装下来回活动。她什么都没说，只看。我马上对她产生了好感。有时候会发生这种情形。</p><p>“律姬，这是自动臂杰克，我的合伙人。”</p><p>他笑着，一只胳膊揽着她的腰。他声音里有某种东西让我明白了；看样子，今晚我得在哪个脏兮兮的旅馆房间里过夜了。</p><p>“嗨。”她说。高挑的个子，十九、二十岁，模样真不错。鼻梁上有几点雀斑，眼睛介于深琥珀色和法国咖啡的颜色之间，紧绷绷的黑色牛仔裤腿卷到小腿一半处，系一条窄窄的塑料腰带，搭配着玫瑰色的凉鞋。</p><p>但现在，失眠睡不着时，浮现在我眼前的是另一个样子的她，飘浮在城市的喧嚣和烟雾之上，像我的两只眼睛投射出来的一幅全息图像。这时的她穿着一件色彩鲜艳的裙子（她从前肯定穿过一回，在我刚刚认识她不久的时候），长不及膝，光着小腿，两条腿又长又直。夹杂着几缕金色的褐发环绕着她的脸，在不知从什么地方吹来的风中拂动着。她在对我挥手道别。</p><p>博比装模作样地在一堆磁带里翻着。“我马上走，伙计。”我说，摘下机械臂，重新装上胳膊。她专注地望着我的动作。</p><p>“你会修东西？”她问。</p><p>“什么都行，随你想修什么，自动臂杰克都能摆平。”我用我的硬铝合金手指向她拧了个响指。</p><p>她从腰带里抽出一个模拟刺激盒，盒盖的铰链断了。</p><p>“明天，”我说，“没问题。”</p><p>老天，老天。我梦游一般走下六层楼，来到街上。一边走一边对自己说，居然翻出这么一张幸运牌，博比得有多大运气啊。只要他把这种运气利用好，从现在起，我们随时都能大发一笔。我咧嘴笑了，打了个哈欠，伸手招呼出租车。</p><p>珂萝米的城堡正在消融。一层层影子一样的冰闪烁着渐渐消失，被俄国程序的破坏子程序吞噬。在我们的正面攻击下，冰面渐渐崩塌，冰墙内层也受了感染，这个破坏子程序就像赛伯空间里的病毒，自我繁殖，无比贪婪。它们不断改变，演化出各种各样的形态，集合全体力量，颠覆、吞吃着珂萝米的防御体系。</p><p>我们已经让她瘫痪了吗？还是警铃正在某处响起，一只红灯正在某处闪烁？她知道我们的攻击吗？</p><p>野姑娘律姬，博比就是这么叫她的。头几周里，她肯定觉得自己拥有了一切。大都会的新鲜场景涌现在她眼前，被霓虹灯光映得五彩缤纷，鲜艳夺目。她刚来不久，有那么多商场和购物中心让她流连忘返，那么多铺子、夜总会。还有博比向她展示城市不为常人所知的另一面，透过表面深入内核，那么多玩家和他们的游戏。他让她觉得这里就是她的家。</p><p>“你的胳膊是怎么出事的？”一天晚上，她在输家酒吧问我。我们三人坐在角落的一张小桌子边喝酒。</p><p>“空中滑翔。”我说，“是个意外。”</p><p>“滑过一大片麦田，”博比说，“那地方叫基辅。深更半夜的，杰克挂在一张翼伞下头，两腿中间吊着五十公斤重的雷达。有个俄国混蛋‘意外’地用激光烧掉了他的胳膊。”</p><p>我不记得当时我是怎么改变话题的，反正我换了个话题。</p><p>当时我一直告诉自己，我其实不是对律姬有什么感觉，只是讨厌博比那样待她。我认识博比很久了，从大战快结束起就认识他了。我知道，对他来说，女人就像赌博用的筹码，赌博本身则是博比·奎因对抗命运，对抗时间，对抗都市的夜晚。他需要为自己提提劲头儿，需要有个生活目标。就在这种时候，律姬出现了。于是，他把她当成一个象征，象征着他想要却要不到、到手了却不能长久保有的一切。</p><p>我不喜欢被迫听他告诉我他是多么爱她。我知道他说的是真心话，所以更加不喜欢听。他是个复原大师：重重摔倒，然后迅速恢复。这种事我见过十多次。他真该用那种白天也能发光的涂料在自个儿的墨镜上印上几个粗体绿字：下一位。只要在输家酒吧发现下一张让他感兴趣的新脸蛋，马上让这几个字唰地一闪。</p><p>我知道他拿她们当什么。她们是象征，是他浪子地图上的一个个标识记号，是引导他周游酒吧和霓虹世界的导航灯塔。没了她们，他靠什么指引他的生活航船？他不爱钱，对钱本身不感兴趣，它的亮度不够，引导不了他。他也不想要支配别人的权力，对这种权力带来的责任避之惟恐不及。对自己的技术，他只有最基本的自豪感，但这种自豪感从来不足以推动他继续向前。</p><p>所以，他用女人推动自己。</p><p>律姬露面的时候，正是他最最需要这种动力的时候。他越来越不行了，垮得很快，喜欢瞎猜的人背地里都说，干这一行，他的“刃”已经钝了。他需要干一票大的，而且要快。只能这样，因为他不可能换一种生活方式。他的思想已经固定成了浪子式，追求的是刺激、肾上腺素，还有那种每一步都做到位、别人卡上的钱划到自己账户上时所产生的感受：超越常人、天启式的感觉。</p><p>是时候了，他应该大捞一笔，然后退出江湖。所以，律姬这个象征一定要抬得更高，比以前所有充当象征物的姑娘高得多，即使她这个人就在那儿。我真想冲他大叫大嚷：她就在那儿，活生生的，有血有肉，是个大活人，充满渴望，开朗，美丽，让人激动——她就是这样的人。</p><p>在我去纽约芬兰佬铺子前一周，他出去了。走了，把我们留在阁楼上。暴雨将至，阁楼玻璃顶棚的一半被上头一个永远完不了工的天棚遮住，另一半只能看见黑沉沉的乌云。我站在工作台边，抬头望着那片天空。闷热的下午加上湿气，搞得我昏昏沉沉。她抚摸着我，抚摸着我的肩膀，抚摸着残肢上自动臂遮不住的那圈半英寸宽、紧绷绷的粉红色伤疤。从来没有人摸过那道伤疤，她们只抚摸我的肩头、脖子……</p><p>但她不同。她的指甲染成黑色，不尖，修成窄窄的椭圆形。那种黑色只比我手臂上那层碳纤板稍深一点。她的手向下滑去，抚着碳纤板上的焊缝，一直摸到肘关节处的黑色氧化面，摸到手腕。她的手很软，像孩子的手，手指张开，和我的手指绞缠在一起，她的掌心贴在我的穿孔硬铝合金掌背上。</p><p>她的另一只手抬起来，抚过掌心的感应面。那天下午，雨下个不停。博比的床上方，雨点像鼓点一样，敲打着用钢和被烟熏黑的玻璃搭成的屋顶。</p><p>冰墙忽闪着垮掉了，像超音速的影子蝴蝶。眼前出现了虚拟空间里的重重幻影，无穷无尽地延伸开去。这个过程就像观看一卷搭建预制房屋的录像带，只不过这卷带子是倒过来高速播放的。冰墙就像预制房屋的一片片组装件一样迅速剥落。</p><p>我一直尽力提醒自己：这个地方和远处的千沟万壑都只是代表数据的虚拟物，我们并不“在”珂萝米的计算机里，只不过在跟她的计算机互动，眼前的幻象只是博比阁楼上的矩阵模拟器生成的……核心数据显形了，敞开了，暴露在我们的攻击之下……这是冰墙之内的景象，矩阵的这一部分我以前从来没见过，但一千五百万合法用户每天都能见到它，将它视为当然。</p><p>核心数据耸立在我们周围，像垂直的货运列车，彼此以颜色区分，明亮的原色，明亮得似乎不可能存在于这片透明的虚无。它们之间的链接则以水平线表示，颜色是幼儿园里那种天蓝色和粉红色。</p><p>但是，这一切的中央仍存在冰墙，遮蔽着某种东西：珂萝米最珍贵、最黑暗的数据的核心，心脏……</p><p>我从纽约购物回来时已经快傍晚了。顶棚没透进多少阳光，博比的显示器上闪烁着一个冰的模型，以平面图的形式显示着某个人的计算机防御体系。一道道线条错综复杂，像装饰派艺术家设计的拜毯花样。我关掉控制台，显示器黑了。</p><p>律姬的东西摊在我的工作台上，几个塞满衣服和化妆品的尼龙包，一双鲜红色牛仔靴，录音带，光亮的日本杂志（刊载模拟刺激明星的消息）。我把这些东西归置到工作台下，卸下我的胳膊，这才想起从芬兰佬那儿买来的程序放在右边口袋里，只好左手别别扭扭地伸过去，摸索了一阵才把它掏出来，把它夹在我处理微小物品的带垫子的夹具上。</p><p>这个工具看上去像那种老式点唱唱片机。夹具长度只有一厘米多一点，上面有个透明防尘罩。这部分可以夹着东西，把它放到相当于几根唱片机转臂中的一根下面。把连接线插进残臂之后，我就用不着再看这个工具了。它成了我的手臂，我只需要看放大镜就行。四十倍放大镜，这只手臂的一举一动看得清清楚楚。</p><p>我瞧了瞧，选择了激光工具。一只转臂抓住它，觉得有点沉，于是我调节重量感应器向大脑输入的信号，让每四分之一公斤的感应值只有一克，这才开始工作。放大四十倍以后，程序卡的侧面瞧上去像辆大货车。</p><p>整个破解花了八个小时：操纵机械臂三小时，中间四次休息；给科罗拉多一个关系打电话花了两小时；还有三小对用来运行一个可以处理八年前的俄国科技词汇的词典程序。</p><p>最后用上了从科罗拉多那人手里买来的读出程序，一行行俄国西里尔字母滚过屏幕，转化为英语。中间有不少缺漏，词典对付不了军事方面的专业缩略语，但我好歹大致知道自己从芬兰佬手里买来的究竟是什么玩意儿了。</p><p>我的感觉就像一个小痞子，出门本来是打算买把开关刀，却弄了颗小型中子弹回家。</p><p>操他妈的，上当了。我心想，街头斗殴，中子弹管什么用？防尘罩下面那玩意儿离我太远太远了，完全派不上用场。我连怎么把它脱手卖掉都不知道，不知上哪儿找买家。有人知道，一个戴保时捷表、揣着张比利时假护照的人。但这人已经死了。他混的那个圈子，我从来没打算想办法钻进去。向芬兰佬销赃的泽西小混混做掉了一个来头不小的大人物，此人准有许多神秘关系。</p><p>夹具里的程序卡是一个俄国军用破冰器，一个凶得要命的病毒程序。</p><p>博比回来时已经天亮了，他是一个人回来的。之前我睡着了，膝盖上还搁着一袋外卖三明治。</p><p>“想吃吗？”我把三明治递给他，但人还迷糊着，没彻底清醒过来。我梦见了那个程序，梦见了它那些凶狠的破坏子程序、狡猾的伪装子程序。在我的梦里，它仿佛成了某种动物，没形没状地流动着。</p><p>他拨开三明治口袋，走向控制台，敲进一个启动命令。屏幕亮起来，上面还是我昨天下午见到的那个复杂图案，为了驱走睡意，我揉了揉眼睛。用的是左手。这种事可不敢使唤我的右手。我本来在琢磨要不要把这个程序的事告诉他，可想着想着就睡着了。或许不告诉他，自个儿卖掉程序，独吞这笔钱，然后搬到别的地方去，劝律姬和我一块儿走。</p><p>“这是谁的冰？”我问。</p><p>他站在那儿，穿着一套黑色棉布连裤装，肩上像披斗篷一样搭着件皮夹克。他有些天没刮胡子了，脸也比平时更瘦削。</p><p>“珂萝米的。”他说。</p><p>我的胳膊一抽搐，咔嗒作响。通过肌电信号，恐惧传递到残肢碳基上，再传到胳膊上。三明治从手里掉下来，嫩菜芽和浅黄色的切片奶酪在没扫干净的木地板上撤了一地。</p><p>“你他妈疯了。”我说。</p><p>“不。”他说，“担心她发现咱们？不可能。真要发现了，咱们这会儿早死翘翘了。我怕双盲保险还不够，所以用的是三盲租赁，在蒙巴萨租了一套系统。线路走的是一颗阿根廷通讯卫星。她知道有人在她的系统里探头探脑，但追踪不到源头。”</p><p>如果珂萝米查到是博比在琢磨她的冰，我们就死定了。但或许他说得没错，不然的话，我多半在从纽约回来的路上就被炸飞了。“为什么要动她，博比？告诉我理由，任何理由都……”</p><p>珂萝米，我在输家酒吧里还见过她大概五六次。没准儿她是去探访贫民窟的，或者是调查人类生活情况。她自己已经不会再过那种日子了。甜甜的鹅蛋脸上是一双你能想像出来的最吓人的眼睛。在任何人的记忆中，她的模样总是只有十四岁。全是血清呀、荷尔蒙呀之类新陈代谢疗法的功劳。过去，她是穷街背巷最凶恶的产品。但现在，她再也不属于穷街背巷了。现在的珂萝米是黑社会高高在上的那一小撮老大之一。道上传说，一开始，她只是个小毒贩。那时合成垂体荷尔蒙还是合法的处方药，她就是靠这个起的家。不过她已经很久不碰荷尔蒙买卖了，现在，整个蓝光会所都是她的。</p><p>“你是彻彻底底地疯了，奎因。把这东西弄到你的屏幕上，说说看，只要给我一个清醒的理由……扔了它，马上！”</p><p>“输家酒吧里有些小道消息。”他耸耸肩，抖掉那件皮夹克，“黑迈伦和乌鸦简讲的，就是那个搞色情电话的简。她说她知道钱都被谁捞走了。她告诉迈伦，说珂萝米彻底控制着蓝光，她根本不是老大们推出来的门面人物。”</p><p>“‘老大们’，博比，”我说，“关键就是这个词儿，不知你有没有糊涂到连这个都没瞧出来的地步。咱们不能招惹老大们，懂吗？就是因为没招惹他们，所以咱们还能四下里走来走去。”</p><p>“所以咱们才到现在都是穷光蛋，我的搭档。”他在控制台前的一把转椅里坐定，拉开连裤装，搔着苍白的瘦胸脯，“但是，这种情形可能不会再持续多久了。”</p><p>“我想的是，咱们这种搭档关系可能刚刚永久性地解除了。”</p><p>他冲我笑了。那种笑容要多疯有多疯，既凶狠又执拗。就在那一刻，我突然明白了，送不送命，博比压根儿不在乎。</p><p>“你瞧，”我说，“知道吗，我手头还剩点儿钱。要不，你用这些钱搭地铁去趟迈阿密，再坐直升机去蒙提戈海湾。伙计，你需要好好歇一阵子，让脑袋清醒清醒。”</p><p>“杰克，我的脑袋，”他一边说，一边在健盘上敲击着什么，“从来没像现在这么清醒。”屏幕上的幻彩拜毯突然抖动了一下：一个激活程序切了进去，图案苏醒过来。线条飞快地编织着繁复的花样，勾人魂魄，像活动起来的禅定图像。博比连续击键，图像的运动渐渐放慢，分解开，不那么复杂了，最后只剩下两个明确的图形，不断来回切换。干得太漂亮了，没想到他还是那么棒。</p><p>“成了。”他说，“看，瞧见没？等等，瞧那儿，又出现了，就是它。一不留神就会漏过去。大功告成。每隔一小时二十分钟，珂萝米就会向他们的通讯卫星发出一个集束信号，短促喷发式。每周付给他们的逆利率④就足足够咱们俩过一整年。”</p><p>【④正常情况下，钱存入银行后，银行向储户支付利息。而珂萝米的黑钱却要反过来向银行支付利息，这就是逆利率。】</p><p>“谁的通讯卫星？”</p><p>“苏黎世，她的银行家们。她把钱存在那儿，杰克。钱就是流到那儿去了。乌鸦简说的一点儿没错。”</p><p>我呆在那儿，胳膊也呆呆地一动不动，忘了咔嗒作响。</p><p>“对了，你在纽约干得怎么样，搭档？弄到什么能帮咱们打破冰墙的货色没有？无论什么，只要能帮上忙，咱们都得用起来。”</p><p>我让自己的两眼直视他的眼睛，强迫自己别朝卸下来的那具机械臂的方向看，更别看那上面的夹具。那个俄国程序就在那儿，防尘罩下。</p><p>这是王牌，能带来好运的大牌。</p><p>“律姬在哪儿？”我问他，一边朝控制台走去，假装研究屏幕上不断切换的图形。</p><p>“她朋友那儿。”他耸耸肩，“一帮小屁孩儿，模拟刺激迷。”他心不在焉地笑了笑，“伙计，就是为了她，我才做这件事。”</p><p>“我得再想想，博比。你要是想让我跟你一块儿干，这会儿先别动控制台。”</p><p>“为了她，我才做这件事。”门在我身后关上时，他说，“这你也知道。”</p><p>下降，下降。程序像一列过山车，翻翻滚滚冲进这片由影子墙壁组成的残破迷宫，这里就像一座灰色的大教堂，坐落在明亮的数据高塔之间。猛冲。</p><p>黑冰。别想它。黑冰。</p><p>输家酒吧里，有关它的传言实在太多了。黑冰是赛伯空间的神话之一。能杀人的冰。当然是非法的，我们有谁干的不是非法勾当？这是一种反馈神经中枢的武器，如果你跟它联上，这种经历只可能发生一次，一次就能干掉你。它就像某种邪恶恐怖的咒语，从大脑内部下手，吃掉你的意识；又像连续发作的癫痫病，没有间断，一浪又一浪，直到把你彻底掏空……</p><p>我们冲向珂萝米的影子教堂中央。</p><p>我极力作好准备，等待着呼吸突然中止，等待着突如其来一阵恶心，然后神经猛地瘫痪。那种冷冰冰的可怕咒语就在这片黑暗中，等着我们。</p><p>我出门去找律姬。她在一家咖啡馆里，和一个半大小子在一起。半大小子有一双仙台公司出产的改造眼。伤口还没有愈合，缝合线从青肿的眼窝呈放射状伸向四周。她在桌上摊开一本亮光光的小册子，塔丽·艾沙姆在上面的十来张照片里微笑着。这姑娘的眼睛是德国蔡斯的。</p><p>她有一个模拟刺激盒。昨天晚上，我把它和其他东西一起收在我的工作台下。那个小盒子还是我替她修好的，就在头一次见到她的第二天。她常常一连好几小时接入这东西，头上缠着接入带，像扎了块灰色的塑料头巾。她最喜欢的就是塔丽·艾沙姆。一扎上接入带，律姬就消失了，去了别的什么地方，感受着盒带里记录的那位最红的模拟刺激明星的种种体验。模拟刺激——塔丽·艾沙姆所体验的世界（或者说，这个世界吸引人的那部分）：塔丽驾驶气垫飞车飞越亚利桑那台地；塔丽在西太平洋特鲁克岛生态保护区潜水；塔丽在私人拥有的希腊小岛上和超级富豪欢宴，那些傍晚时分的小海湾啊，美丽纯净得让人沉醉。</p><p>说实在的，她看上去真的挺像塔丽，同样的肤色，同样的颧骨。我觉得律姬的嘴更有力些，带着一股野性。她倒不是想当真“变成”塔丽·艾沙姆，只是羡慕她那份工作。她的野心就是这个，当个模拟刺激明星。对这种想法，博比只是一笑了之，毫不理会。但她跟我谈过许多次。“换上这双眼睛的话，我看上去怎么样？”她问，手里举着一张整页的脸部特写，把塔丽·艾沙姆的蓝色蔡斯眼睛放在她自己的琥珀色眼睛旁边。她以前曾说，她的眼睛做过两次手术，可视力还是没到20—20，所以她想要一双蔡斯的。明星都用蔡斯。非常昂贵。</p><p>“还在欣赏眼睛，准备买一双？”我坐了下来。</p><p>“老虎刚刚弄了一双。”她说。我觉得她似乎有点疲惫。</p><p>那双仙台眼睛让老虎高兴极了，一脸的笑怎么都止不住。不知这双眼睛出毛病时他还会不会笑。他的脸是那种标准的俊脸，七次光顾街边整容小铺之后，你得到的就是这种脸。这小伙子可能这辈子都会致力于让自己的模样看上去隐隐约约有点像时尚杂志最新推出的一个个封面人物。当然不是一模一样的拷贝，但肯定不是原创。</p><p>“仙台货，对吗？”我还了他一个笑脸。</p><p>他点点头，用一种他所理解的职业模拟刺激明星的目光打量着我，想像着自己正在录像。我觉得他的目光在我的胳膊上停留得太久了一点。“肌肉愈合以后，这种眼睛的视域宽极了。”可我注意到他伸手拿自己的双份蒸馏咖啡时动作是多么小心。仙台眼睛的景深缺陷是出了名的，除了种种质量问题外，保修时的纠纷更是个大麻烦。</p><p>“老虎明天就要动身去好莱坞了。”</p><p>“下一步再到千叶发展，对吗？”我冲他笑着，但他没有回应我的笑脸，“那边邀请你了，老虎？认识什么经纪人吗？”</p><p>“只是去试试。”他轻声说，然后站起身来，走了。只跟律姬说了声再见，没对我说。</p><p>“小伙子的视神经六个月内就会开始退化。这你也知道，对吧律姬？仙台眼睛在英国、丹麦，还有其他好多地方都禁售了。视神经出了问题可没法换。”</p><p>“得了吧，杰克，别发表教诲了。”她拿了一块我的新月面包，小口小口啃着面包的一个角。</p><p>“我还以为自个儿是你的顾问呢，小姑娘。”</p><p>“省省吧。你说得对，老虎是不太机灵，但仙台眼睛的毛病人人都知道。他只买得起这种，所以要冒这个险。只要能找到工作，他就可以重新换一双了。”</p><p>“换这种？”我点点桌上那本蔡斯小册子，“这得花一大笔钱哪，律姬。你心里清楚得很，那种险冒不得。”</p><p>她点点头，“我要蔡斯的。”</p><p>“你要是去博比那儿，告诉他什么都别干，等我跟他回话再说。”</p><p>“行。生意上的事？”</p><p>“生意上的事。”我说。发疯的事。</p><p>我把我的咖啡喝了，她吃掉了我的新月面包。我把她送到博比楼下。然后，我打了十五个电话，每次都用不同的公用电话。</p><p>什么生意。纯粹是发疯。</p><p>长话短说。我们花了六个星期才完成准备工作。六个星期里，博比不断告诉我他是多么爱她。于是我工作得更投入了，以此避开他那些话。</p><p>绝大部分工作都是打电话。头一批极其隐晦的十五个电话中，似乎每一个都派生出另外十五个电话。我寻找的是某种服务。博比和我都认为，对全世界地下经济来说，这种服务是必不可少的组成部分，但它可能从来不会同时有五个以上的客户。这是一种绝不会广而告之的业务。</p><p>我们要找的是全世界最大的销赃组织，有能力不假手他人，完成数额巨大的网上洗钱、转账等一系列业务，最后把这桩事忘得一干二净。</p><p>到头来，我们的所有努力全是没事找事，因为最后帮我们接上头的是芬兰佬。当时我去了趟纽约，打算买个盗打电话的黑盒子。那么多电话，我们简直快破产了。</p><p>我尽可能以纯假设的方式向他提出那个最大的问题。</p><p>“澳门。”他说。</p><p>“澳门？”</p><p>“长鸣家族，股票掮客。”</p><p>他甚至有他们的电话号码。想找销赃客？找销赃客打听。</p><p>长鸣那帮人可真够隐晦的。我还当自己已经够含蓄的了，可跟他们相比，我那一套就跟战术核武器爆炸一样打眼。博比不得不飞了两趟香港，这才最后敲定。我们的资金越来越少，花得太快了。直到现在，我还是不明白自己当初为什么会答应跟他一起干这单生意。我对珂萝米怕得要死，而且从来不是那么一心想发大财。</p><p>我想说服自己，说整垮蓝光会所是件大好事，因为那个地方藏污纳垢。可这个理由完全说服不了我。我并不喜欢蓝光会所，因为我这辈子最沮丧的一晚就是在那儿度过的。但这并不成其为跟珂萝米交锋的理由。说实话，我有一半觉得我们会死在这桩生意里．就算有那种厉害程序，我们仍然处于绝对劣势。</p><p>博比狂热地写程序命令，除此之外什么都顾不上了。我的工作则是把这个命令集插进珂萝米计算机的根本要地。到那时，博比不可能腾出手帮我，他得把全部注意力用在控制住那个俄国程序上，不让它径直冲杀过去，摧毁一切。那个程序太复杂，我们不可能重新改写。他只能尽全力勒住它，给我留出两秒钟下手。</p><p>我跟一个名叫迈尔斯的黑市拳手谈好了，让他在行动那天跟着律姬，紧紧盯着她，在某个特定时间给我打个电话。我告诉他，如果我没接，或者没用事先讲好的句子，他就得抓住她，带她坐第一班地铁逃走。我给了他一个信封，让他到时候交给她。信封里是钱，还有一张字条。</p><p>博比却根本没想过这些，如果我们搞砸了，她怎么办。没怎么想。他只是不停地告诉我他多么爱她，打算跟她一块儿上哪儿去，怎么享用到手的那一大笔钱。</p><p>“先给她买一副蔡斯。她想要的就是这。模拟刺激的事，她是当真的。”</p><p>“嘿，”他从键盘上抬起头，“到那时，她就用不着工作了。咱们会成功的，杰克。她是我的好运气。从今以后，她再也用不着工作了。”</p><p>“你的好运气。”我很不高兴，已经不记得自己什么时候高兴过了，“最近你见过你的那位好运气吗？”</p><p>他没见过，但我也没有。我们俩都太忙了。</p><p>我想她。这种思念让我想起了自己在蓝光会所度过的那个最沮丧的夜晚，去那儿的原因也是由于思念某个人，另外的某个人。我喝得酩酊大醉，然后开始猛吸垂体激素吸入剂。如果你的心上人决定离开你，你想狠狠折磨自己的话，烈酒加垂体激素是最佳药物，绝配。酒让你感情脆弱，激素让你想起往事——事无巨细，历历在目。这东西本来是治疗老年健忘症用的，但道上的伙计们拿它派了别的用途。所以，我给自己买的是一次超密度回放，回放一份破裂的感情。问题是，记起的有甜美的爱情，也有不堪回首的往事。好的坏的一起上。本来想麻痹自己，像动物一样狂欢一次，可你想起了你当时说的那些恶言恶语，还有她的反唇相讥，还有她如何扬长而去、再不回头。</p><p>我不记得当初我怎么会想到去蓝光，也不记得是怎么去的那儿。我只记得那些寂静的走廊，还有那个俗不可耐的装饰性瀑布，从某个看不见的地方哗啦啦淌下来。或许只是个全息图像。那一晚我有不少钱。博比替某个人在另一个人的冰墙上开了个持续三秒钟的洞，挣了一大笔。</p><p>把门的那帮人肯定不喜欢我那副模样，但我猜我的钱并不讨人嫌。</p><p>干完了我去那儿想干的事以后，我又喝了不少。然后我跟吧台酒保搭讪，聊起恋尸癖的话题。那番谈话进行得不太顺。后来，有个块头非常大的家伙硬要管我叫“战斗英雄”。我可不喜欢这个头衔。我猜我向他炫耀了一番我的胳膊，让他瞧瞧这条肌电自动臂能耍什么花徉。然后我就人事不省了，两天后才在别的什么地方的一个最简陋的睡眠舱里醒过来。一个烂地方，那点儿空间连上吊都不够。我坐在小舱室的泡沫地板上痛哭了一场。</p><p>有些事比孤独更可怕。可话又说回来，他们在蓝光会所卖的那些东西真是顶尖货，是最流行的。流行得几乎像合法生意。</p><p>黑暗的心脏处，寂静的中央部位。破坏子程序用狂暴的灯光撕裂黑暗，我们四周仿佛有一圈半透明的刀锋，锐利无比，砍杀着一切。一场大爆炸，悄然无声，缓慢得像慢动作。碎冰四溅，被永远摧毁。我们身处爆炸中央。穿过这片仿佛宽达无数光年的虚无，穿过电子幻象，远远传来博比的声音——</p><p>“快，整垮这婊子。我勒不住这东西了——”</p><p>俄国程序从一重重数据塔楼间升起，切断了塔楼之间的链接。那些幼儿园里用的天蓝色和粉红色被抹掉了。我把博比自制的那个命令包狠狠插进珂萝米冰冷的心脏。短促喷射式信号发出去了，猛地一震，高度压缩的信息冲天而起。而那个俄国程序正像乌黑的高塔一般，越来越大，直压过来。博比拼命控制着它，想尽量多勒住它一会儿，给我多留出至关重要的一秒钟。他就快失控了，但信号抢在前头，飞过俄国程序的控制范围。从那片黑压压的高塔里伸出一只影子般没形没状的手臂，朝信号一把攫来。但它迟了一步。</p><p>我们成功了。</p><p>矩阵像日本折纸般卷过来，在我周遭涌动。</p><p>阁楼里弥漫着汗味，还有线路烧焦的煳味。</p><p>我觉得自己听到了珂萝米的惨叫，像粗粝的金属音。当然，我是不可能听到的。</p><p>博比在放声大笑，眼里噙着泪水。屏幕一角的计时器上显示着07:24:05。这次行动一共花了不到八分钟。</p><p>那块俄国程序卡在卡槽里融化了。</p><p>我们把珂萝米存在苏黎世账户上的资金分给了十来个全球性慈善机构。这笔钱的数额太庞大了，不可能全留给我们自己。但我们知道，要干就要干彻底，必须把她彻底整垮，否则她就会反过来收拾我们。留给我们的只有不到百分之十，划到澳门的长鸣账户上。这笔钱中，他们扣下了百分之六十的手续费，剩下的通过最复杂的香港资金流扔还给我们。足足过了一个小时，我们的钱才汇到我们在苏黎世开的两个户头上。</p><p>我望着一长串零在一个已经没多大意义的数字后面堆积起来。我发财了。</p><p>这时，电话响了。是迈尔斯。我差点忘了说暗语。</p><p>“喂，杰克，伙计，我弄不清状况了，不知这儿是怎么一档子事儿。我是说你那个姑娘。这儿的事有点麻烦……”</p><p>“什么麻烦？快说。”</p><p>“我，一直盯着她，照你说的，眼睛没离开过她。她去了输家酒吧，待了一阵子，然后上了一辆地铁。去蓝光会所了——”</p><p>“她去哪儿？”</p><p>“从侧门进去的。员工专用门。我可没办法绕开那儿的保安。”</p><p>“她这会儿还在那儿？”</p><p>“不知道，伙计。反正我把她跟丢了。这儿跟发了疯似的，好像蓝光准备关门了，彻底关张。拉响的警报至少有七种，人人东奔西跑，简直像开了锅……各种各样的人都来了，保险商，地产商，还有挂着市政府牌子的车……”</p><p>“迈尔斯，她到底去哪儿了？”</p><p>“跟丢了，杰克。”</p><p>“听着，迈尔斯，信封里的钱，你自个儿留着吧。懂吗？”</p><p>“你当真？唉，跟丢了她，真对不起，我……”</p><p>我挂了电话。</p><p>“先别走，咱俩一块儿告诉她。”博比一边说，一边用块毛巾擦着赤裸的胸口。</p><p>“你自己告诉她吧。我得出去茫走。”</p><p>我走进霓虹灯下的夜晚，盲目地走着，随便人流把我推向哪儿，强迫自己成为纵情声色的人群的一分子，行走世间的活人中的一个。我什么都不想，只机械地不断把一只脚放到另一只前面。但过了一会儿，我还是想了想，什么都明白了。她需要钱啊。</p><p>我也想了想珂萝米。我们杀了她，冷酷地谋杀了她。这是肯定的，就好像我们亲手割断了她的喉管一样。这个夜晚裹挟着我穿过一个个商场、购物广场，追杀她的行动也会在同一个夜晚展开。而她却无处可去。单说我身边的这一大群人，这里面有多少是她的敌人？既然不必再害怕她的金钱的威力，他们中有多少人已经准备行动起来？我们夺走了她的一切，她再一次流落街头了。我怀疑她能不能活到明天早上。</p><p>我终于想起了那家咖啡馆，就是我碰上老虎那一家。</p><p>她的墨镜把什么都告诉我了。大大的黑色镜片，其中一只的一角还留着肉色止疼膏的痕迹。“嗨，律姬。”我说。她摘下眼镜的时候，我已经作好了心理准备，</p><p>蓝色。塔丽·艾沙姆那种蓝色。这种眼睛最出名的就是这种标志性的蓝色，每只瞳仁里都有两个小字：蔡斯。大写字母，像金色的斑点。</p><p>“真漂亮。”我说。手术的伤痕肯定被止疼膏遮住了，没有什么手术会像这样不留痕迹，“看样子你挣了笔钱。”</p><p>“是啊。”说完，她打了个寒噤，“可我不能再挣了，不能用那种办法。”</p><p>“我听说那个地方已经关门了。”</p><p>“喔。”她脸上的表情呆滞了，那双崭新的蓝色眼睛凝定不动，深不见底。</p><p>“没关系。博比在等你。我们刚刚做了一票大的。”</p><p>“不，我得走。我想，他不会理解我做的事。我得走。”</p><p>我点了点头，望着自己的胳膊抬起来，握住她的手。这只胳膊好像已经不是我自己的了，但她还是像从前那样握住它。</p><p>“我买了张去好莱坞的单程票。老虎认识一些人，我可以住在他们那儿。说不定以后我还能去千叶呢。”</p><p>她对博比的估计很正确。我陪她回去，他确实不理解她做的事。但对博比来说，她这个人已经起到了应有的作用。我想告诉她别为他伤心。我看得出来，她很伤心。她收拾好她那几个尼龙包之后，他甚至不肯把她送出走廊。我替她把行李拿下楼，吻了她，弄脏了她的止疼膏。什么东西在我心底涌起，就像那个俄国程序在珂萝米的数据塔楼间涌起一样。我突然喘不过气来，没有语言能形容这种感觉。但她得赶飞机。</p><p>博比瘫坐在屏幕前的转椅里，望着他的那一长串零。他又戴上了墨镜。我知道，天黑时他就会去输家酒吧，寻找这一季的姑娘，焦灼地寻找一个征兆，一个人，以此弄清今后的生活目的。我不觉得他今后的生活会有什么两样。日了更舒适，但他仍旧永远会等待着翻开下一张牌。</p><p>我尽可能不去想像她在蓝光会所的工作。三小时一班，跟动眼睡眠⑤的状态差不多，剩下的事全交给肉体和一整套经过处理的条件反射。客人们绝不会抱怨她的高潮是装出来的。高潮是真的，但对她来说，那种感觉（如果她有感觉的话）只是飘浮在梦乡边缘的点点微弱的银光。是啊，最流行的，流行得几乎像合法生意。客人们既需要陪伴，同时又需要独处。这两种需求真是太矛盾了。或许这正是这种事的本质，从古至今。但现在有了神经中枢电子控制系统，他们总算称心如意，两全齐美了。</p><p>【⑤睡眠的一个阶段。在此阶段，睡眠者的眼球会快速运动。】</p><p>我拿起电话，打给她的航空公司。我报了她的真名、航班号。“她要换票，”我说，“去千叶，对，日本。”我把我的信用卡插进卡槽，输入密码，“头等舱。”对方扫描我的信用记录，电话发出轻微的嗡嗡声，“改成来回票。”</p><p>我现在猜想，她肯定退了回程票，兑成现钞。要不就是没用那张回程机票，因为她一直没有回来。夜里，我有时会经过某个贴满模拟刺激明星像的橱窗。眼睛一模一样，都是那么美丽，长在差不多一模一样的脸上。它们凝视着我。有时候，这些眼睛幻化成了她的眼睛，但那些脸庞不是她的，从来不是。我着着她远远飘离四下蔓延的夜色和城市——这时，她向我挥手道别。</p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
