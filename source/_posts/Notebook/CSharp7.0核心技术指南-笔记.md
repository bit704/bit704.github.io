---
title: 《C# 7.0核心技术指南（原书第7版）》笔记
index_img: https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-CSharp7.0核心技术指南-笔记.jpg
banner_img: https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-CSharp7.0核心技术指南-笔记.jpg
layout: post
categories: [Notebook]
tags: [C#]
---

原书作者   *Joseph Albahari   Ben Albahari*

<!-- more -->

C# 7.0 in a Nutshell: The Definitive Reference

译者 刘夏

机械工业出版社

![封面](https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-CSharp7.0核心技术指南-笔记_s.jpg)

## 第1章 C#和.NET Framework简介

C#是一种通用的，类型安全的面向对象编程语言。

C#语言和平台无关，且可以与诸多平台下的编译器和框架（尤其是Windows下的Microsoft .NET Framework）协同工作。

### 1.1 面向对象

C#实现了丰富的面向对象范式，包括封装、继承和多态。

C#面向对象特性包括：统一的类型系统C#中的基础构件是一种称为类型的数据与函数的封装单元。C#拥有统一的类型系统，其中的所有类型都共享一个公共的基类。这意味着所有类型，不论它们是表示业务对象还是表示数字这样的基元类型，都共享相同的基本功能。例如，任何类型的实例都可以通过调用ToString方法将自身转换为一个字符串。类与接口在传统面向对象范式中，唯一的类型就是类。然而C#还有其他几种类型，其中之一是接口（interface）。接口与类相似，但它仅仅描述成员。而实现接口的类型将实现接口定义的这些成员。接口在需要多继承的情形下非常有用（与C++和Eiffel等语言不同，C#并不支持类的多继承）。属性、方法和事件在纯粹的面向对象范式中，所有的函数都是方法（Smalltalk就是这样）。而在C#中，方法只是函数成员之一。除此之外还有属性、事件及其他的形式。属性是封装了一部分对象状态的函数成员，例如按钮的颜色或者标签的文本。事件则是简化对象状态变化处理的函数成员。

虽然C#首先是一种面向对象的语言，但它也借鉴了函数式编程的范式。例如：可以将函数作为值看待C#使用委托（delegate）将函数作为值传递给其他函数或者从其他函数中返回。C#支持纯函数模式函数式编程的核心是避免使用值可以变化的变量，或称为声明式模式。C#拥有支持该模式的若干关键功能。包括支持可以捕获变量的匿名函数（Lambda表达式），通过查询表达式（query expression）执行列表式或响应式编程；它还可以使用只读字段（readonly field）和属性创建不可变的（immutable）类型。

### 1.2 类型安全性

C#是一种类型安全（type-safe）的语言。这意味着类型的实例只能通过它们定义的协议进行交互，从而保证了每种类型的内部一致性。例如，C#不允许将字符串类型作为整数类型进行处理。更具体地说，C#支持静态类型化（static typing），即在编译时会执行安全性检查。此外，在运行时也会同样执行类型安全性检查。

C#还是一门强类型语言（strongly typed language），因为它的类型规则（不论是静态还是运行时）非常严格。例如，不能用一个浮点类型的参数来调用一个接受整数类型参数的函数，必须显式将这个浮点数转换为整数。这可以防止编码错误。

### 1.3 内存管理

C#并未抛弃指针，只是在大多数编程任务中是不需要使用指针的。对于性能优先的热点和互操性，仍然可以在标记为unsafe的程序块内使用指针并进行显式内存分配。

### 1.5 C#和CLR

C#依赖运行时环境，它含有许多特性，如自动化内存管理和异常处理。Microsoft.NET Framework的核心公共语言运行（Common Language Runtime, CLR）就提供了这些运行时特性。

CLR和语言无关。开发者可以使用多种语言，例如C#、F#、VisualBasic.NET，以及托管C++来构建应用程序。

与其他的托管语言一样，C#也会将代码编译为托管代码。托管代码以中间语言（Intermediate Language, IL）的形式表示。CLR通常会在执行前，将IL转换为机器（例如x86或x64）原生代码，称为即时（Just-In-Time, JIT）编译。除此之外，还可以使用提前编译（ahead-of-time compilation）技术来改善拥有大程序集，或在资源有限的设备上运行的程序的启动速度（包括那些使用Xamarin开发的）满足iOS应用商店规则的应用。

托管代码的容器称为程序集（assembly）或可移植程序集（portable executable）。程序集可以是一个可执行文件（.exe）也可以是一个库（.dll）。它们不仅包含IL，还包含称为元数据（metadata）的类型信息。元数据的引入使程序集无须额外的文件就可以引用其他程序集中的类型。

使用Microsoft的ildasm工具可以反编译并查看程序集的IL。而其他工具，例如ILSpy、dotPeek（JetBrains）以及Reflector（Red Gate）则可以将IL代码进一步反编译为C#。

程序也可以通过反射（reflection）查询其元数据，甚至在运行时生成新的IL（reflection. emit）。

### 1.6 CLR和.NET Framework

.NET Framework是由CLR和大量的程序库组成的。这些程序库由核心库（本书主要介绍）和应用库组成，应用库依赖于核心库。

## 第2章 C#语言基础

本章将介绍一些C#语言的基础知识。

### 2.1 第一个C#程序

方法（method）是由一系列语句（语句块）组成的行为。语句块由一对大括号，及其中的零个或者多个语句组成。

方法是C#中的诸多种类的函数之一。另一种函数是我们用来执行乘法运算的*运算符。其他的函数种类还包括构造器、属性、事件、索引器和终结器。

C#编译器将一系列．cs扩展名的源代码文件编译成程序集。程序集是.NET中的最小打包和部署单元。程序集可以是一个应用程序或者是一个库。普通的控制台程序或Windows应用程序是一个．exe文件，包含一个Main方法。而库是一个．dll文件，即一个没有入口点的．exe文件。库可以被应用程序或其他的库调用（引用）。.NET Framework就是由一系列库组成的。

### 2.2 语法

通常约定参数、局部变量以及私有字段应该以小写字母开头（例如myVariable），而其他类型的标识符则应该以大写字母开头（例如MyMethod）。

如果希望用关键字作为标识符，需在关键字前面加上@前缀。

一些关键字是上下文相关的，它们有时不用添加@前缀就可以用作标识符。

### 2.3 类型基础

预定义类型可以简单地通过字面量进行实例化，例如12或"Hello World"。而自定义类型则需要使用new运算符来创建实例。

那些不是由类型的实例操作，而是由类型本身操作的数据成员和函数成员必须标记为static。

所有的C#类型可以分为以下几类：

- 值类型
-  引用类型
-  泛型参数
- 指针类型

值类型包含大多数的内置类型（具体包括所有数值类型、char类型和bool类型）以及自定义的struct类型和enum类型。引用类型包含所有的类、数组、委托和接口类型。（这其中包括了预定义的string类型。）值类型和引用类型最根本的不同在于它们在内存中的处理方式。

引用类型要求为引用和对象单独分配存储空间。对象除占用了和字段一样的字节数外，还需要额外的管理空间开销。管理开销的精确值本质上属于.NET运行时实现的细节，但最少也需要8个字节来存储该对象的类型的键，以及一些诸如多线程锁的状态、是否可以被垃圾回收器固定等临时信息。根据.NET运行时是工作在32位抑或64位平台上，每一个对象的引用都需要额外的4到8个字节。

在CLR中，除了decimal之外的一系列预定义值类型属于基元类型。之所以将其称为基元类型是因为它们在编译过的代码中有直接的指令支持。而这种指令通常翻译为底层处理器直接支持的指令。

### 2.4 数值类型

默认情况下，编译器将数值字面量推断为double类型或是整数类型。

- 如果这个字面量包含小数点或者指数符号（E），那么它是double。
- 否则，这个字面量的类型就是下列能满足这个字面量的第一个类型：int、uint、long和ulong。

将浮点数转换为整数时，小数点后的数值将被截去而不会舍入。静态类System.Convert提供了在不同值类型之间转换的舍入方法（见第6章）。

整数类型的除法运算总是会截断余数（向0舍入）。

checked运算符的作用是：在运行时当整数类型表达式或语句超过相应类型的算术限制时不再默默地溢出，而是抛出OverflowException。checked运算符可在有++、--、+、-（一元运算符和二元运算符）、*、/和整数类型间显式转换运算符的表达式中起作用。

checked运算符对double和float类型没有作用（它们会溢出为特殊的“无限”值，这会在后面介绍），对decimal类型也没有作用（这种类型总是会进行溢出检查）。

8位和16位整数类型指byte、sbyte、short、ushort。这些类型自己并不具备算术运算符，所以C#隐式地将它们转换为所需的更大一些的类型。当试图把运算结果赋给一个小的整数类型时会产生编译时错误。

不同于整数类型，浮点类型包含某些特定运算需要特殊对待的值。这些特殊的值是NaN（Not a Number，非数字）、+∞、-∞和-0。float和double类型包含表示NaN、+∞、-∞值的常量。其他的常量还有MaxValue、MinValue以及Epsilon。

零除以零或无穷大减去无穷大的结果是NaN。

使用比较运算符（==）时，一个NaN的值永远也不等于其他的值，甚至不等于其他的NaN值。

必须使用float.IsNaN或double.IsNaN方法来判断一个值是否为NaN。

但使用object.Equals方法时，两个NaN却是相等的。

float和double在内部都是基于2来表示数值的。因此只有基于2表示的数值才能够精确表示。

decimal基于10，它能够精确表示基于10的数值（也包括它的因数，基于2和基于5的数值）。因为实数的字面量都是基于10的，所以decimal能够精确表示像0.1这样的数。然而，double和decimal都不能精确表示那些基于10的循环小数。

### 2.5 布尔类型和运算符

尽管布尔类型的值仅需要1位的存储空间，但是运行时却使用了1字节内存空间。这是因为字节是运行时和处理器能够有效使用的最小单位。为避免在使用数组时的空间浪费，.NET Framework在System.Collections命令空间下提供了BitArray类，其中的每一个布尔值仅占用一位。

bool类型不能转换为数值类型，反之亦然。

对于引用类型，默认情况下相等是基于引用的，而不是底层对象的实际值。

比较运算符也可以用于枚举（enum）类型的成员，它比较的是表示枚举成员的整数值。

不同于C和C++, &和|运算符在用于布尔表达式时执行布尔比较（非短路计算）。而&和|运算符仅在用于数值运算时才执行位运算。

### 2.6 字符串和字符

C#中的字符串类型（System.String类型的别名，我们将在第6章详细介绍）表示不可变的Unicode字符序列。字符串字面量应位于两个双引号（"）之间。

string类型是引用类型而不是值类型。但是它的相等运算符却遵守值类型的语义。

原意字符串字面量要加@前缀，它不支持转义字符。

原意字符串可以贯穿多行。

原意字符串中需要用两个双引号来表示一个双引号字符。

重复使用+运算符来构建字符串是低效的。更好的解决方案是使用System.Text.StringBuilder类型。

以$字符为前缀的字符串称为插值字符串。插值字符串可以在大括号内包含表达式。

插值字符串只能是在单行内声明，除非使用原意字符串运算符。需要注意，$运算符必须在@运算符之前。

string类型不支持<和>的比较。必须使用字符串的CompareTo方法。

### 2.7 数组

数组的Length属性返回数组中的元素数目。一旦数组创建完毕，它的长度将不能更改。System.Collection命名空间和子命名空间提供了可变长度数组和字典等高级数据结构。

多维数组分为两种类型：矩形数组和锯齿形数组。矩形数组代表n维的内存块，而锯齿形数组则是数组的数组。

锯齿形数组在声明时用一对方括号对表示每个维度。

这里是new int[3][]而非new int[][3]。Eric Lippert有一篇文章详细解释了这个问题，请参见：http://albahari.com/jagged。

### 2.8 变量和参数

值类型的实例（和对象的引用）就存储在变量声明的地方。如果声明为类的字段或数组的元素，则该实例会存储在堆上。

C#中无法像C++那样显式删除对象。未引用的对象最终将被垃圾回收器回收。

静态字段也会存储在堆上。与分配在堆上的对象（可以被垃圾回收）不同，这些变量一直存活直至应用程序域结束。

C#强制执行明确赋值策略。实践中这意味着在unsafe上下文之外无法访问未初始化的内存。明确赋值有三种含义：

- 局部变量在读取之前必须赋值。
- 调用方法时必须提供函数的实际参数（除非标记为可选参数，参见2.8.4.7节）。
- 运行时将自动初始化其他变量（例如字段和数组元素）。

default关键字可用于获得任意类型的默认值（这对泛型非常有用，我们将在第3章介绍泛型）。

在C#中，若按引用传递参数则应使用ref参数修饰符。

注意ref修饰符在声明和调用时都是必须的。

out参数和ref参数类似，但在以下几点上不同：

- 不需要在传入函数之前进行赋值。
- 必须在函数结束之前赋值。

从C# 7开始，允许在调用含有out参数的方法时直接声明变量。

当调用含有多个out参数的方法时，若我们并非关注所有参数的值，那么可以使用下划线来“丢弃”那些不感兴趣的参数。

出于向后兼容性的考虑，如果在作用域内，已经有一个名为下划线的变量的话，这个语言特性就失效了。

params参数修饰符只能修饰方法中的最后一个参数，它能够使方法接受任意数量的指定类型参数。参数类型必须声明为数组。

从C# 4.0开始，方法、构造器和索引器（见第3章）中都可以声明可选参数。只要在参数声明中提供默认值，这个参数就是可选参数。

若public方法对其他程序集可见，则在添加可选参数时双方均需重新编译，就像参数是必须提供的一样。可选参数的默认值必须由常量表达式或者无参数的值类型构造器指定，可选参数不能标记为ref或者out。必填参数必须在可选参数方法声明和调用之前出（params参数例外，它总是最后出现）。

除了用位置确定参数外，还可以用名称来确定参数。

按位置传递的参数必须出现在命名参数之前。

C# 7添加了一个令人费解的特性：即定义一个用于引用数组中某一个元素或对象中某一个字段的局部变量。

从方法中返回的引用局部变量，称为引用返回值。

隐式类型变量仍是静态类型的。

在4.9节我们将介绍必须使用var的情况。

### 2.9 表达式和运算符

表达式本质上是值。最简单的表达式是常量和变量。表达式能够用运算符进行转换和组合。运算符用一个或多个输入操作数来输出一个新的表达式。

二元运算符（除了赋值运算符、Lambda运算符、null合并运算符）是左结合运算符。

### 2.10 null运算符

null合并运算符写作？?。它的意思是“如果操作数不是null则结果为操作数，否则结果为一个默认的值。

C# 6中引入了“? .”运算符，称为null条件运算符或者Elvis运算符（从Elvis表情符号而来）。该运算符可以像标准的“.”运算符那样访问成员以及调用方法。当运算符的左侧为null的时候，该表达式的运算结果也是null而不会抛出NullReferenceException异常。

### 2.11 语句

 变量的作用范围是它所在的整个代码块（前向和后向都包含）。这意味着虽然在变量或常量声明之前引用它是不合法的，但即使将示例中的x初始化移动到方法的末尾我们也会得到相同的错误，这个奇怪的规则和C++是不同的。

C# 7开始支持按类型switch。

可以使用when关键字对case进行预测。

堆叠多个case子句也是没有问题的。

可以混合使用常量选择和模式选择，甚至可以选择null值。

跳转语句仍然遵守try语句的可靠性规则（参见4.5节）。这意味着：

- 到try语句块之外的跳转总是在达到目标之前执行try语句的finally语句块。
- 跳转语句不能从finally语句块内跳到块外（除非使用throw）。

return语句能够出现在方法的任意位置（除finally块中）。

C#重载了using关键字，使它在不同上下文中有不同的含义。特别注意using指令和using语句是不同的。

### 2.12 命名空间

命名空间是独立于程序集的。程序集是像．exe或者．dll一样的部署单元（参见第18章）。命名空间并不影响成员的public、internal、private的可见性。

命名空间中的“.”表明了嵌套命名空间的层次结构。

using指令用于导入命名空间。这是避免使用完全限定名称来指代某种类型的快捷方法。

从C# 6开始，我们不仅可以导入命名空间还可以使用using static指令导入特定的类型。这样就可以类型接使用类型静态成员而不需要指定类型的名称了。

C#编译器还没有聪明到可以基于上下文来推断出正确的类型，因此在导入多个静态类型导致二义性时会发生编译错误。

外层命名空间中声明的名称能够直接在内层命名空间中使用。

使用统一命名空间分层结构中不同分支的类型需要使用部分限定名称。

如果相同类型名称同时出现在内层和外层命名空间中，则内层类型优先。如果要使用外层命名空间中的类型，必须使用它的完全限定名称。

所有的类型名在编译时都会转换为完全限定名称。中间语言（IL）代码不包含非限定名称和部分限定名称。

只要命名空间内的类型名称不冲突就可以重复声明同一个命名空间。

我们能够在命名空间中嵌套使用using指令，这样可以控制using指令在命名空间声明中的作用范围。

导入命名空间可能导致类型名称的冲突，因此可以只导入需要的特定类型而不是整个命名空间，并给它们创建别名。

使用外部别名就可以引用两个完全限定名称相同的类型（例如，命名空间和类型名称都相同）。这种特殊情况只在两种类型来自不同的程序集时才会出现。

编译器总是给当前命名空间中的标识符以更高的优先级；在这种情况下，将会实例化嵌套类B。要解决这样的冲突，可以使用如下的方式限定命名空间中的名称：

- 全局命名空间，即所有命名空间的根命名空间（由上下文关键字global指定）
- 一系列的外部别名“::”用于限定命名空间别名

## 第3章 在C#中创建类型

本章将深入讨论类型和类型的成员。

### 3.1 类

复杂的类可能包含如下内容：

- 在class关键字之前：类特性（Attribute）和类修饰符。非嵌套的类修饰符有：public、internal、abstract、sealed、static、unsafe和partial。
- 紧接YourClassName：泛型参数、唯一基类与多个接口。
- 在花括号内：类成员（方法、属性、索引器、事件、字段、构造器、重载运算符、嵌套类型和终结器）

字段可用以下修饰符进行修饰：

- 静态修饰符：static
- 访问权限修饰符：public internal private protected
- 继承修饰符：new
- 不安全代码修饰符：unsafe
- 只读修饰符：readonly
- 线程访问修饰符：volatile

readonly修饰符防止字段在构造后进行变更。只读字段只能在声明时或在其所属的类型构造器中赋值。

字段不一定要初始化。没有初始化的字段均为默认值（0、\0、null、false）。字段初始化逻辑在构造器之前运行。

方法可以用以下修饰符修饰：

- 静态修饰符：static
- 访问权限修饰符：public internal private protected
- 继承修饰符：new virtual abstract override sealed
- 部分方法修饰符：partial
- 非托管代码修饰符：unsafe extern
- 异步代码修饰符：async

只要确保方法签名不同，可以在类型中重载方法（多个方法公用一个名称）。

方法的返回值类型和params修饰符不属于方法签名的一部分。

参数按值传递还是按引用传递也是方法签名的一部分。例如，Foo(int)和Foo(refint)或Foo(out int)可以同时出现在一个类中。但Foo(ref int)和Foo(out int)不能同时出现在一个类中。

局部方法不能用static修饰。如果父方法是静态的，那么局部方法也是隐式静态的。

构造器执行类或结构体的初始化代码。构造器的定义和方法的定义类似，区别仅在于构造器名和返回值只能和封装它的类型相同。

实例构造器支持以下的修饰符：

- 访问权限修饰符：public internal private protected
- 非托管代码修饰符：unsafe extern

类或者结构体可以重载构造器。为了避免重复代码，构造器可以用this关键字调用另一个构造器

当构造器调用另一个构造器时，被调用的构造器先执行。

C#编译器会自动为没有显式定义构造器的类生成无参数公有构造器。但是，一旦显式定义了至少一个构造器，系统就不再自动生成无参数的构造器。

字段的初始化按声明的先后顺序，在构造器之前执行。

C# 7引入了解构器模式。一个解构器（或称之为解构方法）就像构造器的反过程：构造器使用若干值作为参数，并且将它们赋值给字段；而解构器则相反将字段反向赋值给若干变量。解构方法的名字必须为Deconstruct，并且拥有一个或多个out参数。

还可以通过重载Deconstruct方法向调用者提供一系列解构方案。

Deconstruct方法可以是扩展方法（请参见4.8节）。这种做法可方便地对其他作者的类型进行解构。

如果希望程序在不同版本的程序集中保持二进制兼容，最好避免在公有方法中使用可选参数。

this引用指代实例本身。

属性和字段的声明很类似，但是属性比字段多出了get/set代码块。

本书中广泛使用公有字段以免干扰读者的注意力。但是在实际应用中，为了提高封装性可能会更倾向于使用公有属性。

属性支持以下的修饰符：

- 静态修饰符：static
- 访问权限修饰符：public internal private protected
- 继承修饰符：new virtual abstract override sealed
- 非托管代码修饰符：unsafe extern

如果只定义了get访问器，属性就是只读的。如果只定义了set访问器，那么它就是只写的。一般很少使用只写属性。

从C# 6开始，只读属性（就像之前的例子中那样的属性）可简写为表达式体属性。它使用双箭头替换了花括号、get访问器和return关键字。

C# 7进一步允许在set访问器上使用表达式体。

get和set访问器可以有不同的访问级别。

属性本身应当声明具有较高的访问级别（本例中为public），然后在需要较低级别的访问器上添加相应的访问权限修饰符。

索引器为访问类或者结构体中封装的列表或字典型数据元素提供了自然的访问接口。索引器和属性很相似，但索引器通过索引值而非属性名称访问数据元素。

常量在使用时比起static readonly字段有着更多的限制，不仅能够使用的类型有限，而且初始化字段的语句含义也不同。其他的不同之处还有常量是在编译时进行赋值的。

非局部常量可以使用以下的修饰符：

-  访问权限修饰符：public internal private protected
-  继承修饰符：new

每个类型的静态构造器只会执行一次，而不是每个实例执行一次。一个类型只能定义一个静态构造器，名称必须和类型同名，且没有参数。

运行时将在类型使用之前调用静态构造器，以下两种行为可以触发静态构造器执行：

- 实例化类型
- 访问类型的静态成员

静态构造器只支持两个修饰符：unsafe和extern。

静态字段初始化器会在调用静态构造器前运行。如果类型没有静态构造器，字段会在类型被使用之前或者在运行时中更早的时间进行初始化。静态字段初始化器按照字段声明的先后顺序运行。

类可以标记为static，表明它必须只能够由static成员组成，并不能够派生子类。

终结器（Finalizer）是只能够在类中使用的方法。该方法在垃圾回收器回收未引用的对象占用的内存前调用。终结器的语法是类型的名称加上～前缀。

终结器允许使用以下的修饰符：

- 非托管代码修饰符：unsafe

分部类型（Partial type）允许一个类型分开进行定义，典型的做法是分开在多个文件中。分部类型使用的常见场景是从其他源文件自动生成分部类（例如从VisualStudio模板或设计器），而这些类仍然需要额外手动编写方法。

编译器并不保证分部类型声明中各个组成部分之间的字段初始化顺序。

分部类型可以包含分部方法（partial method）。这些方法能够令自动生成的分部类型为手动编写的代码提供自定义钩子（hook）。

分部方法返回值类型必须是void，且默认是private的。

nameof运算符返回任意符号的字符串名称（类型、成员、变量等）。

### 3.2 继承

派生类也称为子类（subclass）；基类也称为超类（superclass）。

多态之所以能够实现，是因为子类（Stock和House）具有基类（Asset）的全部特征。

对象引用可以：

- 隐式向上转换为基类的引用；
- 显式向下转换为子类的引用。各个兼容的类型的引用之间向上或向下类型转换仅执行引用转换：（逻辑上）生成一个新的引用指向同一个对象。向上转换总是能够成功，而向下转换只有在对象的类型符合要求时才能成功。

as运算符在向下类型转换出错时返回null（而不是抛出异常）。

as运算符不能用来实现自定义转换（请参见4.14节），也不能用于数值的转换。

is运算符检查引用的转换是否能够成功，即对象是否从某个特定的类派生（或是实现某个接口）。

从C# 7开始我们可以在使用is运算符的同时引入一个变量。

提供特定实现的子类可以重写（overridden）标识为virtual的函数。方法、属性、索引器和事件都可以声明为virtual。

虚方法和重写的方法的签名、返回值以及可访问性必须完全一致。重写方法可以通过base关键字调用其基类的实现。

从构造器调用虚方法有潜在的危险性，因为编写子类的人在重写方法的时候未必知道现在正在操作一个未完全实例化的对象。换言之，重写的方法很可能最终会访问到一些方法或属性，而这些方法或属性依赖的字段还未被构造器初始化。

声明为抽象（abstract）的类不能够实例化，只有抽象类的具体实现子类才能实例化。抽象类中可以定义抽象成员，抽象成员和虚成员相似，只不过抽象成员不提供默认的实现。除非子类也声明为抽象类，否则其实现必须由子类提供。

new修饰符可以明确将你的意图告知编译器和其他开发者：重复的成员是有意义的。

重写的函数成员可以使用sealed关键字密封其实现，防止其他的子类再次重写。

虽然密封可以防止重写，但是它却无法阻止成员被隐藏。

base关键字和this关键字很相似。它有两个重要目的：

- 从子类访问重写的基类函数成员
- 调用基类的构造器（见下节）

基类的构造器总是先执行，这保证了基类的初始化发生在子类特定的初始化之前。

如果子类的构造器省略base关键字，那么基类的无参数构造器将被隐式调用。

如果基类没有可访问的无参数的构造器，子类的构造器中就必须使用base关键字。

当对象实例化时，初始化按照以下的顺序进行：1．从子类到基类a）初始化字段b）计算被调用的基类构造器中的参数2．从基类到子类a）构造器方法体的执行。

继承对方法的重载有着特殊的影响。

如果把Asset类转换为dynamic（见第4章），则会在运行时决定调用哪个重载。这样就会基于对象的实际类型进行选择。

### 3.3 object类型

object是引用类型，承载了类的优点。尽管如此，int等值类型也可以和object类型相互转换并加入栈中。C#这种特性称为类型一致化。

装箱是将值类型实例转换为引用类型实例的行为。

装箱转换对系统提供一致性的数据类型至关重要。但这个体系并不是完美的：在3.9节中会介绍，数组和泛型的变量只能支持引用转换，不能支持装箱转换。

C#程序在静态（编译时）和运行时（CLR）都会执行类型检查。

C#中的所有类型在运行时都会维护System.Type类的实例。有两个基本方法可以获得System.Type对象：

- 在类型实例上调用GetType方法
- 在类型名称上使用typeof运算符GetType在运行时计算而typeof在编译时静态计算（如果是用泛型类型参数，那么它将由即时编译器解析）。

### 3.4 结构体

结构体和类相似，不同之处在于：

- 结构体是值类型，而类是引用类型。
- 结构体不支持继承（除了隐式派生自object类型，或更精确地说，是派生自System. ValueType）。
- 除了以下内容，结构体可以包含类的所有成员：
  - 无参数的构造器
  - 字段初始化器
  - 终结器
  - 虚成员或protected成员

结构体的构造语义如下：

- 结构体隐式包含一个无法重写的无参数构造器，将字段按位置为0。
- 定义结构体的构造器时，必须显式为每一个字段赋值。

### 3.5 访问权限修饰符

为了提高封装性，类型或类型成员可以在声明中添加以下五个访问权限修饰符之一来限定其他类型和其他程序集对它的访问

- public：完全访问权限。枚举类型成员或接口成员隐含的可访问性。
- internal：仅可以在程序集内访问，或供友元程序集访问。这是非嵌套类型的默认可访问性。
- private：仅可以在包含类型中访问。这是类或者结构体成员的默认可访问性。
- protected：仅可以在包含类型或子类中访问。
- protected internal:protected和internal可访问性的并集。Eric Lippert是这样解释的：默认情况下尽可能将一切规定为私有，然后每一个修饰符都会提高其访问级别。所以用protected internal修饰的成员在两个方面的访问级别都提高了。

在一些高级的场景中，添加System.Runtime.CompilerServices.InternalsVisibleTo程序集特性就可以将internal成员提供给其他的友元程序集访问。

类型的可访问性是它内部声明成员可访问性的封顶。

当重写基类的函数时，重写函数的可访问性必须一致。

编译器会阻止任何不一致的访问权限修饰符。例如，子类可以比基类的访问权限低，但不能比基类的访问权限高。

### 3.6 接口

接口和类相似，但接口只为成员提供定义而不提供实现。接口的不同之处在于：

- 接口的成员都是隐式抽象的。相反，类可以包含抽象的成员和有具体实现的成员。
- 一个类（或者结构体）可以实现多个接口。而一个类只能够继承一个类，结构体则完全不支持继承（只能从System.ValueType派生）。接口声明和类声明很相似。但接口不提供成员的实现，这是因为它的所有成员都是隐式抽象的。这些成员将由实现接口的类或结构体实现。接口只能包含方法、属性、事件、索引器，而这些正是类中可以定义为抽象的成员类型。

接口成员总是隐式public的，并且不能用访问权限修饰符声明。实现接口意味着它将为所有的成员提供public实现。

尽管CountDown是internal权限的类，通过把CountDown实例转换为IEnumerator，其内部实现IEnumerator接口的成员就可以作为public成员访问。

当实现多个接口时，有时会出现成员签名的冲突。显式实现（explicitlyimplementing）接口成员可以解决冲突。

调用显式实现成员的唯一方式是先将其转换为对应的接口。

默认情况下，隐式实现的接口成员是密封的。为了重写，必须在基类中将其标识为virtual或者abstract。

显式实现的接口成员不能标识为virtual，也不能实现通常意义的重写，但是它可以被重新实现（reimplemented）。

将结构体转换为接口会引发装箱。而调用结构体的隐式实现接口成员不会引发装箱。

### 3.7 枚举类型

每一个枚举成员都对应一个整数。在默认情况下：

- 对应的数值是int类型的。
- 按照枚举成员的声明顺序，自动按照0、1、2……进行常量赋值。

在枚举表达式中，编译器会特殊对待数值字面量0。它不需要进行显式转换。

对0进行特殊对待的原因有两个：

- 第一个枚举成员经常作为默认值。
- 在合并枚举类型中，0表示无标志。

按照惯例，当枚举类型的成员可以合并时，其枚举类型一定要应用Flags特性。如果声明了一个没有标注Flags特性的枚举类型，其成员依然可以合并，但若在该枚举实例上调用ToString方法，则会输出一个数值而非一组名字。

一般来说，合并枚举类型通常用复数名词而不用单数形式。为了方便起见，可以将合并的成员直接放在枚举的声明内。

### 3.8 嵌套类型

嵌套类型有如下的特征：

- 可以访问包含它的外层类型中的私有成员，以及外层类所能够访问的所有内容。
- 可以在声明上使用所有的访问权限修饰符，而不限于public和internal。
- 嵌套类型的默认可访问性是private而不是internal。
- 从外层类以外访问嵌套类型，需要使用外层类名称进行限定（就像访问静态成员一样）。

所有的类型（类、结构体、接口、委托和枚举）都可以被类或结构体嵌套。

嵌套类型在编译器中得到了广泛应用，例如编译器在生成迭代器和匿名方法时就会生成包含这些结构内部状态的私有（嵌套）类。

如果使用嵌套类型的主要原因是为了避免命名空间中类型定义杂乱无章，那么可以考虑使用嵌套命名空间。使用嵌套类型的原因应当是利用它较强的访问控制能力，或者是因为嵌套的类型必须访问外层类型的私有成员。

### 3.9 泛型

通常调用泛型方法不需要提供类型参数，因为编译器可以隐式推断得出。

习惯上，如果泛型类型和泛型方法只有一个类型参数，且参数的含义明确，那么一般将其命名为T。当使用多个类型参数时，每一个类型参数都使用T作为前缀，后面跟一个更具描述性的名称。

在运行时不存在开放的泛型类型：开放泛型类型将汇编为程序的一部分而封闭。但运行时可能存在未绑定（unbound）的泛型类型，只作为Type对象存在。C#中唯一指定未绑定泛型类型的方式是使用typeof运算符。

默认情况下，类型参数可以由任何类型来替换。在类型参数上应用约束，可以将类型参数定义为指定的类型参数。

技术上，子类型中所有的类型参数都是新的：可以说子类型封闭后又重新开放了基类的类型参数。

C#的类型转换运算符可以进行多种的类型转换，包括：

- 数值转换
- 引用转换
- 装箱/拆箱转换
- 自定义转换（通过运算符重载，请参见第4章）

假定A可以转换为B，如果X<A>可以转换为X<B>那么称X有一个协变类型参数。

C# 4.0中，在接口和委托的类型参数上指定out修饰符可将其声明为协变参数。和数组不同，这个修饰符保证了协变类型参数是完全类型安全的。

不管是类型参数还是数组，协变（和逆变）仅仅对于引用转换有效，而对装箱转换无效。因此，如果书写了一个接受IPoppable<object>类型参数的方法，你可以使用IPoppable<string> 调用它，但不能是IPoppable<int> 。

假设A可以隐式引用转换为B，如果X<A>允许引用类型转换为X<B>，则类型X具有协变类型参数。而逆变的转换方向正好相反，即从X<B>转换到X<A>。它仅在类型参数出现在输入位置上，并用in修饰符标记才行得通。

C#的泛型和C++的模板在应用上很相似，但是它们的工作原理却大不相同。两者都发生了生产者和消费者的关联，且生产者的占位符将被消费者填充。但是在C#泛型中，生产者的类型（开放类型如List<T> ）可以编译到程序库中（如mscorlib.dll）。这是因为生产者和消费者进行关联生成封闭类型是在运行时发生的。而C++模板中，这一关联是在编译时进行的。这意味着C++不能将模板库部署为．dll，它们只存在于源代码中。这令动态语法检查难以实现，更不用说即时创建或参数化类型了。

## 第4章 C#的高级特性

本章将在第2章、第3章概念的基础上探讨C#的高级特性。

### 4.1 委托

委托（delegate）是一种知道如何调用方法的对象。委托类型（delegate type）定义了一种委托实例（delegate instance）可以调用的方法。具体来说，它定义了方法的返回类型（return type）和参数类型（parameter type）。

委托实例字面上是调用者的代理：调用者调用委托，而委托调用目标方法。这种间接调用方式可以将调用者和目标方法解耦。

技术上，当引用没有括号和参数的Square方法时，我们指定的是一组方法。如果该方法被重载，C#会根据赋值委托的签名选择正确的重载方法。

委托和回调（callback）类似。一般指捕获类似C函数指针的结构。

委托变量可以在运行时指定一个目标方法，这个特性可用于编写插件方法。

所有的委托实例都拥有多播能力。这意味着一个委托实例可以引用一个目标方法，也可以引用一组目标方法。委托可以使用+和+=运算符联结多个委托实例。

委托是不可变的，因此调用+=和-=的实质是创建一个新的委托实例，并把它赋值给已有变量。

如果一个多播委托拥有非void的返回类型，则调用者将从最后一个触发的方法接收返回值。前面的方法仍然调用，但是返回值都会被丢弃。大部分调用多播委托的情况都会返回void类型，因此这个细小的差异就没有了。

所有的委托类型都是从System.MulticastDelegate类隐式派生的。而System.MulticastDelegate继承自System.Delegate。C#将委托中的+、-、+=、-=运算符都编译成了System.Delegate的静态Combine和Remove方法。

将一个实例方法赋值给委托对象时，后者不但要维护方法的引用，还需要维护方法所属的实例的引用。System.Delegate类的Target属性代表这个实例（如果委托引用的是一个静态方法，则该属性值为null）。

在.NET Framework 2.0之前，并不存在Func和Action委托（因为那个时候还不存在泛型）。由于这个历史问题，所以Framework里面的很多代码都是用自定义委托类型，而不是Func和Action。

能用委托解决的问题，都可以用接口解决。

如果以下一个或多个条件成立，委托可能是比接口更好的选择：

- 接口内仅定义了一个方法
- 需要多播能力
- 订阅者需要多次实现接口

如果委托实例指向相同的目标方法，则认为它们是等价的。

如果多播委托按照相同的顺序引用相同的方法，则认为它们是等价的。

当调用方法时，可以给方法的参数提供更加特定的变量类型，这是正常的多态行为。基于同样的原因，委托也可以有比它的目标方法参数类型更具体的参数类型，这称为逆变。

标准事件模式的设计宗旨是通过使用公共的EventArgs基类来利用逆变特性。例如，可以用两个不同的委托调用同一个方法，一个传递MouseEventArgs而另一个则传递KeyEventArgs。

调用一个方法时可能得到比请求类型更特定的返回值类型，这也是正常的多态行为。基于同样的原因，委托的目标方法可能返回比委托声明的返回值类型更加特定的返回值类型，这称为协变。

如果我们要定义一个泛型委托类型，那么最好参考如下的准则：

- 将只用于返回值类型的类型参数标记为协变（out）。
- 将只用于参数的任意类型参数标记为逆变（in）。

### 4.2 事件

事件是一种使用有限的委托功能实现广播者/订阅者模型的结构。使用事件的主要目的在于保证订阅者之间不互相影响。

声明事件最简单的方法是在委托成员的前面加上event关键字。

编译器对事件上的+=和-=运算符操作相应地调用事件的add或remove访问器。有意思的是当应用于事件时，+=和-=的行为是唯一的，而不像其他的情况下是+和-运算符与赋值运算符的简写。

事件访问器是对事件的+=和-=功能的实现。默认情况下，访问器由编译器隐式实现。

显式定义事件访问器，可以在委托的存储和访问上进行更复杂的操作。这主要有三种情形：

- 当前事件访问器仅仅是广播事件的类的中继器。
- 当类定义了大量的事件，而大部分事件有很少的订阅者，例如Windows控件。在这种情况下，最好在一个字典中存储订阅者的委托实例。这是因为字典比大量的空委托字段的引用的存储开销更少。
- 当显式实现声明事件的接口时。

和方法类似，事件可以是虚的（virtual）、可以重写（overridden）、可以是抽象的（abstract）或者密封的（sealed），当然也可以是静态的。

### 4.3 Lambda表达式

Lambda表达式是一种可以替代委托实例的匿名方法。编译器会立即将Lambda表达式转换为以下两种形式之一：

- 一个委托实例。
- 一个类型为Expression<TDelegate> 的表达式树。该表达式树将Lambda表达式内部的代码表现为一个可遍历的对象模型，因此Lambda表达式的解释可以延迟到运行时（请参见8.10节）。

编译器在内部将这种Lambda表达式编译为一个私有的方法，并将表达式代码转移到该方法中。

编译器通常可以根据上下文推断出Lambda表达式的类型，但是当无法推断的时候则必须显式指定每一个参数的类型。

Lambda表达式所引用的外部变量称为捕获变量（captured variable）。捕获变量的表达式称为闭包（closure）。

捕获的变量会在真正调用委托时赋值，而不是在捕获时赋值。

捕获变量的生命周期延伸到了和委托的生命周期一致。

当捕获for循环的迭代变量时，C#会认为该变量是在循环体外定义的。而这意味着同一次变量在每一次迭代都被捕获了。

与for不同，foreach循环中的迭代变量是不可变的，所以人们可以将它作为循环体的局部变量。

C# 7中的局部方法（请参见1.8.1.4节）和Lambda表达式的相应功能是重叠的，而局部方法拥有以下三个优势：

- 局部方法无须使用奇怪的技巧就可以实现递归（调用自己）。
- 局部方法避免了定义杂乱的委托类型。
- 局部方法的开销更小。

局部方法更加高效，因为它不需要间接使用委托（委托会消耗更多的CPU时钟周期并使用更多的内存），而且当它们访问局部变量的时候不需要编译器像委托那样将捕获的变量放到一个隐藏的类中去。但是，在许多情况下仍然需要使用委托。尤其是当需要调用高阶函数的时候，例如一个使用委托作为参数的方法。

### 4.4 匿名方法

匿名方法类似于Lambda表达式，但是没有以下的特性：

- 隐式类型的参数；
- 表达式语法（匿名方法必须是一个语句块）；
- 在赋值给Expression<T>时将其编译为表达式树的能力。

 完全省略参数的声明是匿名方法独有的特性，即使委托需要这些参数声明，该特性尤其适用于声明一个具有空事件处理器的事件。

### 4.5 try语句和异常

try语句是为了处理错误或者执行清理代码而定义的语句块。try语句块后面必须跟catch语句块或者finally语句块，或者两者都有。当try块执行并发生错误时，则执行catch语句块。当try块结束时（或者如果当前是catch块的话则当catch块结束时），不管有没有发生错误，都会执行finally块来执行清理代码。

catch块可以访问Exception对象，该对象包含错误信息。我们可以在catch块中处理错误或者再次抛出异常。例如，记录日志并重新抛出异常，或者抛出一个更高层次的异常。

finally块为程序的执行提供了确定性：CLR会尽最大努力保证其执行。它通常用于执行清理任务，例如关闭网络连接等。

我们更提倡提前进行检查以避免错误，而不是依赖try/catch块。这是因为异常处理代价比较昂贵，通常需要超过几百个时钟周期。

当抛出异常的时候，公共语言运行时（CLR）会执行如下测试：当前执行点是否在可以捕获该异常的try语句里执行？

> 如果是，则执行点转移到可以处理相应异常的catch块。如果catch块成功地运行结束，则执行转到try之后的语句（如果有finally块，则finally块优先执行）。
>
> 如果不是，则执行会跳转到调用函数，并重复上述测试（在跳转之前，如果当前语句所在的语句块含有关联的finally语句块，则会首先执行finally语句块中的语句）。如果没有任何函数处理该异常，则用户将看到一个提示框[插图]，且程序将终止执行。

一个catch子句只针对一种给定的异常。如果想通过捕获更普遍的异常（如System.Exception）来构建安全网，则必须把处理特定异常的逻辑放在前面。

从C# 6.0开始，可以在catch子句中添加when子句来指定异常筛选器（exceptionfilter）。

finally块会在以下情况执行：

- 在catch块执行完成后
- 使用跳转语句（例如return或goto），离开了try块
- try块执行结束

在finally块中调用Dispose方法是贯穿.NET Framework的标准约定，在C#中也有using语句来提供直接支持。

许多类的内部都封装了非托管资源。例如文件句柄、图像句柄、数据库连接等。这些类都实现了System.IDisposable接口，该接口定义了一个名称为Dispose的无参数方法，用于清除这些非托管资源。using语句提供了一种在finally块中调用IDisposable接口对象的Dispose方法的优雅方式。

在C# 7之前，throw永远是一个语句，而现在它也可以以表达式的形式出现在表达式函数中。

可以捕获异常后再重新抛出。

重新抛出异常可用于需要记录错误但是并不将异常隐藏的情形，也可以在异常超出处理范围的情况下放弃对异常进行处理。

在跨越信任边界时，常用做法是重新抛出一个不那么明确的异常，以防止技术信息泄露而给黑客可乘之机。

System.Exception类的最重要的属性有下面几个：

- StackTrace：表示一个异常从起源到catch块的所有调用方法的字符串。
- Message：描述异常的字符串。
- InnerException：导致外部异常的内部异常（如果有的话）。而内部异常本身也可以有另外一个InnerException。

所有的C#异常都是运行时异常，没有和Java对等的编译时检查异常。

### 4.6 可枚举类型和迭代器

枚举器（Enumerator）是一个只读的且只能在值序列上前移的游标。

可枚举的对象可以是：

- IEnumerable或IEnumerable<T>的实现
- 具有名为GetEnumerator的方法并且返回值是一个枚举器（enumerator）对象

如果迭代器实现了IDisposable，则foreach语句也会起到using语句的作用，隐式销毁枚举器对象。

和foreach语句是枚举器的消费者正好相反，迭代器是枚举器的生产者。

return语句表示“这是该方法的返回值”，而yield return语句则表示“这是当前枚举器产生的下一个元素”。在每条yield语句中，控制都返回给调用者，但是必须同时维护调用者的状态，以便调用者枚举下一个元素的时候，方法能够继续执行。该状态的生命周期是与枚举器绑定的。当调用者枚举结束之后，该状态就可以被释放。

迭代器是包含一个或者多个yield语句的方法、属性或者索引器。

迭代器语句块中使用return语句是非法的，应当使用yield break。

yield return语句不能出现在带catch子句的try语句块中。

yield return语句也不能出现在catch或者finally语句块中。出现这些限制的原因是编译器必须将迭代器转换为带有MoveNext、Current和Dispose成员的普通类，而转换异常处理语句块会大大增加代码的复杂性。

### 4.7 可空类型

若要在值类型中表示null，则必须是用特殊的结构即可空类型（NullableType）。可空类型是由数据类型后加一个“? ”表示的。

如果操作数的类型为bool?，那么&和|运算符会将null作为一个未知值（Unknownvalue）看待。则null | true应当返回true，因为：

- 如果未知值为假的，那么结果为真；

- 如果未知值是真的，那么结果为真。

类似的，null & false的结果为false。这个行为和SQL非常相似

可空类型常用来表示未知的值，尤其是在数据库编程中最为常见。数据编程通常需要将类映射到具有可空列的数据表中。如果这些列是字符串类型（例如Customer表的EmailAddress列），这样就没有任何问题，因为字符串是一种CLR的引用类型因而可以为null；而有些SQL列的类型是值类型，因而使用可空类型可以将这些列映射到CLR。

### 4.8 扩展方法

扩展方法允许在现有类型上扩展新的方法而无须修改原始类型的定义。扩展方法是静态类的静态方法，而其中的第一个参数需要用this修饰符修饰，且第一个参数的类型就是需要扩展的类型。

扩展方法和实例方法类似，可以用简单的方式进行链式调用。

任何兼容的实例方法的优先级总是高于扩展方法。

如果两个扩展方法签名相同，则扩展方法必须作为一个普通的静态方法调用才能进行区分。当然，如果其中一个扩展方法具有更具体的参数，那么更具体参数的方法优先级更高。

### 4.9 匿名类型

匿名类型是一个由编译器临时创建来存储一组值的简单类。如果需要创建一个匿名类型，则可以使用new关键字，后面加上对象初始化器，指定该类型包含的属性和值。

匿名类型只能通过var关键字来引用，因为它并没有一个名字。

在同一个程序集内声明的两个匿名类型实例，如果它们的元素名称和类型是相同的，那么它们在内部就是相同的类型。

匿名类型重写了Equals方法方法从而能够执行比较运算。

方法无法有效地返回匿名类型的对象，因为将函数返回类型指定为var是非法的。

因而我们只得用object或者dynamic作为返回值，而每一个调用Foo方法的点都需要动态绑定。这种方式会丧失静态类型的安全性（以及Visual Studio的IntelliSense）。

匿名类型主要用于编写LINQ查询（参见第8章），它是在C# 3.0中引入的。

### 4.10 元组（C# 7）

和匿名类型一样，元组（tuple）也是存储一组值的便捷方式。元组的主要目的是不使用out参数而从方法中返回多个值（这是匿名类型做不到的）。

元组是值类型，并且它是可变（可读可写）的元素

和匿名类型不同，我们可以将每一个元素的类型列在括号中，来显式指定元组的类型。

当创建元组字面量时，可以为元组的元素起一些有意义的名字。

如果元组（按顺序）对应的元素类型相同，则元组是类型兼容的。而其元素命名可以不同。

命名的元组元素并没有底层类型的命名属性的支撑。这些名字仅仅存在于源代码和编译器的“想象”中。在运行时，这些名字大多会消失。当我们反编译引用命名元素的元组时，可以看到程序仅仅引用了Item1、Item2这样的字段。若将元组变量赋值给一个object对象并在调试器下观察（或者在LINQPad下输出），就可以发现元素的名字完全消失了。因此，在绝大多数情况下，都不能用反射（reflection）（见第19章）的方式确定元组在运行时的命名。

元组隐式支持解构模式（请参见1.8.16节），因此可以将一个元组解构为独立的变量。

ValueTuple<>类型实现了IComparable接口（请参见6.12节），因此元组可以用来作为排序的键。

在System命名空间下还存在着另一类泛型类型：Tuple（而不是ValueTuple）。Tuple是在.NET Framework 4.0时引入的。Tuple是类，而Value Tuple类型是结构体。将元组定义为类在之后被认定为一种错误：在典型的元组使用场景中，结构体有一些性能优势（避免了不必要的内存分配）且几乎没有任何缺点。因此微软在C# 7中增加了对元组的语言支持，推荐使用新的ValueTuple而忽略之前的Tuple类型。

### 4.11 特性

特性（Attribute）是一种将自定义信息添加到代码元素（程序集、类型、成员、返回值、参数和泛型类型参数）的扩展机制。

特性是通过直接或者间接继承抽象类System.Attribute的方式定义的。

如果要将一个特性附加到一个代码元素中，那么就需要在该代码元素之前用方括号指定特性的类型名称。

编译器可以识别该特性，并在编译时对引用该特性标记的类型或成员的行为产生警告。按照惯例，所有特性类型都以Attribute结尾。C#能够识别这个后缀并允许在为成员附加特性时忽略该后缀。

特性可以包含参数。

特性参数分为两类：位置参数和命名参数

位置参数对应于特性类型的公有构造器的参数；命名参数则对应于该特性类型的公有字段或者公有属性。

在不显式指定的情况下，特性的目标就是它后面紧跟的代码元素，并且一般是类型或者类型的成员。然而，也可以将特性附加在程序集上。这就要求显式指定特性的目标了。下面的例子使用CLSCompliant特性来标记整个程序集的CLS兼容性：

一个代码元素可以指定多个特性。特性可以列在同一对方括号中（用逗号分隔），或者分隔在多对方括号中，当然也可以是两种形式的结合。

### 4.12 调用者信息特性

从C# 5开始，可以在可选参数上添加三种调用者信息中的一种，它们可以让编译器从调用者源代码获取参数的默认值

- [CallerMemberName]：表示调用者的成员名称
- [CallerFilePath]：表示调用者的源代码文件的路径
- [CallerLineNumber]：表示调用者源代码文件的行号

### 4.13 动态绑定

动态绑定（dynamic binding）将绑定（binding）（即解析类型、成员和操作的过程）从编译时延迟到运行时。

动态绑定适用于那些开发者知道某个特定的函数、成员或操作的存在，而编译器不知道的情况。这种情况通常出现在操作动态语言（例如IronPython）和COM时。在这些情况下，如果不使用动态绑定就只能使用反射机制了。

动态对象是基于其运行时类型而非它的编译时类型进行绑定的。当编译器遇到一个动态绑定表达式时（通常是一个包含任意dynamic类型值的表达式），它仅仅对表达式进行打包，而绑定则在后面运行时执行。

自定义绑定是通过动态对象实现IDynamicMetaObjectProvider（IDMOP）接口来实现的。

语言绑定是在一个动态对象未实现IDynamicMetaObjectProvider时发生的。语言绑定在处理设计不当的类型或绕过.NET本身类型系统的限制时是非常有用的。

若在一个提供了公开的dynamic成员的类型上使用反射，就可以观察到这些成员就是标记了特性的object。

var说：“让编译器去确定我的类型吧”，dynamic说：“让运行时去确定我的类型吧”。

有些函数无法动态调用，例如：

- 扩展方法（通过扩展方法语法）
- 必须将类型转换为接口才能调用的接口成员
- 基类中被子类隐藏的成员

动态绑定需要两部分信息：调用的函数名和调用该函数的对象。但是在上述三种不可调用的情况中还涉及一个只在编译时可见的附加类型（additional type）。在C# 6中，我们是无法动态指定这种附加类型的。

### 4.14 运算符重载

复合赋值运算符（例如：+=和-=）可以通过重写非复合运算符（例如+、-）隐式重写。

条件运算符&&和||可以通过重写按位操作运算符&和|隐式重写。

运算符函数具有以下规则：

- 函数名为operator关键字跟上运算符符号。
- 运算符函数必须是static和public的。
- 运算符函数的参数即操作数。
- 运算符函数的返回类型表示表达式的结果。
- 运算符函数的操作数中至少有一个类型和声明运算符函数的类型是一致的。

和方法与属性一样，C# 6可以将只含有一个表达式的运算符函数简洁地写成表达式体语法的形式

通常在我们使用结构体（或类，但不常见）时需要重载等号和比较运算符。重载等号和比较运算符有一些特殊的规则和要求，我们将在第6章详细介绍。在这里我们将其总结为：

- 成对重载：C#编译器要求逻辑上成对的运算符必须同时定义。这些运算符包括（==、! =）、（<、> ）和（<=、> =）。
- Equals和GetHashCode：在大多数情况下，如果重载了（==）和（! =）运算符，则通常也需要重载object中定义的Equals和GetHashCode方法。使之具有合理的行为。如果没有按照要求重载，则C#编译器会发出警告（我们将在6.11节详细介绍）.
- IComparable和IComparable<T>：如果重载了（<、> ）和（<=、> =）运算符，那么还应当实现IComparable和IComparable<T>接口。

### 4.15 不安全的代码和指针

C#中可以将代码块标记为不安全的并使用/unsafe编译器选项来使用指针直接进行内存操作。指针类型主要用来与C语言API进行互操作，但是也可以用来访问托管堆以外的内存，或者处理严重影响性能的热点。

由于没有穿越托管运行环境的开销，不安全的C#方法可能比调用外部C函数的执行速度更快。

fixed语句则告诉垃圾回收器“锁定”这个对象，而且不要移动它。这可能对运行时效率会产生一定影响，所以fixed代码块应当只供短暂使用，而且在代码块中应当避免堆上的内存分配。

除了&和*运算符，C#还支持C++形式的->运算符。该运算符可以在结构体上使用。

staclalloc关键字将在栈上显式分配一块内存。由于内存是在栈上分配的，因此其生命周期和其他局部变量（这里的局部变量指那些没有被Lambda表达式、迭代块，或异步方法捕获而使生命周延长的变量）一样，受限于方法执行期。可以在这块内存上使用[]运算符对其进行索引访问。

指针也很适合于访问托管堆之外的数据（例如与C DLL或COM交互时），或不在主存储器上的数据（例如显存或嵌入式设备上的存储介质）。

### 4.16 预处理指令

预处理指令向编译器提供关于一段代码的附加信息。最常用的预处理指令是条件指令，它提供了一种控制某一块代码编译与否的方法。

使用Conditional特性修饰的特性只有在给定的预处理符号出现时才编译。

### 4.17 XML文档

文档注释是一段记录类型或成员的嵌入式XML。文档注释位于类型或成员声明之前，以三个斜线开头。

## 第5章 框架概述

“mscorlib”是“多语言标准通用对象运行时库”，是Multi-language Standard Common Object Runtime Library的缩写”。

### 5.1 .NET标准2.0

.NET标准不是一套框架；它仅仅是一个描述（类型和成员的）最小功能集基线的规范，以保证特定框架间的兼容性。这个概念和C#的接口很相似：.NET标准类似一个接口，而框架则是实现接口的具体类型。

本书涵盖了.NET标准2.0的绝大部分内容。

### 5.2 CLR和核心框架

C#程序编译后产生的程序集包含可执行指令（存储为中间语言或者称为IL）和元数据（描述了程序的类型、成员和特性）。通过反射机制可以在运行时检查元数据或者执行某些操作，如动态调用方法。通过Reflection.Emit可以随时创建新代码。

### 5.3 应用技术

基于用户界面的应用程序可以划分为两类：瘦客户端，例如网站；富客户端，即用户必须下载并安装到电脑或移动设备上的程序。

对于瘦客户端，.NET提供了ASP.NET和ASP.NET Core。
对于面向Windows 7/8/10桌面的富客户端，.NET提供了WPF和Windows Forms API。而对于面向iOS、Android和Windows Phone的富客户端应用程序，则由Xamarin提供支持。此外，面向Windows 10桌面和设备的富客户端商店应用由UWP提供支持。

## 第6章 框架基础

我们在编程时所需的许多核心功能并不是由C#语言提供的，而是由.NET Framework中的类型提供的。在本章中，我们将介绍Framework在基础编程任务（例如虚的等值比较、顺序比较以及类型转换）中的作用。我们还会介绍Framework中的基本类型，例如String、DateTime和Enum。

本章中的绝大部分类型位于System命名空间下，但以下几种类型例外：

- StringBuilder类型定义在System.Text命名空间中。该命名空间中还包含用于进行文本编码的类型。
- CultureInfo及其相关类型定义在System.Globalization命名空间中。
- XmlConvert类型定义在System.Xml命名空间中。

### 6.1 字符串与文本处理

C#中的一个char代表一个Unicode字符。char是System.Char的别名。

我们可以使用静态方法string.IsNullOrEmpty来判断一个字符串是否为null或空字符串。

string是不可变的，因此所有“处理”字符串的方法都会返回一个新的字符串，而原始的字符串则不受影响（其效果和重新为一个字符串变量赋值一样）。


.NET Framework在两个值的比较上划分了两个不同的概念：相等比较（equality comparison）和顺序比较（order comparison）。等值比较验证两个实例是否从语义上是相同的，而顺序比较则验证两个实例（如果有的话）按照升序或者降序排列的话，哪一个应当首先出现。

可以使用==操作符或者string的Equals方法来进行字符串的等值比较。后者可以指定一些选项（例如不区分大小写），因此功能更强。

字符串比较有两种基本算法：序列比较（ordinal）和文化相关的比较（culture-sensitive）。序列比较会直接将字符串解析为数字（按照它们的Unicode字符数值）；而文化相关的比较则参照特定的字母表来解析字符。有两种特殊的文化：“当前文化”，基于计算机控制面板的设定；“不变文化”（invariant culture），在任何计算机上都是相同的（并且和美国文化密切一致）。

字符串的==运算符总是执行区分大小写的序列比较。不带有参数的string.Equals方法也是用同样的方式。这就是string类型的“默认”相等比较的行为。

String的实例方法CompareTo执行文化相关的区分大小写的顺序比较。与==运算符不同，CompareTo不使用序列比较。这是因为对于排序来说，文化相关的算法更为有效。

StringBuilder类（System.Text命名空间）表示一个可变（可编辑）的字符串。StringBuilder可以直接进行子字符串的Append、Insert、Remove和Replace而不需要替换整个StringBuilder。

将StringBuilder的Length属性设置为0并不会减小其内部容量。因此，如果之前StringBuilder已经包含了一百万个字符，则它在Length设置为0后仍然占用2MB的内存。因此，如果希望释放这些内存，则必须新建一个StringBuilder，然后将旧的对象清除出作用域（从而可以被垃圾回收）。

.NET的文本编码分为两类：

- 一类是将Unicode字符映射到其他字符集
- 一类是使用标准的Unicode编码模式

实例化一个正确配置的编码类的最简单方法是使用标准的IANA（互联网数字分配机构，Internet Assigned Numbers Authority）字符集名称调用Encoding.GetEncoding方法。

UTF-8是所有文件和流I/O的默认文本编码方式。

### 6.2 日期和时间

在System命名空间中有三个不可变的结构体用以进行日期和时间的表示：DateTime、DateTimeOffset和TimeSpan。C#没有定义与这些类型对应的关键字。

### 6.4 格式化和解析

格式化即将一个对象转换为字符串；而解析则是将字符串转换为对象。

最简单的格式字符串的机制是ToString方法，它能为所有简单的值类型（bool、DateTime、DateTimeOffset、TimeSpan、Guid和所有数字类型）产生有意义的字符串输出。同时这些类型都定义了静态的Parse方法来完成反向的转换。

如果解析失败，则会抛出FormatException。很多类型还定义了TryParse方法，在转换失败时返回false而不会抛出异常。

静态方法String.Format可以接受一个组合格式字符串。

### 6.5 标准格式字符串与解析标记

标准格式字符串决定了数字类型或DateTime/DateTimeOffset转换为字符串的方式。格式字符串有两种：

标准格式字符串（standard format string）：提供基本的格式控制。标准格式字符串是由一个字母及其后续的可选数字组成。例如"C"或"F2"。

自定义格式字符串（custom format string）：通常使用模板对每一个字符实现精细控制。例如："0:#.000E+00"。
自定义格式字符串与自定义格式提供器无关。

### 6.6 其他转换机制

在前面两节中，我们介绍了格式提供器这一.NET主要的格式化和解析机制。其他的重要转换机制则分散在各种类型和命名空间中。有些可以和string相互转换，有些则采用其他的转换方式。

Convert采用银行家舍入的方式，将中间值转换为偶整数（这样可以避免正负偏差）。

### 6.7 全球化

应用程序的国际化包括两个方面：全球化（globalization）和本地化（localization）。

### 6.8 操作数字

C#并没有为BigInteger提供原生支持，所以无法采用字面量表示BigInteger的值。然而，可以从任意整数类型隐式转换为BigInteger

Complex结构体是.NET Framework 4.0中新增的另一个特殊数值类型，它表示实部和虚部均为double类型的复数。

Random类能够生成类型为byte、integer或double的伪随机数序列。

### 6.9 枚举

枚举值有三种表示形式：

- enum成员
- 对应的整数   
- 字符串

GetBoxedIntegralType方法实际上并没有执行值转换。相反，它将同一个值重新装箱到了另一种类型中。它将一个以枚举类型表示的整数值转换为以整数类型表示的整数值。

### 6.10 Guid结构体

Guid结构体表示一个全局唯一标识符：一个在生成时就几乎可以肯定为全世界唯一的16字节值。Guid在应用程序和数据库中通常作为各种排序的健，而Guid可表示的值总共有2128或3.4×1018个。

### 6.11 相等比较

相等有两种：

- 值相等：两个值在某种意义上是相等的。
- 引用相等：两个引用指向完全相同的对象。

默认情况下：

- 值类型使用值相等。
- 引用类型使用引用相等。
  实际上值类型只能使用值相等（除非被装箱）。

类型的等值比较实现共有三种标准协议：

- ==和！=运算符
- object对象的Equals虚方法
- IEquatable<T>接口
  此外，我们还将在第7章讨论等值比较的扩展协议以及IStructuralEquatable接口。

对于引用类型，Equals默认进行引用相等比较。对于结构体，Equals会调用每一个字段的Equals进行结构化比较。

你可能会疑惑为什么C#的设计人员不将==设计成虚函数以避免这个问题呢。这样它在功能上就等同于Equals。这样设计有以下三个原因：

- 如果第一个操作数为null，则Equals将会抛出NullReferenceException而失败。但是静态方法则不会。
- ==运算符是静态解析的，因此它执行的速度非常快。这意味着可以轻松编写出计算密集型的代码而不需要额外的学习其他的语言，例如C++。
- 有时==和Equals分别应用不同的相等比较定义是非常有用的。

编译器无法绑定一个类型未知的静态方法。

有时候需要强制进行引用相等比较。静态方法object.ReferenceEquals就可以实现这种比较。

另一种强制进行引用相等比较的方法是将值转换为object，然后再使用==运算符。

double类型的==运算符强制规定一个NaN不等于任何对象，即使是另一个值也是NaN。这从数学角度来说是非常自然的，并且也反映了底层CPU的行为。然而，Equals方法必须支持自反相等。

对于值类型来说，分别对Equals和==应用不同的相等定义的做法是非常少见的。但这种做法在引用类型中要多得多，开发者自定义Equals实现值的相等比较，而仍旧令==执行（默认的）引用相等比较。

结构体的Equals方法默认采用的是结构化值相等（例如，它会比较结构体中的每个字段）。

有时创建一个类型时重写这个行为是很有用的，以下两种情况都适用于这种做法：

- 为了改变相等比较的含义
- 为了加快结构体相等比较的速度

重写引用类型的相等语义并不能提高性能。因为引用相等比较的默认算法只需要比较两个32或者64位整数，其运行速度已经非常快了。

下面是重写相等语义的步骤：

1. 重写GetHashCode()和Equals()方法。
2. （可选）重载！=和==。
3. （可选）实现IEquatable<T> 。


如果一个对象作为键添加到字典后其散列码发生了变化，那么这个对象在字典中将不可访问。因此可以基于不可变的字段进行散列码的计算以避免这个问题。

对于类，则有两种处理方法：

- 不重载==和！=，这样它们会应用引用相等规则。
- 重写Equals的同时重载==和！=运算符。


第一种方法通常用于自定义类型，特别是可变类型。它能够保证该类型符合一般预期，即对于引用类型，==与！=执行引用相等比较以避免产生歧义。

第二种方法适用于那些不需要引用相等比较的类型。它们一般是不可变类型，例如string和System.Uri类。它们有时是良好的结构体候选者。

### 6.12 顺序比较

除了标准的相等比较协议之外，C#和.NET还定义了确定对象之间相对顺序的标准协议。基本的协议包括：

- IComparable接口（IComparable和IComparable<T>接口）

-  \>和<运算符

CompareTo方法按照如下的方式执行：

- 如果a在b之后，则a.CompareTo(b)应当返回一个正数。
- 如果a和b位置相同，那么a.CompareTo(b)返回0。
- \如果a在b之前，则a.CompareTo(b)应当返回一个负数。

假设一种类型既重写了Equals，又实现了IComparable接口。那么当Equals返回true时，CompareTo返回0。这种行为是符合预期的。但也有例外的情况：

当Equals返回false时，CompareTo可以返回任何结果（只要其内部规则是一致的）。

换句话说，相等比较是严格的，反之则不然（违反这一点的话排序算法就会出错）。所以，CompareTo的结果可能是所有的对象都相同，而Equals却可以表达“有一些对象比其他对象相同程度更高”的意思。

CompareTo永远不比Equals更严格。

<和>运算符的实现在功能上应当与IComparable接口保持一致。这也是在整个.NET Framework中都适用的标准做法。

若重载了<和>运算符，那么也应当同时实现IComparable接口，这也是一种标准做法。但反之则不然。事实上，大部分实现了IComparable的.NET类型都没有重载<和>。这与相等处理方法不同，如果类型实现了Equals一般也会重载==运算符。

通常，在以下情况下才会重载<和>运算符：

- 类型具有固有的“大于”和“小于”的概念（对应于IComparable的更宽泛的“之前”和“之后”概念）。
- 这种比较只能用一种方式或在一个上下文下执行。
- 比较的结果在各种文化中保持不变。

System.String并不满足最后一点：字符串的比较结果可能会由于语言的不同而不同，因此string类型并不支持<和>运算符

## 第7章 集合

.NET Framework提供了一系列标准的存储和管理对象集合的类型。其中包括可变大小的列表、链表、排序或非排序字典以及数组。在这些类型中，只有数组是C#语言的一部分，而其余的集合只是一些类，我们可以和其他类一样将其实例化。

### 7.1 枚举

IEnumerable可以看作是“IEnumerator的提供者”，它是所有集合类型需要实现的最基础接口。

返回另一个集合的枚举器就是调用内部集合的GetEnumerator方法。然而，这种方法仅仅适合一些最简单的情况，那就是内部集合的元素正好就是所需要的那些元素。而更好的方法是使用C#的yield return语句编写迭代器。迭代器是C#语言的一个特性。它能够协助完成集合的编写，并且可以用foreach语句消费。迭代器会自动处理IEnumerable和IEnumerator及其泛型版本的实现。

最后一种编写GetEnumerator的方法是直接编写一个实现IEnumerator的类。这与编译器解析迭代器所做的工作是完全相同的（大多数情况下不需要这样做）。

### 7.2 ICollection和IList接口

虽然枚举接口提供了一种向前迭代集合的协议，但是它们并没有提供确定集合大小、根据索引访问成员、搜索以及修改集合的机制。为了实现这些功能，.NET Framework定义了ICollection、IList和IDictionary接口。这些接口都支持泛型和非泛型版本。然而，非泛型版本的存在只是为了兼容遗留代码。

ICollection<T>并没有实现ICollection；而IList<T>也没有实现IList；相应的IDictionary<TKey, TValue>也没有实现IDictionary。

若IList<T>实现IList，则当类型转换为IList<T>接口时，会得到一个同时含有Add(T)和Add(object)成员的接口。而这显著破坏了静态类型安全性，因为我们可以将任意类型作为Add方法的参数。

 .NET FrameWork并未统一“集合”（collection）和“列表”（list）这两个词汇的使用方式。例如IList<T>接口比ICollection<T>接口的功能更多，因此很容易认为List<T>类比Collection<T>类的功能更强。但事实并非如此。因此，一般认为“集合”和“列表”这两个术语大体上含义是相同的，只在涉及具体类型时例外。

### 7.3 Array类

果要进行深度复制即复制引用类型子对象，必须遍历整个数组，然后手动克隆每一个元素。

CLR不允许任何对象（包括数组）在大小上超过2GB（不论是32位还是64位运行环境都如此）。

Array提供了4个对数组进行浅表复制的方法：Clone、CopyTo、Copy和ConstrainedCopy。前两个是实例方法；后两个为静态方法。

### 7.4 List、Queue、Stack和Set

如果T是一种值类型，那么List<T>的速度会比ArrayList快好几倍，因为List<T>不需要对元素执行装箱和拆箱操作。


ArrayList从功能上和List<object>类型相似。当需要一个不共享任何相同基类（object除外）的混合类型元素列表时，这两种类型都是很有用的。在这种情况下，如果需要使用反射机制（见第19章）处理列表，那么选择使用ArrayList更有优势。这是因为相比于List<object> ，反射机制更容易处理非泛型的ArrayList。

LinkedList<T>是一个泛型的双向链表（见图7-4）。双向链表是一系列相互引用的节点，每一个节点都引用前一个节点、后一个节点以及实际存储数据的元素。它的主要优点是元素总能够高效插入到链表的任意位置，因为插入节点只需要创建一个新节点，然后修改引用值。然而查找插入节点的位置会比较慢，因为链表本身并没有直接索引的内在机制。我们必须遍历每一个节点，并且无法执行二分搜索。

Queue<T>和Queue是一种先进先出（FIFO）的数据结构，它们提供了Enqueue（将一个元素添加到队列末尾）和Dequeue（取出并删除队列的第一个元素）方法。它们还包括一个只返回而不删除队列第一个元素的Peek方法，以及一个Count属性（可在取出元素前检查该元素是否存在于队列中）。

Stack<T>和Stack是后进先出（LIFO）的数据结构，它们提供了Push（向栈的顶部添加一个元素）和Pop（从栈顶取出并删除一个元素）方法。并也提供了一个只读取而不删除元素的Peek方法、Count属性，以及可以导出数据并进行随机访问的ToArray方法

BitArray是一个压缩保存bool值的可动态调整大小的集合。

SortedSet<T>按一定顺序保存元素，而HashSet<T>则不是。

HashSet<T>是通过使用只存储键的散列表实现的；而SortedSet<T>则是通过一个红/黑树实现的。


### 7.5 字典

Framework通过IDictionary和IDictionary<TKey, TValue>接口以及一系列通用的字典类定义了标准字典协议。这些通用的字典类在以下几个方面互不相同：

- 元素是否按照有序序列存储
- 元素是否可以以位置（索引）或键进行访问
- 是否为泛型
- 从大字典中用键获得元素值时的快慢

Hashtable（没有非泛型的Dictionary类）是非泛型的Dictionary<TKey, TValue> 。因此当我们提到Dictionary的时候，我们指的是泛型的Dictionary<TKey, TValue>类。

OrderedDictionary是一种非泛型字典，它能够保存添加元素时的原始顺序。使用OrderedDictionary既可以根据索引访问元素，也可以根据键来访问元素。

OrderedDictionary并非一个排序字典。

ListDictionary使用一个独立链表来存储实际的数据。虽然它能够保存添加元素时的原始顺序，但是它不支持排序。ListDictionary在处理大型列表时非常缓慢。它存在的真正意义是高效处理非常小的列表（小于10个元素）。

HybridDictionary是一个在达到一定大小后能够自动转换为Hashtable的ListDictionary。其目的是为了解决ListDictionary的性能问题。它的原理在于在字典很小时降低内存开销，而在字典变大时保持良好性能。然而，考虑到中间存在转换的开销，而且Dictionary在这两种情况下都不会太严重或太慢，因此即使直接使用Dictionary也是非常合理的。

SortedDictionary<, >内部为红黑树：一种在插入和检索中表现都相当不错的数据结构。

SortedList<, >内部实现为排序的数组对。它的检索速度很快（通过二分搜索）但插入性能很差（因为必须移动现有值才能够留出空间存储新的元素）。

### 7.6 自定义集合与代理

Collection<T>类是一个可定制的List<T>包装类。

KeyedCollection<TKey, TItem>继承自Collection<TItem>，并对其功能有所增减。它增加了通过键访问元素的功能（和字典类似），移除了代理操作自己内部列表的能力。

ReadOnlyCollection<T>是一个包装器，或者称作代理。

### 7.7 扩展相等比较和排序操作

若类型的Equals和GetHashCode函数能够返回有意义的结果，则该类型就可以作为Dictionary或者Hashtable的键。

若类型实现了IComparable/IComparable<T>则该类型可以作为任何一种排序字典或列表中的键。

IEqualityComparer和IEqualityComparer<T>

- 执行扩展的相等比较和散列操作
- 可以和Hashtable和Dictionary类型配合使用 

IComparer和IComparer<T>
- 执行扩展的顺序比较操作
- 可与排序字典、排序集合以及Array.Sort配合使用

IStrcturalEquatable和IStructuralComparable。这两个接口可以对类和数组进行结构比较。

## 第8章 LINQ查询

LINQ是Language Integrated Query的缩写，它可以视为一组语言和框架特性的集合。LINQ可以对本地对象集合或远程数据源进行结构化的类型安全的查询操作。

LINQ支持查询任何实现了IEnumerable<T>接口的集合类型，无论是数组、列表还是XML DOM，乃至SQL Server数据库中的数据表这种远程数据源都可以查询。LINQ具有编译时类型检查和动态查询组合这两大优点。

### 8.1 入门

LINQ数据的基本组成部分是序列和元素。序列是任何实现了IEnumerable<T>接口的对象，而其中的每一项称为一个元素。

由于标准查询运算符都是以静态扩展方法的方式实现的，因此我们可以像使用对象的实例方法那样直接在names之上调用Where

流式语法和查询语法是相辅相成的。

### 8.2 流式语法

查询运算符绝不会修改输入序列，相反，它会返回一个新序列。这种设计是符合函数式编程规范的，而LINQ就是起源自函数式编程。

若一个Lambda表达式接受一个输入值并返回一个bool，则该表达式称为断言。

查询运算符中的Lambda表达式针对的永远是输入序列的每一个元素，而非输入序列整体。

实际上我们可以不用Lambda表达式，而是使用传统的方法委托作为参数调用Enumerable类中的查询运算符。这种直接调用的方式在查询本地集合（尤其是LINQ to XML时，我们将在第10章介绍）时非常简洁，但却无法用于基于IQueryable<T>的序列（例如当查询数据库时）。这是因为IQueryable的运算符需要从Lambda表达式构建表达式树。

### 8.3 查询表达式

C#为LINQ查询提供了一种简化的语法结构，称为查询表达式。表面上，这种语法像是在C#中内嵌SQL，而实际上，其设计却来源于像LISP和Haskell这样的函数式编程语言中的列表推导功能。

查询表达式一般以from子句开始，最后以select或者group子句结束。

编译器在处理查询表达式前会将其翻译为流式语法形式。这种转换是机械性的，就像是将foreach语句翻译为GetEnumerator和MoveNext一样。这意味着任何可以用查询语法完成的逻辑也可以用运算符流式语法编写。

如果查询使用的是流式语法，则Where、OrderBy和Select运算符在执行前会同样解析为Enumerable类的相应的扩展方法。

LINQ查询表达式看起来和SQL很像，但它们是完全不同的。LINQ查询本质上是C#表达式，必须遵循C#标准的规则。例如，LINQ中，变量必须在声明后才能使用，而在SQL中，SELECT子句可以在FROM子句定义之前直接引用表的别名。

LINQ中的子查询实际上是另一个C#表达式，因此不需要专门的语法。而在SQL中，使用子查询需要遵循特殊的语法规则。LINQ查询中，数据流从左向右随查询流动，而在SQL中，数据的流动并不一定是结构化的。LINQ查询就像传送带或流水线一样，运算符接受序列并输出序列，且这个过程和序列中的元素顺序是相关的。而SQL查询则是由子句网络构成的，且子句处理的集合是和顺序无关的。

有很多运算符在查询语法中并没有相应的关键字与其对应，此时就只能使用（至少是部分使用）流式语法了。

如果没有合适的查询语法来支持查询运算符，那么我们可以混合使用上面介绍的两种查询方式。

### 8.4 延迟执行

大部分查询运算符的一个重要性质是它们并非在构造时执行，而是在枚举（即在枚举器上调用MoveNext）时执行。

几乎所有的标准查询运算符都具有延迟执行的能力，而以下运算符除外：返回单个元素或标量值的运算符，例如：First或Count，转换运算符：ToArray、ToList、ToDictionary、ToLookup。

子查询中提供了额外的间接性。子查询中的任何语句都会延迟执行，包括聚合和转换方法。

如果你的Lambda表达式捕获了外部变量，那么该变量的值将在表达式执行时决定。

在4.3.2节我们介绍过，编译器会将for循环中的迭代变量看成循环作用域之外的变量。因此每一个闭包都捕获了相同的变量i，且在枚举查询结果时其值为5。为了解决这个问题，我们必须将循环变量赋值给语句块内声明的另一个变量。

查询运算符通过返回装饰器序列来提供延迟执行的功能。装饰器序列不同于一般的集合类型（如数组或链表），它（一般）并没有后台结构用于存储元素。而是包装一个在运行时才会生成的序列，并永久维护其依赖关系。当我们向装饰器序列中请求数据时，它就不得不向被包装的输入序列请求数据。

LINQ查询是一条懒惰的生产线，其中的传送带仅当需要时才开始运送元素。创建一个查询即创建了一条一切都准备就绪，但却并不开动生产线。当消费者请求其中的元素时（枚举查询结果时），最右侧的传送带就开始转动，而后依次触发了其他的传送带的转动，直至获得输入序列的元素。LINQ正是遵守着这种按需拉动，而不是供应方推动的模型。这点非常重要，在接下来的内容中我们会介绍如何扩展LINQ以支持SQL数据库的查询。

### 8.5 子查询

子查询是合法的。因为子查询就是另一个C#表达式，而我们可以将任何合法的C#表达式放在Lambda表达式的右侧。这意味着子查询的规则是由Lambda表达式的规则（以及查询运算符的行为）决定的。

子查询仅在父Lambda表达式求值时执行。这意味着子查询也是随外部查询按需查询的。可以说执行是从外向内执行的。本地查询从字面上遵守这种模型，而解释型查询（例如数据库查询）则从概念上遵守这个模型。

子查询中的元素相关运算符和聚合运算符，如First、Count，不会导致外部查询立即执行。延迟执行仍然会被外部查询引用。这是因为子查询是间接执行的：即在本地查询中，它通过委托驱动执行；而在解释型查询中，它通过表达式树来执行。

### 8.6 构造方式

本节将介绍构造复杂查询的三种方式：

- 渐进式查询构造
- 使用into关键字
- 包装查询语句

以上三者全部都是链接的方式。而不论方式如何，在运行时都会生成相同的查询。

### 8.7 映射方式

目前为止，select子句都直接映射为标量元素类型，为了映射更复杂的类型，可以使用C#的对象初始化器。

let关键字可以在查询中定义一个新的变量，这个新的变量能够和范围变量并存。

let有两个方面的功能：

- 它同时映射了新的元素和已有的元素。
- 它允许在一个查询中无须重写而复用其中的表达式。

### 8.8 解释型查询

LINQ提供了两种平行的架构：针对本地对象集合的本地查询，以及针对远程数据源的解释型查询。

本地查询主要针对实现了IEnumerable<T>的集合类型进行操作。本地查询会（默认）使用Enumerable类型中的查询运算符，进而生成链式的装饰器序列。其接受的委托，不论是使用查询语法、流式语法还是通常的委托，都会完全编译为中间语言代码（IL Code），这和其他的C#方法是一致的。与此不同，解释型查询是描述性的。它操作的序列实现了IQuerable<T>接口，并且其查询运算符是定义在Queryable类中的。它们会在运行时解释，并生成表达式树。

Enumerable中的查询运算符也可以接收IQueryable<T>序列。但是这种方式产生的查询永远只能在客户端本地执行，这也是为什么在Queryable类中创建另一套查询运算符的原因。

在.NET Framework中有两种IQueryable<T>的实现：

- LINQ to SQL

- Entity Framework（EF）

这些LINQ-to-db查询在技术上非常相似。在本书中，除非特别说明，LINQ查询语句在两种实现中都能使用。

### 8.9 LINQ to SQL和Entity Framework

我们将在本章和下一章中使用LINQ to SQL（L2S）和Entity Framework（EF）来展示解释型查询的用法。在本节中，我们将介绍这些技术的一些重要特性。

### 8.10 构建查询表达式

本地查询使用Enumerable运算符，接受委托。

解释型查询使用Queryable运算符，接受表达式树。

## 第9章 LINQ运算符

本章将介绍各个LINQ运算符。本章内容可以作为参考资料备查，此外，在9.1.1.2节和9.1.1.3节还介绍了以下概念：

- 映射对象的层次关系
- 使用Select、SelectMany、Join和GourpJoin进行连接查询
- 多个范围变量的查询表达式

### 9.10 聚合方法

Aggregate用于实现自定义的独特聚合算法。Aggregate无法在LINQ to SQL和Entity Framework中使用。并且它的功能是根据特定的使用场景确定的。

Aggregate的第一个参数称为种子，它指定了累积结果的初始值。第二个参数是一个表达式，它积累更新并返回全新元素。第三个参数是可选的，它会将累积值映射为最终的结果。

无种子聚合方法要求传入的委托满足交换性和结合性。否则就可能得出（和正常的查询相比）反直觉的，或非确定性的结果（例如，使用PLINQ将查询并行化）。

## 第10章 LINQ to XML

.NET Framework提供了一系列操作XML数据的API。从.NET Framework 3.5开始，LINQ to XML就成了处理通用XML文档的首选工具。它提供了一个轻量的、LINQ友好的XML文档对象模型以及配套的查询运算符。

LINQ to XML的设计非常完善并且效率很高。它的轻量的DOM设计完善地封装了底层的XmlReader和XmlWriter，这种设计在不使用LINQ时也非常有价值。

LINQ to XML的所有类型都定义在System.Xml.Linq命名空间中。

### 10.1 架构概述

XML文档的每一个部分（声明、元素、属性、值和文本内容）都可以用类来表示。如果使用集合属性来存储子内容，我们就可以用一棵对象树来完整地表示整个文档。这称为文档对象模型（document object model），或DOM。

## 第11章 其他XML技术

System.Xml命名空间由以下命名空间和核心类型构成：System.Xml.*XmlReader和XmlWriter：高性能、前向读写的XML流XmlDocument：基于W3C标准DOM（已过时）的XML文档System.Xml.Linq：全新的以LINQ为中心的XML DOM（请参见第10章）System.Xml.XmlSchema：为W3C的XSD大纲提供的基础类型和APISystem.Xml.Xsl：使用W3C的XSLT对XML进行转换的基础类型和API（XslCompiled Transform）System.Xml.Serialization：提供了类和XML之间的序列化功能（请参见第17章）其中，W3C是World Wide Web Consortium（万维网联盟）的缩写，该组织定义了XML标准。

## 第12章 对象销毁与垃圾回收

有些对象需要显式依靠销毁代码来释放资源。例如，打开的文件、锁、操作系统句柄和非托管对象。它们在.NET的术语中称为销毁（disposal），相应的功能则由IDisposable接口提供。此外，那些占用了托管内存但不再使用的对象必须在某个时间回收。这个功能称为垃圾回收，它由CLR执行。销毁不同于垃圾回收，它通常是显式调用。而垃圾回收则是完全自动执行的。换言之，程序员要关心诸如文件句柄、锁和操作系统资源的释放，而CLR则关心内存的释放。

### 12.1 IDisposable接口、Dispose方法和Close方法

C#的using语句从语法上提供了调用实现IDisposable接口对象的Dispose方法的捷径。它会将相应的语句包裹在try/finally语句块中。

Framework在其销毁逻辑中遵循一系列事实的规则。这些规则并未硬编码在.NET Framework或内置在C#语言中。它的目的是为消费者定义一个一致的协议。其中包括：1．对象一旦销毁就无法再恢复，也不能够重新激活。在销毁之后继续调用其方法（除Dispose之外）或访问其属性都将抛出ObjectDisposedException。2．可以重复调用对象的Dispose方法，且不会发生任何错误。3．若可销毁对象x“拥有”可销毁对象y，则x的Dispose方法会自动调用y的Dispose方法，接到其他指令的情况除外。尽管这些规则并不是强制的，但它对于编写自定义的类也是非常有帮助的。没有什么能够阻止你编写“不能销毁”的方法，但你可能会遭到同行的指责。

在几乎所有的情况下都需要遵守的安全规则是：“如果有疑问就销毁它”。如果一个可销毁的对象可以说话的话，那么它的台词是：当你不再使用我的时候，请告诉我。如果简单地抛弃我，我也许会对其他对象实例、应用程序域、计算机、网络甚至数据库造成麻烦。

一般来说，我们并不需要在Dispose方法中清理对象的字段。然而，在销毁时取消在对象生命周期内对相关事件的订阅却是一个好的实践（请参见12.5节）。取消这种订阅可以避免接收不需要的事件通知，同时能够避免垃圾回收器（GC）认为对象仍处于存活状态。

Dispose方法本身并没有释放（托管）内存，只有垃圾回收时才会释放内存。

### 12.2 自动垃圾回收

无论对象是否需通过Dispose方法来执行自定义清理逻辑，在某些时刻，堆上的内存都必须被释放。CLR通过自动化的垃圾回收器来处理这些工作，而我们则完全无法手动释放托管内存。

根可以使对象保持存活。如果对象没有直接或者间接地被根引用，那么它就可以被垃圾回收器回收了。根有以下几种：

- 当前正在执行的方法（或在其调用栈的任何一个方法中）的局部变量或者参数
- 静态变量
-  终结队列中的对象

Windows Runtime依赖COM的引用计数机制，而不是自动化的垃圾回收器，来释放内存。即便如此，从C#实例化的WinRT对象的生命周期也是靠CLR的垃圾回收器管理的。这是因为CLR会在背后创建一个名为运行时可调用包装器（请参见第24章）的对象，而它将通过这个中间对象访问COM对象。

### 12.3 终结器

终结器和构造器的声明方式很像。但它以～字符作为前缀。

终结器之所以可以执行是因为垃圾回收是分不同的阶段进行的。首先，垃圾回收器会确定未使用的可以删除的对象，而那些没有终结器的对象会被直接删除；有（挂起或未执行的）终结器的对象在当时会保持存活，并被放到一个特殊的队列中。此时，垃圾回收就已经完成了，应用程序将继续执行。此时，一个终结器线程开始与应用程序并行执行，取出特殊队列中的对象并执行其终结方法。在每一个对象的终结器执行之前，对象仍然是存活的，此时这个特殊队列扮演着根对象的角色。一旦对象离开了队列，并且终结器执行完毕，对象就变成了未引用的对象，并将在下一次（属于该对象那一代的）垃圾回收时删除。

终结器非常有用，但是它也有一些附加的代价：

- 终结器会降低内存分配和回收的速度（GC需要对终结器的执行进行追踪）。
- 终结器延长了对象和该对象所引用的对象的生命周期（它们必须等到下一次垃圾回收时才会被真正删除）。
- 无法预测多个对象的终结器调用的顺序。
- 开发者对于终结器调用的时机只有非常有限的控制能力。
- 如果一个终结器的代码阻塞，则其他对象也无法终结。
- 如果应用程序没有被完全卸载，则对象的终结器也可能无法得以执行。

要实现终结器需要遵守以下的准则：

- 保证终结器可以很快执行完毕。
- 永远不要阻塞终结器的执行（见第14章）。
- 不要引用其他可终结对象。
- 不要在终结器中抛出异常。

对象的终结器甚至可以在对象构造器抛出异常时调用。因此需要注意，在编写终结器时，对象的字段有可能并没有初始化完毕。

在终结器中调用Dispose方法是一个常见的模式。这适用于对象的清理并没有那么紧急的情况，而调用对象的Dispose方法更像是一个优化而不是必要的行为了。

需要注意，在这种模式下，内存的回收和资源的回收两件事情耦合在了一起，而实际上它们的关注点是不同的（除非资源本身就是内存）。此外，这种模式会增加终结线程的负担。这个模式通常在消费者忘记调用Dispose方法时作为补救措施。但是，也可以相应地记录日志以便将来修复这个问题。

如果终结器将即将销毁的对象引用到了一个存活的对象上，那么当下一次（属于那个对象代的）垃圾回收发生时，CLR会发现先前需要销毁的对象不再需要销毁了，因此该对象就不会被回收。这是一个高级处理方式，称为“复活”（resurrection）。

### 12.4 垃圾回收器的工作方式

标准CLR使用分代式标记-压缩GC对托管堆上的对象进行自动内存管理。这种垃圾回收器是追踪型垃圾回收器，它不会干涉每一次的对象访问，而是会直接激活并追踪存储在托管堆上的对象引用图，来决定哪些对象应当作为垃圾进行回收。

当内存分配量超过了特定的阈值，或者需要降低应用程序内存使用量时，垃圾回收器就会在进行内存分配时（通过new关键字）触发一次垃圾回收。这个过程还可以通过调用System.GC.Collect方法来手动触发。在垃圾回收过程中，所有的线程都可能冻结。

垃圾回收器使用了多种优化技术来减少垃圾回收的时间。

最重要的优化措施是分代垃圾回收。这是因为尽管许多对象的分配和释放非常频繁，但是某些对象会长时间存活，并不需要在每次回收时都追踪它。垃圾回收器将堆上的内存分为了三代。刚刚分配的对象位于第0代；在第一轮回收中存活的对象在第1代，而其他所有对象为第2代。第0代和第1代对象就是所谓的短生存期（ephemeral）的代。

垃圾回收器会将大于某一个阈值的对象（目前是85000字节）存放在一个独立的堆中，称为大对象堆（Large Object Heap, LOH）。它可以避免过量的第0代回收。如果没有LOH的话，分配一系列的16 MB对象时几乎每次分配就会触发一次第0代的回收。

大对象堆并不是分代的，其上所有的对象都会按第2代来处理。

垃圾回收器在回收时需要在一段时间内冻结（阻塞）执行线程，这包括了第0代和第1代回收的整个时间。在回收第2代内存时，垃圾回收器会进行一些特殊的尝试，以允许线程运行，因为我们并不希望长时间冻结应用程序的执行。这个优化仅限于工作站版本的CLR，主要用于Windows的桌面版本（也可用于在任意Windows版本上运行的独立应用程序）。这是因为对于服务器这种没有用户界面的应用程序来说，阻塞式的回收并不会造成太大问题。

服务器版本的CLR可以在进行完全垃圾回收之前发送通知。这原本是服务器农场（Server Farm）的配置：本意是在进行完全回收之前将请求转发到其他的服务器上，然后立即开始回收，在回收完毕之后再重新开始将请求路由到这台服务器上。

我们可以在任何时刻调用GC.Collect方法来强制进行垃圾回收。调用GC.Collect的无参数方法将会发起一次完整回收。如果传入一个整数值，则只有整数值的那一代会被回收。因此GC.Collect(0)只执行一次快速的第0代垃圾回收。

### 12.5 托管内存泄露

在C++这种非托管语言中，开发者必须牢记在对象不再使用时手动释放内存，否则就会导致内存泄露。在托管语言中，由于CLR的自动垃圾回收系统，这种类型的错误不再可能发生。尽管如此，大型复杂的.NET应用程序也会遇到类似的问题，虽然形式相对温和但是也会造成相同的结果：应用程序会在其生命周期内消耗越来越多的内存，直至最终不得不重启。但托管内存泄露通常更容易诊断和预防，这也是不幸中的万幸了。

托管内存泄露是由那些虽然不再使用，但其引用已经被遗忘而一直存活的对象造成的。

如果当前的大型应用程序已经出现了托管内存泄露，则可以使用windbg.exe工具来找到它。除此之外还有一些拥有友好的图形界面的工具，例如Microsoft的CLR Profiler、SciTech的Memory Profiler以及Red Gate的ANTS Memory Profiler等。

### 12.6 弱引用

有时，相比令对象存活，保持对象的一个GC“不可见”引用更加有效。这种引用称为弱引用，它是由System.WeakReference类实现的。

## 第13章 诊断

当错误发生时，能够得到辅助诊断问题的信息是非常重要的。IDE和调试器对问题的诊断能够起到极大的帮助作用，但这种手段通常只能够在开发时使用。一旦应用程序发布，应用程序自身就必须收集和记录诊断信息。为了满足这种需求，.NET Framework提供了一套记录诊断信息、监视应用程序行为、检测运行时错误并与调试工具（如果有的话）集成的工具。

本章涉及的类主要定义在System.Diagnostics命名空间中。

### 13.1 条件编译

使用C#中的预处理指令可以有条件地编译任意一部分代码。预处理指令是一类特殊的编译器指令，它们都以#符号开头（和其他的C#结构不同，它必须出现在一个独立行中）。从逻辑上说，它们会在主要的编译工作开始前执行（虽然在实践中，编译器是在词法解析时处理这些指令的）。预处理指令中和条件编译相关的指令有：#if、#else、#endif和#elif。

Conditional特性指示编译器在符号没有定义的情况下忽略对特定类或方法的任何调用。

### 13.2 Debug和Trace类

Debug和Trace是提供了基础断言和日志记录功能的静态类。这两个类很相似，主要不同点是其特定的用途。Debug类用于调试版本，而Trace类则用于调试和发布版本。即：

- 所有Debug类中的方法都标记为[Conditional("DEBUG")]。
- 所有Trace类中的方法都标记为[Conditional("TRACE")]。

这意味着如果不定义DEBUG和TRACE符号的话，所有对Debug和Trace类方法的调用都会被编译器忽略。默认情况下，Visual Studio在项目的debug配置中定义了DEBUG和TRACE符号；而在release配置中仅仅定义了TRACE符号。

Debug和Trace类都有Listeners属性，该属性是TraceListener实例的静态集合。它们负责处理由Write、Fail和Trace方法触发的信息。

### 13.3 调试器的集成

在一些情况下，应用程序需要和调试器（如果有的话）进行交互。在开发阶段，调试器通常就是你的集成开发环境（IDE，例如Visual Studio），而在部署阶段，调试器通常是：

- DbgCLR
- 低级调试工具，例如WinDbg、Coredbg或者MdbgDbgCLR是Visual Studio中的调试器，它可以随.NET Framework SDK一起免费下载。虽然需要下载整个.NET Framework SDK，但在没有IDE的情况下它是最简单的调试选择。

### 13.4 进程与线程处理

在第6章的最后一节，我们介绍了如何用Process.Start方法启动新的进程。Process类也可用于查询本机或其他计算机的进程或与其他进程交互。Process类是.NET标准2.0的一部分（但它的功能在UWP平台上是受限的）。

Process.GetProcessXXX方法通过名称或者进程ID检索指定的进程，或者检索本机或指定名称的计算机中的所有进程。

Process.Threads属性可用于枚举其他进程内的所有线程。

### 13.5 StackTrace和StackFrame类

StackTrace和StackFrame类提供了执行调用栈的只读视图，同时它们也是标准桌面版.NET Framework的一部分。我们可以获得当前线程、同一进程中的不同线程以及异常对象的堆栈追踪信息。虽然这些信息可以用于特定的编程用途，但主要还是用于诊断目的。StackTrace代表了一个完整的调用栈，而StackFrame代表了调用栈中的一个单独的方法调用。

### 13.6 Windows事件日志

Win32平台以Windows事件日志的形式提供了一种集中式的日志记录机制。

### 13.7 性能计数器

之前讨论的日志机制适用于获得信息并进行事后分析。然而，要想获得应用程序（或者整个系统）的当前状态，则需要更加实时的方法。在Win32下，这种需求的解决方案就是性能监视基础结构。

### 13.8 Stopwatch类

Stopwatch类提供了一种方便的机制来测量运行时间。Stopwatch使用了操作系统和硬件提供的最高分辨率机制，通常少于1毫秒（相比之下DateTime.Now和Environment.TickCount的分辨率在15毫秒左右）。

## 第14章 并发与异步

本章开始部分将介绍一些相关的基础知识，即线程和任务的概念。然后再详细介绍异步原理和C#的异步函数。我们将在第22章中更加深入地介绍多线程，并在第23章中介绍并行编程的相关知识。

### 14.1 概述

最常见的并发场景包括：编写快速响应的用户界面在WPF、移动应用和Windows Forms应用程序中，都需要并发执行耗时任务以保证用户界面的响应性。可以处理同时出现的请求在服务器上，客户端的请求可能会并发到达，必须通过并行处理才能够保证程序的可伸缩性。如果使用ASP.NET、WCF或者Web Services，则.NET Framework会自动执行并行处理。然而，程序员仍然需要关注某些共享的状态（例如使用静态变量作为缓存）。并行编程如果可以将负载划分到多个核心上，那么多核、多处理器计算机就可以提升密集计算代码的执行速度（第23章将专门介绍这方面的内容）。预测执行在多核主机上，有时可通过预测的方式提前执行某些任务来改善程序性能。例如，LINQPad使用这种方式来提高查询的创建速度。而如果事先无法知道哪种方法是最优的，则可以并行执行多个解决同一任务的不同算法，最先完成的算法就是最优的。

### 14.2 线程

线程是一个可以独立执行的执行路径。每一个线程都运行在一个操作系统进程中。这个进程提供了程序执行的独立环境。在单线程（single threaded）程序中，进程中只有一个线程运行，因此线程可以独立使用进程环境。而在多线程程序中，一个进程中会运行多个线程。它们共享同一个执行环境（特别是内存）。这在一定程度上说明了多线程的作用。例如，可以使用一个线程在后台获得数据，同时使用另一个线程显示所获得的数据。而这些数据就是所谓的共享状态（shared state）。

要创建并启动一个线程，需要首先实例化Thread对象并调用Start方法。Thread的最简单的构造器接收一个ThreadStart委托：一个无参数的方法，表示执行的起始位置。

在单核计算机上，操作系统会为每一个线程划分时间片（Windows系统的典型值为20毫秒）来模拟并发执行。

 线程是抢占式的。它的执行和其他线程的代码是交错执行的。这个术语通常可以解释一些由此而产生的问题。

调用Thread的Join方法可以等待线程结束。

Thread.Sleep(0)将会导致线程立即放弃自己的时间片，自觉地将CPU交于其他的线程。Thread.Yield()执行相同的操作，但是它仅仅会将资源交给同一个处理器上运行的线程。

Sleep(0)或者Yield在高级性能调优方面非常有用。同时它还是一种很好的诊断工具，可用于帮助开发者发现与线程安全相关的问题；如果在代码的任意位置插入Thread.Yield()导致程序失败，则代码一定存在缺陷。

在等待线程Sleep或者Join的过程中，线程是阻塞（blocked）的。

可以使用ThreadState属性测试线程的阻塞状态。

当线程被阻塞或者解除阻塞时，操作系统就会进行一次上下文切换（context switch）。这会导致细小的开销，一般在1到2毫秒左右。

如果一个操作的绝大部分时间都在等待事件的发生，则称为I/O密集，例如下载网页或者调用Console.ReadLine。（I/O密集操作一般都会涉及输入或者输出，但是这并非硬性要求。例如Thread.Sleep也是一种I/O密集的操作）。而相反的，如果操作的大部分时间都用于执行大量的CPU操作，则称为计算密集。

I/O密集操作主要表现为以下两种形式：要么在当前线程同步进行等待，直至操作完成（例如Console.ReadLine、Thread.Sleep以及Thread.Join）；要么异步进行操作，在操作完成的时候或者之后某个时刻触发回调函数。

自旋与阻塞有一些细微的差别。首先，非常短暂的自旋在条件可以很快得到满足的场景（例如几毫秒）下是非常高效的，因为它避免了上下文切换带来的延迟和开销。.NET Framework提供了一些特殊的辅助方法和类来进行这一操作，请参见http://albahari.com/threading/的SpinLock and SpinWait。

CLR为每一个线程分配了独立的内存栈，从而保证了局部变量的隔离。

如果不同的线程拥有同一个对象的引用，则这些线程之间就共享了数据。

当两个线程同时竞争一个锁时（它可以是任意引用类型的对象，这里是_locker），一个线程会进行等待（阻塞），直到锁被释放。

线程执行和线程创建时所处的try/catch/finally语句块无关。

一般情况下，显式创建的线程称为前台线程（Foreground thread）。只要有一个前台线程还在运行，应用程序就仍然保持运行状态。而后台线程（background thread）则不然。当所有前台线程结束时，应用程序就会停止，且所有运行的后台线程也会随之终止。

线程的前台/后台状态和线程的优先级（执行时间的分配）无关。

如果应用程序调用时不带有任何参数，则工作线程会处于前台状态，并在ReadLine语句处等待用户的输入。主线程结束时，由于前台线程仍然在运行，因此应用程序会继续保持运行状态。如果应用程序启动时带有参数，则工作线程就会设置为后台状态，而应用程序也将在主线程结束时退出，从而终止ReadLine的执行。如果进程以上述方式终止，则后台线程执行栈上的任何finally语句块都无法执行。如果应用程序在finally或者using块中执行了清理逻辑，例如删除临时文件，那么可以在应用程序结束时显式等待后台线程汇合（jon），或触发信号发送结构（参见14.2.10节）来避免上述问题。无论采用哪一种方法，都需要指定一个超时时间，来抛弃那些无法按时结束的问题线程。否则用户只能够通过“任务管理器”来终止应用程序了。前台线程则不需要这样的处理，但是必须注意尽量避免出现线程无法结束的缺陷。活跃的前台线程是导致应用程序无法正常退出的常见原因之一。

线程的Priority属性可以决定相对于其他线程，当前线程在操作系统中执行时间的长短。

有时一个线程需要等待来自其他线程的通知，即所谓的信号发送（signaling）。最简单的信号发送结构是ManualResetEvent。调用ManualResetEvent的WaitOne方法可以阻塞当前线程，直到其他线程调用了Set“打开”了信号。

每当启动一个线程时，都需要一定的时间（几百毫秒）来创建新的局部变量栈。而线程池通过预先创建一个可回收线程的池子来降低这个开销。线程池对开发高性能的并行程序和细粒度的并发都是非常必要的。它可以支持运行一些短暂的操作而不会受到线程启动开销的影响。

在使用线程池中的线程时还需要考虑以下问题：

- 线程池中线程的Name属性是无法进行设置的，因此会增加代码调试的难度（但可以在调试时使用Visual Studio的Threads窗口附加一个描述信息）。
- 线程池中的线程都是后台线程。
- 阻塞线程池中的线程将影响性能（请参见14.2.13.2）。

线程池还有另外一个功能，那就是保证临时性的计算密集作业不会导致CPU超负荷（oversubscription）。所谓超负荷指激活的线程数目多于CPU核心数量，导致操作系统必须按时间片执行线程调度。超负荷会影响性能，因为划分时间片需要大量的上下文切换开销，并可能使CPU的缓存失效。而这些都是现代处理器实现高性能的必要条件。

### 14.3 任务

线程是创建并发的底层工具，因此它有一定的局限性。特别是：

- 虽然在线程启动时不难向其中传递数据，但是当线程Join后却难以从中得到“返回值”。通常不得不创建一些共享字段（来得到“返回值”）。此外，捕获和处理线程中操作抛出的异常也是非常麻烦的。
- 在线程完成之后，就无法再次启动它，相反只能够将其Join（并阻塞当前操作线程）。这些局限性会影响细粒度并发性的实现。换言之，这种方式难以将小的并发组合成为大的并发操作（这对于异步编程而言非常重要，后面的章节将对此进行介绍），并会增加手动同步处理（例如使用锁、信号发送等）的依赖，而且很容易造成问题。直接使用线程也会对性能产生影响，具体可参见14.2.13节。而且如果需要运行大量并发的I/O密集型操作，那么基于线程的方法仅仅在线程本身的开销这方面就会消耗成百上千兆的内存。

Task类型可以解决所有这些问题。与线程相比，Task是一个更高级的抽象概念，它代表了一个并发操作，而该操作并不一定依赖线程来完成。Task是可以组合（compositional）的（你可以将它们通过延续（continuation）操作串联在一起）。它们可以使用线程池减少启动延迟，也可以通过TaskCompletionSource采用回调的方式避免多个线程同时等待I/O密集型操作。

启动一个基于线程Task的最简单方式是使用Task.Run。

Task默认使用线程池中的线程，它们都是后台线程。这意味着当主线程结束时，所有的任务也会随之停止。因此，要在控制台应用程序中运行这些例子，必须在启动任务之后阻塞主线程（例如在任务对象上调用Wait，或者调用Console.ReadLine()方法）。

Task.Run会返回一个Task对象，它可以用于监控任务的执行过程。这一点与Thread对象不同（注意，我们没有在Task.Run之后调用Start，这是因为Task.Run创建的任务是“热”的任务；相反，如果要创建“冷”的任务，则必须调用Task的构造器，但是这种方式在实践中很少见到。

可以使用Task的Status属性来追踪其执行状态。

调用Task的Wait方法可以阻塞当前方法，直到任务完成，这和调用线程对象的Join方法类似。

Task有一个泛型子类Task<TResult>，它允许任务返回一个值。如果在调用Task.Run时传入一个Func<TResult>委托（或者兼容的Lambda表达式）替代Action就可以获得一个Task<TResult>对象。

此后，通过查询Result属性就可以获得任务的返回值。如果当前任务还没有执行完毕，则调用该属性会阻塞当前线程，直至任务结束。

可以将Task<TResult> 理解为一个“未来值”，它封装了Result并将在之后生效。

任务可以方便地传播异常，这和线程是截然不同的。因此，如果任务中的代码抛出一个未处理异常（换言之，如果你的任务出错（fault）），那么调用Wait()或者访问Task<TResult>的Result属性时，该异常就会被重新抛出。

使用Task的IsFaulted和IsCanceled属性可以在不抛出异常的情况下检测出错的任务。如果这两个属性都返回了false则说明没有错误发生。如果IsCanceled为true，则说明任务抛出了OperationCanceledException（请参见14.6.1节）；如果IsFaulted为true，则说明任务抛出了其他类型的异常，通过Exception属性可以了解该异常的信息。

自治任务指那些可以“运行并忘记”的任务（这些任务不需要调用Wait()或访问其Result属性，也不需要进行任务的延续）。对于自治任务，最好在任务代码中显式声明异常处理代码，防止出现和线程类似的难以察觉的错误。自治任务中的未处理异常称为未观测异常（unobserved exception）。在CLR 4.0中，它们实际上会导致程序终止（当任务跳出运行范围并被垃圾回收时，CLR会在终结线程上重新抛出该异常）。这种方式有利于发现难以察觉到的问题，然而由于错误实际发生的时间和垃圾回收的时间间隔可能非常大，因而这种行为使得某些异步模式更加复杂（参见14.5.2.3节和14.6.4.1节）, CLR 4.5最终删除了这个特性。

使用静态事件TaskScheduler.UnobservedTaskException可以在全局范围订阅未观测的异常。处理这个事件，并将错误记录在日志中，是一个有效的处理异常的方式。

未观测异常之间也存在一些细微的差异：

- 如果在等待任务时设置了超时时间，则在超时时间之后发生的错误将产生未观测异常。
- 在错误发生之后，如果检查任务的Exception属性，则该异常就成为了已观测到的异常。

延续会告知任务在完成之后继续执行后续的操作。延续通常由一个回调方法实现，该方法会在操作完成之后执行。

第一种方法是使用.NET Framework 4.5中引入的，它非常重要，因为C#的异步功能正是使用了这种方法。

调用任务的GetAwaiter方法将返回一个awaiter对象。这个对象的OnCompleted方法告知先导（antecedent）任务（primeNumberTask）当它执行完毕（或者出现错误）时调用一个委托。将延续附加到一个业已执行完毕的任务上是完全没有问题的，此时，延续的逻辑将会立即执行。

如果先导任务出现错误，则当延续代码调用awaiter.GetResult()的时候将会重新抛出异常。当然我们也可以访问先导任务的Result属性而不是调用GetResult方法。但如果先导任务失败，则调用GetResult方法就可以直接得到原始的异常，而不是包装后的AggregateException。因此，这种方式可以实现更加简洁清晰的catch代码块。对于非泛型任务，GetResult的返回值为void，而这个函数的用途完全是为了重新抛出异常。

另一种附加延续的方式是调用任务对象的ContinueWith方法：

ContinueWith方法本身会返回一个Task对象，因此它非常适用于添加更多的延续。然而，如果任务出现错误，则我们必须直接处理AggregateException；如果需要将延续封送到UI应用程序上还需要书写额外的代码。

前面介绍了如何使用Task.Run创建一个任务，并在线程池线程（或者非线程池线程）上运行特定委托。而另一种创建任务的方法是使用TaskCompletionSource。

TaskCompletionSource可以创建一个任务，但是这种任务并非那种需要执行启动操作并在随后停止的任务；而是在操作结束或出错时手动创建的“附属”任务。这非常适用于I/O密集型的工作。它不但可以利用任务所有的优点（能够传递返回值、异常或延续）而且不需要在操作执行期间阻塞线程。

TaskCompletionSource的真正作用是创建一个不绑定线程的任务。

Task.Delay是Thread.Sleep的异步版本。

### 14.4 异步原则

同步操作（synchronous operation）先完成其工作再返回调用者。异步操作（asynchronous operation）的大部分工作则是在返回给调用者之后才完成的。

异步编程的原则是以异步的方式编写运行时间很长（或者可能很长）的函数。这和编写长时间运行的函数的传统同步方法正好相反。它会在一个新的线程或者任务上调用这些函数，从而实现需要的并发性。异步方法的不同点在于并发性是在长时间运行的方法内启动的，而不是从这个方法外启动的。这样做有两个优点：

- I/O密集的并发性的实现不需要绑定线程（具体参见14.3.5节），因此可以提高可伸缩性和效率。
- 富客户端应用程序可以减少工作线程的代码，因此可以简化线程安全性的实现。这也产生了两种独立的异步编程方法。第一种是编写高效处理并发I/O的（一般是服务器端的）应用程序。它的关键并非线程安全性（因为这种情形很少使用共享状态），而在于线程的效率。特别是，每一个网络请求不要独自消耗一个线程。因此，在这种上下文下，只有I/O密集型的操作可以从异步中受益。第二种则是简化富客户端应用程序的线程安全性。这和程序大小的增长速度密切相关。为了处理程序的复杂性，一般来说会将大的方法重构为若干个小的方法，从而产生一连串互相调用的方法（调用图（calling graph））。

I/O和计算密集型操作都应当采用异步方式实现。常用的经验法则是任何超过50毫秒的响应都用异步的方式处理。

### 14.5 C#的异步函数

async和await关键字是在C# 5.0中引入的。这些关键字可以用同步的代码风格编写异步代码，极大地去除了异步编程的复杂性。

async修饰符会指示编译器将await作为一个关键字而非标识符来避免二义性（C#5之前的代码有可能将await作为标识符，这样做可以确保之前的代码还能够正确进行编译）。async修饰符只支持返回类型为void以及（我们稍后会介绍的）Task或Task<TResult>的方法（或Lambda表达式）。

async修饰符和unsafe修饰符类似，都不会对方法签名或者公共元数据产生影响。它只影响方法内部的执行细节，因此在接口上添加async是没有意义的。但是这种方式也是合法的。例如，可以在一个重写的非异步的虚方法上添加async（但前提是方法签名必须保持不变）。

当遇到await表达式时，通常情况下执行过程会返回到调用者上。就像是迭代器中的yield return一样。但是，运行时在返回之前会在等待的任务上附加一个延续，保证任务结束时，执行点会跳回到方法中，并继续执行剩余的代码。如果任务出错，则会重新抛出异常；如果顺利结束，则用返回值为await表达式赋值。

await等待的表达式通常情况下是一个任务。但实际上，只要该对象拥有GetAwaiter方法，且该方法的返回值为可等待对象（awaitable object）（这个对象需实现INotify-Completion.OnCompleted方法，具有返回恰当类型的GetResult方法和一个bool类型的IsCompleted属性），则编译器都可以接受。

await表达式的最大优势在于它几乎可以出现在代码的任意位置。具体的，await表达式可以在任何（异步函数的）表达式中出现，但不能出现在lock表达式、unsafe上下文，或者执行入口（Main方法）中。

异步函数的简洁性：只需按同步方式书写，并当调用异步函数时进行等待（await）就可以避免阻塞了。

在WinRT中，Task的等价类型为IAsyncAction，而Task<TResult>的等价类型为IAsyncAction<TResult>（两者均位于Windows.Foundation命名空间下）。

### 14.6 异步模式

通常，并发操作在启动之后必须能够取消（可能是出于用户的请求）。使用取消标志即可以轻松实现这个功能。

一些异步操作需要在运行时报告其执行进度。一种简单方案是向异步方法中传入一个Action委托，在进度发生变化时就触发方法。

Framework 4.5及其后续版本提供了大量的返回任务的异步方法，因此它们都可以await（主要和I/O相关）。大部分方法采用了一种基于任务的异步模式（Task-based Asynchronous Pattern, TAP），该模式是到目前为止最合理的一种方式，一个TAP方法：

- 返回一个“热”（正在运行中的）Task或者Task<TResult> 。
- 拥有Async后缀（除非是一些特殊情况，例如任务组合器）。
- 若支持取消操作或进度报告，则需要拥有接受CancellationToken或者IProgress<T>的重载。
- 快速返回调用者（初始同步阶段非常短小）。
- 对于I/O密集型任务不绑定线程。

统一协议的异步函数（它们均返回任务）的优点之一是可以使用并编写任务组合器，即一些和任务的具体用途无关的，可以将任务进行组合的函数。CLR包含两种任务组合器：Task.WhenAny和Task.WhenAll。

Task.WhenAny方法会在任务组中的任意一个任务完成时返回这个任务。

Task.WhenAll返回一个任务，该任务仅当参数中的所有任务全部完成时才完成。

### 14.7 已废弃的模式

在任务和异步函数出现之前，Framework使用其他方式实现异步编程。由于在.NET Framework 4.5之后基于任务的异步处理已经成为主流模式，这些模式现在已经很少使用了。

异步编程模型（Asynchronous Programming Model, APM）是最古老的编程模式。它使用一对以Begin和End开头的方法，以及IAsyncResult接口实现异步执行。

基于事件的异步模式（Event-based Asynchronous Pattern, EAP）是在Framework 2.0时引入的，与APM相比它更为简单，尤其是在UI场景中。然而，提供这种实现的类型并不多，其中最值得一提的是System.Net命名空间下的WebClient类型。EAP只是一种模式，它并没有任何的辅助类型。本质上，这个模式只是一个类提供了一组成员，而这组成员在内部管理程序的并发性。

System.ComponentModel命名空间下的BackgroundWorker是一个通用的EAP实现类。它允许富客户端应用启动一个工作线程，报告执行完成或百分比进度，且无须显式捕获同步上下文。

## 第15章 流与I/O

本章将介绍.NET的输入和输出的基本类型，主要包含以下几个方面的内容：

- .NET流的架构，以及它是如何为多种I/O类型提供统一的读写编程接口的。
- 与处理磁盘文件和目录相关的类。
- 与压缩、命名管道以及内存映射文件相关的特定流。

本章将集中介绍System.IO命名空间（主要提供底层I/O功能）中的类型。.NET Fra-mework还支持更高级的I/O操作，例如SQL连接和命令、LINQ to SQL以及LINQ to XML、WCF、Web Service以及Remoting。

### 15.1 .NET流的架构

.NET流的架构主要包含三个概念：后台存储、装饰器以及流适配器。

后台存储流负责处理原始数据；装饰器流可以透明地进行二进制数据的转换（例如加密）；而适配器则提供了处理更高级类型（例如文本和XML）的方法。

### 15.2 使用流

抽象的Stream类是所有流的基类。它的方法和属性定义了三种基本的操作：读、写、查找。除此之外，它还定义了一些管理性的任务，例如关闭、刷新（flush）和配置超时时间。

流可以支持读操作，写操作或者两者都支持。如果CanWrite为false则这个流就是只读的；如果CanRead为false这个流就是只写的。

如果CanSeek返回true，那么表示当前的流是可以查找的。在一个可以查找的流中（例如文件流），不但可以查询还可以修改它的长度Length（调用SetLength方法）。也可以通过Position属性随时设置读写的位置（Position属性的位置是相对于流的起始位置的）。而Seek方法则可以参照当前位置或者结束位置进行位置的设置。

如果流不支持查找功能（例如加密流），那么确定其长度的唯一方法就是遍历整个流。而且，如果需要重新读取先前的位置，则必须关闭整个流，然后重新从头开始读取。

流在使用结束后必须销毁，以释放底层资源，例如文件和套接字句柄。可以在using语句块中创建流的实例来确保结束后销毁流对象。通常，流对象的标准销毁语义为：

- Dispose和Close方法的功能是一样的。
- 重复销毁或者关闭流对象不会产生任何错误。关闭一个装饰器流会同时关闭装饰器及其后台存储流。关闭装饰器链的最外层装饰器（链条的头部）就可以关闭链条中的所有对象。

有一些流（例如文件流）会将数据缓冲到后台存储中并从中取回数据，减少回程，从而提高性能。这意味着，写入流的数据并不会直接存储到后台存储中，而是会先将缓冲区填满再写入存储器。Flush方法可以强制将缓冲区中的数据写入后台存储中。当流关闭的时候，也会自动调用Flush方法。

通常情况下，流并不是线程安全的，这意味着当两个线程并发读写同一个流对象的时候有可能会发生错误。而Stream类提供了一个简单的解决方案，即使用静态的Synchronized方法。这个方法可以接受任何类型的流，并返回一个线程安全的包装器。这个包装器会使用一个排它锁保证每一次读、写或者查找操作只能有一个线程执行。这样，多个线程就可以同时向一个数据流中写入数据了。

静态方法File.ReadLines和File.ReadAllLines类似，但前者会返回一个延迟加载的IEnumerable<string>类型。它无须将所有内容加载到内存中，因而更加高效。

文件名可以是绝对路径（例如c:\temp\test.txt）也可以是相对当前目录的路径（例如，test.txt或者temp\test.txt）。可以访问Environment.CurrentDirectory属性来获得或者更改当前目录。

在应用程序启动时，当前目录不一定是应用程序可执行文件所在的路径。因此，一定不要用当前目录来定位与可执行文件一起打包的其他运行时文件。

AppDomain.CurrentDomain.BaseDirectory属性会返回应用程序的基础目录（base directony），正常情况下它就是可执行文件所在的文件夹。结合使用Path.Combine方法就可以定位该目录下的文件名。

FileStream类型每一个接受文件名的构造器都需要提供FileMode枚举参数。

以下是创建FileStream时可选的其他参数：

- FileShare枚举：描述了在完成文件处理之前，若其他进程希望访问该文件，则可以给其他进程授予的访问权限（None、Read、ReadWrite或者Write，其中Read为默认权限）。
- 内部缓冲区的大小（字节为单位，默认大小为4KB）。
- 是否由操作系统管理异步I/O的标志。
- FileSecurity对象，描述给新文件分配的用户角色和权限。
- FileOptions标志枚举值，其中包括：请求操作系统加密（Encrypted），在文件关闭时自动删除临时文件（DeleteOnClose），以及优化提示（RandomAccess和SequentialScan）。此外还有一个WriteThrough标志可以要求操作系统禁用写后缓存，这适用于事物文件或日志文件的处理。

MemoryStream使用数组作为后台存储。这在一定程度上与使用流的目的是相违背的，因为这个后台存储都必须一次性地驻留在内存中。然而，MemoryStream仍然有一定的用途。例如，随机访问一个不可查找的流。

我们可以调用ToArray方法将一个MemoryStream转换为一个字节数组。而GetBuffer方法则更加高效地直接返回底层存储数组的引用。但是，需要注意的是这个数组通常会比流的实际长度要长一些。

PipeStream是在Framework 3.5中引入的。它可以使用Windows管道协议与另一个进程进行通信。管道的类型共有两种：

- 匿名管道（速度更快）：支持在同一个计算机中的父进程和子进程之间进行单向通信。
- 命名管道（更加灵活）：允许同一台计算机的任意两个进程之间，或者不同计算机（使用Windows网络）的两个进程间进行双向通信。

管道很适合在同一台计算机进行进程间通信（IPC）：它不依赖于任何网络传输（因此没有网络协议开销），性能更好，也不会有防火墙问题。

管道是基于流实现的，因此一个进程会等待接收字节，而另一个进程则负责发送字节。另一种进程通信的方法是通过共享内存进行通信，我们将在15.8节中介绍相关内容。

PipeStream是一个抽象类，它有4个子类。其中两个用于匿名管道而另外两个用于命名管道。

- 匿名管道：AnonymousPipeServerStream和AnonymousPipeClientStream
- 命名管道：NamedPipeServerStream和NamedPipeClientStream

BufferedStream可以装饰或者包装另外一个具有缓冲功能的流。它是.NET Frame-work的诸多核心装饰器流类型之一。

### 15.3 流适配器

Stream仅仅支持字节处理。但要读写一些数据类型，例如字符串、整数或者XML元素，则需要适配器的支持。

TextReader和TextWriter都是专门处理字符和字符串的适配器的抽象基类。它们在框架中各有两个通用的实现：

- StreamReader/StreamWriter：使用Stream存储其原始数据，将流的字节转换为字符或者字符串。
- StringReader/StringWriter：使用内存字符串实现了TextReader/TextWriter。

Windows的换行符模仿了机械打字机：回车符（13号字符）后面加上一个换行符（10号字符）。用C#的字符串表示为"\r\n"（可以认为是“ReturnN”）。如果顺序调换，结果可能是两行，但也可能一行也没有！

TextReader和TextWriter本身是与流或者后台存储无关的抽象类。然而，Str-eamReader和StreamWriter都与底层字节流有关。因此，它们必须进行字符和字节之间的转换。而它们是通过System.Text命名空间的Encoding类进行这些操作的。在创建StreamReader或者StreamWriter时需要选定一种编码方式，而如果不进行选择，则会默认使用UTF-8编码。

UTF-16使用2字节的前缀来表明字节顺序（“小字节序”或者“大字节序”，即最低有效字节在前还是最高有效字节在前）。Windows系统采用的默认标准是小字节序。

StringReader和StringWriter适配器并不包装流；相反，它们使用一个字符串或者StringBuilder作为底层数据源。这意味着它们不需要进行任何的字节转换。事实上，这些类所执行的操作都可以通过字符串或者StringBuilder与一个索引变量轻松实现。上述类型和StreamReader/StreamWriter共享相同的基类，这也是它们的优势所在。

BinaryReader和BinaryWriter能够读写基本的数据类型：bool、byte、char、decimal、float、double、short、int、sbyte、ushort、uint、ulong以及string和基元类型的数组。和StreamReader/StreamWriter不同，二进制适配器能够高效存储基元数据类型，因为它们本身与内存中的表示就是一致的。因此，一个int占用4个字节，而一个double占用8个字节。字符串是通过文本编码（与StreamReader和StreamWriter一样）写入的，但是带有长度前缀，从而不需要特殊分隔符就可以读取一系列字符串。

销毁流适配器的方式有四种：

1. 只关闭适配器
2. 关闭适配器，而后关闭流
3. （对于写入器）先刷新适配器，而后关闭流
4. （对于读取器）直接关闭流

对于适配器和流而言，Close和Dispose是同义词。

方法1和方法2在语义上是相同的，因为关闭适配器会自动关闭底层流。每嵌入一个using语句，就意味着隐式采用了方法2。

### 15.4 压缩流

System.IO.Compression命名空间中提供了两个通用的压缩流：DeflateStream和GZipStream。这两个类都使用了与ZIP格式类似的常见的压缩算法。其区别是，GZipStream会在开头和结尾处写入额外的协议信息，其中包括检测错误的CRC。除此之外，GZipStream还遵循一个其他软件公认的标准。

这两种流都支持读写操作，但是有以下的限制条件：

- 压缩时总是在写入流。
- 解压缩时总是在读取流。

### 15.5 操作ZIP文件

从.NET Framework 4.5开始，可以使用System.IO.Compression命名空间（位于System.IO.Compression.FileSystem.dll中）中的ZipArchive和ZipFile来操作常用的ZIP压缩格式的文件。与DeflateStream和GZipStream相比，这种格式的优点是可以处理多个文件，并可以兼容Windows资源管理器及其他压缩工具创建的ZIP文件。

### 15.6 文件与目录操作

System.IO命名空间中有一些可以进行文件和目录操作（例如复制和移动、创建目录，以及设置文件的属性和权限）的实用类型。对于大多数的特性我们都有两种选择：一种是静态方法，而另一种则是实例方法。静态类：File和Directory实例方法类（使用文件或者目录名创建）:FileInfo和DirectoryInfo此外，还有一个特殊的静态类Path。它不操作文件或目录，但是它可以处理文件名称或者目录路径字符串。同时Path还可以用于临时文件的处理。

### 15.7 在UWP中进行文件I/O操作

UWP应用程序对目录和文件的访问进行了严格的约束。使用Windows.Storage命名空间中的WinRT类型是了解这些限制的最佳手段。其中最主要的两个类型是Sto-rageFolder和StorageFile。

### 15.8 内存映射文件

内存映射文件提供了两个主要特性：

- 高效地随机访问文件中的数据
- 在同一台计算机的不同进程间共享内存内存映射文件是.NET Framework 4.0引入的，其类型位于System.IO.MemoryMapped-Files命名空间中。它包装了和内存映射文件相关的Win32 API。

### 15.9 独立存储区

每一个.NET应用程序都可以访问其独有的本地存储区域，称为独立存储区（isolated storage）。如果应用程序无法访问标准文件系统（因此也无法在ApplicationData、LocalApplicationData、CommonApplicationData、MyDocuments中写入数据，请参见15.6.5节）那么则更适合使用独立存储区。使用受限Internet权限部署的Silverlight应用程序和ClickOnce应用程序就属于这种情况。

## 第16章 网络

.NET Framework在System.Net.*命名空间中包含了支持各种网络标准的类，支持的标准包括HTTP、TCP/IP以及FTP等。以下列出了其中的主要组件：

- WebClient类：支持通过HTTP或者FTP执行简单的下载/上传操作。
- WebRequest和WebResponse类：可以从底层控制客户端HTTP或FTP操作。
- HttpClient类：消费HTTP Web API和RESTful服务。
- HttpListener类：用于编写HTTP服务器。
- SmtpClient类：构造并通过SMTP协议发送邮件。
- Dns类：用于进行域名和地址之间的转换。
- TcpClient、UdpClient、TcpListener和Socket类：用于直接访问传输层和网络层。

### 16.1 .NET网络架构

传输层定义了发送和接收字节的基础协议（TCP和UDP）；而应用层则定义了为特定应用程序设计的上层协议。例如下载网络页面（HTTP）、传输文件（FTP）、发送邮件（SMTP）以及在域名和IP地址间进行转换（DNS）。

通常情况下在应用层编程是最方便的。然而，有时出于特定的原因，我们必须直接在传输层上进行操作，例如，当需要使用一种.NET Framework并未提供的协议（例如用于接收邮件的POP3协议）时。此外，若需要发明一种用于特定应用程序的自定义协议（例如对等客户端）时也是如此。

### 16.2 地址与端口

计算机或其他设备需要一个地址才能够进行通信。Internet使用了两套地址系统：IPv4：它是目前主流的地址系统。IPv4有32位宽。如果用字符串表示则可以写为用点分隔的四个十进制数（例如，101.102.103.104）。地址可以是全世界唯一的，也可以在一个子网中是唯一的（例如，企业网络）。IPv6：它是更新的128位地址系统。这些地址用字符串表示为以冒号分隔的十六进制数（例如：[3EA0:FFFF:198A:E4A3:4FF2:54fA:41BC:8D31]）。.NET Framework中要求要在IPv6地址前后加上方括号。

TCP和UDP协议将每一个IP地址划分为65535个端口，从而允许一台计算机在一个地址上运行多个应用程序，每一个应用程序使用一个端口。许多应用程序都分配有标准端口，例如，HTTP默认使用80端口，而SMTP使用25端口。

TCP和UDP协议中从49512到65535的端口是未分配端口，因此它可以用于测试及小规模部署。

防火墙可以阻挡端口通信。在许多企业环境中，只有少数端口是开放的。通常情况下只会开放80端口（不加密HTTP）和443端口（安全的HTTP）。

### 16.3 URI

URI是一个具有特殊格式的字符串，它描述了一个Internet或LAN资源。

URI可分为三个组成部分：协议（scheme）、权限（authority)及路径（path）。

 URI后的斜杠是非常重要的。服务器会根据它来决定该URI是否包含了路径信息。例如，假设URI为http://www.albahari.com/nutshell/那么HTTP服务器就会在网站的Web文件夹中查找名为nutshell的子文件夹，并返回该文件夹中的默认文档（通常为index.html）。而如果该URI结尾处并没有斜杠的话，则Web服务器则会试图在网站的根目录下寻找名为nutshell（没有扩展名）的文件，而这种行为通常不是我们期望的。如果该文件不存在，则大多数Web服务器会将其认定为用户输入错误，并返回301永久重定向错误，表示客户端应当尝试在结尾加上斜杠。默认情况下，.NET的HTTP客户端和Web浏览器采用相同的行为来处理301错误，即使用推荐的URI重试一次。这意味着，如果忽略末尾本该添加的斜杠，请求仍然是有效的，只是会额外产生一个不必要的回程。

### 16.4 客户端类型

WebRequest和WebResponse是管理HTTP和FTP客户端活动，以及“file:”协议的通用基类。它们封装了这些协议共同的“请求/响应”模型：即客户端发起请求，然后等待服务器的响应。

WebClient是一个易于使用的门面（facade）类，它负责调用WebRequest和Web-Response的功能，从而节省很多的代码。WebClient支持字符串、字节数组、文件或者流。而WebRequest和WebResponse只支持流。但是WebClient也不是万能的，因为它也不支持所有的特性（例如cookie）。

HttpClient是另一个基于WebRequest和WebResponse的类（更准确说是基于Http-WebRequest和HttpWebResponse），它是.NET Framework 4.5新引入的类型。Web-Client主要作为请求/响应类型上的简单一层，而HttpClient则针对基于HTTP的Web API、基于REST的服务以及自定义的认证协议增加了很多功能性支持。

### 16.5 使用HTTP

WebClient、WebRequest和HttpClient都可以添加自定义的头部信息，也可以枚举响应中的头部信息。头部信息是由一些包含元数据的键值对组成的，例如消息的内容类型或服务器软件

查询字符串是一个以问号开始的、附加在URI后的字符串，用于向服务器发送简单的数据。

WebClient提供了UploadValues方法，以HTML表单的形式提交数据。

cookie是一种名称/值的字符串对，HTTP服务器将其放在响应的头部信息中发送给客户端。Web浏览器客户端通常会记录cookie，并在其过期之前将其附加在（相同地址的）所有的后续请求上发送给服务器。服务器可以通过cookie得知之前是否曾和相同的客户端进行过交互，从而不再需要在URI上重复添加复杂的查询字符串。

在指定“https:”前缀时，WebClient、HttpClient和WebRequest都会自动使用SSL。唯一的复杂之处和设计不佳的X.509证书有关。如果服务端证书由于某种原因失效（例如，它是一个测试证书），那么在通信时就会抛出一个异常。

### 16.6 编写HTTP服务器

可以使用HttpListener类编写自定义的HTTP服务器。

HttpListener在内部并不会使用.NET的Socket对象；相反，它调用的是Windows HTTP Server API。这个API允许多个应用程序监听相同的IP地址和端口，而前提是每一个应用程序都需要注册不同的地址前缀。在我们的例子中，都注册了前缀http://localhost/myapp，因此另一个应用程序也可以以其他的前缀，例如http://localhost/anotherapp，监听相同的IP和端口。这是非常有价值的，因为一般在企业防火墙中开放新的端口需要进行一系列的审批。

### 16.7 使用FTP

使用WebClient就可以实现简单的FTP上传和下载操作。

### 16.8 使用DNS

静态的Dns类封装了域名服务，将原始的IP地址（如66.135.192.87）转换为易于识别的域名（例如ebay.com）。

### 16.9 通过SmtpClient类发送邮件

System.Net.Mail命名空间中的SmtpClient类可使用简单邮件传输协议（Simple Mail Transfer Protocol, SMTP）发送电子邮件。若要发送一段简单的文本消息，首先需要实例化SmtpClient，并将其Host属性设置为SMTP服务器的地址，最后调用Send方法发送邮件

### 16.10 使用TCP

大多数Internet与局域网服务都是构建在TCP或者UDP这种传输层服务协议之上的。HTTP、FTP和SMTP使用TCP; DNS使用UDP。TCP是面向连接的，具有可靠性机制；而UDP则是无连接的，开销更小，并支持广播。BitTorrent和Voice over IP都使用了UDP。
传输层比上层协议具有更高的灵活性，性能一般也更好。但是它需要用户自行处理诸如身份验证和加密这类具体的任务。

在.NET中，既可以使用易用的TcpClient和TcpListener门面类，还可以使用功能丰富的Socket类（实际上上述类型还可以混合使用，例如可以通过TcpClient的Client属性访问底层的Socket对象）。Socket类包含更多的配置选项，并可以直接进行网络层（IP）访问。此外它还支持一些非Internet的协议，例如Novell的SPX/IPX协议。

### 16.11 使用TCP接收POP3邮件

.NET Framework没有在应用层提供任何对POP3的支持。因此要想从POP3服务器接收邮件就需要在TCP层编写代码。

### 16.12 在Windows Runtime中使用TCP

Windows Runtime通过Windows.Networking.Sockets命名空间提供了TCP的相应功能。和.NET Framework的实现一样，主要有两个类来分别充当服务器和客户端角色。在WinRT中它们分别是StreamSocketListener和StreamSocket。

## 第17章 序列化

本章将介绍序列化和反序列化，即将对象表示为纯文本或二进制形式的机制。

### 17.1 序列化的概念

序列化是将内存中的对象或者对象图（一组相互引用的对象）拉平为一个可以保存或进行传输的字节流，或者XML节点。反序列化正好相反，它把数据流重新构造成内存中的一个对象或者对象图。

序列化和反序列化通常用于：

- 通过网络或程序边界传输对象
- 在文件或者数据库中保存对象
  此外，它还可以用于深度克隆对象。而数据契约和XML序列化引擎也可以当作通用工具，用于加载和保存已知结构的XML文件。

.NET Framework的序列化和反序列化既支持从客户端角度序列化或反序列化对象，也支持从类型角度控制对象的序列化方式。

在.NET Framework中有4种序列化机制：

- 数据契约序列化器
- 二进制序列化器（用于桌面应用程序）
- （基于特性的）XML序列化器（XmlSerializer）
-  IXmlSerializable接口

前三种“引擎”承担了大部分的序列化工作，而最后的IXmlSerializable接口是一个使用XmlReader和XmlWriter进行自定义序列化的钩子（hook）。它可以结合数据契约序列化器或者XmlSerializer处理更复杂的XML序列化任务。

出现三种序列化引擎有一定程度的历史原因。Framework的序列化功能原本基于两个完全不同的目的：

- 在保证类型和引用完整性的前提下对.NET对象图进行序列化。
- 与XML和SOAP等消息标准进行互操作。

第一种由Remoting的需求而产生；而第二种则是为了支持Web服务。使用一个序列化引擎同时完成这两个任务是非常困难的。因此Microsoft编写了两个引擎：二进制序列化器和XML序列化器。

后来在.NET Framework 3.0时引入了WCF。其部分目标在于统一Remoting和Web服务。而这就要求一个新的序列化引擎。因此就出现了数据契约序列化器。数据契约序列化器统一了现存的两个序列化引擎中和消息（互操作）相关的特性。但是在这个上下文之外，两个先前引入的序列化引擎仍然很重要。

### 17.2 数据契约的序列化

使用数据契约序列化器，需要以下几步：

1. 决定是选用DataContractSerializer还是NetDataContractSerializer。
2. 使用[DataContract]和[DataMember]特性修饰要序列化的类型和成员。
3. 实例化序列化器后调用WriteObject和ReadObject。

如果选择DataContractSerializer，则需要同时注册已知类型（即能够序列化的子类型），并且要决定是否保留对象引用。
   此外，还需要采取特殊的措施确保集合能够被正确序列化。

数据契约序列化器有两种：

- DataContractSerializer:.NET类型与数据契约类型松耦合。
- NetDataContractSerializer:.NET类型与数据契约类型紧耦合。

选择序列化器之后，下一步需要在要序列化的类型和成员上添加相应的特性标注。至少应当添加以下这些标注：

- 在每个类型上添加[DataContract]特性
- 在每一个需要序列化的成员上添加[DataMember]特性

这些特性足够令数据契约引擎隐式对该类型进行序列化了。

当然也可以通过显式实例化DataContractSerializer或者NetDataContract-Serializer并调用WriteObject或者ReadObject方法来序列化或者反序列化一个对象实例。

[DataMember]可以支持公有和私有的字段和属性，且字段和属性的数据类型可以是以下类型中的任何一种：

- 任何基元类型
- DateTime、TimeSpan、Guid、Uri或者Enum值
- 上述类型的可空类型版本
- byte[]（在XML中序列化为base 64编码）
- 任何用DataContract修饰的已知类型
- 任何IEnumerable类型（请参见17.8.3节）
- 任何被[Serializable]修饰，或者实现了ISerializable接口的类型（请参见17.4节）
- 任何实现了IXmlSerializable接口的类型。


契约中引用的对象也会被序列化。

NetDataContractSerializer总是会保留引用的相等性，而DataContractSe-rializer除非专门指定，否则不会保留。

版本容错性指可以添加或删除数据成员，而不破坏向前和向后兼容性。默认情况下，数据契约序列化器会使用如下规则进行反序列化：

- 跳过类型中没有用[DataMember]修饰的数据
- 如果序列化流缺少任何[DataMember]，则反序列化过程不会受到影响

在序列化时，成员会按照如下的顺序进行书写：

1. 从基类型到子类型
2. 从低Order值到高Order值（对于使用了Order特性修饰的数据成员）
3. 字母表顺序，使用字符串的序数（ordinal）进行排序。

处理null和值为空的数据成员的方式有两种：

1. 显式写入null或者空值（默认方式）。
2. 序列化输出时忽略这些数据成员。

### 17.3 数据契约与集合

数据契约序列化器可以保存并恢复任何可枚举的集合。

### 17.4 扩展数据契约

本节将介绍如何通过[Serializable]和IXmlSerializable这些序列化钩子来扩展数据契约的能力。

如果要在序列化之前或者序列化之后执行一个自定义方法，则可以在该方法上标记以下特性：

- [OnSerializing]：在序列化之前调用这个方法。
- [OnSerialized]：在序列化之后调用这个方法。

反序列化也支持类似的特性：
- [OnDeserializing]：在反序列化之前调用这个方法。
- [OnDeserialized]：在反序列化之后调用这个方法。

这些自定义方法只能包含一个StreamingContext类型的参数。这个要求主要是为了保证和二进制引擎的兼容性，但它并不会被数据契约序列化器使用。

用这四个特性修饰的方法可以是私有的。如果子类型需要参与其中，那么它们可以使用相同的特性来标记自己的方法，这些方法同样会得到执行。

### 17.5 二进制序列化器

二进制序列化引擎可以将对象保存到磁盘上或者从磁盘上恢复对象。Remoting就会隐式使用它。二进制序列化高度自动化并可以用最少的操作处理复杂的对象图。

需要指出的是Windows商店应用是不支持二进制序列化器的。

令类型支持二进制序列化的方式有两种：第一种是基于特性标记的；第二种则需要实现ISerializable接口。添加特性标记相对简单，而实现ISerializable则更灵活。一般来说，实现ISerializable的目的有两个：

- 动态控制序列化的内容。
- 让可序列化的类型能更加友好地被第三方继承。

[Serializable]特性将令序列化器序列化类型中的所有字段。这既包含私有字段，又包含公有字段（但不包含属性）。

[Serializable]特性不能继承，因此子类不会自动成为可序列化的类，除非在子类上也标记这个特性。

在二进制引擎中有两个可用的格式化器：

- BinaryFormatter：该格式化器的效率较高，可以用更短的时间产生更小的输出。其位于System.Runtime.Serialization.Formatters.Binary命名空间中。
- SoapFormatter：该序列化器在和Remoting配合使用时可以生成基本的SOAP样式的消息。它位于System.Runtime.Serialization.Formatters.Soap命名空间中。

### 17.6 二进制序列化特性

数据契约可以选择性地将可序列化字段加入，而二进制引擎则不同，它可以选择性地将字段排除。对于不希望进行序列化的字段（例如进行临时计算的字段或者存储文件或者窗口句柄的字段），必须显式使用[NonSerialized]特性来标记它们。

默认情况下，添加一个字段就会破坏已序列化数据的兼容性。为了保持兼容性，可在该字段上附加[OptionalField]特性。


### 17.7 使用ISerializable接口进行二进制序列化

实现ISerializable接口可以完全控制二进制序列化和反序列化的过程。

GetObjectData方法会在序列化时触发。其任务是将序列化的所有字段放入Seria-lizationInfo（一个键值对字典）对象中。

除了实现ISerializable接口之外，若类型还希望控制其序列化过程则还需提供一个反序列化构造器。这个构造器的参数和GetObjectData相同。该构造器不论声明为何种访问级别，运行时都可以找到它。一般来说，我们会将其声明为protected，这样子类就可以调用该函数了。

### 17.8 XML序列化

Framework提供了专门进行XML序列化的引擎：System.Xml.Serialization命名空间下的XmlSerializer类。它可以将.NET类型序列化为XML文件，ASMX Web服务也会隐式使用它。

和二进制引擎相似，我们可以使用两种方式使用XML序列化引擎：

- 在类型上使用特性标记（其定义位于System.Xml.Serialization命名空间下）。
- 实现IXmlSerializable接口。

但是和二进制引擎不同的是，实现IXmlSerializable接口将放弃序列化引擎，并完全使用XmlReader和XmlWriter来自行实现序列化。

XML反序列化器具有版本容错性：不论缺少了元素或者属性，或者有多余的数据出现，它都不会产生错误。

默认情况下，字段和属性都会序列化为XML元素。但是可以要求序列化器将其序列化为XML属性。

XML序列化器的默认的命名空间为空（这和数据契约序列化器不同，数据契约序列化器默认使用类型的命名空间）。若需要指定XML的命名空间，则可以在[XmlElement]和[XmlAttribute]特性上指定Namespace参数。也可以在类型本身使用[XmlRoot]来指定类型的名称和命名空间。

## 第18章 程序集

程序集是.NET中的基本部署单元，也是所有类型的容器。程序集包含已编译的类型、IL（中间语言）代码、运行时资源，以及用于版本控制、安全及其他程序集的引用信息。程序集同样定义了类型解析和安全许可的边界。一般来说，一个程序集包含单个的Windows可移植执行文件（Windows Portable Executable, PE）。如果是应用程序则带有.exe扩展名；如果是可重用的类库则带有.dll扩展名。WinRT类库的扩展名为．winmd，它和．dll相似，但是它仅仅包含元数据，而并不包含中间语言代码。

### 18.1 程序集的组成部分

程序集包含4项内容：

- 程序集清单：向.NET运行时提供各种信息，例如程序集的名称、版本、请求的权限以及其引用的其他程序集。
- 应用程序清单：向操作系统提供必要的信息，例如如何部署该程序集以及是否需要管理员权限。
- 编译后的类型：程序集中定义的类型的元数据以及编译后的IL代码。
- 资源：嵌入程序集中的其他数据，例如图像和本地化文本。

所有这些内容中，只有程序集清单是必需的，尽管程序集几乎总是会包含编译后的类型（除非它是WinRT引用程序集）。

程序集不管是可执行文件还是库，其结构都是相似的，主要的区别在于可执行文件必须定义一个入口点。

程序集清单有两个目的：

- 向托管宿主环境描述程序集。
- 它像一个目录一样存储着程序集的模块、类型和资源。

Visual Studio会为每一个新的C#项目生成一个AssemblyInfo.cs文件并将其存储在Properties文件夹中。其中预定义了一些默认程序集特性。我们可以以这些内容为起点进一步定义它们的内容。

应用程序清单是一个XML文件，它向操作系统提供程序集相关的信息。应用程序清单若存在，则会在.NET托管宿主环境加载该程序集之前进行读取和处理，从而影响操作系统启动应用程序进程的方式。

程序集的内容实际上是存储在一个或者多个称为模块的中间容器中。一个模块对应一个包含程序集内容的文件。采用额外的容器层的原因是为了令一个程序集可以跨越多个文件，这样就可以将多种编程语言的编译结果构建为一个程序集了。

System.Reflection命名空间下的Assembly类是在运行时访问程序集元数据的入口。获得程序集对象的方式有很多，最简单的方式则是通过Type的Assembly属性。

### 18.2 强名称和程序集签名

强命名的程序集具有唯一的和不可更改的标识。它是通过在清单中添加如下的两种元数据实现的：

- 属于该程序集作者的唯一编号。
- 程序集签名后的散列值，以证实该程序集是由持有其唯一编号的作者生成的。

这种机制需要生成一个公钥/私钥对。公钥将提供唯一的标识编号，而私钥则负责为程序集签名。

### 18.3 程序集名称

程序集的标识包含四种清单中的元数据：

- 简单名称
- 版本（如果未指定，则为“0.0.0.0”）
- 文化设定（如果不是附属程序集，则为“neutral”）
- 公钥令牌（如果不是强命名程序集，则为“null”）


简单名称不是来自任何特性，而是来源于其最初编译成的文件的名称（不带扩展名）。因此System.Xml.dll的简单名称为“System.Xml”。重命名不会改程序集的简单名称。

### 18.4 认证代码签名

认证代码（Authenticode）是一个代码签名系统，其目的在于证明发行商的身份。认证代码和强名称签名是独立的，既可以独立使用又可以联合使用。

尽管强名称签名可以证明程序集A、B和C来自相同的一方（假设私钥并未泄露），但是它并不知道那一方到底是谁。为了知道这一方到底是Joe Albahari还是Microsoft Corporation，就需要用到认证代码。

### 18.5 全局程序集缓存

在.NET Framework安装过程中，会在计算机上创建一个中心仓库来存储.NET程序集。该仓库称为全局程序集缓存（Global Assembly Cache, GAC）。GAC包含.NET Framework本身的一个中心副本，并可集中管理用户拥有的程序集。

是否将程序集放入GAC的主要考虑因素和版本控制相关。对于GAC中的程序集，版本控制集中在本机级别，并由系统管理员控制。对于GAC之外的程序集，版本控制则是以应用程序为中心进行的。因此每一个应用程序都需要关注自己的依赖，并注意更新问题（通常它会维护自身引用的程序集的副本来实现对程序集的管理）。

### 18.6 资源和附属程序集

应用程序通常不仅仅包含可执行代码，还包含文本、图像或者XML文件等内容。这些内容可以作为程序集中的资源。资源有两个相互有交集的使用场景：

- 容纳无法进入源代码的数据，例如图像。
- 存储在多语言应用程序中需要进行翻译的数据。

### 18.7 程序集的解析和加载

一个典型的应用程序包含一个可以执行的主程序集和一组被其引用的库程序集。

### 18.8 在基础目录之外部署程序集

有时我们可能需要将程序集部署到应用程序的基础目录之外的位置。

### 18.9 打包单个可执行文件

假设我们编写了一个包含10个程序集的应用程序：1个主要的可执行文件，外加9个DLL。尽管这样的划分粒度有助于设计和调试，但是若能将这些文件打包成一个独立的“单击即可执行”的可执行文件就更好了，这样就无须用户执行安装或解压之类的操作了。其中的一种方式是将编译好的程序集DLL作为资源嵌入到主项目中，并处理AssemblyResolve事件以便在需要时直接加载其二进制映像。

### 18.10 处理未引用的程序集

有时我们需要显式加载编译时未引用的.NET程序集。

## 第19章 反射和元数据

在运行时检查并使用元数据和编译代码的操作称为反射。

程序集中的编译代码包括源代码的绝大部分内容。但是仍然有一些信息会丢失，例如局部变量名称、注释和预处理指令。反射可以访问几乎所有的信息，甚至可以编写一个反编译器。

.NET通过C#语言提供的诸多服务（例如动态绑定、序列化、数据绑定和Remoting）都是依托于元数据的。我们的应用程序可以充分地利用这些元数据，甚至可以通过自定义特性向元数据中添加信息。反射相关的API均位于System.Reflection命名空间下。我们甚至可以通过System.Reflection.Emit命名空间中的类在运行时动态创建新的元数据和可执行IL（中间语言）指令。

### 19.1 反射和激活类型

System.Type的实例代表了类型的元数据。

调用任意对象的GetType方法或者使用C#的typeof运算符都可以得到System.Type的实例。

UWP和.NET Core应用程序实现了有限的反射机制。特别是它们无法访问非公有成员，也无法使用Reflection.Emit。

类型具有Namespace、Name以及FullName属性。在大多数情况下，FullName是前两者的组合。

反射还提供了两种和is静态运算符等价的动态运算符：

- IsInstanceOfType方法可以接受类型和实例。
- IsAssignableFrom方法接受两个类型。

IsSubclassOf方法和IsAssignableFrom方法的功能类似，但是IsSubclassOf不包含接口。

从类型创建对象实例的方式有两种：

- 调用静态的Activator.CreateInstance方法；
- 调用ConstructorInfo.Invoke方法，并使用Type的GetConstructor方法的返回值作为参数（高级的对象实例化场景）。

Type既可以表示封闭的泛型类型也可以表示未绑定类型参数的泛型类型。在编译时只能够实例化封闭的泛型类型，而无法实例化未绑定的泛型类型。

### 19.2 反射并调用成员

GetMembers方法可以返回类型的成员。

TypeInfo类提供了另一种（更加简单的）成员反射协议。

某些C#的功能结构和CLR的结构并非一一对应。这是因为CLR的反射API是为所有.NET语言设计的，例如，我们可以在Visual Basic中使用反射。

在调用GetMethod时显式指定参数类型可以避免重载方法的二义性。但这种方式无法指定泛型参数类型。

动态调用的效率不高，其开销通常为几微秒。如果要在一个循环中重复调用某个方法，则可以为目标动态方法动态实例化一个委托，这样就可以将微秒级的开销降低到纳秒级。

类型上所有检测元数据的方法（例如GetProperty、GetField等）都含有使用BindingFlags枚举的重载方法。而这个枚举参数就是元数据的筛选器，使用它可以更改默认的筛选标准。它的常见用法是检索非公有成员（仅仅适用于桌面应用程序）。

### 19.3 反射程序集

若需要动态反射程序集，只需调用Assembly对象的GetType或者GetTypes即可。

### 19.4 使用特性

CLR允许使用特性将额外的元数据追加到类型、成员和程序集上。这是许多CLR功能（例如序列化和安全）的运行机制，因而特性是一个应用程序不可或缺的一部分。

特性的一个关键的特点是可以自定义，并且像其他特性那样将附加的信息添加到代码元素上。这些附加信息会在编译过程中进入程序集，并可以在运行时通过反射获得这些信息并声明性地创建服务（如自动化单元测试）。

C#有三类特性：

- 位映射特性
- 自定义特性
- 伪自定义特性
  这三种特性中，只有自定义特性是可扩展的。

位映射特性（本书中定义的术语）可以映射到类型元数据的特定位上。大多数的C#修饰符关键字，例如public、abstract以及sealed都会编译为位映射特性。这些特性非常高效，因为它们在元数据中占用的空间极小（大部分仅仅占据1位）并且CLR可以几乎不需要间接操作就可以直接定位这些信息。

自定义特性可以编译为类型的主元数据表中的二进制数据。所有的自定义特性都是由System.Attribute的子类表示的，而且与位映射特性不同，它们是可扩展的。这些元数据中的二进制块就是该特性类的标识，其中还包含了所有占位和命名的参数的值。自定义特性和.NET Framework中定义的特性的结构是完全相同的。

伪自定义特性与自定义特性之间的差异在于编译器或者CLR内部会进行优化，将伪自定义特性转换为位映射特性。关于这方面的例子包括[Serializable]（见第17章）、StructLayout、In和Out（见第25章）。

AttributeUsage是一种应用在特性类上的特性。它可以告诉编译器如何使用目标特性。

以下是自定义特性的编写方式：

1. 创建一个继承自System.Attribute或者System.Attribute子类的类。按照惯例，这个类的名字应当以“Attribute”作为后缀（并非必须）。
2. 按照上一节的方式应用AttributeUsage特性。如果该特性无须属性或有参数构造器，工作就到此为止了。
3. 编写一个或者多个公有构造器。这些构造器的参数定义了该特性的预留参数。这些参数在使用特性时必须提供。
4. 为每一个命名参数声明公有字段或者属性。在使用该特性时，这些命名参数都是可选的。

在运行时检索特性的方法有两种：

- 调用Type或者MemberInfo的GetCustomAttributes方法。
- 调用Attribute.GetCustomAttribute或者Attribute.GetCustomAttributes方法。

第二项中的方法拥有两个重载，它们可以接受任何特性支持的反射对象（Type、Assembly、Module、MemberInfo或者ParameterInfo）。

若将一个成员加载到只反射上下文中，则无法调用该成员的GetCustomAttributes方法。这是因为该操作会实例化特定类型的特性（注意，只反射上下文中不允许进行对象的实例化）。

### 19.5 动态生成代码

System.Reflection.Emit命名空间包含了可以在运行时创建元数据和IL的类型。动态生成代码对于特定的编程任务是非常重要的。例如正则表达式API就是一个好例子。它会将正则表达式转换为高性能的类型。

DynamicMethod类是位于System.Reflection.Emit命名空间的一个轻量级工具类。该类可以在运行时生成方法。与TypeBuilder不同，它不需要首先创建包含该方法的程序集、模块和类型。这个特点使其非常适用于完成简单的任务。

评估栈（Evaluation Stack）是IL的核心概念。如果要调用含有参数的方法，则需要首先将这些参数推入（“加载”）评估栈中，而后调用该方法。而相应的方法会从评估栈上弹出所需的参数。

IL中没有while、do和for循环结构。它们都是使用标签、相等goto与条件goto语句实现的。分支操作码包括Br（无条件分支）、Brtrue（如果评估栈中的值为true则分支）和Blt（如果第一个值小于第二个值则分支）。

### 19.6 生成程序集和类型

尽管DynamicMethod非常方便，但是它毕竟只能生成方法。如果我们需要生成其他结构或者一个完整的类型，就需要使用完全的“重量级的”API了。这意味着我们需要以动态方式构建程序集和模块。这些程序集无须加载到磁盘上，它们会完全存储在内存中。

这些工作可以由Assem-blyBuilder和ModuleBuilder类型完成。

我们无法将类型添加到一个现存的程序集中。因为程序集一旦创建就不可变了。

### 19.7 生成类型成员

和实例化DynamicMethod相似，在调用DefineMethod方法时也可以指定返回类型和参数类型。

生成实例方法时需要在调用DefineMethod时指定MethodAttributes.Instance。

如果要定义类型的子类，则请在定义方法时指定MethodAttributes.HideBySig。HideBySig可确保C#风格的方法隐藏语义。即，如果子类使用相同签名的方法，则隐藏基类的相应方法。如果不指定HideBySig，则方法只会根据名称进行隐藏。因此子类型中的Foo(string)将隐藏基类中的Foo()方法，而这种行为并不是我们期望的。

若需要创建字段，可调用TypeBuilder的DefineField方法，并指定字段名称、类型和可见性。

而创建属性和索引器则需要额外的几个步骤。首先需要调用TypeBuilder上的De-fineProperty方法，并指定属性的名称和类型。

下一步则是编写get和set方法。

调用TypeBuilder的DefineConstructor方法就可以创建自定义的构造器了。

使用SetCustomAttribute和CustomAttributeBuilder就可以向动态结构中附加自定义特性。

### 19.8 生成泛型方法和类型

要生成泛型方法需要进行如下操作：
1．调用MethodBuilder的DefineGenericParameters方法来获得一个Generic-TypeParameterBuilder对象的数组。
2．使用上述泛型类型参数调用MethodBuilder的SetSignature方法。
3．如果需要，还可以为这些参数命名。

### 19.9 复杂的生成目标

复杂的生成目标

### 19.10 解析IL

调用MethodBase对象的GetMethodBody方法就可以获得现有方法的内容信息。该函数将返回MethodBody对象，该对象拥有检查方法的局部变量、异常处理子句、栈长度以及原始IL的一系列属性。而获得原始IL的属性和Reflection.Emit的过程正好相反。

解析代码的原始IL对于代码分析是非常重要的。一个简单的用途就是在程序集更新后探测其中的哪些方法发生了改变。
为了展示如何进行IL解析，我们将书写一个类似ildasm的反汇编IL的应用程序。这个工具可以作为代码分析工具或者更高级的语言反汇编器的基础。

## 第20章 动态编程

在本章我们将首先简要介绍DLR，进而介绍如下动态编程模式：

- 数值类型统一
- 动态成员重载的解析
- 自定义绑定（实现动态对象）
- 动态语言互操作性

本章使用的类型位于System.Dynamic命名空间中。但CallSite<>除外，它位于System.Runtime.CompilerService命名空间中。

### 20.1 动态语言运行时

C#依赖动态语言运行时（Dynamic Language Runtime, DLR）执行动态绑定。

与其名称的意义相反，DLR并非CLR的动态版本。确切地说，它是建立在CLR之上的库，就像是System.Xml.dll这种库一样。它的主要任务是为静态类型语言和动态类型语言提供统一的动态编程运行时服务。因此诸如C#、VB、IronPython和IronRuby等语言都可以用相同的协议来动态调用函数。这允许这些语言共享库并调用其他语言编写的代码。

Framework 4.0是第一个带有DLR的Framework版本。在此之前的版本则需要单独从Codeplex下载DLR。

### 20.2 数值类型统一

有趣的是C#可以允许static和dynamic关键字相邻出现！而关键字internal和extern也可以相邻出现。

### 20.3 动态成员重载解析

以动态类型参数调用静态已知的方法会将方法重载的解析从编译时推迟到运行时。这种方式可以解决特定的编程问题，例如简化访问者设计模式（Visitor）的实现。它还可以用来突破一些由C#静态类型化带来的限制。

本质上，访问者模式允许向一个类层次结构中添加方法而无须更改现有类的代码。尽管这种模式用处很广，但是和其他设计模式相比，其静态形式微妙而反直觉。该模式还要求被访问的类提供Accept方法以获得更加友好的访问性。若这些类并非由我们控制则很难实现这一点。

而使用动态绑定则简单得多，而且无须更改已经存在的类。

C#严格的静态类型约束是一把双刃剑。一方面，它确保了程序在编译时具有一定的正确性；另一方面，它偶尔会导致某些情况难以甚至无法用代码表达，以至于必须求助于反射。在这些情况下，使用动态绑定往往是比反射更清晰也更快捷的方法。

### 20.4 实现动态对象

对象可以实现IDynamicMetaObjectProvider来提供绑定语义。而更简单的方式是从DynamicObject类派生。DynamicObject提供了对该接口的默认实现。

DynamicObject的另一个简单应用就是编写一个动态类，能够在以字符串为键的字典中，存储和检索对象，然而ExpandoObject已经提供了这个功能。

### 20.5 与动态语言进行互操作

尽管C#支持使用dynamic关键字进行动态绑定，但是它无法在运行时执行字符串中描述的表达式

真正的动态语言，例如IronPython和IronRuby却是允许执行任意字符串，而且该功能对于一些任务（例如编写脚本、动态配置以及实现动态规则引擎）是非常重要的。因此，虽然大部分的应用也许是用C#编写的，但是对于上述任务调用动态语言则更加有效。而且在.NET库中没有对等功能时，使用动态语言的API也许是更加有效的办法。

## 第21章 安全

本章将介绍.NET最主要的两个安全组件：

- 身份和角色安全（授权）
- 加密

其中，身份和角色安全决定了应用程序中谁（who）可以干什么事情（what）。而加密API则是为了存储/交换高价值的数据，并防止窃听，检测篡改，生成单向散列值以存储密码以及创建数字签名。我们还会讨论如何处理操作系统安全，以及遗留代码访问安全（Code Access Security, CAS），即限制代码可以执行的操作。

### 21.1 代码访问安全性

代码访问安全性允许CLR创建封闭的或称为沙盒（sandboxed）的环境，以避免执行具有特定操作的代码（例如，读取操作系统文件、执行反射或者创建用户界面）。由CAS引用的沙盒环境又称为部分受信（partial trust）环境。而普通的未受限制的环境称为完全受信（full trust）环境。

从2015年开始，Microsoft不再将CAS认定为实现安全边界的机制了（而CAS的大部分内容都已经从.NET标准2.0中移除了）。

不依赖CAS的沙盒仍然是有效的：UWP应用就是在沙盒中运行的，而SQL CLR库亦然。这些沙盒的安全性是由操作系统或者宿主CLR来保证的。这种机制不但易于理解和维护，而且比CAS沙盒要健壮得多。此外，操作系统安全性还支持非托管代码，因此不论UWP应用是使用C#还是C++进行开发，都不能读写任意的文件。

### 21.2 身份和角色安全

身份和角色安全主要用于授权（authorization）操作。该操作一般在中间层服务器或ASP. NET应用程序中执行。所谓授权即根据授权的用户名称（身份）或者角色（组）对其功能进行限制。


身份和角色安全性依赖于权限（permission）。

手动实例化权限对象，并调用其Demand方法来进行安全性验证。这种安全性称为命令式安全性（imperative security）。除了这种形式之外，我们还可以在方法、构造器、类、结构体或者程序集上附加特性来实现相同的效果，这称为声明式安全性。

虽然命令式安全性更加灵活，但声明式安全性也有三个优点：

- 所需代码更少
- 允许CLR提前确定程序集所需的权限
- 可以改善性能

### 21.3 操作系统安全性

操作系统可以进一步根据登录用户的权限规范应用程序的行为。在Windows中，有两类账户：

- 管理员账户：可以无限制地对本地计算机进行访问。
- 权限受限账户：无法执行管理员功能，无法查看其他用户的数据。

从Windows Vista开始引入的用户账户管理功能（User Account Control, UAC）可以令管理员在登录时持有两个令牌（“帽子”）：一个是管理员，另一个是普通用户。默认情况下，应用程序将以普通用户，即权限受限状态执行。如果应用程序请求管理员权限提升（administrative elevation），则必须首先在弹出的对话框中进行授权。

对于开发者来说，由于UAC的影响，应用程序默认将以受限的用户权限执行。因而有两种处理方式：

- 在开发应用程序时确保它可以在非管理员权限下执行。
- 在应用程序清单中请求管理员权限提升。

第一个选项不但安全而且方便用户使用。在大多数情况下，确保程序可以在非管理员权限下执行并不困难：这种限制比那些典型的代码访问安全性（CAS）沙盒的限制要少得多。

标准Windows用户账户无法执行如下的操作：
- 在以下的目录下写入文件：
-  操作系统目录（一般是\Windows）及其子目录
-  程序文件目录（\Program Files）及其子目录
-  操作系统所在驱动器的根目录（例如C:\）
-  在注册表的HKEY_LOCAL_MACHINE分支下写入数据
-  读取性能监视（WMI）数据

普通用户（甚至是管理员用户）可能无法访问属于其他用户的资源或者文件。Windows使用访问控制列表（Access Control List, ACL）系统来保护此类资源。我们可以使用System.Security.AccessControl命名空间下的类型来查询或者断言当前用户在ACL中的权限。ACL还可以附加在跨进程的等待句柄中。

在大多数情况下，我们可以采用如下方式处理标准用户权限限制：
-  将文件存储在推荐的位置。
-  避免使用注册表信息（HKEY_CURRENT_USER分支除外，标准用户拥有读写该分支的读写权限），可以将这些信息存储在文件中。
-  请在安装过程中注册ActiveX或者COM组件。

应用程序清单可以在程序启动时请求Windows操作系统向用户弹出管理员权限提升对话框。

### 21.4 加密概述

.NET Framework中System.Security.Cryptography.Xml命名空间内的类型对创建和验证基于XML的签名提供了支持。同时System.Security.Cryptography. X509Certificates命名空间对数字证书提供了支持。

### 21.5 Windows数据保护

Windows数据保护可以在攻击者获得计算机完全访问权限后仍提供中等程度的安全保护。而保护的强度取决于用户密码的强度。

### 21.6 散列法

散列法提供了一种单向加密的方式。这种方式非常适用于在数据库中存储密码。因为我们无须（也不希望）提供解密的信息。在登录验证时，只需简单地将用户的输入进行散列，并和数据库中存储的散列值进行比较即可。
由于散列码的长度不会随着源数据的长度而变化，因此可用于文件比较和数据流错误检查（和校验码非常类似）。源数据中任意一个位的变化都能够使散列码发生巨大的变化。

MD5和SHA256是.NET Framework中从HashAlgorithm派生的子类。

算法的长度越短运算的速度越快。MD5的运算速度比SHA512快20多倍，因此非常适用于计算文件的校验和。MD5算法可以每秒钟加密数百兆字节的数据，并将其存储在一个Guid中（Guid恰好也是16字节长，并且作为一个值类型比字节数组更易于处理。例如，我们可以直接用相等运算符比较两个Guid的值。）但同时，越短的散列算法发生碰撞（两个不同的文件会生成相同的散列码）的概率越大。

如果要存储密码或其他高安全等级的敏感数据，请至少使用SHA256。MD5和SHA1在这种情形下是不安全的。MD5和SHA1仅适用于防止意外的破坏，而无法防御故意的篡改行为。

可以通过重复散列的方式来加长密码散列值的长度，从而提供更强的保护。

一种防止字典攻击的技术是在加密过程中引入“盐”，即由随机数生成器生成的一长串字节，并在散列之前将其并入密码中。这样做可以通过两种途径来对抗攻击者：首先，这需要更长的计算时间，其次，攻击者无法访问“盐”字节的值。

### 21.7 对称加密

对称加密算法在加密和解密时使用相同的密钥。Framework提供了四种对称加密算法。这些算法中Rijndael算法是最优秀的。Rijndael即快速又安全。

对加密密钥进行硬编码是不可取的，因为使用常见的工具就可以将程序集反编译为可读代码。一个更好方案是在每一次安装时制作一个随机密钥，并使用Windows数据保护来安全地存储它（或者使用Windows数据保护加密整条消息）。如果要加密消息流，则公钥加密仍然是目前的最佳选择。

### 21.8 公钥加密和签名

公钥加密是非对称的，因此加密和解密需要使用不同的密钥。
对称加密的密钥可以是一串长度合适的任意字节串。但非对称加密则需要专门制作一对密钥。这个密钥对包含一个公钥和一个私钥。它们将一起完成如下工作：
-  公钥加密消息
-  私钥对消息进行解密
制作密钥对的一方会保证私钥的安全，而将公钥自由分发。这种加密技术的特点在于无法仅通过公钥而计算出私钥。因此，如果私钥丢失就无法解密了。相反，如果私钥泄露了，那么加密系统也就无法起到保护作用了。

公钥加密算法要求加密的信息小于密钥的长度，因此更适合于加密少量的数据（例如对称加密的密钥）。如果试图加密的数据长度大于密钥长度的一半，则会抛出异常。

.NET Framework提供了很多非对称加密算法。其中RSA算法最为流行。

公钥算法可以对消息或文档进行数字签名。签名与散列值类似，但是这个散列值会用私钥进行加密从而防止伪造，而公钥则用来验证这个数字签名。

## 第22章 高级线程处理

在第14章中，作为任务和异步操作的基础，我们介绍了线程的基本知识。具体地说，我们介绍了如何启动/配置线程，介绍了线程池、阻塞、自旋和同步上下文的基本概念。我们还介绍了锁和线程安全性，展示了最简单的信号发送结构：ManualResetEvent。

本章将介绍前面没有涉及的线程概念。

主要涵盖：
-  非排它锁（Semaphore和读写锁）
-  所有的信号发送结构（AutoResetEvent、ManualResetEvent、CountdownEvent和Barrier）
-  延迟初始化（Lazy<T>和LazyInitializer）
-  线程本地存储（ThreadStaticAttribute、ThreadLocal<T>和GetData/SetData方法）
-  抢占式线程方法（Interrupt、Abort、Suspend和Resume）
-  定时器

### 22.1 同步概述

同步（synchronization）是指协调并发操作，得到可以预测的结果的行为。同步在多个线程访问相同的数据时显得尤为重要，但这种操作很容易出现问题。

最简单的但是也是最实用的同步工具是第14章介绍的延续（continuation）和任务组合器。延续和任务组合器将并发程序构造为异步操作，减少了对锁和信号发送的依赖。但即便如此，很多时候我们仍然需要依赖那些同步底层结构。

同步结构可以分为三类：
-  排它锁：排它锁每一次只允许一个线程执行特定的活动或一段代码。它的主要目的是令线程访问共享的写状态而不互相影响。排它锁包括lock、Mutex和SpinLock。
-  非排它锁：非排它锁实现了有限的并发性。非排它锁包括Semaphore（Slim）和ReaderWriterLock（Slim）。
-  信号发送结构：这种结构允许线程在接到一个或者多个其他线程的通知之前保持阻塞状态。信号发送结构包括ManualResetEvent（Slim）、AutoResetEvent、CountdownEvent和Barrier。前三者就是所谓的事件等待句柄（event wait handles）。

一些结构在不使用锁的前提下也可以（巧妙的）处理特定的共享状态的同步操作，称为非阻塞同步结构（nonblocking synchronization constructs）。它们包括Thread. MemoryBarrier、Thread.VolatileWrite、volatile关键字和Interlocked类。

### 22.2 排它锁

排它锁结构有三种：lock语句、Mutex和SpinLock。其中lock是最方便，最常用的结构。而其他两种结构多用于处理特定的情形。
-  Mutex可以跨越多个进程（计算机范围锁）。
-  SpinLock可用于实现微优化。它可以在高并发场景下减少上下文切换

C#的lock语句是包裹在try/finally语句块中的Monitor.Enter和Monitor. Exit语法糖

Monitor还提供了TryEnter方法来指定一个超时时间（以毫秒为单位的整数或者一个TimeSpan值）。如果在指定时间内获得了锁，则该方法返回true，如果超时并且没有获得锁，该方法返回false。

若一个对象在各个参与线程中都是可见的，那么该对象就可以作为同步对象。但是该对象必须是一个引用类型的对象（这是必须满足的条件）。同步对象通常是私有的（因为这样便于封装锁逻辑），而且一般是实例字段或者静态字段。

锁本身不会限制同步对象的访问功能。即x.ToString()不会因为其他线程调用了lock(x)而被阻塞。只有两个线程均执行lock(x)语句才会发生阻塞。

使用锁的基本原则是：若需要访问可写的共享字段，则需要在其周围加锁。即便对于最简单的情况（例如对某个字段进行赋值），也必须考虑进行同步。

如果不使用锁，则可能出现两个问题：
-  诸如变量自增这类操作并不是原子操作，甚至变量的读写，在某些情况下也不是原子操作。
-  为了提高性能，编译器、CLR乃至处理器都会调整指令的执行顺序并在CPU的寄存器中缓存变量值。只要这种优化不会影响单线程程序的（或者使用锁的多线程程序的）行为即可。
使用锁可以避免第二个问题。因为锁会在其前后创建内存栅障（memory barrier），内存栅障就像是这些操作的围栏，而指令执行顺序的重排和变量缓存是无法跨越这个围栏的。

如果使用同一个锁对一组变量的读写操作进行保护，那么可以认为这些变量的读写操作是原子的（atomically）。

指令级（instruction）原子性与原子操作是有些相似但本质不同的概念：只有当指令以不可分割的方式在底层处理器上执行时，才是原子操作。

在使用嵌套锁时，只有最外层的lock语句退出时（或者执行相同数目的Monitor.Exit时）对象的锁才会解除。

两个线程互相等待对方占用的资源就会使双方都无法继续执行，从而形成死锁。

标准托管环境下的CLR和SQL Server不同，它不会自动检查和处理死锁（强制终止其中一个线程）。除非指定超时时间，否则线程死锁将致使线程永久阻塞。（SQL Server的CLR集成托管环境则不同，它会自动检测死锁，然后在其中的一个线程抛出一个可捕获的异常。）

一段代码可能锁定了x类对象中的私有a字段，但却无法得知调用者（甚至调用者的调用者）已经锁定了y类对象中的b字段。同时，另外一个线程则按相反的顺序执行了锁定，而结果就造成了死锁。讽刺的是，（良好的）面向对象的设计模式会加剧这个问题，因为这些设计模式会创建只有在运行时才能够确定的调用链。

因此最常见的建议是“使用一致的顺序锁定对象以避免死锁”。

当锁定一个对象的方法调用时，务必警惕该对象是否持有当前对象的引用。

使用更高级的同步手段，例如任务的延续/组合器、数据并行、不可变类型（本章稍后会进行介绍）都可以减少对锁的依赖。

锁的操作是很快的：2015年生产的计算机在没有出现竞争的情况下一般可以在50纳秒内获取或者释放锁。如果在竞争的情况下，则相应的上下文切换开销将增加到微秒级。但即便如此，这个时间也可能小于线程实际的调度时间。

Mutex和C#的lock类似，但是它可以支持多个进程。换言之，Mutex不但可以用于应用程序范围，还可以用于计算机范围。在非竞争的情况下获得或者释放Mutex需要大约一微秒的时间，大概比lock要慢20倍。


Mutex类的WaitOne方法将获得该锁，ReleaseMutex方法将释放该锁。Mutex只能在获得锁的线程释放锁。

如果直接调用Mutex的Close或Dispose方法，但不调用ReleaseMutex，则所有等待该Mutex的线程都将抛出。AbandonedMutexException异常。

跨进程Mutex的一个常见用途是保证一次只能够运行一个应用程序的实例。

如果应用程序运行在终端服务下，则一个计算机范围的Mutex仅对同一个终端服务会话是可见的。如果想令其对所有终端服务可见，则需要在其名称中使用“Globa\”前缀。


### 22.3 锁和线程安全性

如果应用程序或方法可以在任意多线程的场景下正确执行，那么它就是线程安全的。线程安全主要是通过锁以及减少线程间的交互性实现的。

通用类型很少是完全线程安全的。因为：
-  完全线程安全的实现难度很大，特别是当类型拥有多个字段的时候（每一个字段都有在任意多线程上下文中进行交互的潜在可能性）。
-  线程安全会增加性能开销（该开销与类型是否被多个线程使用有部分关系）。
-  使用线程安全的类型并不能保证程序是线程安全的。通常，在后者的实现过程中反而无须使用线程安全的类型。
因此，线程安全性通常只在需要的地方实现，以处理特定的多线程场景。

有一些方法可以“神奇”地令一些大型复杂的类在多线程的环境上安全地执行。其中之一是通过牺牲粒度，将一大部分的代码（甚至是整个对象）都包裹在一个排它锁中，来保证顶层的序列访问性。这个策略在多线程上下文下使用非线程安全的第三方代码时（或者相关的大部分Framework类型时）非常奏效。其实现方式是用相同的排它锁保护不具备线程安全性对象的所有属性、方法和字段的访问。当对象的方法执行速度很快时效果尤其突出（反之则会造成大量的阻塞）。

除了基元类型之外，.NET Framework的类型在实例化后，除并发的只读访问之外，很少是线程安全的。而保证线程安全性是开发者的责任，一般都是通过排它锁实现的。

另一种“巧妙的”降低线程间交互的方法就是减少共享数据。

最后一种实现线程安全性的方法是使用自动锁机制。

锁可以将非线程安全的代码变为线程安全的代码。.NET Framework本身就应用了这种方式：几乎所有的非基元类型在实例化之后（除了只读访问之外）都不是线程安全的。但只要对该对象的所有访问都被锁保护起来，那么它就可以用在多线程代码中了。

有时，即使访问线程安全的对象也需要使用锁。

只有将整个if语句都包裹在一个锁中，才能防止判断包含关系的语句和添加元素的语句之间插入其他操作。不仅如此，任何修改列表的代码都必须添加相同的锁才行。

将对象的访问包裹在自定义锁中这种方式只有在所有的线程都会访问并使用这个锁的情况下才有效。如果对象的适用范围很广则情况就变得不同了。最坏的情况就是公有类型的公有静态成员了。

例如，假设DateTime结构体的DateTime.Now静态属性不是线程安全的，两个并发调用可能会导致错误的输出或抛出异常。那么使用外部锁的唯一方式就是在调用DateTime.Now之前锁定类型对象本身：lock(typeof(DateTime))。但这样做的前提是所有的程序员都同意使用这种方式（通常是不可能的）。此外，在类型上加锁本身也存在一些问题。

因此，DateTime的所有静态成员都小心地进行了实现以确保它们都是线程安全的。而这种模式在整个.NET Framework中都得到了广泛的应用：静态成员是线程安全的，而实例成员则不具备线程安全性。在编写公共消费的类型时，应尽量遵守这个规范，以防止难以实现线程安全的情况。即，确保静态成员的线程安全性，为使用该类型的代码实现线程安全性提供了保障。

静态方法的线程安全性是必须显式实现的。静态方法本身不会自动实现线程安全性。

若类型对（可能的）并发只读访问是线程安全的，则它就具有很大的优势。因为在消费这个类的时候可以避免过度使用锁。许多.NET Framework的类型都遵守了这个原则。例如，集合的并发读操作都是线程安全的。

只读线程安全性也是将枚举器和可枚举对象分离的原因之一：两个线程可以同时枚举一个集合，因为它们分别使用了独立的枚举器对象。

应用服务器需要多个线程来处理并发的客户端请求。WCF、ASP.NET和Web Service应用程序本身就是多线程的。而使用网络通道（例如TCP或HTTP）的Remoting服务应用程序也是多线程的。这意味着，编写服务器代码时，如果处理客户端请求的线程间有可能发生交互，就必须考虑线程安全性。幸好，这种可能性很低。一个典型的服务器类要么是无状态的（没有字段），要么其激活模型会为每一个客户端的每一个请求创建一个独立的对象实例。而交互通常只发生在静态字段上。有时是为了将部分数据库缓存在内存中来改善性能。

不可变对象指内部和外部状态都不会发生变化的对象。不可变对象的字段通常都声明为只读，而且全部在构造时初始化。

不可变性是函数式编程的特点，它不修改对象，而是创建一个带有不同属性的新对象。LINQ就采用了这种编程范式。由于不可变性不会共享可写的状态，即去除（或减少了）写入操作，因此它非常适用于多线程环境。

不可变性的一种应用模式是将一组相关的字段封装为一个不可变对象以减少锁的持有时间。

### 22.4 非排它锁

信号量（semaphore）就像俱乐部一样：它有特定的容量，还有门卫保护。一旦满员之后，就不允许其他人进入了，人们只能在外面排队。每当有人离开时，才准许另外一个人进入。信号量的构造器需要至少两个参数：即俱乐部当前的空闲容量，以及俱乐部的总容量。

容量为1的信号量和Mutex和lock类似，但是信号量没有持有者这个概念，它是线程无关的。任何线程都可以调用Semaphore的Release方法。Mutex和lock则不然，只有持有锁的线程才能够释放锁。

信号量有两个功能相似的实现：Semaphore和SemaphoreSlim。后者是在.NET Framework 4.0引入的。它进行了一些优化以适应并行编程对低延迟的需求。此外，它也适用于传统的多线程编程，因为它可以在等待时指定一个取消令牌（请参见14.6.1）。此外，它还提供了WaitAsync方法以进行异步编程，但是它不能用于进程间通信。

Semaphore在调用WaitOne和Release方法时大概会消耗1微秒的时间，而Sem-aphoreSlim的开销只有前者的十分之一。


命名的Semaphore和Mutex一样是可以跨进程使用的。


通常，一个类型实例的并发读操作是线程安全的，而并发更新操作则不然（并发读和更新也不是线程安全的）。诸如文件这样的资源也具有相同的特点。虽然可以简单地使用一个排它锁来保护对实例的任何形式的访问，但是如果其读操作很多但更新操作很少，则使用单一的锁限制并发性就不太合理了。这种情况常出现在业务应用服务器上，它会将常用的数据缓存在静态字段中进行快速检索。ReaderWriterLockSlim是专门为这种情形进行设计的，它可以最大限度地保证锁的可用性。

ReaderWriterLockSlim是在.NET Framework 3.5中引入的。它替代了笨重的ReaderWriterLock类。虽然后者具有相似的功能，但是它比前者的执行速度慢数倍，并且其本身存在一些锁升级处理机制的设计缺陷。

与常规的lock（Monitor.Enter/Exit）相比ReaderWriterLockSlim的执行速度仍然慢一倍，但是它可以在大量的读操作和少量写操作的环境下减少锁竞争。

ReaderWriterLockSlim和ReaderWriterLock都拥有两种基本的锁，即读锁和写锁：
-  写锁是全局排它锁
-  读锁可以兼容其他的读锁
因此，一个持有写锁的线程将阻塞其他任何试图获取读锁或写锁的线程（反之亦然）。但是如果没有任何线程持有写锁的话，那么其他任意数量的线程都可以并发获得读锁。

有时最好能在一个原子操作中将读锁转换为写锁。

一个可升级锁就像读锁一样，但是它可以在随后通过一个原子操作升级为一个写锁。以下是其使用方式：

1. 调用EnterUpgradableReadLock。
2. 执行读操作（例如，判断该元素是否已经存在于列表中）。
3. 调用EnterWriteLock（该操作将可升级锁转化为写锁）。
4. 执行基于写的操作（例如，将该元素添加到列表中）。
5. 用ExitWriteLock（将写锁转换回可升级锁）。
6. 执行其他读操作。
7. 调用ExitUpgradableReadLock。


可升级锁和读锁还有一个重要的区别：虽然可升级锁可以和任意数目的读锁并存，但是一次只能获取一个可升级锁。这可以将锁的升级竞争序列化从而避免在升级中出现死锁，这和SQL Server中的更新锁是一致的。

ReaderWriterLock同样提供了锁转换。但这种转换并不可靠，因为它不支持可升级锁。这正是ReaderWriterLockSlim对此重新进行设计的原因。

递归锁的基本原则是，一旦获得了锁，后续的递归锁级别可以更低，但不能更高。其等级顺序如下：

读锁→可升级锁→写锁

### 22.5 使用事件等待句柄发送信号

最简单的信号发送结构是事件等待句柄（event wait handles）。注意它和C#的事件是无关的。事件等待句柄有三种实现：AutoResetEvent、ManualResetEvent(Slim)和CountdownEvent。前两种基于通用的EventWaitHandle类，它们继承了基类的所有功能。

AutoResetEvent就像验票机的闸门一样：插入一张票据只允许一个人通过。其名称中的Auto指的是开放的闸机在行人通过后会自动关闭或重置。线程可以调用WaitOne方法在闸机门口等待、阻塞（在“一个”闸机前等待，直至闸机门开启）。调用Set方法即向闸机中插入一张票据。如果有一系列的线程调用了WaitOne，那么它们会在闸机后排队等待￼。票据可以来自任何线程，即任何一个能够访问AutoResetEvent对象的非阻塞线程都可以调用Set方法来释放一个阻塞的线程。

在没有任何线程等待的情况下调用Set方法会导致句柄一直处于打开状态，直至有线程调用了WaitOne方法。这种行为可以避免即将到达闸机前的线程和插入票据的线程产生竞争（不好，票据插入的时间早了一微秒，那现在只能一直等待了）。但是在一个没有线程等待的闸机对象上重复调用Set方法不会导致多个到达的线程一次性通过；只有下一个线程可以通过，而其他的票据就被“浪费”了。

假设主线程需要向工作线程连续发送三次信号。如果主线程单纯地连续调用Set方法若干次，那么第二次或者第三次发送的信号就有可能丢失，因为工作线程需要时间来处理每一次的信号。

其解决方案是主线程等待工作线程准备就绪之后再发送信号。这可以通过引入另一个AutoResetEvent来实现

如第14章所述，ManualResetEvent的作用就像是一个大门。调用Set方法就开启大门，并允许任意数目的调用WaitOne方法的线程通过大门。而调用Reset方法则会关闭大门。在大门关闭时调用WaitOne方法会发生阻塞。而当大门再次打开时，线程会立刻释放。除这些区别之外，ManualResetEvent的功能和AutoResetEvent是一样的。

在无阻塞的情况下等待或者激活一个AutoResetEvent或者ManualResetEvent对象需要消耗一微秒的时间。

在短暂的等待中，ManualResetEventSlim和CountdownEvent的速度要快50倍。因为它们不依赖操作系统，并且谨慎地使用了自旋结构。

在大多数情况下，信号发送类本身的开销并不会形成瓶颈，因此很少需要特意进行考虑。

ManualResetEvent适用于用一个线程来释放其他所有线程的情形，而Countd-ownEvent则适用于相反的情形。

CountdownEvent可用于等待多个线程。该类是在.NET Framework 4.0引入的，并同样具有高效的纯托管实现。若使用该类，需要在实例化时指定线程数目或者需要等待的线程“计数”。

调用Signal会使计数递减；而调用Wait则会阻塞，直至计数减为零。

EventWaitHandle构造器可以创建命名的实例以支持跨进程的操作。该名称是一个普通的字符串，只要该名称不与其他的命名实例冲突，其内容可以为任何值。如果该名称已经被计算机的其他命名实例使用了，那么将返回同一个EventWaitHandle的引用；否则操作系统将创建一个新的实例。

如果不希望等待一个句柄从而阻塞线程，还可以调用ThreadPool.RegisterWait-ForSingleObject方法来将一个延续操作附加在等待句柄上。这个方法接受一个委托对象，并会在句柄收到信号时执行。

除了Set、WaitOne和Reset方法，WaitHandle类还具有一些执行复杂同步操作的静态方法。其中WaitAny、WaitAll和SignalAndWait方法可以对多个句柄执行信号发送或者等待操作。而具体的等待句柄可以是不同的类型（包括Mutex、Semaphore，它们均派生自WaitHandle类）。对于ManualResetEventSlim和Countdown-Event也可以通过其WaitHandle属性使用这些方法。

WaitHandle.WaitAny可以等待一组句柄中的任意一个句柄；WaitHandle.WaitAll可以用原子的方式等待所有给定的句柄。

SignalAndWait方法会调用其中一个WaitHandle的Set方法，而后调用另一个WaitHandle的WaitOne方法。在第一个等待句柄信号发送之后，它会转而跳到等待第二个句柄的队列头部以尽可能地使等待成功（但这个过程并非是原子操作）。这个方法就像从一个信号“切换”到另一个信号。如果在一对EventWaitHandle上使用该方法就可以令两个线程在同一时刻汇合。

### 22.6 Barrier类

Barrier类实现了一个线程执行屏障（thread execution barrier）。它允许多个线程在同一时刻汇合。这个类的执行速度很快，非常高效。它是基于Wait、Pulse和自旋锁实现的。

使用这个类的步骤如下：
-  创建Barrier实例。指定参与汇合的线程的数量（此后还可以调用AddPartici-pants/RemoveParticipants方法对这个数量进行更改）。
-  当需要汇合时，在每一个线程上都调用SignalAndWait。

### 22.7 延迟初始化

从.NET Framework 4.0开始引入了Lazy<T>类，该类实现了延迟初始化（lazy initialization）功能。如果实例化时以true为参数，则它就会使用上例中线程安全的初始化模式。

Lazy<T>实际上还在锁上进行了微小的优化，称为“双检锁”（doublech-ecked lock）。双检锁执行一次volatile读操作，避免在对象初始化后进行锁操作。

LazyInitializer是一个静态类。它和Lazy<T>工作方式很像，但是也有以下不同点：
-  它直接使用静态方法操作自定义类型的字段。这样做可以避免引入一个间接层次，从而提高性能。它适用于一些需要极致优化的场合。
-  它提供了另一种初始化模式，多个线程可以竞争实例化过程。

### 22.8 线程本地存储

有时反而需要将数据隔离，保证每一个线程都有一个独立的副本。局部变量就可以实现这个目标，但它们仅适合保存临时数据。

另一个方案是使用线程本地存储（thread-local storage）。实际上，隔离到每一个线程上的数据本质上就是临时数据。这可能有些难以想象。但是其主要用途就是存储“过程外”数据，并作为执行路径的基础设施，例如消息、事务、安全令牌等。如果将这些数据以方法参数的形式进行传递则代码就会非常难看，因为几乎每一个方法都需要接受它们。而如果将这种数据存储在静态字段中那么它又可以被所有的线程共享而失去独立性。

线程本地存储还可用于对并行代码进行优化。它允许每一个线程无须使用锁就可以独立访问属于该线程的（非线程安全）对象。同时它无须在（同一线程的）方法调用过程中重建这个对象。

但是，线程本地存储并不适合在异步代码中使用，因为有一些延续可能会运行在之前的线程上。

实现线程本地存储的方法有三种。

实现线程本地存储最简单的方式是在静态字段上附加ThreadStatic特性。

ThreadLocal<T>是.NET Framework 4.0中新增的类型。它对静态和实例字段都提供了线程本地存储支持，并允许指定默认值。

第三种实现线程本地存储的方式是使用Thread类的GetData和SetData方法。这些方法会将数据存储在线程独有的“插槽”（slot）中。Thread.GetData负责读取线程独有的数据存储中读取数据，而Thread.SetData则向其中写入数据。这两个方法都需要使用LocalDataStoreSlot对象来获得这个插槽。所有的线程都可以获得相同的插槽，但是它们的值却是互相独立的。

Thread.FreeNamedDataSlot方法将释放所有线程中的命名插槽。但需要注意的是，只有当LocalDataStoreSlot对象的所有引用都已经在作用域之外并被垃圾回收时插槽才会释放。这确保了当线程需要特定数据插槽时，只要它保留了正确的LocalDataStoreSlot对象的引用，那么相应的数据插槽就不会丢失。

### 22.9 Interrupt和Abort方法

Interrupt方法和Abort方法可以主动操作其他线程。其中Interrupt方法基本没有特别合适的使用场景，而Abort也只有很少的适用场景。

Interrupt方法强制释放处于阻塞状态的线程，同时在相应的线程上抛出Thread-InterruptedException。如果相应的线程并未处于阻塞状态，则线程会继续执行直至遇到下一个阻塞状态，届时将抛出ThreadInterruptedException。Interrupt用处不大，这是因为相应的场景在大部分情况下都可以使用信号发送结构或取消令牌（甚至Abort方法）来妥善解决。此外，这个方法从本质上也有一定的危险性。因为我们无法确切得知会在何处强制解除阻塞状态（例如，它有可能会在.NET Framework框架内部解除阻塞）。

Abort会尝试强行中止其他线程，并在相应线程上立即抛出ThreadAbortException（非托管代码除外）。ThreadAbortException是一种非常特殊的异常。它可以被捕获，但是在catch代码块的末尾会被重新抛出（即一直会试图中止该线程）。若需要阻止这种行为，则可以在catch代码块内调用Thread.ResetAbort方法。（在此期间，线程的ThreadState为AbortRequested。）


未处理的ThreadAbortException是唯一两种不会导致应用程序关闭的异常之一（另一种异常是AppDomainUnloadException）。

### 22.10 Suspend和Resume方法

Suspend和Resume方法可以冻结或解冻其他线程。冻结线程表面上就像阻塞一样，但它们是不同的（它们具有不同的ThreadState属性值）。和Interrupt一样，Suspend/Resume方法缺少有效的用例，并且也有潜在的危险性。如果我们挂起了一个持有锁的线程，则其他线程（包括自己创建的线程）就无法获得锁了，这令程序更容易发生死锁。因此，Suspend和Resume方法在.NET Framework 2.0就被废弃了。

### 22.11 定时器

如果需要定期重复执行一些方法，最容易的方式就是使用定时器。

.NET Framework提供了四种定时器，两种定时器是通用多线程定时器：
-  System.Threading.Timer
-  System.Timers.Timer
另外两种则是特殊用途的单线程定时器：
-  System.Windows.Forms.Timer（Windows Forms应用的定时器）
-  System.Windows.Threading.DispatcherTimer（WPF的定时器）
多线程定时器更加强大，定时精确，使用灵活；而对于定期更新Windows Forms或WPF界面元素的简单任务来说，单线程定时器更加安全方便。

System.Threading.Timer是最简单的多线程定时器：它只有一个构造器和两个方法

.NET Framework在System.Timers命名空间中提供了另外一个同名定时器类。它简单包装了System.Threading.Timer，在相同底层引擎的基础上提供了额外的易用性。以下总结了它的附加功能：
-  实现了IComponent接口，允许嵌入到Visual Studio设计器的组件托盘中。
-  提供了Interval属性替代Change方法。
-  提供了Elapsed事件取代回调委托。
-  提供了Enabled属性来开始和停止计时器（默认值为false）。
-  如果不习惯使用Enabled属性还可以使用Start和Stop方法。
-  提供了AutoReset标志，用于指示重复的事件（默认值为true）。
-  提供了SynchronizingObject属性。可调用该对象的Invoke和BeginInvoke方法安全地调用WPF元素和Windows Forms控件的方法。

.NET Framework专门为WPF和Windows Forms提供了不需要考虑线程安全性的定时器：
-  System.Windows.Threading.DispatcherTimer（WPF）
-  System.Windows.Forms.Timer（Windows Forms）

## 第23章 并行编程

本章将介绍多线程API和可以发挥多核处理器能力的各种结构：
-  并行LINQ或称PLINQ
-  Parallel类
-  任务并行（task parallelism）结构
-  并发集合类型
这些类型是在.NET Framework 4.0时引入的。一般统称为并行框架（Parallel Framework, PFX）。Parallel类和任务并行结构统称为任务并行库（Task parallel Library, TPL）。


### 23.1 选择PFX的原因

充分发挥多核心的优势对于大多数服务器应用程序来说非常容易。因为服务器应用程序的每一个线程都可以独立处理客户端的请求。但是这对于桌面程序就比较困难了，因为要发挥多核优势，桌面应用程序通常需要对计算密集型的代码进行如下的处理：

1. 将代码划分为多个小块

2. 通过多线程并行执行这些小块代码。
3. 以线程安全和高效的方式在计算完毕后整理出最终的结果。

尽管可以使用传统的多线程结构来实现这些功能，但是难度很高，尤其是划分和整理的过程。一个更深层次的问题是，当很多线程同时使用同一块数据时，若采用通常的锁来保证线程安全性会造成大量的竞争。  

PFX库正是专门为这些情况而设计的。

通过编程发挥多核或多处理器优势的方式称为并行编程（parallel program-ming）。它是多线程这个更宽泛概念的一个子集。

在线程间划分工作的策略有两种：数据并行（data parallelism）和任务并行（task par-allelism）。

当一组任务需要处理很多的数据值时，我们可以令每一个线程以相同的方式处理一部分数据值。这称为数据并行（data parallelism）。即我们将数据在线程间进行了划分。而相对的，任务并行（task parallelism）则是划分任务，即每一个线程处理不同的任务。

一般而言，数据并行更为简单而且在高度并行化的硬件条件下扩展更容易，因为这种方式降低或者彻底消除了共享数据（从而解决了竞争和线程安全问题）。同时，通常情况下数据要比分散的任务要多得多，而数据并行正好可以应对这一点。

数据并行也有助于实现结构化并行（structured parallelism），即并行工作单元在程序中的启动和结束点都是一致的。而相比之下，任务并行往往是非结构化的，意味着并行工作单元的启动和结束可能分散在程序中的各个地方。因此结构化并行更加简单，更不易出错，而且还可以将任务划分和线程协调（甚至结果整理）等高难度工作交给库去完成。

上层结构由两种结构化数据并行API组成：PLINQ和Parallel类。下层架构则由任务并行类和辅助并行编程活动的结构组成。

PFX主要用于并行编程，即利用多核处理器来加速计算密集型代码的执行速度。

利用多核处理器的挑战之一是Amdahl定律，根据这个定律，并行化的最大性能改进取决于必须顺序执行的代码的占比。例如，如果一种算法的执行时间只有三分之二是可以并行化的，那么无论使用多少个内核其性能绝不会超过三倍。

### 23.2 PLINQ

PLINQ可以自动并行化本地LINQ查询。易于使用是PLINQ的优势，因为它将工作划分和结果整理的任务交给了Framework。
要使用PLINQ只需直接在输入序列上调用AsParallel()方法，而后和先前一样编写普通的LINQ查询即可。

AsParallel是System.Linq.ParallelEnumerable类的一个扩展方法，它将输入包装为一个以ParallelQuery<TSource>为基类的序列，这样，后续的LINQ查询运算符就会绑定到由ParallelEnumerable定义的另外一套扩展方法上。这些扩展方法为每一种标准查询运算符提供了并行化实现

调用AsSequential()会将ParallelQuery序列包装解除，后续的查询运算符将会重新绑定到标准查询运算符上并顺序执行。这在调用有副作用或者非线程安全的代码之前是非常必要的。

对于接受两个输入序列的运算符而言（Join、GroupJoin、Concat、Union、Intersect、Except和Zip），必须在两个输入序列上都调用AsParallel()方法（否则会抛出异常）。但不需要在查询时在中间再次应用AsParallel方法。因为PLINQ的运算符的输出是另一个ParallelQuery序列。

PLINQ仅仅适用于本地集合：它不支持LINQ to SQL或者Entity Framework。因为它们都会将LINQ翻译为SQL并在数据库服务器上执行。但是在获得数据库查询结果之后就可以使用PLINQ对这些结果集进行本地查询了。

和普通的LINQ查询一样，PLINQ也是延迟计算的。即只有当消费结果时（一般通过foreach循环，也可以调用像ToArray这种转换运算符，或者返回单一元素或值的运算符）才会触发查询执行。

PLINQ无法像LINQ那样保持序列的原始顺序。

如果需要保持序列的原始顺序，则必须在AsParallel()之后调用AsOrdered()方法

调用AsUnordered可以在稍后的查询中抵消AsOrdered的效果：它会引入“随机洗牌点”从而使查询更高效地执行。

找到现有的LINQ查询，并将其并行化这种想法看起来非常诱人。但通常这是不现实的，因为对于大多数问题，LINQ本身就是最佳方案，它们执行速度非常快，根本无法从并行化中再获得任何好处。因此一个更好的策略是找到大量使用CPU的瓶颈并考虑是否可以将其转换为LINQ查询。（这种结构改变还有一个好处，即LINQ往往会令代码变得更小巧，更易读。）

PLINQ十分适合于解决易于并行的问题，但是它可能并不适合进行图像处理。因为将上百万个像素整理为输出序列本身可能就是一个瓶颈。但是，若使用Parallel类或者任务并行来管理多线程运算，而直接将像素写入输出序列或者非托管内存块则可能会产生更好的结果。

默认情况下，PLINQ会根据处理器的情况选择最合适的并行级别。如需修改这个设置，可在AsParallel方法之后调用WithDegreeOfParallelism方法。

若在foreach循环中消费PLINQ查询的结果，则只需要跳出foreach循环查询就会自动取消，因为其枚举器会被隐式销毁。对于以转换、元素类操作以及聚合操作运算符终止的查询，可使用取消令牌在另一个线程中取消该操作（请参见14.6.1节）。如需使用取消令牌，则应在调用AsParallel方法之后，调用WithCancellation方法；并以CancellationTokenSource对象的Token属性值作为参数。另一个线程可以调用CancellationTokenSource对象的Cancel方法。

ForAll方法会在每一个ParallelQuery的输出元素上运行一个委托。该方法会直接嵌入PLINQ内部，跳过整理和枚举步骤。

PLINQ在无须任何其他操作的情况下就可以将Sum、Average、Min、Max运算符有效并行化。而Aggregate运算符却给PLINQ带来了特殊的挑战。

对于不指定种子的聚合操作而言，所提供的委托必须满足交换性和结合性。如果不满足这个规则，则PLINQ就会得出错误的结果。这是因为PLINQ需要为输入序列生成多个种子，从而可以同时从多个分块序列中进行聚合。
显式提供种子的聚合在PLINQ中看起来是一种更安全的选择，但是，由于对于单个种子的依赖，这种查询会顺序执行。为了解决这个问题，PLINQ提供了另外一种Aggregate重载。我们可以在这种重载中指定多个种子，更确切地说是一个种子的工厂函数。每一个线程都会执行这个函数来生成一个独立的种子，这些种子会成为线程本地的累加器对本地元素进行聚合操作。

这个重载需要四个委托，以下按照顺序列出了这四个委托：
-  seedFactory：返回一个新的本地累加器
-  updateAccumulatorFunc：将元素聚合到一个本地累加器中
-  combineAccumulatorFunc：将本地累加器与主累加器结合
-  resultSelector：在最终的结果上应用任意的转换

### 23.3 Parallel类

PFX在Parallel类中提供了三个静态方法作为结构化并行的基本形式：
-  Parallel.Invoke方法：并行执行一组委托。
-  Parallel.For方法：执行与C# for循环等价的并行方法。
-  Parallel.ForEach方法：执行与C#的foreach循环等价的并行方法。
这三个方法都会阻塞线程直到所有工作完成为止。和PLINQ一样，在出现未处理异常之后，其他的工作线程将会在它们当前的迭代完成之后停止，并将异常包装为AggregateException抛出给调用者（请参见23.5节）

和PLINQ一样，Parallel.*方法是针对计算密集型任务而不是I/O密集型任务进行优化的。

Parallel.For和Parallel.ForEach分别等价于C#中的for和foreach循环，但是每一次迭代都是并行而非顺序执行的。

通常，同时将内层和外层循环并行化是没有必要的。

由于并行的For或ForEach的循环体是一个委托，因此我们无法使用break语句提前结束循环。但是可以调用ParallelLoopState对象的Break方法或者Stop方法来跳出或者结束循环。

Parallel.For和Parallel.ForEach方法均提供了一组接受TLocal泛型类型参数的重载，这些重载方法可帮助优化密集迭代循环过程中的结果整理工作。

### 23.4 任务并行

任务并行是PFX中最底层的并行化方式。相关的类型定义在System.Threading.Tasks命名空间中。

第14章介绍了任务的基础。在本节我们将着重介绍并行编程中的高级任务特性。它们是：
-  调整任务调度方式
-  从一个任务中启动另一个任务，并确认其父/子关系
-  延续的高级使用方式
-  TaskFactory

任务调度器负责将任务分配到线程上。任务调度器是由抽象类TaskScheduler表示的。.NET Framework提供了两个具体的任务调度器的实现：与CLR的线程池协同工作的默认调度器，和同步上下文调度器。其中后者（主要）是为了和WPF以及Windows Forms这样的线程模型（这种线程模型规定界面元素或控件的访问操作只能在创建它们的线程中执行。请参见14.2.11节）共同工作而设计的。它会捕获同步上下文，并令任务或延续在这个上下文上执行。

也可以从TaskScheduler派生子类，编写自定义的任务调度器。只有在非常特定的情况下才会编写任务调度器，而对于一般的自定义调度，使用TaskCompletionSource就足够了。


访问Task.Factory静态属性将返回一个默认的TaskFactory对象。TaskFactory的作用是创建任务，更确切地说是以下三种任务：
- “普通”任务（调用StartNew）
-  具有多个前导任务的延续任务（调用ContinueWhenAll与ContinueWhenAny）
-  将符合异步编程模型（APM）的方法包装为任务（调用FromAsync。请参见14.7节）
另一种创建任务的方法是实例化一个Task对象而后调用Start。但是，这样只能创建一个“普通”任务，而不是延续任务。


### 23.5 处理AggregateException

PLINQ、Parallel类和Task会自动将异常封送给消费者。这个操作是必不可少的。

AggregateException通常会包含其他的AggregateException。例如，当子任务抛出异常的时候就会出现这种情况。调用Flatten方法可以消除任意层级的嵌套以简化处理过程。这个方法会返回一个新的AggregateException对象，并包含展平的内部异常列表。

### 23.6 并发集合

.NET Framework 4.0在System.Collections.Concurrent命名空间下引入了一系列新的集合。所有这些集合都是完全线程安全的

并发集合对高并发场景进行了优化。但是它们也可以单纯作为一般的线程安全的集合使用（替代用锁保护的一般集合）。但是使用时需要注意：
-  传统集合在非并发场景下的性能要高于并发集合。
-  线程安全的集合并不能保证使用它们的代码是线程安全的。（请参见15.2.5节）
-  在枚举并发集合时，如果另一个线程更新了集合的内容，不会抛出任何异常。相反的，我们会得到一个新旧内容混合的结果。
-  List<T>没有对应的并发集合。
-  ConcurrentStack、ConcurrentQueue和ConcurrentBag类型内部是使用链表实现的。因此，其内存利用不如非并发的Stack和Queue高效。但是它们适用于并发访问，因为链表更容易实现无锁算法或者少锁的算法。（这是因为在链表中插入一个节点只需要更新几个引用，而在一个类似List<T>的结构中插入一个元素可能需要移动数以千计的现有元素。）

并发集合和传统集合的另一个不同在于并发集合提供了原子的检测并执行操作，例如TryPop。其中大部分方法是通过IProducerConsumerCollection<T>接口统一起来的。

生产者/消费者集合主要有两种使用场景：
-  添加一个元素（“生产”）
-  检索一个元素并删除它（“消费”）

其中TryAdd和TryTake方法会测试添加和删除操作是否可以执行，如果可以则执行该操作。测试和执行是以原子方式执行的，因此无须像传统集合那样在操作时加锁。

TryTake方法在集合为空的情况下会返回false。TryAdd在现有的三个实现类中都必定成功，并返回true。但如果自定义的集合不允许出现重复元素（例如并发的集合），则该方法应在欲添加元素已经存在的情况下返回false。
不同类型的TryTake方法执行的操作也各有差异：
-  对于ConcurrentStack类型，TryTake会删除最近添加的元素。
-  对于ConcurrentQueue类型，TryTake会删除最早添加的元素。
-  对于ConcurrentBag类型，哪个元素删除效率最高，TryTake方法就会删除那个元素。
以上三个具体类型都显式实现了TryTake和TryAdd方法，并用更加特定的公有方法来提供相应的功能，例如TryDequeue和TryPop。


ConcurrentBag<T>是一个无序的对象集合（而且集合中允许出现重复的对象）。如果我们不关心调用Take或者TryTake时所获得的元素的顺序，就可以使用Concu-rrentBag<T>类。

ConcurrentBag<T>不适于实现生产者/消费者队列，因为元素的添加和移除操作是在不同的线程间执行的。

### 23.7 BlockingCollection<T>类

使用BlockingCollection<T>的步骤如下：

1. 创建阻塞集合的实例，（可选）指定需要包装的IProducerConsumerCollection<T>与集合的最大元素数目（边界）。
2. 调用Add或者TryAdd方法在底层集合上添加元素。
3. 调用Take或者TryTake从底层集合中移除（消费）元素。

如果集合大小有界，那么Add和TryAdd会在集合大小到达边界时阻塞；而Take和TryTake会在集合为空时阻塞。

生产者/消费者队列是一种实用的结构，适用于并行编程或一般的并发编程场景。其工作原理是：
-  创建一个队列用于描述工作项目，或存储工作项目所处理的数据。
-  当需要执行一项工作时，调用者将其插入队列，并继续执行其他操作。
-  后台的若干（一个或者多个）工作线程从队列中取出工作项目并执行相应工作。

生产者/消费者队列可以精确地控制同时运行的工作线程数目，这有助于控制CPU和其他资源的开销。例如，如果任务需要执行密集的磁盘I/O操作，控制并发性就可以有效避免操作系统和其他应用程序出现饥饿的情况。此外，我们可以在队列的生命周期动态添加或移除工作线程。CLR的线程池本身就是一个生产者/消费者队列，并特别针对短时计算密集型任务进行了优化。

## 第24章 应用程序域

应用程序域（application domain）是相互隔离的运行时单元。.NET应用程序就是在这种单元中运行的。它提供了一个托管内存边界，一个用来保存加载的程序集和应用程序配置的容器以及分布式应用程序的通信边界。

每一个.NET进程通常只有一个应用程序域：默认域。默认域是在进程启动时由CLR自动创建的。有时根据需要，还可以在同一个进程创建额外的应用程序域。这种方式不仅提供良好的隔离性，而且可以避免多进程的开销和进程间通信的复杂性。因此适用于负载测试、应用程序补丁等情形；还可以用其实现健壮的错误恢复机制。

本章不适用于UWP和.NET Core应用程序。这两类应用程序只能访问唯一的一个应用程序域。

### 24.1 应用程序域的架构

在大多数情况下，例如当用户双击.NET可执行文件时或者启动一个Windows服务时，承载应用程序域的进程是由操作系统隐式创建的。但是应用程序域也可以托管在其他进程中，例如IIS进程或者通过CLR集成托管在SQL Server进程中。

### 24.2 创建和销毁应用程序域

在进程中，可以分别调用静态方法AppDomain.CreateDomain和AppDomain.Unload来创建和销毁附加应用程序域。

当默认的应用程序域（在启动时由CLR创建的应用程序域）销毁时，所有其他的应用程序域也会自动销毁，进而应用程序关闭。访问AppDomain的IsDefaultDomain属性就可以确定一个应用程序域是否是默认应用程序域。

### 24.3 使用多个应用程序域

多应用程序域主要用于以下场景：
-  以最小的系统开销提供类似于进程间的独立性。
-  在不重新启动进程的情况下卸载程序集。

### 24.4 DoCallBack方法

在新的应用程序域上调用ExecuteAssembly方法虽然非常方便，但无法和应用程序域进行交互。同时，被调用目标程序集必须是可执行的，以便向调用者提供自身的唯一入口点。该方案只能通过字符串参数与可执行程序进行交互。

AppDomain的DoCallBack方法是另外一种多应用程序域的方案，这种方案功能更加强大。它可以在另外一个应用程序域执行指定类型的指定方法。指定的类型将自动加载到相应的应用程序域上（如果当前应用程序域已经引用了这个程序集，则CLR就一定能找到它。）。

### 24.5 监视应用程序域

从.NET Framework 4.0开始就可以监视特定应用程序域的内存和CPU使用状况了。

### 24.6 应用程序域和线程

调用另一个应用程序域中的方法和调用当前应用程序域的方法一样，也会阻塞执行，直至方法运行结束。虽然一般情况下这种行为是符合预期的，但是有时也会遇到需要进行并发执行的场景。我们可以通过多线程编程来解决这个问题。

### 24.7 在应用程序域间共享数据

应用程序域可以通过命名的“槽”（slot）来共享数据。

与其他应用程序域进行通信的最灵活的方式是通过代理在其他应用程序域中实例化对象。这种方式称为Remoting。

## 第25章 原生程序和COM组件互操作性

本章将介绍如何在程序中集成原生（非托管）DLL和COM组件。除非特别说明，本章所提到的类型均位于System或者System.Runtime.InteropServices命名空间中。

### 25.1 调用原生DLL

P/Invoke是平台调用服务（Platform Invocation Services）的简称。它可以访问非托管DLL中的函数、结构以及回调函数。

例如，Windows DLL中的user32.dll定义了MessageBox函数：

int MessageBox (HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);在C#中，可以使用extern关键字和DllImport特性将上述函数声明为一个同名的静态方法，即可在程序中直接调用。

CLR包含了一个封送器（marshaler），它可以将参数和返回值在.NET类型和非托管类型间进行转换。

### 25.2 类型的封送

在非托管代码中给定的数据类型可能有多种表示方法。例如，一个字符串可以包含单字节的ANSI字符，也可以包含双字节的Unicode字符；可能带有长度前缀，可能以null结尾，或者为固定长度。CLR的封送器可以从MarshalAs特性中得知这些变化，从而在封送时正确进行转换。

C语言和C#中对象的字段均位于从对象的起始地址的第n个字节上。而不同点在于在C#中，CLR会通过字段的令牌查找其偏移量，而C语言会将字段的名称直接编译为偏移量。

### 25.3 非托管代码中的回调函数

P/Invoke层尽可能在相关的结构间进行映射，以保持边界两侧编程模型的自然。C#不但可以调用C函数，还可以（通过函数指针）作为C函数的回调函数。P/Invoke层可以将非托管函数指针映射为C#的委托（C#中和函数指针最接近的结构）。

### 25.4 模拟C共用体

struct中的每一个字段都会分配足够的空间来存储它的每一个数据。假设一个struct包含一个int和一个char。则int很可能位于偏移量为0的位置，并且其长度至少为4个字节，char则位于偏移量为4的位置。如果出于某种原因，char类型的数据位于偏移量为2的位置，则对char数据赋值就会破坏int数据的值。这听上去是不是不可思议？但是C语言中确实存在支持这种变化的结构，称为共用体（union）。C#语言则使用LayoutKind.Explicit和FieldOffset特性来模拟这种结构。

### 25.5 共享内存

内存映射文件，或称为共享内存，是Windows在本机进行多进程数据共享的方式。共享内存非常迅速，它没有Remoting和WCF的通信开销；和管道不同，它支持随机访问共享的数据。

Win32函数CreateFileMapping用于分配共享内存。该函数需要指定需要分配的大小和共享内存的名称。另一个应用程序可使用OpenFileMapping函数以相同的名称订阅该共享内存。这两个方法都会返回一个句柄，并可以使用MapViewOfFile函数转换为一个指针。

### 25.6 将结构体映射到非托管内存中

如果结构体的StructLayout特性是Sequential或者Explicit的话，则该结构体可以直接映射到非托管内存区。

使用fixed关键字可以直接在结构体中定义定长的值类型内联数组。同时，需要将相应的代码放入unsafe区域。

请大胆使用指针：C++程序员在整个应用程序的开发中都会使用它，并借助它们完成各种功能。在大多数情况下，使用指针是相对简单的。

### 25.7 COM互操作性

从第一个版本开始，.NET运行时就对COM进行了特殊的支持。可以在.NET中使用COM对象，反之亦然。在C# 4.0中，对COM的支持空前提升，在可用性和部署方面都进行了大量改进。

COM是组件对象模型（Component Object Model）的简写。它有Microsoft于1993年发布的一个二进制标准API。COM的设计初衷是令各个组件在语言无关的环境下互相通信，并提供一定的版本兼容性。在COM之前，Windows中要实现这些功能必须发布动态链接库（Dynamic Link Library, DLL），并使用C语言的方式声明结构和函数。这种方式和语言绑定在一起，并且非常脆弱。库中类型的规格和其实现是紧密联系的，即使添加一个字段也会破坏这个规格。

COM的优点是可以通过COM接口将底层实现与其类型规格分离。COM还能够调用有状态对象的方法，而不仅仅限于简单的过程调用。

COM类型系统是以接口为中心的。COM接口和.NET接口类似，但是使用范围更广，这是因为COM类型只能通过接口暴露其功能。

当我们需要添加一个重载Test方法时，COM要比.NET复杂得多。首先，不得直接更改IFoo接口，因为这样做会破坏上一个版本的二进制兼容性（COM的一个原则是，接口一旦发布就不可变）。其次COM不支持方法重载。因此，需要令Foo实现第二个接口。

所有的COM接口都使用GUID作为标识。

COM中的根接口为IUnknown接口，所有的COM对象必须实现这一接口。这个接口有三个方法：

- AddRef方法

- Release方法

- QueryInterface方法

AddRef方法和Release方法管理COM对象的生命周期。COM使用引用计数的方式控制着对象的生命周期，并不具备自动垃圾回收功能（COM是为非托管代码设计的，无法进行自动垃圾回收）。QueryInterface方法会在对象支持的情况下返回相应接口的对象的引用。

为了实现动态编程（例如脚本和自动化）, COM对象往往还会实现IDispatch接口。该接口允许类似VBScript等动态语言通过延迟绑定的方式简单地调用COM对象，其行为和C#中的dynamic相似。

### 25.8 在C#中调用COM组件

CLR内置了对COM的支持。因此只需直接使用CLR对象，运行时就会将各类调用通过运行时可调用包装器（Runtime-Callable Wrappers, RCW）传递给COM，无须直接操作IUnknown和IDispatch接口。运行时还会自动调用AddRef和Release方法（在对象终结过程中调用）来管理对象生命周期；并恰当地进行基本类型的转换。这些类型转换确保了数据可以被双方正确理解。

### 25.9 内嵌互操作类型

一般情况下，C#通过互操作类型调用COM组件，而互操作类型是用tlbimp.exe工具（直接使用该工具，或通过Visual Studio）生成的。

曾经，我们只能像引用其他程序集那样引用互操作程序集。但这种方式非常麻烦，因为复杂COM组件互操作程序集可能会非常大。例如，若要开发一个Microsoft Word的小插件，则它引用的互操作程序集可能要比插件本身大好几个量级。

从C# 4.0开始，除了引用互操作程序集之外，还可以链接到互操作程序集上。当链接到互操作程序集时，编译器会对其进行分析并找到应用程序真正使用的类型和成员，进而将这些类型和成员的定义直接嵌入到应用程序中。因此，无须再为巨大的互操作程序集而担忧了，因为应用程序只会包含那些真正使用的COM接口。

### 25.10 主互操作程序集

在C# 4.0之前，由于没有互操作链接和类型等价的概念，因此若两个开发者分别运行tlbimp.exe工具对同一个COM组件生成互操作程序集，那么这两个互操作程序集就是不兼容的。这种行为大大降低了互操作性。而解决方案是由COM库的作者生成一个官方的互操作程序集，称为主互操作程序集（Primary Interop Assembly, PIA）。

### 25.11 在COM中调用C#对象

在COM中消费C#对象也是可行的。这种操作是CLR通过一种COM可调用的封装器（COM-callable Wrapper, CCW）来实现的。CCW会在两种环境中封送相关类型（和RCW类似），并实现COM协议所需的IUnknown接口（有时还会实现IDispatch接口）。CCW的生命周期是在COM一侧通过引用计数来管理的，并不由CLR端的垃圾回收器控制。

## 第26章 正则表达式

正则表达式语言可以识别各种字符模式。.NET中的正则表达式基于Perl 5的正则表达式，并支持搜索和替换功能。

### 26.1 正则表达式基础

量词符号是正则表达式最常用的运算符之一。？表示匹配运算符前的项目0次或者1次。换句话说，？表示可选的项目。所谓项目，可以是单个字符，也可以是放在方括号之内的由多个字符构成的复杂结构。

Regex.Match方法可以在一个大型字符串内进行搜索。其返回的对象的属性既包含了匹配部分所在的Index（位置）和Length（长度），还包含了具体的匹配值Value。

从.NET Framework 4.5开始，正则表达式支持在匹配操作中指定超时时间。如果匹配操作超出了指定的时间间隔（TimeSpan）就会抛出RegexMatch-TimeoutException。如果应用程序需要处理任意的正则表达式（例如，在高级搜索对话框中）则务必使用该参数以防止一些恶意的正则表达式导致的无限计算。

RegexOptions枚举可以控制正则表达式匹配的行为。

Regex的Escape方法可以将包含元字符的字符串替换为转义形式，Unescape方法则正好相反。

本章中所有的正则表达式均使用了@修饰符。该修饰符会忽略C#的转义机制（同样也是使用反斜线字符）。如果不使用@运算符，则正则表达式中的反斜线字面量需要用四个反斜线字符表示。

正则表达式中的字符集合是一系列字符的通配符。

### 26.2 量词符号

量词符号匹配特定次数的项目。

在默认情况下，量词符号都是贪婪，而不是懒惰的。贪婪量词符号会尽可能多地匹配重复项目。而懒惰的量词符号则尽可能少地进行匹配。若在量词符号后添加？后缀，就可以将任何量词符号转换为懒惰的。

### 26.3 零宽度断言

正则表达式语言允许在匹配的前后设置约束条件。这些条件包括后向条件（lookbehind）、前向条件（lookahead）、锚点（anchors）以及单词边界（word boundaries）。由于它们并不会增加匹配字符的长度，因此这些条件称为零宽度断言（zero-width assertions）。

(? =expr)结构可用于检查后续的文本是否与expr匹配，而expr本身并不作为结果的一部分。这种条件称之为正前向条件。

与正前向条件相反的是负前向条件结构(? ! expr)。该条件表示匹配后不能跟随出现expr。

(? <=expr)结构代表正后向条件，它要求匹配之前要出现指定表达式表示的内容。与其相反，(? <! expr)表示负后向条件。它要求匹配之前不能够出现指定表达式的内容。

锚点（anchor）^和$代表确定的位置。默认的：
-  ^匹配字符串的开头
-  $匹配字符串的结束

^符号根据上下文的不同有两种不同的含义：一种含义是锚点；另一种含义是为字符类否定修饰符。

同样的$符号根据上下文的不同也有两种不同的含义：一种含义是锚点；另一种含义是替换组的标志。


单词边界断言\b匹配与一个或者多个单词字符（\w）毗邻的位置。这些位置
-  要么是非单词字符（\W）
-  要么是字符串的开始和结尾（^和$）

### 26.4 分组

有时需要将正则表达式分成一系列子表达式或分组（groups）。

可以通过圆括号来分组捕获

### 26.5 替换并分割文本

Regex.Replace方法和string.Replace方法的功能类似，只不过前者将使用正则表达式执行查找。

替换字符串可以通过$0作为替代结构访问原始的匹配。

通过\$1、\$2、\$3以此类推就可以访问任意捕获的分组。对于命名分组则可以通过\${name}的方式进行访问。

Replace方法拥有一个重载方法。其中使用了MatchEvaluator委托作为参数。这个参数每一次匹配都会调用一次，并使用C#代码生成替换字符串。当正则表达式语言无法有效表示替换的逻辑时使用这种方式是非常有效的。

Regex.Split方法是比string.Split方法功能更强的静态方法。它使用正则表达式来表示分隔符的模式。

## 第27章 Roslyn编译器

C# 6及其后续版本的编译器是完全由C#编写的，称为“Roslyn”编译器。该编译器遵循模块化设计，因此除了将代码编译为可执行程序或者程序库之外，还可应用于其他场景。它的出现大大简化了编写静态代码分析和重构工具、具有语法高亮功能和自动完成功能的代码编辑器以及编写能够理解C#代码的Visual Studio插件的难度。

### 27.1 Roslyn架构

Roslyn架构将编译过程分为三个部分：

1. 将代码解析为语法树（语法层）
2. 将标识符绑定到符号上（语义层）
3. 生成IL

在第一个阶段，解析器读入C#代码并输出语法树。语法树是一个文档对象模型（Document Object Model, DOM），它将源代码表示为树形结构。

第二阶段是C#静态绑定阶段。这个阶段将加载引用的程序集，编译器会执行绑定操作。例如，将Console绑定到mscorlib.dll的System.Console上。重载方法解析和类型引用也是这个阶段的工作。

第三阶将生成输出程序集。若仅使用Roslyn进行代码或重构分析则无须使用这部分功能。

Visual Studio的编辑器分别使用语法层的输出对代码中的关键字、字符串、注释以及禁用部分进行高亮展示（关键字将渲染为蓝色，字符串为红色，注释为绿色，禁用代码为灰色）；使用语义层的输出对类型名称进行渲染（青色）。

### 27.2 语法树

语法树是源代码的DOM。虽然语法树API和System.Linq.Expressions API（请参见8.10.2节）在概念上有相似之处，但是它们仍然是完全独立的。两种API都可以将C#表达式表示为DOM，其中Roslyn语法树有如下特性：
-  它可以表示整个C#语言的语法，而不限于表达式。
-  它可以包含注释、空格以及其他非关键的结构；因此能够完全还原原始源代码。
-  其ParseText方法可以直接将源代码解析为语法树。
而System.Linq.Expressions API有如下特性：
-  它是.NET Framework的一部分。同时，当C#编译器需要将Lambda表达式赋值转换为Expression<T>时也会生成System.Linq.Expression类型相关的代码。
-  表达式的Compile方法是一个快速轻量级的方法，其输出是一个委托；而编译Roslyn语法树的语义层只能够将完整的程序编译到程序集中，因此相比前者要沉重得多。

### 27.3 编译过程和语义模型

编译过程（compilation）是由语法树（syntax tree）、引用（reference）和编译选项（com-pilation options）构成的。它有两个目的：
-  将编译模型转换为程序库或者可执行程序（生成阶段）。
-  生成语义模型（sematic model）以提供符号信息（在绑定过程中可获得这些符号信息）。
语义模型在符号重命名、提供代码自动完成功能等过程中是十分关键的信息。

