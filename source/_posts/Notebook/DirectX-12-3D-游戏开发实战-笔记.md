---
title: 《DirectX 12 3D 游戏开发实战》笔记
index_img: https://cdn.jsdelivr.net/gh/bit704/blog-image-bed@main/image/2022-09-18-DX123D.jpg
banner_img: https://cdn.jsdelivr.net/gh/bit704/blog-image-bed@main/image/2022-09-18-DX123D.jpg
layout: post
categories: [Notebook]
tags: [DirectX]
---

原书作者 *Frank D. Luna*

<!-- more -->

Introduction to 3D Game Programming with DirectX 12

译者 王陈

人民邮电出版社

![封面](https://cdn.jsdelivr.net/gh/bit704/blog-image-bed@main/image/2022-09-18-DX123D_s.jpg)

### 前置说明

[配套代码地址](https://github.com/d3dcoder/d3d12book)

对书中第一个实例进行编译时可能遇到错误，可以参考[这篇文章](https://i-got-it.blog.csdn.net/article/details/112689870)

---



### 内容提要

本书适合希望通过Direct3D来学习3D编程的C++中级程序员阅读，也可供已对Direct3D有一定了解或具有非DirectX API使用经验的3D程序员参考。

### 预备知识

熟悉使用Win32 API进行Windows编程还是很有必要的，可谓是学习本书的基础。

### 使用DirectX SDK文档以及SDK示例

DirectX SDK在MSDN上的最新文档为《Direct3D 12 Programming Guide》，即《Direct3D 12编程指南》。

### 通过Visual Studio 2015安装演示项目

通过在源代码文件Common/d3dApp.h中使用#pragma预处理指令来链接所需的库文件，如：

```c++
#pragma comment(lib,"d3dcompliler.lib")
#pragma comment(lib,"D3D12.lib")
#pragma comment(lib,"dxgi.lib")
```

对于创建演示程序而言，该预处理指令使我们免于打开项目属性页面并在连接器配置项下指定附加依赖库。

尤其是到了Direct3D 12，更像Mantle等API那样实现了前所未有的更底层的硬件抽象，削减驱动层的工作，转交给开发者负责，从而令图形的处理流程更加“智能”，使用起来犹如贴地飞行的“快感”。

DirectX包罗系列与多媒体以及游戏开发有关的API，因此Direct3D只是DirectX的一个子集。详细信息请见《DirectX Graphics and Graming》（ee663274）。本书则侧重Direct3D的讲解。

### 第1章 向量代数

向量（vector）是一种兼具大小（也称为模，magnitude）和方向的量。具有这两种属性的量皆称为向量值物理量（vector-valued quantity）。

Direct3D采用的是左手坐标系（left-handed coordinate system）。如果我们伸出左手，并拢手指，假设它们指向的是x轴的正方向，再弯曲四指指向y轴的正方向，则最后伸直拇指的方向大约就是z轴的正方向。

*即勾股定理*

> 毕达哥拉斯定理

对于具有n个向量的一般集合而言，为了将其正交化为规范正交集，我们就要使用格拉姆—施密特正交化（Gram-Schmidt Orthogonalization）方法进行处理。

只有3D向量的叉积有定义（不存在2D向量叉积）

叉积所得的向量可以通过左手拇指法则来加以确认

对于Windows 8及其以上版本来讲，DirectXMath（其前身为XNA Math数学库，DirectXMath正是基于此而成）是一款为Direct3D应用程序量身打造的3D数学库，而它也自此成为了Windows SDK的一部分。该数学库采用了SIMD流指令扩展2（Streaming SIMD Extensions 2，SSE2）指令集。借助128位宽的单指令多数据（Single Instruction Multiple Data，SIMD）寄存器，利用一条SIMD指令即可同时对4个32位浮点数或整数进行运算。

对于希望了解如何开发一个优秀的SIMD向量库，乃至希望深入理解DirectXMath库设计原理的读者，我们在这里推荐一篇文章《Designing Fast Cross-Platform SIMD Vector Libraries（设计快速的跨平台SIMD向量库）》。


为了使用DirectXMath库，我们需要向代码中添加头文件#include <DirectXMath.h>，而为了一些相关的数据类型还要加入头文件#include <DirectXPackedVector.h>。除此之外并不需要其他的库文件，因为所有的代码都以内联的方式实现在头文件里。DirectXMath.h文件中的代码都存在于DirectX命名空间之中，而DirectXPackedVector.h文件中的代码则都位于DirectX::PackedVector命名空间以内。

针对x86平台，我们需要启用SSE2指令集（Project Properties（工程属性）→Configuration Properties（配置属性）→C/C++→Code Generation（代码生成）→Enable Enhanced Instructon Set（启用增强指令集））。对于所有的平台，我们还应当启用快速浮点模型/fp:fast（Project Properties（工程属性）→Configuration Properties（配置属性）→C/C++→Code Generation（代码生成）→Floating Point Model（浮点模型））。而对于x64平台来说，我们却不必开启SSE2指令集，这是因为所有的x64 CPU对此均有支持。

在DirectXMath库中，核心的向量类型是XMVECTOR，它将被映射到SIMD硬件寄存器。通过SIMD指令的配合，利用这种具有128位的类型能一次性处理4个32位的浮点数。在开启SSE2后，此类型在x86和x64平台的定义是：

```c++
typedef __m128 XMVECTOR;
```

这里的\__m128是一种特殊的SIMD类型（定义见xmmintrin.h）。在计算向量的过程中，必须通过此类型才可充分地利用SIMD技术。正如前文所述，我们将通过SIMD技术来处理2D和3D向量运算，而计算过程中用不到的向量分量则将它置零并忽略。

XMVECTOR类型的数据需要按16字节对齐，这对于局部变量和全局变量而言都是自动实现的。至于类中的数据成员，建议分别使用XMFLOAT2（2D向量）、XMFLOAT3（3D向量）和XMFLOAT4（4D向量）类型来加以代替。

1．局部变量或全局变量用XMVECTOR类型。

2．对于类中的数据成员，使用XMFLOAT2、XMFLOAT3和XMFLOAT4类型。

3．在运算之前，通过加载函数将XMFLOATn类型转换为XMVECTOR类型。

4．用XMVECTOR实例来进行运算。

5．通过存储函数将XMVECTOR类型转换为XMFLOATn类型。

为了使代码更具通用性，不受具体平台、编译器的影响，我们将利用FXMVECTOR、GXMVECTOR、HXMVECTOR和CXMVECTOR类型来传递XMVECTOR类型的参数。基于特定的平台和编译器，它们会被自动地定义为适当的类型。

一定要把调用约定注解XM_CALLCONV加在函数名之前，它会根据编译器的版本确定出对应的调用约定属性。

传递XMVECTOR参数的规则如下：

1．前3个XMVECTOR参数应当用类型FXMVECTOR；

2．第4个XMVECTOR参数应当用类型GXMVECTOR；

3．第5、6个XMVECTOR参数应当用类型HXMVECTOR；

4．其余的XMVECTOR参数应当用类型CXMVECTOR。

在编写构造函数时，前3个XMVECTOR参数用FXMVECTOR类型，其余XMVECTOR参数则用CXMVECTOR类型。另外，对于构造函数不要使用XM_CALLCONV注解。

XMVECTOR类型的常量实例应当用XMVECTORF32类型来表示。

即使在数学上计算的结果是标量（如点积），但这些函数所返回的类型依旧是XMVECTOR，而得到的标量结果则被复制到XMVECTOR中的各个分量之中。这样做的原因之一是：将标量和SIMD向量的混合运算次数降到最低，使用户除了自定义的计算之外全程都使用SIMD技术，以提升计算效率。

DirectXMath库也提供了一些估算方法，精度低但速度快。如果愿意为了速度而牺牲一些精度，则可以使用它们。

DirectXMath库提供了XMVector3NearEqual函数，用于以Epsilon作为容差，测试比较的向量是否相等

### 第2章 矩阵代数

行列式是一种特殊的函数，它以一个方阵作为输入，并输出一个实数。方阵A的行列式通常表示为det A。我们可以从几何的角度来解释行列式。行列式反映了在线性变换下，（[插图]维多面体）体积变化的相关信息。另外，行列式也应用于解线性方程组的克莱姆法则（Cramer’s Rule，亦称克莱默法则）。然而，我们在此学习行列式的主要目的是：利用它推导出求逆矩阵的公式（第2.7节的主题）。此外，行列式还可以用于证明：方阵A是可逆的，当且仅当detA不为0。这个结论很实用，因为它为我们确认矩阵的可逆性提供了一种行之有效的计算工具。

在3D图形学中，主要使用4X4矩阵。

存在逆矩阵的方阵称为可逆矩阵（invertiblematrix），不存在逆矩阵的方阵称作奇异矩阵（singular matrix）。

对于规模较小的矩阵（[插图]及其以下规模的矩阵）来说，运用伴随矩阵的方法将得到不错的计算效率。但针对规模更大的矩阵而言，就要使用诸如高斯消元法（Gaussian elimination，也作高斯消去法）等其他手段。由于我们关注于3D计算机图形学中所涉及的具有特殊形式的矩阵，因此也就提前确定出了它们的求逆矩阵公式。

XMMATRIX由4个XMVECTOR实例所构成，并借此来使用SIMD技术。

就像通过XMFLOAT2 (2D)，XMFLOAT3 (3D)和XMFLOAT4 (4D)来存储类中不同维度的向量一样，DirectXMath文档也建议我们用XMFLOAT4X4来存储类中的矩阵类型数据成员。

*应该是FXMMATRIX参数不超过2个*

> 假设传入函数的FXMVECTOR参数不超过两个，则第一个XMMATRIX参数应当为FXMMATRIX类型，其余的XMMATRIX参数均应为CXMMATRIX类型。

在32位Windows操作系统上的\__fastcall调用约定中，XMMATRIX类型的参数是不能传至SSE/SSE2寄存器的，因为这些寄存器此时只支持3个XMVECTOR参数传入。而XMMATRIX参数却是由4个XMVECTOR构成，所以矩阵类型的数据只能通过堆栈来加以引用。

DirectXMath建议用户总是在构造函数中采用CXMMATRIX类型来获取XMMATRIX参数，而且对于构造函数也不要使用XM_CALLCONV约定注解。

矩阵与其逆矩阵的乘积结果为单位矩阵。如果一个矩阵是可逆的，则此矩阵的逆矩阵是唯一的。只有方阵才可能有逆矩阵，即便是方阵也未必可逆。

### 第3章 变换

旋转矩阵有个有趣的性质：每个行向量都为单位长度且两两正交（请分别证明）。也就是说，这些行向量都是规范正交的（orthonormal，即互相正交且具有单位长度）。若一个矩阵的行向量都是规范正交的，则称此矩阵为正交矩阵（orthogonal matrix）。正交矩阵有个引人注目的性质，即它的逆矩阵与转置矩阵是相等的

仿射变换（affine transformation）是由一个线性变换与一个平移变换组合而成的。

在采用齐次坐标表示法时，我们将坐标扩充为四元组，其中，第四个坐标w的取值将根据被描述对象是点还是向量而定。具体来讲：1．(x,y,z,0)表示向量；2．(x,y,z,1)表示点。

设w=1能使点被正确地平移，设w=0则可以防止向量坐标受到平移操作的影响。

我们能够将一个改变几何体的复合变换（缩放、旋转和平移），解释为一种对应的坐标变换。由于我们以后通常要将世界空间（第5章）的坐标变换矩阵定义为缩放、旋转和平移操作组成的复合变换，所以了解这一点是很重要的。

我们通过4X4矩阵来表示变换，并利用1X4齐次坐标来描述点和向量：当把第4个分量设置为w=1时，表示点；设置为w=0时，则表示向量。这样一来，平移操作将只应用于点，而不会影响向量。

由于矩阵的乘法运算满足结合律，因此我们就能够将若干种变换矩阵合而为一。此矩阵给予物体的变换效果，与合成它的多个单一矩阵对物体按次序进行变换的净效果相同。

### 第4章 Direct3D的初始化

除了添加一些新的渲染特性以外，Direct3D 12经重新设计已焕然一新，较之上一个版本的主要改变在于其性能优化方面在大大减少了CPU开销的同时，又改进了对多线程的支持。为了达到这些性能目标，Direct3D 12的API较Direct3D 11更偏于底层。另外，API抽象程度的降低使它更趋于具体化，与现代GPU的构架也更为契合，因此也就促使开发者要付出比昔日更多的努力。当然，使用这种更复杂的API所得到的回报是：性能的提升。

组件对象模型（Component Object Model，COM）是一种令DirectX不受编程语言束缚，并且使之向后兼容的技术。

要获取指向某COM接口的指针，需借助特定函数或另一COM接口的方法——而不是用C++语言中的关键字new去创建一个COM接口。

COM对象会统计其引用次数；因此，在使用完某接口时，我们便应调用它的Release方法（COM接口的所有功能都是从IUnknown这个COM接口继承而来的，包括Release方法在内），而不是用delete来删除——当COM对象的引用计数为0时，它将自行释放自己所占用的内存。

Microsoft::WRL::ComPtr类（#include <wrl.h>），我们可以把它当作是COM对象的智能指针。

本书中常用的3个ComPtr方法如下。

1．Get：返回一个指向此底层COM接口的指针。此方法常用于把原始的COM接口指针作为参数传递给函数。

2．GetAddressOf：返回指向此底层COM接口指针的地址。凭此方法即可利用函数参数返回COM接口的指针。

3．Reset：将此ComPtr实例设置为nullptr释放与之相关的所有引用（同时减少其底层COM接口的引用计数）。此方法的功能与将ComPtr目标实例赋值为nullptr的效果相同。

COM接口都以大写字母“I”作为开头。例如，表示命令列表的COM接口为ID3D12GraphicsCommandList。

2D纹理（2D texture）是一种由数据元素构成的矩阵（可将此“矩阵”看作2D数组）。

有种称作法线贴图（normal mapping）的高级技术，其纹理内的每个元素存储的就是一个3D向量而不是颜色信息。

大写字母R、G、B、A分别表示红色（red）、绿色（green）、蓝色（blue）和alpha。所有的颜色都是由红、绿、蓝三基色组合而成（例如，红色和绿色混合成黄色）。alpha通道（或称为alpha分量）则通常用于控制透明度。

为了避免动画中出现画面闪烁的现象，最好将动画帧完整地绘制在一种称为后台缓冲区的离屏（off-screen，即不可直接呈现在显示设备上之意）纹理内。只要将指定动画帧的整个场景绘到后台缓冲区中，它就会以一个完整的帧画面展现在屏幕上；依照此法，观者便不会察觉出帧的绘制过程——而只会观赏到完整的动画帧。为此，需要利用由硬件管理的两种纹理缓冲区：即所谓的前台缓冲区（frontbuffer）和后台缓冲区（back buffer）。前台缓冲区存储的是当前显示在屏幕上的图像数据，而动画的下一帧则被绘制在后台缓冲区里。当后台缓冲区中的动画帧绘制完成之后，两种缓冲区的角色互换：后台缓冲区变为前台缓冲区呈现新一帧的画面，而前台缓冲区则为了展示动画的下一帧转为后台缓冲区，等待填充数据。前后台缓冲的这种互换操作称为呈现（presenting，亦有译作提交、显示等）。呈现是一种高效的操作，只需交换指向当前前台缓冲区和后台缓冲区的两个指针即可实现。

尽管后台缓冲区是一个纹理（因而构成纹理的基本元素又称纹素，texel），但我们仍常将其组成元素称为像素，因为就后台缓冲区这种情况而言，它所存储的内容是颜色信息。即便纹理中存储的不是颜色信息，大家有时也称纹理的元素为像素（如“法线图中的像素”）

深度缓冲区（depth buffer）这种纹理资源存储的并非图像数据，而是特定像素的深度信息。深度值的范围为0.0～1.0。0.0代表观察者在视锥体（view frustum，亦有译作视域体、视景体、视截体或视体等，意即观察者能看到的空间范围，形如从四棱锥中截取的四棱台，常称该形为平截头体（frustum，见图4.3，后文亦有详述））中能看到离自己最近的物体，1.0则代表观察者在视锥体中能看到离自己最远的物体。深度缓冲区中的元素与后台缓冲区内的像素呈一一对应关系（即后台缓冲区中第i行第j列的元素对应于深度缓冲区内第i行第j列的元素）。

这里要着重强调一个细节：若使用了深度缓冲，则物体的绘制顺序也就变得无关紧要了。

一个应用程序不一定要用到模板缓冲区。但一经使用，则深度缓冲区将总是与模板缓冲区如影随形，共同进退。例如，32位格式[插图]使用24位作为深度缓冲区，其他8位作为模板缓冲区。出于这个原因，深度缓冲区叫作深度/模板缓冲区更为得体。

在渲染处理的过程中，GPU可能会对资源进行读（例如，从描述物体表面样貌的纹理或者存有3D场景中几何体位置信息的缓冲区中读取数据）和写（例如，向后台缓冲区或深度/模板缓冲区写入数据）两种操作。在发出绘制命令之前，我们需要将与本次绘制调用（draw call）相关的资源绑定（bind或称链接，link）到渲染流水线上。部分资源可能在每次绘制调用时都会有所变化，所以我们也就要每次按需更新绑定。但是，GPU资源并非直接与渲染流水线相绑定，而是要通过一种名为描述符（descriptor）的对象来对它间接引用，我们可以把描述符视为一种对送往GPU的资源进行描述的轻量级结构。从本质上来讲，它实际上即为一个中间层；若指定了资源描述符，GPU将既能获得实际的资源数据，也能了解到资源的必要信息。因此，我们将把绘制调用需要引用的资源，通过指定描述符的方式绑定到渲染流水线。

为什么我们要额外使用描述符这个中间层呢？究其原因，GPU资源实质都是一些普通的内存块。由于资源的这种通用性，它们便能被设置到渲染流水线的不同阶段供其使用。一个常见的例子是先把纹理用作渲染目标（即Direct3D的绘制到纹理技术），随后再将该纹理作为一个着色器资源（即此纹理会经采样[9]而用作着色器的输入数据）。不管是充当渲染目标、深度/模板缓冲区还是着色器资源等角色，仅靠资源本身是无法体现出来的。而且，我们有时也许只希望将资源中的部分数据绑定至渲染流水线，但如何从整个资源中将它们选取出来呢？再者，创建一个资源可能用的是无类型格式，这样的话，GPU甚至不会知道这个资源的具体格式。解决上述问题就是引入描述符的原因。除了指定资源数据，描述符还会为GPU解释资源：它们会告知Direct3D某个资源将如何使用（即此资源将被绑定在流水线的哪个阶段上），而且我们可借助描述符来指定欲绑定资源中的局部数据。这就是说，如果某个资源在创建的时候采用了无类型格式，那么我们就必须在为它创建描述符时指明其具体类型。

视图（view）与描述符（descriptor）是同义词。“视图”虽是Direct3D先前版本里的常用术语，但它仍然沿用在Direct3D 12的部分API中。在本书里，两者交替使用，例如，“常量缓冲区视图（constant buffer view）”与“常量缓冲区描述符（constant buffer descriptor）”表达的是同一事物。

每个描述符都有一种具体类型，此类型指明了资源的具体作用。本书常用的描述符如下。1．CBV/SRV/UAV描述符分别表示的是常量缓冲区视图（constant bufferview）、着色器资源视图（shader resource view）和无序访问视图（unorderedaccess view）这3种资源。2．采样器（sampler，亦有译为取样器）描述符表示的是采样器资源（用于纹理贴图）。3．RTV描述符表示的是渲染目标视图资源（render target view）。4．DSV描述符表示的是深度/模板视图资源（depth/stencil view）。

描述符堆（descriptor heap）中存有一系列描述符（可将其看作是描述符数组），本质上是存放用户程序中某种特定类型描述符的一块内存。我们需要为每一种类型的描述符都创建出单独的描述符堆。另外，也可以为同一种描述符类型创建出多个描述符堆。

我们能用多个描述符来引用同一个资源。例如，可以通过多个描述符来引用同一个资源中不同的局部数据。而且，前文曾提到过，一种资源可以绑定到渲染流水线的不同阶段。因此，对于每个阶段都需要设置独立的描述符。例如，当一个纹理需要被用作渲染目标与着色器资源时，我们就要为它分别创建两个描述符：一个RTV描述符和一个SRV描述符。类似地，如果以无类型格式创建了一个资源，又希望该纹理中的元素可以根据需求当作浮点值或整数值来使用，那么就需要为它分别创建两个描述符：一个指定为浮点格式，另一个指定为整数格式。

创建描述符的最佳时机为初始化期间。由于在此过程中需要执行一些类型的检测和验证工作，所以最好不要在运行时（runtime）才创建描述符。

在不能提升显示器分辨率，或在显示器分辨率受限的情况下，我们就可以运用各种反走样（antialiasing，也有译作抗锯齿、反锯齿、反失真等）技术。有一种名为超级采样（supersampling，可简记作SSAA，即Super Sample Anti-Aliasing）的反走样技术，它使用4倍于屏幕分辨率大小的后台缓冲区和深度缓冲区。3D场景将以这种更大的分辨率渲染到后台缓冲区中。当数据要从后台缓冲区调往屏幕显示的时候，会将后台缓冲区按4个像素一组进行解析（resolve，或称降采样，downsample。把放大的采样点数降低回原采样点数）：每组用求平均值的方法得到一种相对平滑的像素颜色。因此，超级采样实际上是通过软件的方式提升了画面的分辨率。超级采样是一种开销高昂的操作，因为它将像素的处理数量和占用的内存大小都增加到之前的4倍。

Direct3D还支持一种在性能与效果等方面都较为折中的反走样技术，叫作多重采样（multisampling，可简记作MSAA，即MultiSampleAnti-Aliasing）。这种技术通过跨子像素[12]共享一些计算信息，从而使它比超级采样的开销更低。

“功能级别”为不同级别所支持的功能进行了严格的界定（每个功能级别所支持的特定功能可参见SDK文档）。例如，一款支持功能级别11的GPU，除了个别特例之外（像类似于多重采样数量这样的信息仍然需要查询，因为Direct3D规范允许这些Direct3D 11硬件在此方面有各自不同的实现），必须支持完整的Direct3D 11功能集。功能集使程序员的开发工作更加便捷——只要了解所支持的功能集，就能知道有哪些Direct3D功能可供使用。

DirectX图形基础结构（DirectX Graphics Infrastructure，DXGI，也有译作DirectX图形基础设施）是一种与Direct3D配合使用的API。设计DXGI的基本理念是使多种图形API中所共有的底层任务能借助一组通用API来进行处理。例如，为了保证动画的流畅性，2D渲染与3D渲染两组API都要用到交换链和页面翻转功能，这里所用的交换链接口IDXGISwapChain（详见4.1.4节）实际上就属于DXGIAPI。DXGI还用于处理一些其他常用的图形功能，如切换全屏模式（full-screenmode。另一种是窗口模式，windowed mode），枚举显示适配器、显示设备及其支持的显示模式（分辨率、刷新率等）等这类图形系统信息。除此之外，它还定义了Direct3D支持的各种表面格式信息（DXGI_FORMAT）。

“Microsoft Basic Render Driver（Microsoft基本呈现驱动程序）”是Windows8及后续系统版本中包含的软件适配器。

在Direct3D 12中，应用程序通过控制资源在显存中的去留，主动管理资源的驻留情况（即residency。无论资源是否本已位于显存中，都可对其进行管理。在Direct3D 11中则由系统自动管理）。该技术的基本思路为使应用程序占用最小的显存空间。这是因为显存的空间有限，很可能不足以容下整个游戏的所有资源，或者用户还有运行中的程序也在同时使用显存。这里给出一条与性能相关的提示：程序应当避免在短时间内于显存中交换进出相同的资源，这会引起过高的开销。最理想的情况是，所清出的资源在短时间内不会再次使用。游戏关卡或游戏场景的切换是关于常驻资源的好例子。

在进行图形编程的时候，我们一定要了解有两种处理器在参与处理工作，即CPU和GPU，两者并行工作，但时而也需同步。为了获得最佳性能，最好的情况是让两者尽量同时工作，少同步。同步是一种我们不乐于执行的操作，因为这意味着一种处理器要以空闲状态等待另一种处理器完成某些任务，换句话说，它破坏了两者并行工作的机制。

每个GPU都至少维护着一个命令队列（command queue，本质上是环形缓冲区，即ring buffer）。借助Direct3D API，CPU可利用命令列表（command list）将命令提交到这个队列中去[22]（见图4.6）。当一系列命令被提交至命令队列之时，它们并不会被GPU立即执行，理解这一点至关重要。由于GPU可能正在处理先前插入命令队列内的命令，因此，后来新到的命令会一直在这个队列之中等待执行。

假如命令队列中变得空空如也，那么没有任务可执行的GPU只能空闲下来；相反地，如果命令队列被填满，那么CPU必将随着GPU的工作步伐在某些时刻保持空闲[Crawfis12]。这两种情况都是我们不希望碰到的。对于像游戏这样的高性能应用程序来说，它们的目标是充分利用硬件资源，保持CPU和GPU同时忙碌。

__uuidof(\*\*(ppType))将获取(\*\*(ppType))的COM接口ID（globallyunique identifier，全局唯一标识符，GUID），在上述代码段中得到的即为ID3D12CommandQueue接口的COM ID。IID_PPV_ARGS辅助函数的本质是将ppType强制转换为void\*\*类型。我们在全书中都会见到此宏的身影，这是因为在调用Direct3D 12中创建接口实例的API时，大多都有一个参数是类型为void\*\*的待创接口COM ID。

虽然这些方法的名字看起来像是会使对应的命令立即执行，但事实却并非如此，上面的代码仅仅是将命令加入命令列表而已。

在没有确定GPU执行完命令分配器中的所有命令之前，千万不要重置命令分配器

强制CPU等待，直到GPU完成所有命令的处理，达到某个指定的围栏点（fence point）为止。我们将这种方法称为刷新命令队列（flushing the command queue），可以通过围栏（fence）来实现这一点。围栏用ID3D12Fence接口来表示，此技术能用于实现GPU和CPU间的同步。

为了实现常见的渲染效果，我们经常会通过GPU对某个资源[插图]按顺序进行先写后读这两种操作。然而，当GPU的写操作还没有完成抑或甚至还没有开始，却开始读取资源，便会导致资源冒险（resource hazard）。为此，Direct3D专门针对资源设计了一组相关状态。资源在创建伊始会处于默认状态，该状态将一直持续到应用程序通过Direct3D将其转换（transition）为另一种状态为止。这就使GPU能够针对资源状态转换与防止资源冒险作出适当的行为。例如，如果要对某个资源（比如纹理）执行写操作时，需要将它的状态转换为渲染目标状态；而要对该纹理进行读操作时，再把它的状态变为着色器资源状态。根据Direct3D给出的转换信息，GPU就可以采取适当的措施避免资源冒险的发生。譬如，在读取某个资源之前，它会等待所有与之相关的写操作执行完毕。

Direct3D 12中的许多结构体都有其对应的扩展辅助结构变体（variation），考虑到使用上的方便性，我们更偏爱于运用那些变体。以CD3DX12作为前缀的变体全都定义在d3dx12.h头文件当中，这个文件并不属于DirectX 12 SDK的核心部分，但是可以通过微软的官方网站下载获得。为了方便起见，本书源代码的Common目录里附有一份d3dx12.h头文件。

添加到命令列表中的资源屏障究竟是何物呢？事实上，我们可以将此资源屏障转换看作是一条告知GPU某资源状态正在进行转换的命令。所以在执行后续的命令时，GPU便会采取必要措施以防资源冒险。

Direct3D 12的设计目标是为用户提供一个高效的多线程环境，命令列表也是一种发挥Direct3D多线程优势的途径。对于内含许多物体的庞大场景而言，仅通过一个构建命令列表来绘制整个场景会占用不少的CPU时间。因此，可以采取一种并行创建命令列表的思路。例如，我们可以创建4条线程，每条分别负责构建一个命令列表来绘制25%的场景物体。

以下是一些在多线程环境中使用命令列表要注意的问题。1．命令列表并非自由线程（not free-threaded）对象。也就是说，多线程既不能同时共享相同的命令列表，也不能同时调用同一命令列表的方法。所以，每个线程通常都只使用各自的命令列表。2．命令分配器亦不是线程自由的对象。这就是说，多线程既不能同时共享同一个命令分配器，也不能同时调用同一命令分配器的方法。所以，每个线程一般都仅使用属于自己的命令分配器。3．命令队列是线程自由对象，所以多线程可以同时访问同一命令队列，也能够同时调用它的方法。特别是每个线程都能同时向命令队列提交它们自己所生成的命令列表。4．出于性能的原因，应用程序必须在初始化期间，指出用于并行记录命令的命令列表最大数量。为了简单起见，本书不会使用多线程技术。完成本书的阅读后，读者可以通过查阅SDK中的Multithreading12示例[30]来学习怎样并行生成命令列表。如果希望应用程序充分利用系统资源，应该通过多线程技术来发挥CPU多核心的并行处理能力。

我们对Direct3D进行初始化的过程可以分为以下几个步骤：1．用D3D12CreateDevice函数创建ID3D12Device接口实例。2．创建一个ID3D12Fence对象，并查询描述符的大小。3．检测用户设备对4X MSAA质量级别的支持情况。4．依次创建命令队列、命令列表分配器和主命令列表。5．描述并创建交换链。6．创建应用程序所需的描述符堆。7．调整后台缓冲区的大小，并为它创建渲染目标视图。8．创建深度/模板缓冲区及与之关联的深度/模板视图。9．设置视口（viewport）和裁剪矩形（scissor rectangle）。

一般来说，显示适配器是一种3D图形硬件（如显卡）。但是，一个系统也能用软件显示适配器来模拟3D图形硬件的功能（如WARP适配器）。

当调用D3D12CreateDevice失败后，程序将回退到一种软件适配器：WARP设备。WARP意为Windows Advanced Rasterization Platform（Windows高级光栅化平台）。在Windows 7及以下版本的操作系统中，WARP设备支持的最高功能级别是10.1；在Windows 8系统中，WARP设备支持的最高功能级别是11.1

创建描述符堆之后，还要能访问其中所存的描述符。在程序中，我们是通过句柄来引用描述符的，并以ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart方法来获得描述符堆中第一个描述符的句柄。

资源不能与渲染流水线中的阶段直接绑定，所以我们必须先为资源创建视图（描述符），并将其绑定到流水线阶段。例如，为了将后台缓冲区绑定到流水线的输出合并阶段（output merger stage，这样Direct3D才能向其渲染），便需要为该后台缓冲区创建一个渲染目标视图。

深度缓冲区其实就是一种2D纹理，它存储着离观察者最近的可视对象的深度信息（如果使用了模板，还会附有模板信息）。

为了使性能达到最佳，通常应将资源放置于默认堆中。只有在需要使用上传堆或回读堆的特性之时，才选用其他类型的堆。

在Direct3D中，存储在深度缓冲区中的数据都是范围在0～1的归一化深度值。

不能为同一个渲染目标指定多个视口。而多视口（multiple viewport）则是一种用于对多个渲染目标同时进行渲染的高级技术。

命令列表一旦被重置，视口也就需要随之而重置。

*比如游戏《双人成行》*

> 事实上，还可以用视口技术来实现双人游戏的分屏（split screen）模式。首先创建两个视口，一个占屏幕左半部，另一个占右半部。接下来，在左视口中以玩家1的视角来绘制3D场景，再在右视口中以玩家2的视角来绘制3D场景即可。

不能为同一个渲染目标指定多个裁剪矩形。多裁剪矩形（multiple scissorrectangle）是一种用于同时对多个渲染目标进行渲染的高级技术。

裁剪矩形需要随着命令列表的重置而重置。

为了制作出精准的动画效果就需要精确地计量时间，特别是要准确地度量出动画每帧画面之间的时间间隔。如果帧率（frame rate，也有作帧速率、帧频等，每秒刷新的帧数）较高，那么帧与帧之间的间隔就会比较短，此时我们就要用到高精度的计时器。

为了精确地度量时间，我们将采用性能计时器（performance timer。或称性能计数器，performance counter）。如果希望调用查询性能计时器的Win32函数，我们必须引入头文件#include <windows.h>。

MSDN对QueryPerformanceCounter函数作有如下备注：“按道理来讲，对于一台具有多个处理器的计算机而言，无论在哪一个处理器上调用此函数都应返回当前时刻的计数值。然而，由于基本输入/输出系统（BIOS）或硬件抽象层（HAL）上的缺陷，导致了在不同的处理器上可能会得到不同的结果

全书的演示程序都使用了d3dUtil.h、d3dUtil.cpp、d3dApp.h和d3dApp.cpp中的框架代码，可以从本书的官方网站下载到这些文件。d3dUtil.h和d3dUtil.cpp文件中含有程序所需的实用工具代码，d3dApp.h和d3dApp.cpp文件内包含用于封装Direct3D示例程序的Direct3D应用程序类核心代码。由于在书中不能细述这些文件里的每一行代码（例如，我们不会展示如何创建一个窗口，基本的Win32编程是阅读本书的必备知识[44]），所以我们鼓励读者在阅读完本章后，仔细研究这些文件。构建此框架的目标是：隐去窗口创建和Direct3D初始化的具体细节；通过对这些代码进行封装，那些细枝末节就不会分散我们的注意力，继而使我们把精力集中在重点代码上。

在析构函数中刷新命令队列的原因是：在销毁GPU引用的资源以前，必须等待GPU处理完队列中的所有命令。否则，可能造成应用程序在退出时崩溃。

对于本书的所有示例程序来说，我们每次都会重写D3DApp中的6个虚函数。这6个函数用于针对特定的示例来实现所需的具体功能。这种设定的好处是把初始化代码、消息处理等流程都统一实现在D3DApp类中，继而使我们可以把精力集中在特定例程中的关键代码之上。以下是对这6个框架方法的概述。

1．Initialize：通过此方法为程序编写初始化代码，例如分配资源、初始化对象和建立3D场景等。

2．MsgProc：该方法用于实现应用程序主窗口的窗口过程函数（procedurefunction）。

3．CreateRtvAndDsvDescriptorHeaps：此虚函数用于创建应用程序所需的RTV和DSV描述符堆。

4．OnResize：当D3DApp::MsgProc函数接收到WM_SIZE消息时便会调用此方法。

5．Update：在绘制每一帧时都会调用该抽象方法，我们通过它来随着时间的推移而更新3D应用程序（如呈现动画、移动摄像机、做碰撞检测以及检查用户的输入等）。

6．Draw：在绘制每一帧时都会调用的抽象方法。我们在该方法中发出渲染命令，将当前帧真正地绘制到后台缓冲区中。当完成帧的绘制后，再调用IDXGISwapChain::Present方法将后台缓冲区的内容显示在屏幕上。

除了上述6个框架方法之外，我们为了便于处理鼠标的按下、释放和移动事件，还分别提供了3个相关的虚函数：[插图]如此一来，若希望处理鼠标消息，我们只需重写这几种方法，而不必重写MsgProc方法。这3个处理鼠标消息方法的第一个参数都是WPARAM，它存储了鼠标按键的状态（即鼠标事件发生时，哪个键被按下）。第二个和第三个参数则表示鼠标指针在工作区的坐标(x, y)。

正如[Dunlop03]在《FPS versus Frame Time（FPS vs. 帧时间）》一文中所指出的，由于FPS曲线图（FPS curve）的非线性特征，使得采用FPS进行分析可能会得到误导性的结果。例如，请考虑场景（一）：假设我们的应用程序跑到了1000FPS，利用1 ms（毫秒）就可以渲染1帧。那么，当帧率降到了250 FPS时，渲染1帧就要用4 ms。现在再来思考情景（二）：设想我们的应用程序跑到100 FPS，花10 ms渲染1帧。如果帧率降到了76.9 FPS，那么渲染1帧将花费约13 ms。这两种情景中每帧的渲染时间都增加了3 ms，也就表示它们在渲染每一帧的过程中都增加了同样多的时间。然而，FPS所反映出的统计值却并不直观。虽然从1000 FPS跌到250 FPS看起来要比从100 FPS下降到76.9 FPS的幅度大得多，但诚如我们所看到的，它们渲染每帧所增加的时间实际上却是相同的。

对于用户拖动调整栏的操作，我们一定要小心对待，因为这个行为会连续发出WM_SIZE消息，但我们不希望随之连续调整缓冲区。因此，如若确定用户正在拖动边框调整窗口大小，我们理应什么也不做（暂停应用程序除外），直到用户完成调整操作后再执行修改缓冲区等操作。通过处理WM_EXITSIZEMOVE消息就可以实现这一点。这条消息会在用户释放调整栏时发送。

ID3D12GraphicsCommandList::OMSetRenderTargets，通过此方法即可设置我们希望在渲染流水线上使用的渲染目标和深度/模板缓冲区。

可以把Direct3D 看作是一种介于程序员和图形硬件之间的“桥梁”。借此，程序员便可以通过调用Direct3D函数来实现把资源视图绑定到硬件渲染流水线、配置渲染流水线的输出以及绘制3D几何体等操作。

GPU较之于显卡的地位大致相当于CPU较之于主板。

*用Bing搜索*

> 像书中给出的这类地址，完全可以通过搜索神秘代码上车，比如这里的mt186622。

ID3D12CommandQueue::Signal方法从GPU端设置围栏值，而ID3D12Fence::Signal方法则从CPU端设置围栏值。

Direct3D 12并不支持创建MSAA交换链，因此也就不能在运行时改动交换链的MSAA参数！

### 第5章 渲染流水线

如果给出一台具有确定位置和朝向的虚拟摄像机（virtual camera）以及某个3D场景的几何描述，那么渲染流水线则是以此虚拟摄像机为视角进行观察，并据此生成给定3D场景2D图像的一整套处理步骤

从观察效果上看，平行线最终会相交于消失点（vanishing point，又称灭点）

实体3D对象是借助三角形网格（triangle mesh）来近似表示的，因而我们要以三角形作为3D物体建模的基石。

在本书的第一部分中，我们仍将采用手动或运用数学公式的方式来生成3D对象（比如，通过参数方程就可以方便地生成用于模拟圆柱和球体的三角形列表），在第三部分中，我们将展示如何加载和显示以3D建模程序生成的3D模型。

每款显示器所能发出的红、绿、蓝三色光的强度都是有限的。为了便于描述光的强度，我们常将它量化为范围在0～1归一化区间中的值。0代表无强度，1则表示强度最大，处于两者之间的值就表示对应的中间强度。例如，强度值（0.25, 0.67,1.0）就表明此光线由强度为25%的红色光、强度为67%的绿色光以及强度为100%的蓝色光混合而成。

颜色向量也有它们自己专属的颜色运算，即分量式（modulation或componentwise）乘法。

我们通常还会用到另一种名为alpha分量（alpha component）的颜色分量。alpha分量常用于表示颜色的不透明度[5]（opacity。值为0.0表示完全透明，值为1.0表示不透明）

一般来说，128位颜色值常用于高精度的颜色运算（例如位于像素着色器中的各种运算）。在这种情况下，由于运算所用的精度较高，因此可有效降低计算过程中所产生的误差。但是，最终存储在后台缓冲区中的像素颜色数据，却往往都是以32位颜色值来表示。而目前的物理显示设备仍不足以充分发挥出更高色彩分辨率的优势

![渲染流水线的各个阶段](https://cdn.jsdelivr.net/gh/bit704/blog-image-bed@main/image/2022-09-18-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5.jpg)

输入装配器（Input Assembler，IA）阶段会从显存中读取几何数据（顶点和索引，vertex and index），再将它们装配为几何图元（geometric primitive，亦译作几何基元，如三角形和线条这种构成图形的基本元素）。

在Direct3D中，我们要通过一种名为顶点缓冲区（vertex buffer）的特殊数据结构，将顶点与渲染流水线相绑定。顶点缓冲区利用连续的内存来存储一系列顶点。

通过指定图元拓扑（primitive topology，或称基元拓扑）来告知Direct3D如何用顶点数据来表示几何图元

经过观察可以发现，在三角形带中，次序为偶数的三角形与次序为奇数三角形的绕序（winding order，也译作环绕顺序等，即装配图元的顶点顺序为逆时针或顺时针方向）是不同的，这就是剔除（culling，亦称消隐）问题的由来（参见5.10.2节）。为了解决这个问题，GPU内部会对偶数三角形中前两个顶点的顺序进行调换，以此使它们与奇数三角形的绕序保持一致。

当使用三角形列表拓扑时，在绘制调用的过程中会将每3个顶点装配成独立的三角形

对于存有邻接数据的三角形列表而言，每个三角形都有 3 个与之相邻的邻接三角形（adjacent triangle）

为三角形指定顶点顺序是一项十分重要的工作，我们称这个顺序为绕序（winding order）

先创建一个顶点列表和一个索引列表。在顶点列表中收录一份所有独立的顶点，并在索引列表中存储顶点列表的索引值，这些索引定义了顶点列表中的顶点是如何组合在一起，从而构成三角形的。

待图元被装配完毕后，其顶点就会被送入顶点着色器阶段（vertex shader stage，简记作VS）。我们可以把顶点着色器看作一种输入与输出数据皆为单个顶点的函数。每个要被绘制的顶点都须经过顶点着色器的处理再送往后续阶段。

我们可以利用顶点着色器来实现许多特效，例如变换、光照和位移贴图（displacement mapping，也译作置换贴图。map有映射之意，因此也有译作位移映射，类似的还有在后面将见到的纹理贴图、法线贴图等）。

将局部坐标系内的坐标转换到全局场景坐标系中的过程叫作世界变换（world transform），所使用的变换矩阵名为世界矩阵（world matrix）。

为了构建场景的2D图像，我们必须在场景中架设一台虚拟摄像机。该摄像机确定了观察者可见的视野，也就是生成2D图像所需的场景空间范围。对此，我们先为该摄像机赋予一个图5.19所示的局部坐标系（这被称作观察空间（view space），也译作观察坐标系、视图空间、视觉空间（eye space）或摄像机空间（camera space））。

由世界空间至观察空间的坐标变换称为取景变换（view transform，也译作观察变换、视图变换等），此变换所用的矩阵则称为观察矩阵（view matrix，亦译作视图矩阵）。

只要给定摄像机的位置、观察目标点以及世界空间中“向上”方向的向量，我们就能构建出对应的摄像机局部坐标系，并推导出相应的观察矩阵。

我们将由顶点到观察点（eye point，也译作视点）的连线称为顶点的投影线（vertex’s line of projection）。继而就可以定义出：将3D顶点v变换至其投影线与2D投影平面交点v'的透视投影变换（perspective projection transformation）。我们称点v'为点v的投影。

在观察空间中，我们可以通过近平面（near plane，也译作近裁剪面）n、远平面（far plane，也译作远裁剪面）f、垂直视场角（vertical field of view angle）a以及纵横比（aspect ratio，也作宽高比）r这4个参数来定义一个：以原点作为投影的中心，并沿z轴正方向进行观察的平截头体

由于该图像终将被映射到后台缓冲区中，因此，我们希望令投影窗口与后台缓冲区两者的纵横比保持一致。为此，我们通常将投影窗口的纵横比指定为后台缓冲区的纵横比。

经此映射处理后，x坐标和y坐标就成为了规格化设备坐标（Normalized Device Coordinates，NDC）（请注意，这里并没有对z坐标进行归一化处理）。

在NDC坐标中，投影窗口的高和宽都为2，所以它的大小是固定的，硬件也就无须知道纵横比。但是，我们一定要确保将投影坐标映射到NDC空间内（图形硬件假设我们会完成这项工作）

顶点乘以投影矩阵之后但还未进行透视除法之前，几何体会处于所谓的齐次裁剪空间（homogeneous clip space）或投影空间（projection space）之中。待完成透视除法之后，便是用规格化设备坐标（NDC）来表示几何体了。

曲面细分阶段（tessellation stages）是利用镶嵌化处理技术对网格中的三角形进行细分（subdivide），以此来增加物体表面上的三角形数量。再将这些新增的三角形偏移到适当的位置，使网格表现出更加细腻的细节

使用曲面细分的优点有以下几方面。

1．我们能借此实现一种细节层次（level-of-detail，LOD）机制，使离虚拟摄像机较近的三角形经镶嵌化处理得到更加丰富的细节，而对距摄像机较远的三角形不进行任何更改。通过这种方式，即可只针对用户关注度高的部分网格增添三角形，从而提升其细节效果。

2．我们在内存中仅维护简单的低模（low-poly，低精度模型，也有译作低面多边形、低面片等）网格（低模网格是指三角形数量较少的网格，已逐渐形成一门独特画风的艺术制作手段），再根据需求为它动态地增添额外的三角形，以此节省内存资源。

3．我们可以在处理动画和物理模拟之时采用简单的低模网格，而仅在渲染的过程中使用经镶嵌化处理的高模（high-poly，与低模对应）网格。

几何着色器接受的输入应当是完整的图元。例如，假设我们正在绘制三角形列表，那么向几何着色器传入的将是定义三角形的3个顶点。（注意，这3个顶点在此之前已经过了顶点着色器阶段的处理）几何着色器的主要优点是可以创建或销毁几何体。比如说，我们可以利用几何着色器将输入的图元拓展为一个或多个其他图元，抑或根据某些条件而选择不输出任何图元。顶点着色器与之相比，则不能创建顶点：它只能接受输入的单个顶点，经处理后再将该顶点输出。几何着色器的常见拿手好戏是将一个点或一条线扩展为一个四边形。

苏泽兰（萨瑟兰德）-霍奇曼裁剪算法（Sutherland-Hodgman clipping algorithm，前者Ivan Sutherland是图形界的奠基人，可以了解一下）

光栅化阶段（rasterization stage，RS，亦有将rasterization译作像素化或栅格化）的主要任务是为投影至屏幕上的3D三角形计算出对应的像素颜色。

当裁剪操作完成之后，硬件会通过透视除法将物体从齐次裁剪空间变换为规格化设备坐标（NDC）。一旦物体的顶点位于NDC空间内，构成2D图像的2D顶点[插图]、[插图]坐标就会被变换到后台缓冲区中称为视口（viewport）的矩形里

如果观察者看到的是三角形的正面，我们就称此三角形是正面朝向（front-facing）的；如果观察者看到的是三角形的背面，则称此三角形是背面朝向（back-facing）的。

背面剔除（backface culling，也称背面消隐）就是用于将背面朝向的三角形从渲染流水线中除去的处理流程。这种操作能将待处理的三角形总量削减一半。

在默认的情况下，Direct3D将以观察者的视角把顺时针绕序的三角形看作正面朝向，把逆时针绕序的三角形当作背面朝向。但是，通过对Direct3D渲染状态的设置，我们也可以将这个约定“颠倒”过来。

经过视口变换之后，我们需要为求取三角形内诸像素所附的属性而进行插值（interpolate，也有译作内插）运算。而且，除了上述顶点属性，还需对顶点的深度值进行内插，继而得到每个像素参与实现深度缓冲算法的深度值。为了得到屏幕空间（screen space，即将3D场景渲染为最终图像的2D空间）中各个顶点的插值属性，往往要通过一种名为透视校正插值（perspective correct interpolation）的方法，对3D空间中三角形的属性进行线性插值（见图5.33）。从本质上来说，插值法即利用三角形顶点的属性值计算出其内部像素的属性值。

我们编写的像素着色器（pixel shader，PS）是一种由GPU来执行的程序。它会针对每一个像素片段（pixel fragment，亦有译作片元）进行处理（即每处理一个像素就要执行一次像素着色器），并根据顶点的插值属性作为输入来计算出对应的像素颜色。像素着色器既可以直接返回一种单一的恒定颜色，也可以实现如逐像素光照（per-pixel lighting）、反射（reflection）以及阴影（shadow）等更为复杂的效果。

通过像素着色器生成的像素片段会被移送至渲染流水线的输出合并（OutputMerger，OM）阶段。在此阶段中，一些像素片段可能会被丢弃（例如，那些未通过深度缓冲区测试或模板缓冲区测试的像素片段）。而后，剩下的像素片段将会被写入后台缓冲区中。混合（blend，也有译作融合）操作也是在此阶段实现的，此技术可令当前处理的像素与后台缓冲区中的对应像素相融合，而不仅是对后者进行完全的覆写。一些如“透明”这样的特殊效果，也是由混合技术来实现的。

渲染流水线可以划分为输入装配（Input Assembly，IA）阶段、顶点着色器（Vertex Shader，VS）阶段、曲面细分（tessellation）阶段、几何着色器（Geometry Shader，GS）阶段、裁剪阶段、光栅化阶段（RasterizationShage，RS）、像素着色器（Pixel Shader，PS）阶段以及输出合并（OutputMerger，OM）等重要阶段。

### 第6章 利用Direct3D绘制几何体

完成本章的学习后，我们将能以实体着色（solid coloring）模式或在线框模式（wireframemode）下绘制一个3D立方体。

在着色器代码中，未标明索引的语义将默认其索引值为0

Direct3D共支持16个输入槽（索引值为0～15），可以通过它们来向输入装配阶段传递顶点数据。

为了使GPU可以访问顶点数组，就需要把它们放置在称为缓冲区（buffer）的GPU资源（ID3D12Resource）里。我们把存储顶点的缓冲区叫作顶点缓冲区（vertexbuffer）。缓冲区的结构比纹理更为简单：既非多维资源，也不支持mipmap、过滤器以及多重采样等技术。当需要向GPU提供如顶点这类数据元素所构成的数组时，我们便会使用缓冲区。

在Direct3D 12中，所有的资源均用ID3D12Resource接口表示。相比之下，Direct3D 11则采用如ID3D11Buffer与ID3D11Texture2D等多种不同的接口来表示各种不同的资源。

在Direct3D 12中，资源的类型由D3D12_RESOURCE_DESC::D3D12_RESOURCE_DIMENSION字段来加以区分。例如，缓冲区用D3D12_RESOURCE_DIMENSION_BUFFER类型表示，而2D纹理则以D3D12_RESOURCE_DIMENSION_TEXTURE2D类型表示。

对于静态几何体（static geometry，即每一帧都不会发生改变的几何体）而言，我们会将其顶点缓冲区置于默认堆（D3D12_HEAP_TYPE_DEFAULT）中来优化性能。一般说来，游戏中的大多数几何体（如树木、建筑物、地形和动画角色）都是如此处理。

我们需要利用作为中介的上传缓冲区来初始化默认缓冲区（即用堆类型D3D12_HEAP_TYPE_DEFAULT创建的缓冲区）中的数据

为了将顶点缓冲区绑定到渲染流水线上，我们需要给这种资源创建一个顶点缓冲区视图（vertex buffer view）。与RTV（render target view，渲染目标视图）不同的是，我们无须为顶点缓冲区视图创建描述符堆。

与顶点相似，为了使GPU可以访问索引数组，就需要将它们放置于GPU的缓冲区资源（ID3D12Resource）内。我们称存储索引的缓冲区为索引缓冲区（indexbuffer）。

为了使索引缓冲区与渲染流水线绑定，我们需要给索引缓冲区资源创建一个索引缓冲区视图（index buffer view）。如同顶点缓冲区视图一样，我们也无须为索引缓冲区视图创建描述符堆。

我们将每个物体的第一个顶点相对于全局顶点缓冲区的位置叫作它的基准顶点地址（base vertex location）。通常来讲，一个物体的新索引是通过原始索引加上它的基准顶点地址来获取的。

在Direct3D中，编写着色器的语言为高级着色语言（High Level ShadingLanguage，HLSL）[7]，其语法与C++十分相似，这使得它较易于学习。

注意，SV_POSITION语义比较特殊（SV代表系统值，即system value），它所修饰的顶点着色器输出元素存有齐次裁剪空间中的顶点位置信息。因此，我们必须为输出位置信息的参数附上SV_POSITION语义，使GPU可以在进行例如裁剪、深度测试和光栅化等处理之时，借此实现其他属性所无法介入的有关运算。

如果没有使用几何着色器（我们会在第12章中介绍这种着色器），那么顶点着色器必须用SV_POSITION语义来输出顶点在齐次裁剪空间中的位置，因为（在没有使用几何着色器的情况下）执行完顶点着色器之后，硬件期望获取顶点位于齐次裁剪空间之中的坐标。如果使用了几何着色器，则可以把输出顶点在齐次裁剪空间中位置的工作交给它来处理。

在顶点着色器（或几何着色器）中是无法进行透视除法的，此阶段只能实现投影矩阵这一环节的运算。而透视除法将在后面交由硬件执行。

事实上，顶点数据与输入签名不需要完全匹配，前提是我们一定要向顶点着色器提供其输入签名所定义的顶点数据。这就是说，顶点数据中也可以附带一些顶点着色器根本用不到的额外数据。

由于硬件优化的原因，某些像素片段在移送至像素着色器之前，可能已经被渲染流水线所剔除（例如提前深度剔除，early-z rejection，也有译作早期深度剔除、早期z剔除等）。这就是为什么要首先执行深度测试的原因，如果已经确定某像素片段被遮挡，那么像素着色器将不再对它进行处理。然而，也有一些情况能够禁止提前深度剔除优化。比如说，倘若在像素着色器中有对像素深度值进行修改的操作，那么像素着色器就必须针对每个像素各执行一次，因为在像素着色器修改像素深度值以前，我们并不知道每个像素的最终深度值。

像素着色器返回一个4D颜色值，而位于此函数参数列表后的SV_TARGET语义则表示该返回值的类型应当与渲染目标格式（render target format）相匹配（该输出值会被存于渲染目标之中）。

与顶点缓冲区和索引缓冲区不同的是，常量缓冲区通常由CPU每帧更新一次。举个例子，如果摄像机每帧都在不停地移动，那么常量缓冲区也需要在每一帧都随之以新的视图矩阵而更新。所以，我们会把常量缓冲区创建到一个上传堆而非默认堆中，这样做能使我们从CPU端更新常量。

由于常量缓冲区是用D3D12_HEAP_TYPE_UPLOAD这种堆类型来创建的，所以我们就能通过CPU为常量缓冲区资源更新数据。

一般来讲，物体的世界矩阵将随其移动/旋转/缩放而改变，观察矩阵随虚拟摄像机的移动/旋转而改变，投影矩阵随窗口大小的调整而改变。

常量缓冲区描述符都要存放在以D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV类型所建的描述符堆里。这种堆内可以混合存储常量缓冲区描述符、着色器资源描述符和无序访问（unorderedaccess）描述符。

这段代码与我们之前创建渲染目标和深度/模板缓冲区这两种资源描述符堆的过程很相似。然而，其中却有着一个重要的区别，那就是在创建供着色器程序访问资源的描述符时，我们要把标志Flags指定为DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE。

通常来讲，在绘制调用开始执行之前，我们应将不同的着色器程序所需的各种类型的资源绑定到渲染流水线上。实际上，不同类型的资源会被绑定到特定的寄存器槽（register slot）上，以供着色器程序访问。比如说，前文代码中的顶点着色器和像素着色器需要的是一个绑定到寄存器b0的常量缓冲区。在本书的后续内容中，我们会用到这两种着色器更高级的配置方法，以使多个常量缓冲区、纹理（texture）和采样器（sampler）都能与各自的寄存器槽相绑定

根签名（root signature）定义的是：在执行绘制命令之前，那些应用程序将绑定到渲染流水线上的资源，它们会被映射到着色器的对应输入寄存器。

如果我们把着色器程序当作一个函数，而将输入资源看作着色器的函数参数，那么根签名则定义了函数签名（其实这就是“根签名”一词的由来）。通过绑定不同的资源作为参数，着色器的输出也将有所差别。例如，顶点着色器的输出取决于实际向它输入的顶点数据以及为它绑定的具体资源。

在Direct3D中，根签名由ID3D12RootSignature接口来表示，并以一组描述绘制调用过程中着色器所需资源的根参数（root parameter）定义而成。根参数可以是根常量（root constant）、根描述符（root descriptor）或者描述符表（descriptor table）。

每当在（图形）绘制调用或（计算）调度（dispatch，也有译作分派）调用（此“调度调用”指调度计算着色器进行GPU通用计算）之间有根签名的内容（即描述符表、根常量以及根描述符）发生改变时，D3D12的驱动程序便会将与应用程序相绑定的根签名内容自动更新为最新的数据。因此，在每次绘制/调度调用时都会产生一整套独立的根签名状态[16]。

如果更改了根签名，则会失去现存的所有绑定关系。也就是说，在修改了根签名后，我们需要按新的根签名定义重新将所有的对应资源绑定到渲染流水线上。

在Direct3D中，着色器程序必须先被编译为一种可移植的字节码。接下来，图形驱动程序将获取这些字节码，并将其重新编译为针对当前系统GPU所优化的本地指令[ATI1]。

我们不仅可以在运行期间编译着色器，还能够以单独的步骤（例如，将其作为构建整个工程过程中的一个独立环节，或是将其视为资源内容流水线（asset contentpipeline）流程的一部分）离线地（offline）编译着色器。这样做有原因若干：

1．对于复杂的着色器来说，其编译过程可能耗时较长。因此，借助离线编译即可缩短应用程序的加载时间。

2．以便在早于运行时的构建处理期间提前发现编译错误。

3．对于Windows 8应用商店中的应用而言，必须采用离线编译这种方式。

我们通常用.cso (即compiled shader object，已编译的着色器对象)作为已编译着色器的扩展名。

为了以离线的方式编译着色器，我们将使用DirectX自带的FXC命令行编译工具。

FXC程序根据可选参数/Fc 来生成可移植的着色器汇编代码。通过查阅着色器的汇编代码，既可核对着色器的指令数量，也能了解生成的代码细节——这是为了验证编译器所生成的代码与我们预想的是否一致。

当今渲染流水线中的大多阶段都是可编程的，但是有些特定环节却只能接受配置。例如，用于配置渲染流水线中光栅化阶段的光栅器状态（rasterizer state）组由结构体D3D12_RASTERIZER_DESC来表示

大多数控制图形流水线状态的对象被统称为流水线状态对象（Pipeline State Object，PSO），用ID3D12PipelineState接口来表示。

ID3D12PipelineState对象集合了大量的流水线状态信息。为了保证性能，我们将所有这些对象都集总在一起，一并送至渲染流水线。通过这样的一个集合，Direct3D便可以确定所有的状态是否彼此兼容，而驱动程序则能够据此而提前生成硬件本地指令及其状态。在Direct3D 11的状态模型中，这些渲染状态片段都是要分开配置的。然而这些状态实际都有一定的联系，以致如果其中的一个状态发生改变，那么驱动程序可能就要为了另一个相关的独立状态而对硬件重新进行编程。由于一些状态在配置流水线时需要改变，因而硬件状态也就可能被频繁地改写。为了避免这些冗余的操作，驱动程序往往会推迟针对硬件状态的编程动作，直到明确整条流水线的状态发起绘制调用后，才正式生成对应的本地指令与状态。但是，这种延迟操作需要驱动在运行时进行额外的记录工作，即追踪状态的变化，而后才能在运行时生成改写硬件状态的本地代码。在Direct3D 12的新模型中，驱动程序可以在初始化期间生成对流水线状态编程的全部代码，这便是我们将大多数的流水线状态指定为一个集合所带来的好处。

考虑到程序的性能问题，我们应当尽可能减少改变PSO状态的次数。为此，若能以一个PSO绘制出所有的物体，绝不用第二个PSO。切记，不要在每次绘制调用时都修改PSO！

