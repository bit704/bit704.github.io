---
title: 《Java程序设计基础（第6版）》笔记
index_img: https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-Java程序设计基础-笔记.jpg
banner_img: https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-Java程序设计基础-笔记.jpg
layout: post
categories: [Notebook]
tags: [Java]
---

作者 *陈国君*

<!-- more -->

清华大学出版社

![封面](https://bit704.oss-cn-beijing.aliyuncs.com/image/2022-09-18-Java程序设计基础-笔记_s.jpg)

## 第1章 Java语言概述

### 1.2 Java语言的特点

Java语言是一种跨平台、适合于分布式计算环境的面向对象编程语言。它具有简单、面向对象、分布式、解释型、可靠性、安全、平台无关、可移植、高性能、多线程、动态性等特点。

Java语言虽然衍生自C++语言，与C++语言相比Java语言是一种完全面向对象的编程语言。出于安全性和稳定性的考虑，Java语言去掉了C/C++语言支持的三个不易理解和掌握的数据类型：指针（pointer）、联合体（unions）和结构体（structs）。而C/C++语言中联合体和结构体的功能，完全可以在Java语言中用类及类的属性等面向对象的方法来实现。

平台无关有两种：源代码级和目标代码级。C和C++语言具有一定程度的源代码级平台无关，即用C和C++语言编写的应用程序不用修改只需重新编译就可以在不同平台上运行。Java语言是靠Java虚拟机（JVM）在目标代码级实现平台无关性的。

Java语言的编译器并不是把源文件（.java）编译成二进制码，而是将其编译成一种独立于机器平台的字节码文件（.class文件）。字节码文件可以被Java解释器执行，由解释器将字节码文件再翻译成二进制码，使程序得以运行。

### 1.4 Java虚拟机

所以从底层上看，JVM就是以Java字节码为指令组的“软CPU”。可以说，JVM是可运行Java字节码的假想计算机。它的作用类似于Windows操作系统，只不过在Windows上运行的是.exe文件，而在JVM上运行的是Java字节码文件，也就是扩展名为.class的文件。JVM其实就是一个字节码解释器。

### 1.5 Java程序的种类和结构

在应用程序中包含有main（）方法的类一定是主类，但主类并不一定要求是public类。

一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。在Java小程序里，这个主类是一个继承自系统类JApplet的子类。应用程序的主类不一定要求是public类，但小程序的主类一定要求是public类。主类是Java程序执行的入口点。

## 第2章 Java语言开发环境

### 2.1 Java开发工具

ClassPath环境变量的作用就是告诉Java解释器在哪里找到.class文件及相关的库程序

在Windows系统中，通过%xxx%来表示xxx环境变量的当前值，例如环境变量Path的设置值为“C:\windows\system32；c\windows；”，则%path%就表示这个字符串。

### 2.3 JDK的使用

Java应用程序源文件的命名规则：首先源文件的扩展名必须是.java；如果源文件中有多个类，则最多只能有一个public类，如果有，那么源文件的名字必须与这个public类的名字相同（文件名字符的大小写可以与public类名的大小写不同）；如果源文件没有public类，那么源文件的名字由用户任意命名。

## 第3章 Java语言基础 

### 3.1 数据类型

Java语言中的数据类型分为两大类：一类是基本数据类型（primitive types）；另一类是引用数据类型（reference types），简称引用类型。

基本数据类型有整型、浮点型、逻辑型和字符型；引用数据类型包括类、数组和接口等。

### 3.2 关键字与标识符

用Java语言编程时，经常遵循以下命名习惯（不是强制性的）：类名首字母大写；变量名、方法名及对象名的首字母小写。对于所有标识符，其中包含的所有单词都应紧靠在一起，而且中间单词的首字母大写。例如，ThisIsAClassName，thisIsMethodOrFieldName。若定义常量时，则所有字母大写，这样便可标志出它们属于编译期的常数。Java包（package）属于一种特殊情况，它们全都是小写字母，即便中间的单词亦是如此。

### 3.4 变量

变量具有四个基本要素：名字、类型、值和作用域。

### 3.7 运算符与表达式

对取模运算符“%”来说，其操作数可以为浮点数。即a%b与a-（（int）（a/b）∗b）的语义相同，这表示a%b的结果是除完后剩下的浮点数部分。

运算符的优先级决定了表达式中不同运算执行的先后顺序，大体上来说，从高到低是：一元运算符、算术运算、关系运算和逻辑运算、赋值运算。运算符除有优先级外，还有结合性，运算符的结合性决定了并列的多个同级运算符的先后执行顺序。同级的运算符大都是按从左到右的方向进行（称为“左结合性”）。大部分运算的结合性都是从左向右，而赋值运算、一元运算等则有右结合性。

大部分运算的结合性都是从左向右，而赋值运算、一元运算等则有右结合性。

### 本章小结

当表达式中各数值型操作数的类型不匹配时，有如下处理方法：①占用较少字节的数据类型会转换成占用较多字节的数据类型；②有short和int类型，则用int类型；③字节类型会转换成short类型；④int类型转换成float类型；⑤若某个操作数的类型为double，则另一个也会转换成double类型；⑥布尔型不能转换成其他的类型。

## 第4章 流程控制

### 4.1 语句与复合语句

Java语言的复合语句与C++复合语句不同的是：Java语言不允许在两个嵌套的复合语句内声明同名的变量。如下面的代码在编译时将会出错。

文件注释是Java语言所特有的文档注释。它以/∗∗开头，以∗/结尾。这种注释主要用于描述类、数据和方法。它是使用JDK提供的javadoc.exe命令所生成的扩展名为.html的文件，从而为程序提供文档说明。


### 4.3 分支结构

在Java语言中，if（）和else if（）括号中条件表达式的结果必须是逻辑型量（即true或false），这一点与C和C++语言不同。

### 4.4 循环结构

与while循环语句的一个主要区别是do-while循环语句在结尾处加了一个分号“；”。

### 本章小结

Java语言的注释方式有三种：①以//开始，直到该行结束；②以/∗和∗/括起来的文字；③利用JDK提供的javadoc.exe命令所生成的扩展名为.html的文档注释。

## 第5章 数组与字符串

### 5.1 数组的基本概念

Java语言把内存分为两种：栈内存和堆内存。
在方法中定义的一些基本类型的变量和对象的引用变量都在方法的栈内存中分配，当在一段代码块中定义一个变量时，Java就在栈内存中为这个变量分配内存空间，当超出变量的作用域后，Java会自动释放掉为该变量所分配的内存空间。
堆内存用来存放由new运算符创建的数组或对象，在堆中分配的内存，由Java虚拟机的垃圾回收器来自动管理。在堆中创建了一个数组或对象后，同时还在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，引用变量实际上保存的是数组或对象在堆内存中的首地址（也称为对象的句柄），以后就可以在程序中使用栈的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组或对象本身在堆内存中分配，即使程序运行到使用new运算符创建数组或对象的语句所在的代码块之外，数组或对象本身所占据的内存也不会被释放，数组或对象在没有引用变量指向它时，会变为垃圾，不能再被使用，但仍然占据内存空间不放，在随后一个不确定的时间被垃圾回收器收走（释放掉），这也是Java比较占内存的原因。

### 5.2 一维数组

Java语言是将“[]”放到数组名的前面，但也可以像C/C++语言的定义方式将“[]”放在数组名的后面来定义数组，如“数据类型数组名[]；”

与C/C++语言不同，Java语言在数组的定义中并不为数组元素分配内存，因此“[]”中不用给出数组中元素的个数（即数组的长度），但必须在为它分配内存空间后才可使用。

在Java内部还是有指针，只是把指针的概念对用户隐藏起来了，而用户所使用的是引用变量。

在Java程序中声明数组时，无论用何种方式定义数组，都不能指定其长度。如以“int[5]a；”方式定义数组将是非法的，该语句在编译时将出错。

### 5.4 多维数组

但在Java语言中并没有真正的多维数组。所谓多维数组，就是数组元素也是数组的数组。

Java语言的二维数组不一定是规则的矩形

## 第6章 类与对象

### 6.1 类的基本概念

类是对象的模板、图纸，而对象则是类的一个实例，是实实在在的个体，一个类可以对应多个对象。

一般来说，类是由数据成员与函数成员封装而成的，其中数据成员表示类的属性，函数成员（即程序代码）表示类的行为，由此可见，类描述了对象的属性和对象的行为。

Java语言把数据成员称为域变量、属性、成员变量等；而把函数成员称为成员方法，简称为方法。

### 6.2 定义类

类修饰符分为公共访问控制符、抽象类说明符、最终类说明符和缺省访问控制符四种。

成员变量的修饰符有访问控制符、静态修饰符、最终修饰符、过渡修饰符和易失修饰符等

方法的修饰符较多，包括访问控制符、静态修饰符、抽象修饰符、最终修饰符、同步修饰符和本地修饰符等

（1）从语法形式上看，成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public、private、static等修饰符所修饰，而局部变量则不能被访问控制修饰符及static所修饰；成员变量和局部变量都可以被final所修饰。
（2）从变量在内存中的存储方式上看，成员变量是对象的一部分，而对象是存在于堆内存的，而局部变量是存在于栈内存的。
（3）从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而产生，随着方法调用的结束而自动消失。
（4）成员变量如果没有被赋初值，则会自动以类型的默认值赋值（有一种情况例外，被final修饰但没有被static修饰的成员变量必须显式地赋值）；而局部变量则不会自动赋值，必须显式地赋值后才能使用。

有一种情况例外，被final修饰但没有被static修饰的成员变量必须显式地赋值

### 6.3 对象的创建与使用

Cylinder volu=new Cylinder();  //声明并创建新的对象,并让volu指向该对象

与创建数组同样的道理，在创建对象的第一步或等号的左边以类名Cylinder作为变量的类型在栈内存中定义了一个变量volu，用来指向通过new运算符在堆内存中创建的一个Cylinder类的实例对象。也就是说变量volu是对存放在堆内存中对象的引用变量。

如果Java程序中有多个类，经编译之后便会产生与类相等数目的.class文件。

### 6.4 参数的传递

当参数是基本数据类型时，是传值方式调用；而当参数是引用型的变量时，是传址方式调用。

（1）如果方法中有多个参数，可变参数必须位于最后一项，即可变参数只能出现在参数列表的最后。
（2）可变参数符号“…”要位于数据类型和数组名之间，其前后有无空格都可以。
（3）调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。

### 6.5 匿名对象

当一个对象被创建之后，在调用该对象的方法时，也可以不定义对象的引用变量，而直接调用这个对象的方法，这样的对象称为匿名对象。

使用匿名对象通常有如下两种情况。
（1）如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。
（2）将匿名对象作为实参传递给一个方法调用。

### 本章小结

同一个Java程序内，若定义了多个类，则最多只能有一个类声明为public，在这种情况下，文件名称必须与声明成public的类名称相同。

## 第7章 Java语言类的特性

### 7.1 类的私有成员与公共成员

若在类成员的前面不加任何访问控制符，则该成员具有缺省的访问控制特性，这种缺省访问控制权表示这个成员只能被同一个包（类库）中的类所访问和调用，如果一个子类与其父类位于不同的包中，子类也不能访问父类中的缺省访问控制成员，也就是说其他包中的任何类都不能访问缺省访问控制成员。
同理，对于类来说，如果一个类没有访问控制符，说明它具有缺省访问控制特性，这种缺省的访问控制权规定只能被同一包中的类访问和引用，而不可以被其他包中的类所使用。

### 7.2 方法的重载

方法的重载中参数的类型是关键，仅仅是参数的变量名不同是不行的。也就是说参数的列表必须不同，即：或者参数个数不同，或者参数类型不同，或者参数的顺序不同。

方法的重载是指同一类内定义多个名称相同的方法，然后根据其参数的不同（可能是参数的个数不同，或参数的类型不同）来设计不同的功能，以适应编程的需要。

Java语言中不允许参数个数或参数类型完全相同，而只有返回值类型不同的重载。

### 7.3 构造方法

构造方法（constructor）是一种特殊的方法，它是在对象被创建时初始化对象成员的方法。构造方法的名称必须与它所在的类名完全相同。构造方法没有返回值，但在定义构造方法时，构造方法名前不能用修饰符void来修饰，这是因为一个类的构造方法的返回值类型就是该类本身。构造方法定义后，创建对象时就会自动调用它，因此构造方法不需要在程序中直接调用，而是在对象创建时自动调用并执行。这一点不同于一般的方法，一般的方法在用到时才调用。

（1）在某一个构造方法内调用另一个构造方法时，必须使用this（）语句来调用，否则编译时将出现错误。
（2）this（）语句必须写在构造方法内的第一行位置。

### 7.4 静态成员

被static修饰的成员称为静态成员，也称为类成员，而不用static修饰的成员称为实例成员。

实例成员属个别对象所有，彼此之间不能共享。

用static修饰的成员变量称为静态变量，也称为类变量。静态变量是隶属于类的变量，而不是属于任何一个类的具体对象。

static方法只能访问static成员变量或调用static成员方法，或者说在静态方法中不能访问实例变量与实例方法。

在静态方法中不能使用this或super。因为this是代表调用该方法的对象，但现在静态方法既然不需要对象来调用，this也自然不应存在于静态方法内部。

 类名.静态方法名();￼      对象名.静态方法名();

对于静态方法的调用，建议采用“类名．静态方法名（）；”的形式来访问。

类是在第一次被使用的时候才被装载的，而不是在程序启动时就装载程序中的所有可能要用到的类。

静态初始化器的作用是对整个类完成初始化操作，包括给static成员变量赋初值，它在系统向内存加载时自动完成。

### 7.5 对象的应用

当参数是基本数据类型时，是传值方式调用，而当参数是引用变量时，则是传址方式调用。

### 7.6 Java语言的垃圾回收

垃圾回收有以下特点。
（1）只有当一个对象不被任何引用类型的变量使用时，它占用的内存才可能被垃圾回收器回收。

（2）不能通过程序强迫垃圾回收器立即执行。

（3）当垃圾回收器将要释放无用对象占用的内存时，先调用该对象的finalize（）方法。

### 本章小结

所谓重载是指在同一个类内定义相同名称的多个方法。这些同名的方法或者参数的个数不同或者参数的个数相同但类型不同，这些同名的方法便可以具有不同的功能。

如果一个类没有定义构造方法，则Java编译系统会自动为其生成默认的构造方法。默认的构造方法是没有任何参数，方法体内也没有任何语句的构造方法。

实例变量与实例方法、静态变量与静态方法是不同的成员变量与成员方法。

基本类型的变量是指由int、double等关键字所声明而得到的变量，而由类声明而得到的变量称为类类型的变量，它是属于引用类型变量的一种。

## 第8章 继承、抽象类、接口和枚举

### 8.1 类的继承

在Java语言中有一个名为java.lang.Object的特殊类，所有的类都是直接或间接地继承该类而得到的。

如果没有extends关键字，则该类默认为java.lang.Object类的子类

子类的每个对象也是其父类的对象，这是继承性的“即是”性质。也就是说，若SubClass继承SuperClass，则SubClass即是SuperClass，所以在任何可以使用SuperClass实例的地方，都允许使用SubClass实例，反之则不然，父类对象不一定是它的子类的对象。

（1）通过extends关键字，可将父类中的非私有成员继承给子类。在使用这些继承过来的成员时，利用过去惯用的语法即可，如第38、39行均是利用子类所产生的stu对象，调用从父类继承而来的方法。
（2）Java程序在执行子类的构造方法之前，会先自动调用父类中没有参数的构造方法，其目的是为了帮助继承自父类的成员做初始化的操作。
（3）在严格意义上说，构造方法是不能被继承的，例如父类Person有一个构造方法Person（String, int），不能说子类Student也自动有一个构造方法Person（String，int），但这并不意味着子类不能调用父的构造方法。

程序中即使没有明确地指定子类调用父类的构造方法，但程序执行时子类还是会先调用父类中没有参数的构造方法，以便进行初始化操作。但如果父类中有多个构造方法时，如何才能调用父类中某个特定的构造方法呢？其做法就是在子类的构造方法中通过super（）语句来调用父类特定的构造方法。

调用父类构造方法的super（）语句必须写在子类构造方法的第一行，否则编译时将出现错误信息。

在子类中访问父类的构造方法，其格式为super（参数列表）。super（）可以重载，也就是说，super（）会根据参数的个数与类型，执行父类相应的构造方法。

Java程序在执行子类的构造方法之前，如果没有用super（）来调用父类中特定的构造方法，则会先调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super（）来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到“没有参数的构造方法”可供执行。解决的办法是在父类中加上一个“不做事”且没有参数的构造方法即可，如public Person（）{}。

super（）与this（）的功能相似，但super（）是从子类的构造方法调用父类的构造方法，而this（）则是在同一个类内调用其他的构造方法。当构造方法有重载时，super（）与this（）均会根据所给出的参数类型与个数，正确地执行相对应的构造方法。

super（）与this（）均必须放在构造方法内的第1行，也就是这个原因，super（）与this（）无法同时存在同一个构造方法内。

与this关键字一样，super指的也是对象，所以super同样不能在static环境中使用，包括静态方法和静态初始化器（static语句块）。

在子类中使用super不但可以访问父类的构造方法，还可以访问父类的成员变量和成员方法，但super不能访问在子类中添加的成员。

由于在子类中不能继承父类中的private成员，所以无法在子类中（类外）访问父类中的这种成员。但如果将父类中的成员声明为protected（保护）成员的，而非private成员，则protected成员不仅可以在父类中直接访问，同时也可以在其子类中访问。

用protected修饰的成员可以被该类自身、与它在同一个包中的其他类、在其他包中该类的子类三种类所引用。将成员声明为protected的最大好处是可以同时兼顾成员的安全性与便利性，因为它只能供父类与子类或同一包中的类来访问，而其他类则无法访问它。

重载是指在同一个类内定义多个名称相同但参数个数或类型不同的方法，Java虚拟机可根据参数的个数或类型的不同来调用相应的方法。而覆盖则是指在子类中定义名称、参数个数与类型均与父类中完全相同的方法，用以重写父类中同名方法的功能。

子类中不能覆盖父类中声明为final或static的方法。

在子类中覆盖父类的方法时，可以扩大父类中的方法权限，但不可以缩小父类方法的权限

通过父类的对象访问子类的成员，只限于“覆盖”的情况发生时。也就是说，父类与子类的方法名称、参数个数与类型必须完全相同，才可通过父类的对象调用子类的方法。

所有已被private修饰符限定为私有的方法，以及所有包含在final类中的方法，都被默认为是final的。这些方法既不可能被子类所继承，也不可能被覆盖，所以它们自然都是最终的方法。

一个成员变量若被static final两个修饰符所限定时，它实际的含义就是常量，所以在程序中通常用static和final一起来指定一个常量，且这样的常量只能在定义时被赋值。

定义一个成员变量时，若只用final修饰而不用static修饰，则必须且只能赋值一次，不能默认。这种成员变量的赋值方式有两种：一种是在定义变量时赋初值；另一种是在某一个构造方法中进行赋值。

对于字符串变量来说，使用“==”运算符和使用equals（）方法来比较字符串时，其比较方式是不同的。“==”运算符用于比较两个变量本身的值，即两个对象在内存中的首地址，而equals（）方法则是比较两个字符串中所包含的内容是否相同；而对于非字符串类型的变量来说，“==”运算符和equals（）方法都用来比较其所指对象在堆内存中的首地址，换句话说，“==”运算符和equals（）方法都是用来比较两个类类型的变量是否指向同一个对象

### 8.2 抽象类

抽象方法声明中修饰符static和abstract不能同时使用。

抽象类的子类必须实现父类中的所有抽象方法，或者将自己也声明为抽象的。

（1）由于抽象类是需要被继承的，所以抽象类不能用final来修饰。也就说，一个类不能既是最终类又是抽象类，即关键字abstract与final不能合用。
（2）abstract不能与private、static、final或native并列修饰同一种方法。

抽象类中不一定包含抽象方法，但包含抽象方法的类一定要声明为抽象类。

抽象类可以有构造方法，且构造方法可以被子类的构造方法所调用，但构造方法不能被声明为抽象的。由于不能用抽象类直接创建对象，因此某些情况下在抽象类内定义构造方法是多余的。

### 8.3 接口

接口（interface）是Java语言所提供的另一种重要功能，它的结构与抽象类非常相似。接口本身也具有数据成员、抽象方法、默认方法和静态方法，但它与抽象类有下列不同。
（1）接口的数据成员都是静态的且必须初始化，即数据成员必须是静态常量。
（2）接口中除了声明抽象方法外，还可以定义静态方法和默认方法。

按照Java语言的命名惯例，接口中的常量通常都使用大写字母命名。

由于接口中的常量与静态方法都是静态的，所以可以直接用接口名调用。虽然可以在接口中定义常量，但不推荐这种使用方式，因为使用枚举定义常量比接口中定义常量更好。

与类的继承不同的是，一个接口可以有一个以上的父接口，它们之间用逗号分隔，形成父接口列表。新接口将继承所有父接口中的常量、抽象方法和默认方法，但不能继承父接口中的静态方法，也不能被实现类所继承。

接口中的静态方法不能被子接口继承，也不能被实现该接口的类继承。

如果一个类继承一个父类并实现了一个接口，而从父类和接口中继承了同名的方法，此时采用“类比接口优先”的原则，即只继承父类的方法，而忽略来自接口的默认方法。

### 8.4 枚举

修饰符可以是public、private、internal。

### 8.5 包

同一包中的类名不能重复，不同包中的类名可以相同。

包层次的根文件夹是由环境变量ClassPath（参见2.1.2节）来确定的。

Java类库是以包的形式实现的。Java语言已经把功能相近的类分门别类地存放到不同的类库中（除类之外还包含有接口、异常等）。Java提供的用于程序开发的类库称为应用程序接口（Application Programming Interface, API）。

Java编译器为所有程序自动隐含地导入java.lang包，因此用户无须用import语句导入它所包含的所有类，就可使用其中的类，但是若要使用其他包中的类，就必须用import语句导入。

使用星号“∗”只能表示本层次的所有类，不包括子层次下的类。

由于Java语言使用文件系统来存储包和类，类名就是文件名，包名就是文件夹名。

### 本章小结

在构造方法内调用同一类内的其他构造方法使用this（）语句，而从子类的构造方法调用其父类的构造方法则使用super（）语句。

this（）与super（）的相似之处：（1）当构造方法有重载时，两者均会根据所给予的参数的类型与个数，正确地选择执行相对应的构造方法；（2）两者均必须编写在构造方法内的第一行，也就是因为这个原因，this（）与super（）无法同时存在于同一个构造方法内。

把成员声明成protected最大的好处是可同时兼顾到成员的安全与便利性，因为它只能供父类、子类及同一包中的类来访问，而其他类则无法更改或读取它。

如果父类的方法不希望子类的方法来覆盖它，可以在父类的方法之前加上final关键字，这样该方法就不会被覆盖。

接口的结构和抽象类非常相似，它也具有数据成员、抽象方法、默认方法和静态方法，但它与抽象类有两点不同：（1）接口的数据成员都是静态的且必须初始化；（2）接口中的抽象方法必须全部声明为public abstract。

Java语言并不允许类的多重继承，但利用接口可实现多重继承。

## 第9章 异常处理

### 9.1 异常处理的基本概念

当程序不能正常运行或运行结果不正确时，表明程序中有错误。按照错误的性质可将程序错误分为语法错、语义错和逻辑错三种。

目前大多数面向对象的语言都提供了异常处理机制，而错误处理一般由系统承担，语言本身不提供错误处理机制。

### 9.2 异常处理类

Java编译器要求Java程序必须捕捉或声明所有的非运行时异常，如果程序不加以捕捉，Java编译器则给出编译错误信息。

程序对错误与异常的处理方式有三种：一是程序不能处理的错误；二是程序应避免而可以不去捕获的运行时异常；三是必须捕获的非运行时异常。

### 9.3 异常的处理

catch括号中的异常类型应对应所产生的异常类或该异常的祖先类

由于异常对象与catch块的匹配是按照catch块的先后排列顺序进行的，所以在处理多异常时应注意认真设计各catch块的排列顺序。一般地，将处理较具体、较常见异常的catch块应放在前面，而可以与多种异常类型相匹配的catch块应放在较后的位置。若将子类异常的catch语句块放在父类异常catch语句块的后面，则编译不能通过。

当catch块中含有System.exit（0）语句时，则不执行finally块中的语句，程序直接终止；当catch块中含有return语句时则执行完finally块中的语句后再终止程序。

### 9.4 抛出异常

在程序代码中抛出系统定义的运行时异常并没有太大的意义，通常从程序代码中抛出的是自己编写的异常，因为系统并不会自动帮我们抛出它们。

### 9.5 自动关闭资源的try语句

如果在try-with-resources语句中含有catch和finally子句，则catch和finally子句将会在try-with-resources语句中打开的资源被关闭之后得到调用。

如果资源关闭时出现异常，那么try语句块中的其他异常会被忽略，可以在catch语句块中调用getSuppressed（）方法将“被忽略的异常”重新显示出来。

### 本章小结

方法中没有使用try-catch语句来处理异常，可在方法声明的头部使用throws语句或在方法内部使用throw语句将它送往上一层调用机构去处理。

## 第10章 Java语言的输入输出与文件处理

### 10.1 Java语言的输入输出

字节流每次读写8位二进制数，由于它只能将数据以二进制的原始方式读写，而不能分解、重组和理解这些数据，所以可以使之变换、恢复到原来的有意义的状态，因此字节流又被称为二进制字节流（binary byte stream）或位流（bits stream）；而字符流一次读写16位二进制数，并将其作为一个字符而不是二进制位来处理。

### 10.2 使用InputStream和OutputStream流类

虽然字节流可以操作文本文件，但不提倡这样做，因为用字节流操作文本文件，如果文件中有汉字，可能会出现乱码。这是因为字节流不能直接操作Unicode字符所致。因此Java语言不提倡使用字节流读写文本文件，而建议使用字符流操作文本文件。

FileDescriptor是java.io包中定义的另一个类，该类不能实例化，该类中有三个静态成员：in、out和err，分别对应于标准输入流、标准输出流和标准错误流，利用它们可以在标准输入流和标准输出流上建立文件输入输出流，实现键盘输入或屏幕输出操作。

### 10.3 使用Reader和Writer流类

Java把每个汉字和英文字母均作为一个字符对待，但把Enter键生成的回车换行符“\r\n”作为两个字符。

### 10.4 文件的处理与随机访问

由于不同的操作系统使用的文件夹分隔符不同，如Windows操作系统使用反斜线“\”，UNIX操作系统使用正斜线“/”。为了使Java程序能在不同的平台上运行，可以利用File类的一个静态变量File.separator。该属性中保存了当前系统规定的文件夹分隔符，使用它可以组合成在不同操作系统下都通用的路径。例如：

＂d:＂+File.separator+＂java＂+File.separator+＂myfile＂

## 第11章 多线程

并发执行与并行执行不同，并行执行通常表示同一时刻有多个代码在处理器上执行，这往往需要多个处理器，如CPU等硬件的支持。而并发执行通常表示，在单处理器上，同一时刻只能执行一个代码，但在一个时间段内，这些代码交替执行，即所谓“微观串行，宏观并行”。

### 11.1 线程的概念

多线程（multithread）是指在同一个进程中同时存在几个执行体，按几条不同的执行路径同时工作的情况。所以，多线程编程的含义就是可将一个程序任务分成几个可以同时并发执行的子任务。特别是在网络编程中，会发现许多功能都是可以并发执行的。

进程只是资源分配的单位，线程是处理器调度的基本单位。一个进程包含一个以上线程，一个进程中的线程只能使用该进程的资源和环境。

多任务与多线程是两个不同的概念，多任务是针对操作系统而言的，表示操作系统可以同时运行多个应用程序，而多线程是针对一个进程而言的，表示在一个进程内部可以同时执行多个线程。

线程调度有两种模型：分时模型和抢占模型。在分时模型中，CPU资源是按照时间片来分配的，获得CPU资源的线程只能在指定的时间片内执行，一旦时间片使用完毕，就必须把CPU让给另一个处于就绪状态的线程。在分时模型中，线程本身不会让出CPU；在抢占模型中，当前活动的线程一旦获得执行权，将一直执行下去，直到执行完或由于某种原因主动放弃执行权。如在一个低优先级线程的执行过程中，又有一个高优先级的线程准备就绪，那么低优先级的线程就把CPU资源让给高优先级的线程。为了使低优先级的线程有机会执行，高优先级的线程应该不时地主动进入“睡眠”状态，而暂时让出CPU。Java语言支持的就是抢占式调度模型。

### 11.2 Java的Thread线程类与Runnable接口

①当可运行对象包含线程对象时，即线程对象是可运行对象的成员时，则在run（）方法中可以通过调用Thread.currentThread（）方法来获得正在运行的线程的引用。②当可运行对象不包含线程对象时，在可运行对象run（）方法中需要使用语句Thread.currentThread（）.getName（）来返回当前正在运行线程的名字。

### 11.3 多线程的同步控制

在并发程序设计中，对多线程共享的资源或数据称为临界资源或同步资源，而把每个线程中访问临界资源的那一段代码称为临界代码或临界区。简单地说，在一个时刻只能被一个线程访问的资源就是临界资源，而访问临界资源的那段代码就是临界区。

Synchronized直译为同步，但实际指的是互斥。

临界代码中的共享变量应定义为private型。否则，其他类的方法可能直接访问和操作该共享变量，这样synchronized的保护就失去了意义。

### 11.4 线程之间的通信

对于一个线程，若基于对象x调用wait（）、notify（）或notifyAll（）方法，该线程必须已经获得对象x的互斥锁。换句话说，wait（）、notify（）和notifyAll（）只能在同步代码块里调用。

## 第12章 泛型与容器类

泛型是JDK 5开始引入的新特性。泛型技术可以通过一种类型或方法操纵各种不同类型的对象，同时又提供了编译时的类型安全保证。容器（即集合）则是以类库形式提供的多种数据结构，用户在编程时可直接使用。泛型通常（但不限于）与容器一起使用。

### 12.1 泛型

泛型的概念实际上是基于“类型也可以像变量一样实现参数化”这一简单的设计理念实现的，因此泛型也称为参数多态。

在实例化泛型类的过程中，实际类型必须是引用类型，即必须是类类型，不能用如int、double或char等这样的基本类型来替换类型参数T。

当一个泛型有多个类型参数时，每个类型参数在该泛型中都应该是唯一的。如不能定义形如Map＜K，K＞形式的泛型，但可以定义Map＜K，V＞形式的泛型。

一个static方法，无法访问泛型类的类型参数，所以如果static方法需要使用泛型能力，必须使其成为泛型方法。

Java中父类的对象可以指向子类的对象，因为子类被认为是与父类兼容的类型。但在使用泛型时，要注意它们之间的关系。例如，虽然Integer是Number的子类，但GeneralType＜Integer＞与GeneralType＜Number＞没有父子关系，即GeneralType＜Integer＞不是GeneralType＜Number＞的子类，这种限定称为泛型不是协变的。也就是说利用泛型进行实例化时，若泛型的实际参数的类之间有父子关系时，参数化后得到的泛型类之间并不会具有同样的父子类关系，即子类泛型“并不是一种”父类泛型。

直接用通配符＜？＞创建泛型对象，有两个特点。
（1）具有通用性，即该泛型类的其他对象可以赋值给用通配符“？”创建的泛型对象，因为“？”等价于“？extends Object”，反之不可。
（2）用通配符“？”创建的泛型对象，只能获取或删除其中的信息，但不可为其添加新的信息。

在泛型通配符“？extends T”中，由于T被认为是类型参数“？”的上限，所以“？extends T”也被称为上限通配；当然也可以对类型参数进行下限限制，此时只需将extends改为super即可，“？super T”表示是T或T的一个未知父类型，T表示类型参数“？”的下限，所以被称为下限通配。例如，像“GeneralType＜？super List＞x=null；”这样定义后，泛型对象x只接收List接口或上层父类类型，如“x=new GeneralType＜Object＞（）；”。

## 第13章 注解、反射、内部类、匿名内部类与Lambda表达式

### 13.1 注解

通过使用注解，可以在不改变程序逻辑的情况下，在源文件中嵌入一些补充信息，然后通过反射机制编程可以实现对这些注解进行访问。注解并不影响程序代码的执行，无论增加还是删除注解，代码都始终如一地执行。

根据注解的作用可以将注解分为基本注解、元注解（或称元数据注解）与自定义注解3种。

函数式接口是为Lambda表达式准备的，所以允许使用Lambda表达式来创建函数式接口的实例。

元注解也称元数据注解，是对注解进行标注的注解。

类型注解。Java 8为ElementType枚举增加了TYPE_PAEAMETER和TYPE_USE两个枚举值，允许在定义枚举时使用@Target（ElementType.TYPE_USE）来修饰，此种注解被称为类型注解（type annotation）。类型注解可以用在任何用到类型的地方。除了在定义类、接口、方法和成员变量等常见的程序元素时可以使用类型注解外，还可以在创建对象、方法参数、类型转换、使用throws声明抛出异常、使用implements实现接口等位置使用类型注解。

### 13.3 内部类与匿名内部类

在外部类中，通过一个内部类的对象引用内部类中的成员；反之，在内部类中可以直接引用它的外部类的成员，包括静态成员、实例成员及私有成员。

匿名内部类继承一个类或实现一个接口不需要使用extends或implements关键字。

在Java的窗口程序设计中，经常利用匿名内部类的技术来编写事件（event）的程序代码。

### 13.4 函数式接口和Lambda表达式

Lambda表达式指的是应用在只含有一个抽象方法的接口环境下的一种简化定义形式，可用于解决匿名内部类的定义复杂问题。

函数式接口（Functional Interface，FI）是指只包含一个抽象方法的接口，因此也称为单抽象方法接口。

### 13.5 方法引用

方法引用其实就是Lambda表达式的另一种表现形式。

## 第14章 图形界面设计

## 第15章 事件处理

## 第16章 绘图与动画程序设计

## 第17章 Java数据库程序设计

## 第18章 Java网络编程
