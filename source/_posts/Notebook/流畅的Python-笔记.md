---
title: 《流畅的Python》笔记
index_img: https://cdn.jsdelivr.net/gh/bit704/blog-image-bed@main/image/2022-09-18-流畅的python.jpg
banner_img: https://cdn.jsdelivr.net/gh/bit704/blog-image-bed@main/image/2022-09-18-流畅的python.jpg
categories: [Notebook]
tags: [Python]
---

原书作者  *卢西亚诺·拉马略*

<!-- more -->

Fluent Python

译者  安道    吴珂

人民邮电出版社

![封面](https://cdn.jsdelivr.net/gh/bit704/blog-image-bed@main/image/2022-09-18-流畅的python_s.jpg)

## 前言

doctest是Python的一个标准库，做测试用的。这个库通过模拟控制台对话来检验表达式求值是否正确

本书所有的代码都在Python 3.4里测试过，而且是应用最广的用C实现的CPython 3.4。

## 第一部分 序幕

### 第1章 Python数据模型

Python最好的品质之一是一致性。

**数据模型**其实是对Python框架的描述，它规范了这门语言自身构建模块的接口，这些模块包括但不限于序列、迭代器、函数、类和上下文管理器。

特殊方法也叫双下方法（dunder method）。

namedtuple加入到Python里，用以构建只有少数属性但是没有方法的对象，比如数据库条目。

特殊方法的存在是为了被Python解释器调用的，你自己并不需要调用它们。也就是说没有my_object.len（）这种写法，而应该使用len(my_object)。在执行len(my_object)的时候，如果my_object是一个自定义类的对象，那么Python会自己去调用其中由你实现的len方法。

作为你的类的用户，他们不必去记住标准操作的各式名称（“怎么得到元素的总数？是.size（）还是.length（）还是别的什么？”）


如果是Python内置的类型，比如列表（list）、字符串（str）、字节序列（bytearray）等，那么CPython会抄个近路，len实际上会直接返回PyVarObject里的ob_size属性。PyVarObject是表示内存中长度可变的内置对象的C语言结构体。直接读取这个值比调用一个方法要快很多。

通过内置的函数（例如len、iter、str，等等）来使用特殊方法是最好的选择。

%和str.format这两种格式化字符串的手段在本书中都会使用。其实整个Python社区都在同时使用这两种方法。个人来讲，我越来越喜欢str.format了，但是Python程序员更喜欢简单的%。因此，这两种形式并存的情况还会持续下去。

**repr和str的区别**在于，后者是在str（）函数被使用，或是在用print函数打印一个对象的时候才被调用的，并且它返回的字符串对终端用户更友好。

中缀运算符的基本原则就是不改变操作对象，而是产出一个新的值。

AMOP的第一作者Gregor Kiczales后来成为面向方面编程的先驱，他写出了一个Java扩展叫AspectJ，用来实现他对面向方面编程的理念。

## 第二部分 数据结构

###  第2章 序列构成的数组

容器序列

>  list、tuple和collections.deque这些序列能存放不同类型的数据。

扁平序列

> str、bytes、bytearray、memoryview和array.array，这类序列只能容纳一种类型。

容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。

掌握列表推导还可以为我们打开生成器表达式（generator expression）的大门，后者具有生成各种类型的元素并用它们来填充序列的功能。

列表推导是构建列表（list）的快捷方式，而生成器表达式则可以用来创建其他任何类型的序列。

很多Python程序员都把**列表推导**（list comprehension）简称为listcomps，**生成器表达式**（generator expression）则称为genexps。

通常的原则是，只用列表推导来创建新的列表，并且尽量保持简短。如果列表推导的代码超过了两行，你可能就要考虑是不是得用for循环重写了。

Python会忽略代码里[]、{}和（）中的换行，因此如果你的代码里有多行的列表、列表推导、生成器表达式、字典这一类的，可以省略不太好看的**续行符\\**。

虽然也可以用列表推导来初始化元组、数组或其他序列类型，但是生成器表达式是更好的选择。这是因为生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。前面那种方式显然能够节省内存。

生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已。

如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外再用括号把它围起来。

有些Python入门教程把元组称为“不可变列表”，然而这并没有完全概括元组的特点。除了用作不可变的列表，它还可以用于没有字段名的记录。

还可以用*运算符把一个可迭代对象拆开作为函数的参数。

在进行拆包的时候，我们不总是对元组里所有的数据都感兴趣，**_占位符**能帮助处理这种情况

在Python 3之前，元组可以作为形参放在函数声明中，例如def fn(a, (b, c), d):。然而Python 3不再支持这种格式

collections.namedtuple是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类——这个带名字的类对调试程序有很大帮助。

创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。

元组是一种很强大的可以当作记录来用的数据类型。它的第二个角色则是充当一个不可变的列表。

除了跟增减元素相关的方法之外，元组支持列表的其他所有方法。还有一个例外，元组没有reversed方法，但是这个方法只是个优化而已，reversed(my_tuple)这个用法在没有reversed的情况下也是合法的。

这本书的哲学：**先讲用法**，第四部分中再来讲如何创建新类。

在切片和区间操作里不包含区间范围的最后一个元素是Python的风格，这个习惯符合Python、C和其他语言里以0作为起始下标的传统。

seq[start:stop:step]进行求值的时候，Python会调用seq.getitem(slice(start, stop, step))。

**Python内置的序列类型都是一维的**，因此它们只支持单一的索引，成对出现的索引是没有用的。

**省略（ellipsis）的正确书写方法是三个英语句号（...）**，而不是Unicdoe码位U+2026表示的半个省略号（...）。省略在Python解析器眼里是一个符号，而实际上它是Ellipsis对象的别名，而Ellipsis对象又是ellipsis类的单一实例

如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。

通常+号两侧的序列由相同类型的数据所构成，在拼接的过程中，两个被操作的序列都不会被修改，Python会新建一个包含同样类型数据的序列来作为拼接的结果。

+和\*都遵循这个规律，不修改原有的操作对象，而是构建一个全新的序列。

如果在a \*n这个语句中，序列a里的元素是对其他可变对象的引用的话，你就需要格外注意了，因为这个式子的结果可能会出乎意料。比如，你想用my_list=[[]] \* 3来初始化一个由列表组成的列表，但是你得到的列表里包含的3个元素其实是3个引用，而且这3个引用指向的都是同一个列表。

+=背后的特殊方法是__iadd__ （用于“就地加法”）。但是如果一个类没有实现这个方法的话，Python会退一步调用__add__ 。

不要把可变对象放在元组里面。

增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。

查看Python的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。

要存放1000万个浮点数的话，数组（array）的效率要高得多，因为数组在背后存的并不是float对象，而是数字的机器翻译，也就是字节表述。

另外一个快速序列化数字类型的方法是使用pickle模块。pickle.dump处理浮点数组的速度几乎跟array.tofile一样快。不过前者可以处理几乎所有的内置数字类型，包含复数、嵌套集合，甚至用户自定义的类。前提是这些类没有什么特别复杂的实现。

memoryview是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。

内存视图其实是泛化和去数学化的NumPy数组。它让你在不需要复制内容的前提下，在数据结构之间共享内存。其中数据结构可以是任何形式，比如PIL图片、SQLite数据库和NumPy的数组，等等。这个功能在处理大型数据集合的时候非常重要。

NumPy实现了多维同质数组（homogeneous array）和矩阵，这些数据结构不但能处理数字，还能存放其他由用户定义的记录。通过NumPy，用户能对这些数据结构里的元素进行高效的操作。

SciPy是基于NumPy的另一个库，它提供了很多跟科学计算有关的算法，专为线性代数、数值积分和统计学而设计。SciPy的高效和可靠性归功于其背后的C和Fortran代码，而这些跟计算有关的部分都源自于Netlib库。换句话说，SciPy把基于C和Fortran的工业级数学计算功能用交互式且高度抽象的Python包装起来，让科学家如鱼得水。

collections.deque类（双向队列）是一个线程安全、可以快速从两端添加或者删除元素的数据类型。

extendleft(iter)方法会把迭代器里的元素逐个添加到双向队列的左边，因此迭代器里的元素会逆序出现在队列里。

双向队列也付出了一些代价，从队列中间删除元素的操作会慢一些，因为它只对在头尾的操作进行了优化

append和popleft都是原子操作，也就说是deque可以在多线程程序中安全地当作先进先出的队列使用，而使用者不需要担心资源锁的问题。

Python序列类型最常见的分类就是可变和不可变序列。但另外一种分类方式也很有用，那就是把它们分为扁平序列和容器序列。

sorted和list.sort背后的排序算法是Timsort，它是一种自适应算法，会根据原始数据的顺序特点交替使用插入排序和归并排序，以达到最佳效率。

### 第3章 字典和集合

散列表则是字典类型性能出众的根本原因。

标准库里的所有映射类型都是利用dict来实现的，因此它们有个共同的限制，即只有可散列的数据类型才能用作这些映射里的键。

如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现hash（）方法。另外可散列对象还要有eq（）方法，这样才能跟其他键做比较。如果两个可散列对象是相等的，那么它们的散列值一定是一样的……

“Python里所有的不可变类型都是可散列的”。这个说法其实是不准确的，比如虽然元组本身是不可变序列，它里面的元素可能是其他可变类型的引用。

一般来讲用户自定义的类型的对象都是可散列的，散列值就是它们的id（　）函数的返回值，所以所有这些对象在比较的时候都是不相等的。如果一个对象实现了eq方法，并且在方法中用到了这个对象的内部状态的话，那么只有当所有这些内部状态都是不可变的情况下，这个对象才是可散列的。

字典推导（dictcomp）可以从任何以键值对作为元素的可迭代对象中构建出字典。

```python
# 这样写：
my_dict.setdefault(key, []).append(new_value)
# 跟这样写：
if key not in my_dict:
  my_dict[key] = []
  my_dict[key].append(new_value)
```


二者的效果是一样的，只不过后者至少要进行两次键查询——如果键不存在的话，就是三次，用setdefault只需要一次就可以完成整个操作。

有时候为了方便起见，就算某个键在映射里不存在，我们也希望在通过这个键读取值的时候能得到一个默认值。有两个途径能帮我们达到这个目的，一个是通过defaultdict这个类型而不是普通的dict，另一个是给自己定义一个dict的子类，然后在子类中实现missing方法。

用户创建defaultdict对象的时候，就需要给它配置一个为找不到的键创造默认值的方法。

defaultdict里的default_factory只会在getitem里被调用，在其他的方法里完全不会发挥作用。比如，dd是个defaultdict，k是个找不到的键， dd[k]这个表达式会调用default_factory创造某个默认值，而dd.get(k)则会返回None。

所有这一切背后的功臣其实是特殊方法missing。它会在defaultdict遇到找不到的键的时候调用default_factory，而实际上这个特性是所有映射类型都可以选择去支持的。

missing方法只会被getitem调用（比如在表达式d[k]中）。提供missing方法对get或者contains（in运算符会用到这个方法）这些方法的使用没有影响。

如果要自定义一个映射类型，更合适的策略其实是继承collections.UserDict类。

contains方法不会在找不到键的时候调用missing方法。

像`k in my_dict.keys()`这种操作在Python 3中是很快的，而且即便映射类型对象很庞大也没关系。这是因为dict.keys())的返回值是一个“视图”。视图就像一个集合，而且跟字典类似的是，在视图里查找一个元素的速度很快。

collections.OrderedDict 这个类型在添加键的时候会保持顺序，因此键的迭代次序总是一致的。

collections.ChainMap 该类型可以容纳数个不同的映射对象，然后在进行键查找操作的时候，这些对象会被当作一个整体被逐个查找，直到键被找到为止。

collections.Counter 这个映射类型会给键准备一个整数计数器。每次更新一个键的时候都会增加这个计数器。所以这个类型可以用来给可散列表对象计数，或者是当成多重集来用——多重集合就是集合里的元素可以出现不止一次。

跟OrderedDict、ChainMap和Counter这些开箱即用的类型不同，UserDict是让用户继承写子类的。

更倾向于从UserDict而不是从dict继承的主要原因是，后者有时会在某些方法的实现上走一些捷径，导致我们不得不在它的子类中重写这些方法，但是UserDict就不会带来这些问题。

UserDict并不是dict的子类，但是UserDict有一个叫作data的属性，是dict的实例，这个属性实际上是UserDict最终存储数据的地方。

标准库里所有的映射类型都是可变的。

“集”这个概念在Python中算是比较年轻的，同时它的使用率也比较低。set和它的不可变的姊妹类型frozenset直到Python 2.3才首次以模块的形式出现，然后在Python 2.6中它们升级成为内置类型。

集合中的元素必须是可散列的，set类型本身是不可散列的，但是frozenset可以。因此可以创建一个包含不同frozenset的set。

给定两个集合a和b，a \| b返回的是它们的合集，a & b得到的是交集，而a-b得到的是差集。

除空集之外，集合的字面量——{1}、{1, 2}，等等——看起来跟它的数学形式一模一样。如果是空集，那么必须写成set（）的形式。

不要忘了，如果要创建一个空集，你必须用不带任何参数的构造方法set（）。如果只是写成{}的形式，跟以前一样，你创建的其实是个空字典。

像{1, 2, 3}这种字面量句法相比于构造方法（set([1, 2, 3])）要更快且更易读。后者的速度要慢一些，因为Python必须先从set这个名字来查询构造方法，然后新建一个列表，最后再把这个列表传入到构造方法里。但是如果是像{1, 2, 3}这样的字面量，Python会利用一个专门的叫作BUILD_SET的字节码来创建集合。

由于Python里没有针对frozenset的特殊字面量句法，我们只能采用构造方法。

从unicodedata模块里导入name函数，用以获取字符的名字。

想求4个聚合类型a、b、c和d的合集，可以用a.union(b, c, d)，这里a必须是个set，但是b、c和d则可以是任何类型的可迭代对象。

散列表其实是一个稀疏数组（总是有空白元素的数组称为稀疏数组）。在一般的数据结构教材中，散列表里的单元通常叫作表元（bucket）。在dict的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。

Python会设法保证大概还有三分之一的表元是空的，所以在快要达到这个阈值的时候，原有的散列表会被复制到一个更大的空间里面。

内置的hash()方法可以用于所有的内置类型对象。如果是自定义对象调用hash()的话，实际上运行的是自定义的hash。如果两个对象在比较的时候是相等的，那它们的散列值必须相等，否则散列表就不能正常运行了。

从Python 3.3开始，str、bytes和datetime对象的散列值计算过程中多了随机的“加盐”这一步。所加盐值是Python进程内的一个常量，但是每次启动Python解释器都会生成一个不同的盐值。随机盐值的加入是为了防止DOS攻击而采取的一种安全措施。

一个可散列的对象必须满足以下要求。

(1)支持hash（　）函数，并且通过hash（　）方法所得到的散列值是不变的。

(2)支持通过eq（　）方法来检测相等性。

(3)若a==b为真，则hash(a)==hash(b)也为真。

所有由用户自定义的对象默认都是可散列的，因为它们的散列值由id（　）来获取，而且它们都是不相等的。

如果一个含有自定义的eq依赖的类处于可变的状态，那就不要在这个类中实现hash方法，因为它的实例是不可散列的。

如果你需要存放数量巨大的记录，那么放在由元组或是具名元组构成的列表中会是比较好的选择；最好不要根据JSON的风格，用由字典组成的列表来存放这些记录。用元组取代字典就能节省空间的原因有两个：其一是避免了散列表所耗费的空间，其二是无需把记录中字段的名字在每个元素里都存一遍。

往字典里添加新键可能会改变已有键的顺序。无论何时往字典里添加新的键，Python解释器都可能做出为字典扩容的决定。扩容导致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里。这个过程中可能会发生新的散列冲突，导致新散列表中键的次序变化。要注意的是，上面提到的这些变化是否会发生以及如何发生，都依赖于字典背后的具体实现，因此你不能很自信地说自己知道背后发生了什么。如果你在迭代一个字典的所有键的过程中同时对字典进行修改，那么这个循环很有可能会跳过一些键——甚至是跳过那些字典中已经有的键。由此可知，不要对字典同时进行迭代和修改。如果想扫描并修改一个字典，最好分成两步来进行：首先对字典迭代，以得出需要添加的内容，把这些内容放在一个新字典里；迭代结束之后再对原有字典进行更新。

在Python 3中，.keys()、.items() 和.values() 方法返回的都是字典视图。也就是说，这些方法返回的值更像集合，而不是像Python 2那样返回列表。视图还有动态的特性，它们可以实时反馈字典的变化。

set和frozenset的实现也依赖散列表，但在它们的散列表里存放的只有元素的引用（就像在字典里只存放键而没有相应的值）。

字典算得上是Python的基石。除了基本的dict之外，标准库还提供现成且好用的特殊映射类型，比如defaultdict、OrderedDict、ChainMap和Counter。这些映射类型都属于collections模块，这个模块还提供了便于扩展的UserDict类。

大多数映射类型都提供了两个很强大的方法：setdefault和update。setdefault方法可以用来更新字典里存放的可变值（比如列表），从而避免了重复的键搜索。

### 第4章 文本和字节序列

Python 3明确区分了人类可读的文本字符串和原始的字节序列。隐式地把字节序列转换成Unicode文本已成过去。

如果想帮助自己记住.decode()和.encode()的区别，可以把字节序列想成晦涩难懂的机器磁芯转储，把Unicode字符串想成“人类可读”的文本。那么，把字节序列变成人类可读的文本字符串就是解码，而把字符串变成用于存储或传输的字节序列就是编码。

虽然Python 3的str类型基本相当于Python 2的unicode类型，只不过是换了个新名称，但是Python 3的bytes类型却不是把str类型换个名称那么简单，而且还有关系紧密的bytearray类型。

Python内置了两种基本的二进制序列类型：Python 3引入的不可变bytes类型和Python 2.6添加的可变bytearray类型。（Python 2.6也引入了bytes类型，但那只不过是str类型的别名，与Python 3的bytes类型不同。）

bytes或bytearray对象的各个元素是介于0~255（含）之间的整数，而不像Python 2的str对象那样是单个的字符。

bytes对象的切片还是bytes对象，即使是只有一个字节的切片。

bytearray对象的切片还是bytearray对象。

s[0]==s[:1]只对str这个序列类型成立。不过，str类型的这个行为十分罕见。对其他各个序列类型来说，s[i]返回一个元素，而s[i:i+1]返回一个相同类型的序列，里面是s[i]元素。

虽然二进制序列其实是整数序列，但是它们的字面量表示法表明其中有ASCII文本。因此，各个字节的值可能会使用下列三种不同的方式显示:

- 可打印的ASCII范围内的字节（从空格到\~），使用ASCII字符本身。
- 制表符、换行符、回车符和\对应的字节，使用转义序列\\t、\\n\、\\r和\\。
- 其他字节的值，使用十六进制转义序列（例如，\x00是空字节）。


struct模块提供了一些函数，把打包的字节序列转换成不同类型字段组成的元组，还有一些函数用于执行反向转换，把元组转换成打包的字节序列。struct模块能处理bytes、bytearray和memoryview对象。

memoryview类不是用于创建或存储字节序列的，而是共享内存，让你访问其他二进制序列、打包的数组和缓冲中的数据切片，而无需复制字节序列，例如Python Imaging Library（PIL）￼就是这样处理图像的。

memoryview对象的切片是一个新memoryview对象，而且不会复制字节序列。 

Python 3默认使用UTF-8编码源码，Python 2（从2.5开始）则默认使用ASCII。

b'\\xff\\xfe'。这是BOM，即字节序标记（byte-order mark），指明编码时使用Intel CPU的小字节序。

为了避免混淆，UTF-16编码在要编码的文本前面加上特殊的不可见字符ZERO WIDTH NO-BREAK SPACE（U+FEFF）。在小字节序系统中，这个字符编码为b'\xff\xfe'（十进制数255, 254）。因为按照设计，U+FFFE字符不存在，在小字节序编码中，字节序列b'\xff\xfe'必定是ZERO WIDTH NO-BREAK SPACE，所以编解码器知道该用哪个字节序。

与字节序有关的问题只对一个字（word）占多个字节的编码（如UTF-16和UTF-32）有影响。UTF-8的一大优势是，不管设备使用哪种字节序，生成的字节序列始终一致，因此不需要BOM。

除非想判断编码，否则不要在二进制模式中打开文本文件；即便如此，也应该使用Chardet，而不是重新发明轮子（参见4.4.4节）。常规代码只应该使用二进制模式打开二进制文件，如光栅图像。

U+0301是COMBINING ACUTE ACCENT，加在“e”后面得到“é”。在Unicode标准中，'é'和'e\u0301'这样的序列叫“标准等价物”（canonical equivalent），应用程序应该把它们视作相同的字符。但是，Python看到的是不同的码位序列，因此判定二者不相等。

这个问题的解决方案是使用unicodedata.normalize函数提供的Unicode规范化。

标准库中的一些函数能接受字符串或字节序列为参数，然后根据类型展现不同的行为。re和os模块中就有这样的函数。

## 第三部分 把函数视作对象

### 第5章 一等函数

在Python中，函数是一等对象。编程语言理论家把“一等对象”定义为满足下述条件的程序实体：

- 在运行时创建
- 能赋值给变量或数据结构中的元素
- 能作为参数传给函数
- 能作为函数的返回结果

在Python中，整数、字符串和字典都是一等对象——没什么特别的。如果在Python之前，你使用的语言并未把函数当作一等公民，那么本章以及第三部分余下的内容将重点讨论把函数作为对象的影响和实际应用。

人们经常将“把函数视作一等对象”简称为“一等函数”。这样说并不完美，似乎表明这是函数中的特殊群体。在Python中，所有函数都是一等对象。

doc属性用于生成对象的帮助文本。

map函数返回一个可迭代对象，里面的元素是把第一个参数（一个函数）应用到第二个参数（一个可迭代对象，这里是range(11)）中各个元素上得到的结果。

接受函数为参数，或者把函数作为结果返回的函数是高阶函数（higher-order function）。

在函数式编程范式中，最为人熟知的高阶函数有map、filter、reduce和apply。apply函数在Python 2.3中标记为过时，在Python 3中移除了，因为不再需要它了。如果想使用不定量的参数调用函数，可以编写fn(\*args, \*\*keywords)，不用再编写apply(fn, args, kwargs)。

函数式语言通常会提供map、filter和reduce三个高阶函数（有时使用不同的名称）。在Python 3中，map和filter还是内置函数，但是由于引入了列表推导和生成器表达式，它们变得没那么重要了。列表推导或生成器表达式具有map和filter两个函数的功能，而且更易于阅读。

Python简单的句法限制了lambda函数的定义体只能使用纯表达式。换句话说，lambda函数的定义体中不能赋值，也不能使用while和try等Python语句。

除了作为参数传给高阶函数之外，Python很少使用匿名函数。由于句法上的限制，非平凡的lambda表达式要么难以阅读，要么无法写出。

如果使用lambda表达式导致一段代码难以理解，Fredrik Lundh建议像下面这样重构。

(1)编写注释，说明lambda表达式的作用。

(2)研究一会儿注释，并找出一个名称来概括注释。

(3)把lambda表达式转换成def语句，使用那个名称来定义函数。

(4)删除注释。

这几步摘自“Functional Programming HOWTO”，这是一篇必读文章。

lambda句法只是语法糖：与def语句一样，lambda表达式会创建函数对象。这是Python中几种可调用对象的一种。

除了用户定义的函数，调用运算符（即()）还可以应用到其他对象上。如果想判断对象能否调用，可以使用内置的callable()函数。Python数据模型文档列出了7种可调用对象:

- 用户定义的函数
  - 使用def语句或lambda表达式创建。
- 内置函数
  - 使用C语言（CPython）实现的函数，如len或time.strftime。
- 内置方法
  - 使用C语言实现的方法，如dict.get。
- 方法
  - 在类的定义体中定义的函数。
- 类
  - 调用类时会运行类的__new__方法创建一个实例，然后运行__init__方法，初始化实例，最后把实例返回给调用方。因为Python没有new运算符，所以调用类相当于调用函数。（通常，调用类会创建那个类的实例，不过覆盖__new__方法的话，也可能出现其他行为。19.1.3节会见到一个例子。）
- 类的实例
  - 如果类定义了__call__方法，那么它的实例可以作为函数调用。参见5.5节。
- 生成器函数
  - 使用yield关键字的函数或方法。调用生成器函数返回的是生成器对象。
    生成器函数在很多方面与其他可调用对象不同，详情参见第14章。生成器函数还可以作为协程，参见第16章。

不仅Python函数是真正的对象，任何Python对象都可以表现得像函数。为此，只需实现实例方法__call__。


实现call方法的类是创建函数类对象的简便方式，此时必须在内部维护一个状态，让它在调用之间可用，例如BingoCage中的剩余元素。装饰器就是这样。装饰器必须是函数，而且有时要在多次调用之间“记住”某些事[例如备忘（memoization），即缓存消耗大的计算结果，供后面使用]。

与用户定义的常规类一样，函数使用dict属性存储赋予它的用户属性。这相当于一种基本形式的注解。一般来说，为函数随意赋予属性不是很常见的做法，但是Django框架这么做了。参见“The Django admin site”文档中对short_description、boolean和allow_tags属性的说明。

Python最好的特性之一是提供了极为灵活的参数处理机制，而且Python 3进一步提供了仅限关键字参数（keyword-only argument）。与之密切相关的是，调用函数时使用*和**“展开”可迭代对象，映射到单个参数。

定义函数时若想指定仅限关键字参数，要把它们放到前面有*的参数后面。如果不想支持数量不定的定位参数，但是想支持仅限关键字参数，在签名中放一个*

函数对象有个defaults属性，它的值是一个元组，里面保存着定位参数和关键字参数的默认值。仅限关键字参数的默认值在kwdefaults属性中。然而，参数的名称在code属性中，它的值是一个code对象引用，自身也有很多属性。


Python 3提供了一种句法，用于为函数声明中的参数和返回值附加元数据。

函数声明中的各个参数可以在:之后增加注解表达式。如果参数有默认值，注解放在参数名和=号之间。如果想注解返回值，在)和函数声明末尾的:之间添加->和一个表达式。那个表达式可以是任何类型。注解中最常用的类型是类（如str或int）和字符串（如'int > 0'）。

Python对注解所做的唯一的事情是，把它们存储在函数的annotations属性里。仅此而已，Python不做检查、不做强制、不做验证，什么操作都不做。换句话说，注解对Python解释器没有任何意义。注解只是元数据，可以供IDE、框架和装饰器等工具使用。

虽然Guido明确表明，Python的目标不是变成函数式编程语言，但是得益于operator和functools等包的支持，函数式编程风格也可以信手拈来。

operator模块为多个算术运算符提供了对应的函数，从而避免编写lambda a, b: a\*b这种平凡的匿名函数。

operator模块中还有一类函数，能替代从序列中取出元素或读取对象属性的lambda表达式：因此，itemgetter和attrgetter其实会自行构建函数。

functools.partial这个高阶函数用于部分应用一个函数。部分应用是指，基于一个函数创建一个新的可调用对象，把原函数的某些参数固定。使用这个函数可以把接受一个或多个参数的函数改编成需要回调的API，这样参数更少。

functools.partialmethod函数（Python 3.4新增）的作用与partial一样，不过是用于处理方法的。

functools模块中的lru_cache函数令人印象深刻，它会做备忘（memoization），这是一种自动优化措施，它会存储耗时的函数调用结果，避免重新计算。

对Python、Ruby或Perl这些语言还要了解什么呢？它们的设计者没有耐心去精确实现林奈层次结构；设计者按照自己的意愿从别处借鉴特性，创建出完全无视过往概念的大杂烩。

Krishnamurthi指出，不要试图把语言归为某一类；相反，把它们视作特性的聚合更有用。

lambda、map、filter和reduce首次出现在Lisp中，这是最早的一门函数式语言。然而，Lisp没有限制在lambda表达式中能做什么，因为Lisp中的一切都是表达式。 Python使用的是面向语句的句法，表达式中不能包含语句，而很多语言结构都是语句，例如try/catch，我编写lambda表达式时最想念这个语句。Python为了提高句法的可读性，必须付出这样的代价。

### 第6章 使用一等函数实现设计模式

虽然设计模式与语言无关，但这并不意味着每一个模式都能在每一门语言中使用。1996年，Peter Norvig在题为“Design Patterns in Dynamic Languages”的演讲中指出，Gamma等人合著的《设计模式：可复用面向对象软件的基础》一书中有23个模式，其中有16个在动态语言中“不见了，或者简化了”（参见第9张幻灯片）。他讨论的是Lisp和Dylan，不过很多相关的动态特性在Python中也能找到。

《设计模式：可复用面向对象软件的基础》一书是这样概述“策略”模式的：

> 定义一系列算法，把它们一一封装起来，并且使它们可以相互替换。本模式使得算法可以独立于使用它的客户而变化。

在Python 3.4中，声明抽象基类最简单的方式是子类化abc.ABC。

从Python 3.0到Python 3.3，必须在class语句中使用metaclass=关键字（例如，class Promotion(metaclass=ABCMeta):）。

共享是推荐的做法，这样不必在每个新的上下文（这里是Order实例）中使用相同的策略时不断新建具体策略对象，从而减少消耗。

globals() 返回一个字典，表示当前的全局符号表。这个符号表始终针对当前模块（对函数或方法来说，是指定义它们的模块，而不是调用它们的模块）。

“命令”设计模式也可以通过把函数作为参数传递而简化。

“命令”模式的目的是解耦调用操作的对象（调用者）和提供实现的对象（接收者）。

Gamma等人说过：“命令模式是回调机制的面向对象替代品。”问题是，我们需要回调机制的面向对象替代品吗？有时确实需要，但并非始终需要。

我们可以不为调用者提供一个Command实例，而是给它一个函数。此时，调用者不用调用command.execute()，直接调用command()即可。

Python拥有一等函数和一等类型，Norvig声称，这些特性对23个模式中的16个有影响（“Design Patterns in Dynamic Languages”，第10张幻灯片）。

### 第7章 函数装饰器和闭包

函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。

除了在装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础。

装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。￼装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。

装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二个特性是，装饰器在加载模块时立即执行。

函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。这突出了Python程序员所说的导入时和运行时之间的区别。

Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。这比JavaScript的行为好多了，JavaScript也不要求声明变量，但是如果忘记把变量声明为局部变量（使用var），可能会在不知情的情况下获取全局变量。

闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。

闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。

只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。

为了解决这个问题，Python 3引入了nonlocal声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。

这是装饰器的典型行为：把被装饰的函数替换成新函数，二者接受相同的参数，而且（通常）返回被装饰的函数本该返回的值，同时还会做些额外操作。

Python内置了三个用于装饰方法的函数：property、classmethod和staticmethod。property在19.2节讨论，另外两个在9.4节讨论。

另一个常见的装饰器是functools.wraps，它的作用是协助构建行为良好的装饰器。

标准库中最值得关注的两个装饰器是lru_cache和全新的singledispatch（Python 3.4新增）。这两个装饰器都在functools模块中定义。

functools.lru_cache是非常实用的装饰器，它实现了备忘（memoization）功能。这是一项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。LRU三个字母是“Least Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。

因为lru_cache使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，所以被lru_cache装饰的函数，它的所有参数都必须是可散列的。

因为Python不支持重载方法或函数，所以我们不能使用不同的签名定义htmlize的变体，也无法使用不同的方式处理不同的数据类型。在Python中，一种常见的做法是把htmlize变成一个分派函数，使用一串if/elif/elif，调用专门的函数，如htmlize_str、htmlize_int，等等。这样不便于模块的用户扩展，还显得笨拙：时间一长，分派函数htmlize会变得很大，而且它与各个专门函数之间的耦合也很紧密。
Python 3.4新增的functools.singledispatch装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用@singledispatch装饰的普通函数会变成泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。

singledispatch机制的一个显著特征是，你可以在系统的任何地方和任何模块中注册专门函数。如果后来在新的模块中定义了新的类型，可以轻松地添加一个新的专门函数来处理那个类型。此外，你还可以为不是自己编写的或者不能修改的类添加自定义函数。

@singledispatch不是为了把Java的那种方法重载带入Python。在一个类中为同一个方法定义多个重载变体，比在一个函数中使用一长串if/elif/elif/elif块要更好。但是这两种方案都有缺陷，因为它们让代码单元（类或函数）承担的职责太多。@singledispath的优点是支持模块化扩展：各个模块可以为它支持的各个类型注册一个专门函数。

怎么让装饰器接受其他参数呢？答案是：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。

## 第四部分 面向对象惯用法

### 第8章 对象引用、可变性和垃圾回收

Python变量类似于Java中的引用式变量，因此最好把它们理解为附加在对象上的标注。

每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理解为对象在内存中的地址。is运算符比较两个对象的标识；id（　）函数返回对象标识的整数表示。

==运算符比较两个对象的值（对象中保存的数据），而is比较对象的标识。

如果引用的元素是可变的，即便元组本身不可变，元素依然可变。也就是说，元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。

构造方法或[:]做的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用）。

copy模块提供的deepcopy和copy函数能为任意对象做深复制和浅复制。

Python唯一支持的参数传递模式是共享传参（call by sharing）。多数面向对象语言都采用这一模式，包括Ruby、Smalltalk和Java（Java的引用类型是这样，基本类型按值传参）。
共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。
这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识（即不能把一个对象替换成另一个对象）。

默认值在定义函数时计算（通常在加载模块时），因此默认值变成了函数对象的属性。因此，如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。

del语句删除名称，而不是对象。del命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时

有个del特殊方法，但是它不会销毁实例，不应该在代码中调用。即将销毁实例时，Python解释器会调用del方法，给实例最后的机会，释放外部资源。自己编写的代码很少需要实现del代码，有些Python新手会花时间实现，但却吃力不讨好，因为del很难用对。

在CPython中，垃圾回收使用的主要算法是引用计数。

正是因为有引用，对象才会在内存中存在。当对象的引用数量归零后，垃圾回收程序会把对象销毁。但是，有时需要引用对象，而不让对象存在的时间超过所需时间。这经常用在缓存中。

弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此我们说，弱引用不会妨碍所指对象被当作垃圾回收。

弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。

weakref模块的文档指出，weakref.ref类其实是低层接口，供高级用途使用，多数程序最好使用weakref集合和finalize。也就是说，应该使用WeakKeyDictionary、WeakValueDictionary、WeakSet和finalize（在内部使用弱引用），不要自己动手创建并处理weakref.ref实例。

如果一个类需要知道所有实例，一种好的方案是创建一个WeakSet类型的类属性，保存实例的引用。如果使用常规的set，实例永远不会被垃圾回收，因为类中有实例的强引用，而类存在的时间与Python进程一样长，除非显式删除类。

如果两个变量指代的不可变对象具有相同的值（a==b为True），实际上它们指代的是副本还是同一个对象的别名基本没什么关系，因为不可变对象的值不会变，但有一个例外。这里说的例外是不可变的集合，如元组和frozenset：如果不可变集合保存的是可变元素的引用，那么可变元素的值发生变化后，不可变集合也会随之改变。实际上，这种情况不是很常见。不可变集合不变的是所含对象的标识。

我一直觉得Java的==运算符用着不舒服。程序员关注的基本上是相等性，而不是标识，但是Java的==运算符比较的是对象（不是基本类型）的引用，而不是对象的值。就算是比较字符串这样的基本操作，Java也强制你使用.equals方法。尽管如此，.equals方法还有另一个问题：如果编写a.equals(b)，而a是null，会得到一个空指针异常。Java设计者觉得有必要重载字符串的+运算符，那为什么不把==也重载了？Python采取了正确的方式。==运算符比较对象的值，而is比较引用。此外，Python支持重载运算符，==能正确处理标准库中的所有对象，包括None——这是一个正常的对象，与Java的null不同。

在“纯”函数式编程中，所有数据都是不可变的，如果为集合追加元素，那么其实会创建新的集合。然而，Python不是函数式语言，更别提纯不纯了。

Python没有直接销毁对象的机制，这一疏漏其实是一个好的特性：如果随时可以销毁对象，那么指向对象的强引用怎么办？CPython中的垃圾回收主要依靠引用计数，这容易实现，但是遇到引用循环容易泄露内存，因此CPython 2.0（2000年10月发布）实现了分代垃圾回收程序，它能把引用循环中不可获取的对象销毁。但是引用计数仍然作为一种基准存在，一旦引用数量归零，就立即销毁对象。

